; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30147.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1BG@HMJJDGFN@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1DA@HCNHOFJN@?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAo?$AAr?$AAa?$AAg?$AAe?$AA?4?$AAS?$AAi@ ; `string'
PUBLIC	??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@ ; `string'
PUBLIC	??_C@_1EI@NNJKMECF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AAf?$AAf?$AAf@ ; `string'
PUBLIC	??_C@_1BO@KBODBKOH@?$AAf?$AAi?$AAr?$AAs?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@ ; `string'
PUBLIC	??_C@_1CG@BDIGDJGP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@ ; `string'
PUBLIC	??_C@_1BM@JHJLEEND@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@ ; `string'
PUBLIC	??_C@_1CM@LEHAODMI@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AAc?$AA?9?$AA?$DO?$AAa?$AAl?$AAi?$AAg@ ; `string'
PUBLIC	??_C@_1BE@MNLKNDNL@?$AAx?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1FA@GPDJEJHP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@ ; `string'
PUBLIC	??_C@_1BI@JNFMLHFF@?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAe?$AAs?$AAt?$AA_?$AAy@ ; `string'
PUBLIC	??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@ ; `string'
PUBLIC	??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@ ; `string'
PUBLIC	??_C@_1CC@OMFGMKMB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_1CE@EPOLDKHI@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx?$AA4?$AA0?$AA0?$AA0?$AA0?$AA0@ ; `string'
PUBLIC	??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@ ; `string'
PUBLIC	??_C@_1BC@KDMJFGHG@?$AAb?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA8@ ; `string'
PUBLIC	??_C@_1CI@PFMEGAIA@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_04LBBEMOBJ@typ1@				; `string'
PUBLIC	??_C@_04LLEFIKCJ@OTTO@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_C@_04KIOEMAHO@ttcf@				; `string'
PUBLIC	??_C@_04EICJPCEA@cmap@				; `string'
PUBLIC	??_C@_04DACNFKGE@loca@				; `string'
PUBLIC	??_C@_04NEODDMOL@head@				; `string'
PUBLIC	??_C@_04LLIHEPK@glyf@				; `string'
PUBLIC	??_C@_04FMPHLIKP@hhea@				; `string'
PUBLIC	??_C@_04ONMNCIMC@hmtx@				; `string'
PUBLIC	??_C@_04HHMMLDJI@kern@				; `string'
PUBLIC	??_C@_04PCFDEHHD@GPOS@				; `string'
PUBLIC	??_C@_04HJGCPIEK@CFF?5@				; `string'
PUBLIC	??_C@_04KODIGLGG@maxp@				; `string'
PUBLIC	??_C@_1HE@BLOLDBDN@?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAc?$AAo?$AAd?$AAe?$AAp?$AAo?$AAi@ ; `string'
PUBLIC	??_C@_1CA@MDABGEPC@?$AA?$CB?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAc?$AAf?$AAf?$AA?4?$AAs?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_1GE@KABFAMEA@?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAc?$AAt?$AAx?$AA?4?$AAn?$AAu?$AAm?$AA_@ ; `string'
PUBLIC	??_C@_1O@EHPNOHML@?$AAz?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1BA@ENLNFFAM@?$AAy?$AA0?$AA?5?$AA?$DM?$AA?5?$AAy?$AA1@ ; `string'
PUBLIC	??_C@_1BO@JGPMADBG@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AA?9?$AA?$DO?$AAe?$AAy@ ; `string'
PUBLIC	??_C@_1BI@NJPIGMLC@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AA1@ ; `string'
PUBLIC	??_C@_1BA@FAAMJPKE@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx@ ; `string'
PUBLIC	??_C@_1BA@FEPJEPJJ@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx@ ; `string'
PUBLIC	??_C@_1BI@NMCMAHDB@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AA1@ ; `string'
PUBLIC	??_C@_1CO@IKFPJDAK@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA1?$AA?5?$AA?$DM@ ; `string'
PUBLIC	??_C@_1GC@IACIBKNK@?$AAx?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA0?$AA?5?$AA?$DM@ ; `string'
PUBLIC	??_C@_1BO@MDBOACOJ@?$AAe?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAy?$AA_?$AAt?$AAo?$AAp@ ; `string'
PUBLIC	??_C@_1EI@KOIFPDFH@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAy?$AA_?$AAb?$AAo?$AAt?$AAt@ ; `string'
PUBLIC	??_C@_1CE@GDDDMDCC@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AAl@ ; `string'
PUBLIC	??_C@_1CK@PHOJNIKI@?$AAf?$AAa?$AAb?$AAs?$AAf?$AA?$CI?$AAa?$AAr?$AAe?$AAa?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_1BK@LMAHJHLI@?$AAz?$AA?9?$AA?$DO?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn@ ; `string'
PUBLIC	??_C@_1CI@PMJHELI@?$AAz?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAc?$AAa?$AAn?$AA_?$AAy@ ; `string'
PUBLIC	??_C@_1BO@BDJAMAMF@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1EC@IGKGDOM@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?5?$AA?$CK?$AA?5?$AAs?$AAt?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@ ; `string'
PUBLIC	??_C@_1CC@JCMOPDC@?$AAm?$AAa?$AAx?$AA_?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0@ ; `string'
PUBLIC	??_C@_1LC@MAEAJCLC@?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAm?$AAd?$AA?4?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe@ ; `string'
PUBLIC	??_C@_1DI@FGNNAPCK@?$AAc?$AAu?$AAr?$AAr?$AA_?$AAc?$AAm?$AAd?$AA?9?$AA?$DO?$AAU?$AAs?$AAe?$AAr?$AAC@ ; `string'
PUBLIC	??_C@_0DF@FNKJFHEE@Misuse?5of?5legacy?5hardcoded?5ImDr@ ; `string'
PUBLIC	??_C@_1JM@GAJOFMMN@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AA0?$AAF?$AA?$CJ?$AA?5@ ; `string'
PUBLIC	??_C@_1GI@CIGOLMNM@?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0GA@FGMHMEOI@Nested?5channel?5splitting?5is?5not@ ; `string'
PUBLIC	??_C@_1BAE@LAENHIMB@?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_1DC@ILGGLBID@?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAd?$AAx@ ; `string'
PUBLIC	??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@ ; `string'
PUBLIC	??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@ ; `string'
PUBLIC	??_C@_1GM@FAHJAOLI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AAD@ ; `string'
PUBLIC	??_C@_1DI@LEOIHPJH@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe?$AAP@ ; `string'
PUBLIC	??_C@_0CI@EDBCHFCN@Cannot?5use?5MergeMode?5for?5the?5fi@ ; `string'
PUBLIC	??_C@_1HI@KOOOLAEJ@?$AA?$CB?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?4?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?5@ ; `string'
PUBLIC	??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@	; `string'
PUBLIC	??_C@_1EG@KCPDJPKE@?$AA?$CI?$AA0?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn@ ; `string'
PUBLIC	??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@		; `string'
PUBLIC	??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@ ; `string'
PUBLIC	??_C@_1DK@GHLOFHKF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAw?$AAi@ ; `string'
PUBLIC	??_C@_1DO@CAIIJEKF@?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh@ ; `string'
PUBLIC	??_C@_1BE@PBFICKNN@?$AAf?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1DM@CMBJAGBP@?$AAT?$AAe?$AAx?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@ ; `string'
PUBLIC	??_C@_1CC@DEJIAPCP@?$AAr?$AAe?$AAc?$AAt?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI@ ; `string'
PUBLIC	??_C@_1DC@JHOLDEIK@?$AAP?$AAa?$AAc?$AAk?$AAI?$AAd?$AAM?$AAo?$AAu?$AAs?$AAe?$AAC?$AAu?$AAr?$AAs@ ; `string'
PUBLIC	??_C@_1DG@BBHAKCJP@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAD?$AAa@ ; `string'
PUBLIC	??_C@_1KE@NPGLPIC@?$AAc?$AAf?$AAg?$AA?4?$AAD?$AAs?$AAt?$AAF?$AAo?$AAn?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; `string'
PUBLIC	??_C@_1CO@NKKOCLPN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAD?$AAs?$AAt?$AAI?$AAn?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_0DC@IFELKFNN@FontData?5is?5incorrect?0?5or?5FontN@ ; `string'
PUBLIC	??_C@_1JA@MENENCJI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_1FO@GJGKHCEN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AAL@ ; `string'
PUBLIC	??_C@_1DC@ENBGOGEF@?$AAg?$AAl?$AAy?$AAp?$AAh?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA_?$AAi?$AAn?$AA_@ ; `string'
PUBLIC	??_C@_1CE@FMMHMDCM@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN@ ; `string'
PUBLIC	??_C@_1CK@POMOOFJC@?$AAu?$AAs?$AAe?$AAr?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_1KE@CBAIECN@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAw@ ; `string'
PUBLIC	??_C@_1EG@KOLNNAOF@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AAw@ ; `string'
PUBLIC	??_C@_1EI@CHFOHLGN@?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAy?$AA?5?$AA?$CL?$AA?5?$AAh@ ; `string'
PUBLIC	??_C@_1BM@DDBMCGAE@?$AAr?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1MA@PDHEAINP@?$AAr?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN@ ; `string'
PUBLIC	??_C@_1EA@DBHHBIED@?$AAr?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_1HO@DLMJCKJA@?$AAp?$AAa?$AAd?$AA_?$AAl?$AAe?$AAf?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAi?$AAn?$AAe@ ; `string'
PUBLIC	??_C@_1HG@JLCPLJIF@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAT?$AAe?$AAx?$AAP?$AAi?$AAx?$AAe?$AAl@ ; `string'
PUBLIC	??_C@_1EC@BJJINGAO@?$AAr?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi@ ; `string'
PUBLIC	??_C@_1CK@FHBHHKB@?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0@ ; `string'
PUBLIC	??_C@_1EO@HLFAHELG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAX?$AA?4?$AAS@ ; `string'
PUBLIC	??_C@_1CK@OHOOGJPG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAL?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?4?$AAS?$AAi?$AAz@ ; `string'
PUBLIC	??_C@_1JM@LKKCKIOL@?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_?$AAc?$AAu?$AAr?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5@ ; `string'
PUBLIC	??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_1DG@GCANDLHA@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@ ; `string'
PUBLIC	??_C@_1DG@EGIPGKEG@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAo?$AAu@ ; `string'
PUBLIC	??_C@_1CC@BPLGCGDC@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAi?$AAz@ ; `string'
;	COMDAT ?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_BSS	SEGMENT
?full_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 01395H DUP (?) ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::full_ranges
_BSS	ENDS
;	COMDAT ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_BSS	SEGMENT
?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 01779H DUP (?) ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::full_ranges
_BSS	ENDS
;	COMDAT ?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4QBFB
CONST	SEGMENT
?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4QBFB DW 00H ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::accumulative_offsets_from_0x4E00
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	0aH
	DW	01H
	DW	02H
	DW	013H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	08H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	04H
	DW	06H
	DW	05H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	07H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	03H
	DW	06H
	DW	0aH
	DW	0cH
	DW	05H
	DW	07H
	DW	02H
	DW	0eH
	DW	02H
	DW	09H
	DW	01H
	DW	01H
	DW	06H
	DW	07H
	DW	0aH
	DW	04H
	DW	07H
	DW	0dH
	DW	01H
	DW	05H
	DW	04H
	DW	08H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	01cH
	DW	05H
	DW	06H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	014H
	DW	02H
	DW	02H
	DW	09H
	DW	08H
	DW	0bH
	DW	02H
	DW	09H
	DW	011H
	DW	01H
	DW	08H
	DW	06H
	DW	08H
	DW	01bH
	DW	04H
	DW	06H
	DW	09H
	DW	014H
	DW	0bH
	DW	01bH
	DW	06H
	DW	044H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	06H
	DW	0bH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	08H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	07H
	DW	02H
	DW	01H
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	05H
	DW	06H
	DW	03H
	DW	06H
	DW	02H
	DW	0cH
	DW	03H
	DW	01H
	DW	03H
	DW	09H
	DW	02H
	DW	04H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	03H
	DW	03H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	02H
	DW	03H
	DW	02H
	DW	06H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	04H
	DW	05H
	DW	0fH
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	03H
	DW	016H
	DW	013H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	0cH
	DW	08H
	DW	02H
	DW	09H
	DW	012H
	DW	016H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	010H
	DW	01H
	DW	02H
	DW	07H
	DW	0aH
	DW	0fH
	DW	01H
	DW	01H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	04H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	02H
	DW	05H
	DW	07H
	DW	02H
	DW	013H
	DW	04H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	06H
	DW	02H
	DW	02H
	DW	0eH
	DW	04H
	DW	06H
	DW	06H
	DW	0bH
	DW	09H
	DW	01H
	DW	0fH
	DW	03H
	DW	01H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	05H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	05H
	DW	04H
	DW	06H
	DW	0eH
	DW	03H
	DW	02H
	DW	03H
	DW	05H
	DW	015H
	DW	02H
	DW	07H
	DW	014H
	DW	0aH
	DW	01H
	DW	02H
	DW	013H
	DW	02H
	DW	04H
	DW	01cH
	DW	01cH
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	0eH
	DW	04H
	DW	01H
	DW	01aH
	DW	01cH
	DW	02aH
	DW	0cH
	DW	028H
	DW	03H
	DW	034H
	DW	04fH
	DW	05H
	DW	0eH
	DW	011H
	DW	03H
	DW	02H
	DW	02H
	DW	0bH
	DW	03H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	08H
	DW	02H
	DW	017H
	DW	04H
	DW	05H
	DW	08H
	DW	0aH
	DW	04H
	DW	02H
	DW	07H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	05H
	DW	01cH
	DW	01H
	DW	01H
	DW	07H
	DW	07H
	DW	014H
	DW	05H
	DW	03H
	DW	01dH
	DW	03H
	DW	011H
	DW	01aH
	DW	01H
	DW	08H
	DW	04H
	DW	01bH
	DW	03H
	DW	06H
	DW	0bH
	DW	017H
	DW	05H
	DW	03H
	DW	04H
	DW	06H
	DW	0dH
	DW	018H
	DW	010H
	DW	06H
	DW	05H
	DW	0aH
	DW	019H
	DW	023H
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	03H
	DW	0eH
	DW	03H
	DW	06H
	DW	02H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	08H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	0dH
	DW	02H
	DW	02H
	DW	04H
	DW	05H
	DW	02H
	DW	01H
	DW	0eH
	DW	0eH
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	02H
	DW	03H
	DW	01H
	DW	0eH
	DW	03H
	DW	0cH
	DW	03H
	DW	011H
	DW	02H
	DW	010H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	08H
	DW	09H
	DW	03H
	DW	013H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	011H
	DW	019H
	DW	015H
	DW	014H
	DW	01cH
	DW	04bH
	DW	01H
	DW	0aH
	DW	01dH
	DW	067H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	03H
	DW	018H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	05H
	DW	06H
	DW	0dH
	DW	09H
	DW	010H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	02H
	DW	04H
	DW	05H
	DW	02H
	DW	05H
	DW	02H
	DW	02H
	DW	03H
	DW	07H
	DW	0dH
	DW	07H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	06H
	DW	04H
	DW	09H
	DW	02H
	DW	01H
	DW	0eH
	DW	02H
	DW	0eH
	DW	02H
	DW	01H
	DW	012H
	DW	03H
	DW	04H
	DW	0eH
	DW	04H
	DW	0bH
	DW	029H
	DW	0fH
	DW	017H
	DW	0fH
	DW	017H
	DW	0b0H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	03H
	DW	01H
	DW	02H
	DW	03H
	DW	07H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	09H
	DW	07H
	DW	01H
	DW	0aH
	DW	05H
	DW	08H
	DW	010H
	DW	01dH
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	05H
	DW	04H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	07H
	DW	01H
	DW	06H
	DW	0aH
	DW	01H
	DW	011H
	DW	01H
	DW	02cH
	DW	04H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	05H
	DW	04H
	DW	02H
	DW	0aH
	DW	01H
	DW	06H
	DW	09H
	DW	02H
	DW	08H
	DW	01H
	DW	018H
	DW	01H
	DW	02H
	DW	0dH
	DW	07H
	DW	08H
	DW	08H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	02H
	DW	05H
	DW	0aH
	DW	09H
	DW	04H
	DW	09H
	DW	0cH
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	07H
	DW	07H
	DW	04H
	DW	0aH
	DW	08H
	DW	03H
	DW	01H
	DW	0dH
	DW	04H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	011H
	DW	010H
	DW	05H
	DW	02H
	DW	010H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	08H
	DW	05H
	DW	0bH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	06H
	DW	0aH
	DW	09H
	DW	05H
	DW	07H
	DW	04H
	DW	07H
	DW	04H
	DW	07H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	08H
	DW	07H
	DW	01H
	DW	06H
	DW	0bH
	DW	05H
	DW	05H
	DW	03H
	DW	018H
	DW	09H
	DW	04H
	DW	02H
	DW	07H
	DW	0dH
	DW	05H
	DW	01H
	DW	08H
	DW	052H
	DW	010H
	DW	03dH
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	010H
	DW	0aH
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	06H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	08H
	DW	04H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	06H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	04H
	DW	04H
	DW	03H
	DW	01H
	DW	08H
	DW	01H
	DW	03H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	07H
	DW	01H
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	0aH
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	0bH
	DW	03H
	DW	09H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	09H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	07H
	DW	09H
	DW	09H
	DW	08H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	06H
	DW	08H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	020H
	DW	06H
	DW	01H
	DW	02H
	DW	0fH
	DW	09H
	DW	03H
	DW	07H
	DW	0dH
	DW	01H
	DW	03H
	DW	0aH
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0dH
	DW	0aH
	DW	02H
	DW	01H
	DW	03H
	DW	0aH
	DW	04H
	DW	0fH
	DW	02H
	DW	0fH
	DW	0fH
	DW	0aH
	DW	01H
	DW	03H
	DW	09H
	DW	06H
	DW	09H
	DW	020H
	DW	019H
	DW	01aH
	DW	02fH
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	03H
	DW	04H
	DW	03H
	DW	02H
	DW	08H
	DW	05H
	DW	04H
	DW	01H
	DW	09H
	DW	04H
	DW	02H
	DW	02H
	DW	013H
	DW	0aH
	DW	06H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	09H
	DW	04H
	DW	04H
	DW	04H
	DW	06H
	DW	04H
	DW	08H
	DW	09H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	05H
	DW	05H
	DW	01H
	DW	03H
	DW	08H
	DW	04H
	DW	06H
	DW	02H
	DW	01H
	DW	04H
	DW	0cH
	DW	01H
	DW	05H
	DW	03H
	DW	07H
	DW	0dH
	DW	02H
	DW	05H
	DW	08H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	05H
	DW	0eH
	DW	06H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	08H
	DW	0fH
	DW	05H
	DW	01H
	DW	017H
	DW	06H
	DW	03eH
	DW	02H
	DW	0aH
	DW	01H
	DW	01H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	0aH
	DW	04H
	DW	02H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	0bH
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	07H
	DW	01H
	DW	0eH
	DW	01H
	DW	02H
	DW	03H
	DW	0cH
	DW	05H
	DW	02H
	DW	05H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	07H
	DW	0eH
	DW	0bH
	DW	01H
	DW	03H
	DW	01H
	DW	08H
	DW	09H
	DW	0cH
	DW	02H
	DW	01H
	DW	0bH
	DW	08H
	DW	04H
	DW	04H
	DW	02H
	DW	06H
	DW	0aH
	DW	09H
	DW	0dH
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	05H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	04H
	DW	01H
	DW	012H
	DW	02H
	DW	03H
	DW	0eH
	DW	0bH
	DW	04H
	DW	01dH
	DW	04H
	DW	02H
	DW	07H
	DW	01H
	DW	03H
	DW	0dH
	DW	09H
	DW	02H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	014H
	DW	07H
	DW	010H
	DW	08H
	DW	05H
	DW	048H
	DW	022H
	DW	06H
	DW	04H
	DW	016H
	DW	0cH
	DW	0cH
	DW	01cH
	DW	02dH
	DW	024H
	DW	09H
	DW	07H
	DW	027H
	DW	09H
	DW	0bfH
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	0bH
	DW	08H
	DW	04H
	DW	09H
	DW	02H
	DW	03H
	DW	016H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	011H
	DW	01H
	DW	07H
	DW	07H
	DW	01H
	DW	0bH
	DW	01fH
	DW	0aH
	DW	02H
	DW	04H
	DW	08H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	010H
	DW	04H
	DW	020H
	DW	02H
	DW	03H
	DW	013H
	DW	0dH
	DW	04H
	DW	09H
	DW	01H
	DW	05H
	DW	02H
	DW	0eH
	DW	08H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	013H
	DW	06H
	DW	05H
	DW	01H
	DW	010H
	DW	06H
	DW	02H
	DW	0aH
	DW	08H
	DW	05H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	05H
	DW	01H
	DW	0bH
	DW	06H
	DW	06H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	06H
	DW	03H
	DW	08H
	DW	01H
	DW	01H
	DW	04H
	DW	0aH
	DW	07H
	DW	05H
	DW	07H
	DW	07H
	DW	05H
	DW	08H
	DW	09H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	06H
	DW	010H
	DW	01H
	DW	04H
	DW	06H
	DW	03H
	DW	01H
	DW	0aH
	DW	06H
	DW	01H
	DW	03H
	DW	0fH
	DW	02H
	DW	09H
	DW	02H
	DW	0aH
	DW	019H
	DW	0dH
	DW	09H
	DW	010H
	DW	06H
	DW	02H
	DW	02H
	DW	0aH
	DW	0bH
	DW	04H
	DW	03H
	DW	09H
	DW	01H
	DW	02H
	DW	06H
	DW	06H
	DW	05H
	DW	04H
	DW	01eH
	DW	028H
	DW	01H
	DW	0aH
	DW	07H
	DW	0cH
	DW	0eH
	DW	021H
	DW	06H
	DW	03H
	DW	06H
	DW	07H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	0bH
	DW	0eH
	DW	04H
	DW	09H
	DW	05H
	DW	0cH
	DW	0bH
	DW	031H
	DW	012H
	DW	033H
	DW	01fH
	DW	08cH
	DW	01fH
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	08H
	DW	01H
	DW	0aH
	DW	01H
	DW	04H
	DW	04H
	DW	03H
	DW	018H
	DW	01H
	DW	0aH
	DW	01H
	DW	03H
	DW	06H
	DW	06H
	DW	010H
	DW	03H
	DW	04H
	DW	05H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	039H
	DW	0aH
	DW	06H
	DW	016H
	DW	02H
	DW	016H
	DW	03H
	DW	07H
	DW	016H
	DW	06H
	DW	0aH
	DW	0bH
	DW	024H
	DW	012H
	DW	010H
	DW	021H
	DW	024H
	DW	02H
	DW	05H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	0aH
	DW	01H
	DW	04H
	DW	0dH
	DW	02H
	DW	07H
	DW	05H
	DW	02H
	DW	09H
	DW	03H
	DW	04H
	DW	01H
	DW	07H
	DW	02bH
	DW	03H
	DW	07H
	DW	03H
	DW	09H
	DW	0eH
	DW	07H
	DW	09H
	DW	01H
	DW	0bH
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	04H
	DW	012H
	DW	0dH
	DW	01H
	DW	0eH
	DW	01H
	DW	03H
	DW	06H
	DW	0aH
	DW	049H
	DW	02H
	DW	02H
	DW	01eH
	DW	06H
	DW	01H
	DW	0bH
	DW	012H
	DW	013H
	DW	0dH
	DW	016H
	DW	03H
	DW	02eH
	DW	02aH
	DW	025H
	DW	059H
	DW	07H
	DW	03H
	DW	010H
	DW	022H
	DW	02H
	DW	02H
	DW	03H
	DW	09H
	DW	01H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	07H
	DW	03H
	DW	0aH
	DW	03H
	DW	09H
	DW	05H
	DW	01cH
	DW	09H
	DW	02H
	DW	06H
	DW	0dH
	DW	07H
	DW	03H
	DW	01H
	DW	03H
	DW	0aH
	DW	02H
	DW	07H
	DW	02H
	DW	0bH
	DW	03H
	DW	06H
	DW	015H
	DW	036H
	DW	055H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	01H
	DW	027H
	DW	03H
	DW	015H
	DW	02H
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	0fH
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	08H
	DW	02H
	DW	014H
	DW	01H
	DW	08H
	DW	07H
	DW	0dH
	DW	04H
	DW	01H
	DW	01aH
	DW	06H
	DW	02H
	DW	09H
	DW	022H
	DW	04H
	DW	015H
	DW	034H
	DW	0aH
	DW	04H
	DW	04H
	DW	01H
	DW	05H
	DW	0cH
	DW	02H
	DW	0bH
	DW	01H
	DW	07H
	DW	02H
	DW	01eH
	DW	0cH
	DW	02cH
	DW	02H
	DW	01eH
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	010H
	DW	09H
	DW	011H
	DW	027H
	DW	052H
	DW	02H
	DW	02H
	DW	018H
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	010H
	DW	09H
	DW	0eH
	DW	02cH
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	03H
	DW	02H
	DW	06H
	DW	01H
	DW	0bH
	DW	05H
	DW	0bH
	DW	02H
	DW	01H
	DW	012H
	DW	013H
	DW	08H
	DW	01H
	DW	03H
	DW	018H
	DW	01dH
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	0dH
	DW	06H
	DW	05H
	DW	01H
	DW	02eH
	DW	0bH
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	05H
	DW	08H
	DW	02H
	DW	0aH
	DW	06H
	DW	0cH
	DW	06H
	DW	03H
	DW	07H
	DW	0bH
	DW	02H
	DW	04H
	DW	010H
	DW	0dH
	DW	02H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	05H
	DW	02H
	DW	01cH
	DW	05H
	DW	02H
	DW	017H
	DW	0aH
	DW	08H
	DW	04H
	DW	04H
	DW	016H
	DW	027H
	DW	05fH
	DW	026H
	DW	08H
	DW	0eH
	DW	09H
	DW	05H
	DW	01H
	DW	0dH
	DW	05H
	DW	04H
	DW	03H
	DW	0dH
	DW	0cH
	DW	0bH
	DW	01H
	DW	09H
	DW	01H
	DW	01bH
	DW	025H
	DW	02H
	DW	05H
	DW	04H
	DW	04H
	DW	03fH
	DW	0d3H
	DW	05fH
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	03H
	DW	07H
	DW	0fH
	DW	05H
	DW	03H
	DW	02H
	DW	05H
	DW	03H
	DW	09H
	DW	0bH
	DW	04H
	DW	02H
	DW	016H
	DW	01H
	DW	06H
	DW	03H
	DW	08H
	DW	07H
	DW	01H
	DW	04H
	DW	01cH
	DW	04H
	DW	010H
	DW	03H
	DW	03H
	DW	019H
	DW	04H
	DW	04H
	DW	01bH
	DW	01bH
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01cH
	DW	08H
	DW	02H
	DW	0eH
	DW	01H
	DW	08H
	DW	06H
	DW	010H
	DW	019H
	DW	03H
	DW	03H
	DW	03H
	DW	0eH
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	06H
	DW	03H
	DW	08H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	06H
	DW	0aH
	DW	06H
	DW	02H
	DW	03H
	DW	012H
	DW	03H
	DW	02H
	DW	05H
	DW	05H
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	04H
	DW	017H
	DW	07H
	DW	06H
	DW	0cH
	DW	06H
	DW	04H
	DW	011H
	DW	0bH
	DW	09H
	DW	05H
	DW	01H
	DW	01H
	DW	0aH
	DW	05H
	DW	0cH
	DW	01H
	DW	01H
	DW	0bH
	DW	01aH
	DW	021H
	DW	07H
	DW	03H
	DW	06H
	DW	01H
	DW	011H
	DW	07H
	DW	01H
	DW	05H
	DW	0cH
	DW	01H
	DW	0bH
	DW	02H
	DW	04H
	DW	01H
	DW	08H
	DW	0eH
	DW	011H
	DW	017H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	08H
	DW	010H
	DW	0bH
	DW	09H
	DW	06H
	DW	05H
	DW	02H
	DW	06H
	DW	04H
	DW	010H
	DW	02H
	DW	08H
	DW	0eH
	DW	01H
	DW	0bH
	DW	08H
	DW	09H
	DW	01H
	DW	01H
	DW	01H
	DW	09H
	DW	019H
	DW	04H
	DW	0bH
	DW	013H
	DW	07H
	DW	02H
	DW	0fH
	DW	02H
	DW	0cH
	DW	08H
	DW	034H
	DW	07H
	DW	05H
	DW	013H
	DW	02H
	DW	010H
	DW	04H
	DW	024H
	DW	08H
	DW	01H
	DW	010H
	DW	08H
	DW	018H
	DW	01aH
	DW	04H
	DW	06H
	DW	02H
	DW	09H
	DW	05H
	DW	04H
	DW	024H
	DW	03H
	DW	01cH
	DW	0cH
	DW	019H
	DW	0fH
	DW	025H
	DW	01bH
	DW	011H
	DW	0cH
	DW	03bH
	DW	026H
	DW	05H
	DW	020H
	DW	07fH
	DW	01H
	DW	02H
	DW	09H
	DW	011H
	DW	0eH
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	08H
	DW	0bH
	DW	032H
	DW	04H
	DW	0eH
	DW	02H
	DW	013H
	DW	010H
	DW	04H
	DW	011H
	DW	05H
	DW	04H
	DW	05H
	DW	01aH
	DW	0cH
	DW	02dH
	DW	02H
	DW	017H
	DW	02dH
	DW	068H
	DW	01eH
	DW	0cH
	DW	08H
	DW	03H
	DW	0aH
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	04H
	DW	014H
	DW	07H
	DW	02H
	DW	09H
	DW	06H
	DW	0fH
	DW	02H
	DW	014H
	DW	01H
	DW	03H
	DW	010H
	DW	04H
	DW	0bH
	DW	0fH
	DW	06H
	DW	086H
	DW	02H
	DW	05H
	DW	03bH
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	09H
	DW	011H
	DW	03H
	DW	01aH
	DW	089H
	DW	0aH
	DW	0d3H
	DW	03bH
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	03H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	0eH
	DW	06H
	DW	01H
	DW	03H
	DW	02H
	DW	09H
	DW	06H
	DW	0fH
	DW	01bH
	DW	09H
	DW	022H
	DW	091H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	05H
	DW	08H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	04H
	DW	05H
	DW	01H
	DW	014H
	DW	04H
	DW	010H
	DW	01H
	DW	0fH
	DW	09H
	DW	05H
	DW	0cH
	DW	02H
	DW	09H
	DW	02H
	DW	05H
	DW	04H
	DW	02H
	DW	01aH
	DW	013H
	DW	07H
	DW	01H
	DW	01aH
	DW	04H
	DW	01eH
	DW	0cH
	DW	0fH
	DW	02aH
	DW	01H
	DW	06H
	DW	08H
	DW	0acH
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	01H
	DW	0bH
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	08H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	08H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0cH
	DW	05H
	DW	07H
	DW	02H
	DW	04H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	0cH
	DW	0eH
	DW	0bH
	DW	06H
	DW	06H
	DW	04H
	DW	0cH
	DW	02H
	DW	08H
	DW	01H
	DW	07H
	DW	0aH
	DW	01H
	DW	023H
	DW	07H
	DW	04H
	DW	0dH
	DW	0fH
	DW	04H
	DW	03H
	DW	017H
	DW	015H
	DW	01cH
	DW	034H
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	01H
	DW	07H
	DW	0aH
	DW	02H
	DW	07H
	DW	035H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	0a3H
	DW	0214H
	DW	01H
	DW	0aH
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	04H
	DW	08H
	DW	02H
	DW	08H
	DW	06H
	DW	02H
	DW	02H
	DW	017H
	DW	016H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	09H
	DW	08H
	DW	02H
	DW	01H
	DW	02H
	DW	08H
	DW	01H
	DW	0aH
	DW	02H
	DW	0cH
	DW	015H
	DW	014H
	DW	0fH
	DW	069H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	0fH
	DW	0bH
	DW	013H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	04H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	05H
	DW	03H
	DW	05H
	DW	0cH
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	0bH
	DW	01H
	DW	01H
	DW	0fH
	DW	09H
	DW	01H
	DW	04H
	DW	05H
	DW	03H
	DW	01aH
	DW	08H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	0fH
	DW	013H
	DW	02H
	DW	0cH
	DW	01H
	DW	02H
	DW	05H
	DW	02H
	DW	07H
	DW	02H
	DW	013H
	DW	02H
	DW	014H
	DW	06H
	DW	01aH
	DW	07H
	DW	05H
	DW	02H
	DW	02H
	DW	07H
	DW	022H
	DW	015H
	DW	0dH
	DW	046H
	DW	02H
	DW	080H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	0fH
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	02aH
	DW	0aH
	DW	06H
	DW	01H
	DW	031H
	DW	055H
	DW	08H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	05H
	DW	07H
	DW	04H
	DW	03H
	DW	0d3H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	06H
	DW	05H
	DW	06H
	DW	0aH
	DW	03H
	DW	04H
	DW	030H
	DW	064H
	DW	06H
	DW	02H
	DW	010H
	DW	0128H
	DW	05H
	DW	01bH
	DW	0183H
	DW	02H
	DW	02H
	DW	03H
	DW	07H
	DW	010H
	DW	08H
	DW	05H
	DW	026H
	DW	0fH
	DW	027H
	DW	015H
	DW	09H
	DW	0aH
	DW	03H
	DW	07H
	DW	03bH
	DW	0dH
	DW	01bH
	DW	015H
	DW	02fH
	DW	05H
	DW	015H
	DW	06H
CONST	ENDS
;	COMDAT ?base_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_DATA	SEGMENT
?base_ranges@?1??GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 020H ; `ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon'::`2'::base_ranges
	DW	0ffH
	DW	02000H
	DW	0206fH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
	DW	0fffdH
	DW	0fffdH
_DATA	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesKorean'::`2'::ranges
	DW	0ffH
	DW	03131H
	DW	03163H
	DW	0ac00H
	DW	0d7a3H
	DW	0fffdH
	DW	0fffdH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesDefault'::`2'::ranges
	DW	0ffH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesThai'::`2'::ranges
	DW	0ffH
	DW	02010H
	DW	0205eH
	DW	0e00H
	DW	0e7fH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesVietnamese@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesVietnamese@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesVietnamese'::`2'::ranges
	DW	0ffH
	DW	0102H
	DW	0103H
	DW	0110H
	DW	0111H
	DW	0128H
	DW	0129H
	DW	0168H
	DW	0169H
	DW	01a0H
	DW	01a1H
	DW	01afH
	DW	01b0H
	DW	01ea0H
	DW	01ef9H
	DW	00H
CONST	ENDS
;	COMDAT ?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4QBFB
CONST	SEGMENT
?accumulative_offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4QBFB DW 00H ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::accumulative_offsets_from_0x4E00
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	01H
	DW	05H
	DW	03H
	DW	05H
	DW	07H
	DW	05H
	DW	06H
	DW	01H
	DW	02H
	DW	01H
	DW	07H
	DW	02H
	DW	06H
	DW	03H
	DW	01H
	DW	08H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	012H
	DW	02H
	DW	0bH
	DW	02H
	DW	06H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	0cH
	DW	07H
	DW	09H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	09H
	DW	02H
	DW	02H
	DW	04H
	DW	05H
	DW	06H
	DW	09H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	09H
	DW	03H
	DW	012H
	DW	05H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	06H
	DW	03H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	017H
	DW	02H
	DW	0aH
	DW	04H
	DW	03H
	DW	05H
	DW	02H
	DW	04H
	DW	0aH
	DW	02H
	DW	04H
	DW	0dH
	DW	01H
	DW	06H
	DW	01H
	DW	09H
	DW	03H
	DW	01H
	DW	01H
	DW	06H
	DW	06H
	DW	07H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	0bH
	DW	03H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	0fH
	DW	02H
	DW	02H
	DW	05H
	DW	04H
	DW	03H
	DW	06H
	DW	04H
	DW	01H
	DW	02H
	DW	05H
	DW	02H
	DW	0cH
	DW	010H
	DW	06H
	DW	0dH
	DW	09H
	DW	0dH
	DW	02H
	DW	01H
	DW	01H
	DW	07H
	DW	010H
	DW	04H
	DW	07H
	DW	01H
	DW	013H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	07H
	DW	08H
	DW	02H
	DW	06H
	DW	05H
	DW	04H
	DW	09H
	DW	012H
	DW	07H
	DW	04H
	DW	05H
	DW	09H
	DW	0dH
	DW	0bH
	DW	08H
	DW	0fH
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	08H
	DW	02H
	DW	09H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	09H
	DW	01H
	DW	04H
	DW	03H
	DW	05H
	DW	05H
	DW	02H
	DW	07H
	DW	05H
	DW	03H
	DW	04H
	DW	08H
	DW	02H
	DW	01H
	DW	0dH
	DW	02H
	DW	03H
	DW	03H
	DW	01H
	DW	0eH
	DW	01H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	07H
	DW	06H
	DW	06H
	DW	07H
	DW	01H
	DW	04H
	DW	07H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0cH
	DW	03H
	DW	03H
	DW	09H
	DW	05H
	DW	02H
	DW	06H
	DW	01H
	DW	05H
	DW	06H
	DW	01H
	DW	02H
	DW	03H
	DW	012H
	DW	02H
	DW	04H
	DW	0eH
	DW	04H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	05H
	DW	05H
	DW	03H
	DW	02H
	DW	02H
	DW	02H
	DW	02H
	DW	0cH
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	0bH
	DW	01H
	DW	07H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	011H
	DW	01H
	DW	09H
	DW	01H
	DW	018H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	0fH
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	014H
	DW	02H
	DW	05H
	DW	09H
	DW	01H
	DW	0aH
	DW	08H
	DW	07H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	02H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	0cH
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0aH
	DW	03H
	DW	01H
	DW	07H
	DW	05H
	DW	0dH
	DW	01H
	DW	02H
	DW	03H
	DW	04H
	DW	06H
	DW	01H
	DW	01H
	DW	01eH
	DW	02H
	DW	09H
	DW	09H
	DW	01H
	DW	0fH
	DW	026H
	DW	0bH
	DW	03H
	DW	01H
	DW	08H
	DW	018H
	DW	07H
	DW	01H
	DW	09H
	DW	08H
	DW	0aH
	DW	02H
	DW	01H
	DW	09H
	DW	01fH
	DW	02H
	DW	0dH
	DW	06H
	DW	02H
	DW	09H
	DW	04H
	DW	031H
	DW	05H
	DW	02H
	DW	0fH
	DW	02H
	DW	01H
	DW	0aH
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	06H
	DW	0fH
	DW	01eH
	DW	023H
	DW	03H
	DW	0eH
	DW	012H
	DW	08H
	DW	01H
	DW	010H
	DW	0aH
	DW	01cH
	DW	0cH
	DW	013H
	DW	02dH
	DW	026H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	0dH
	DW	02H
	DW	01H
	DW	07H
	DW	03H
	DW	06H
	DW	05H
	DW	03H
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	07H
	DW	08H
	DW	01H
	DW	05H
	DW	03H
	DW	012H
	DW	05H
	DW	03H
	DW	06H
	DW	01H
	DW	015H
	DW	04H
	DW	018H
	DW	09H
	DW	018H
	DW	028H
	DW	03H
	DW	0eH
	DW	03H
	DW	015H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	03H
	DW	01H
	DW	0fH
	DW	0fH
	DW	06H
	DW	05H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	05H
	DW	06H
	DW	01H
	DW	09H
	DW	07H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	04H
	DW	03H
	DW	08H
	DW	015H
	DW	05H
	DW	010H
	DW	04H
	DW	05H
	DW	02H
	DW	0aH
	DW	0bH
	DW	0bH
	DW	03H
	DW	06H
	DW	03H
	DW	02H
	DW	09H
	DW	03H
	DW	06H
	DW	0dH
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	0bH
	DW	0cH
	DW	06H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	06H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	06H
	DW	0dH
	DW	03H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	03H
	DW	03H
	DW	0eH
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	05H
	DW	01H
	DW	09H
	DW	05H
	DW	01H
	DW	01H
	DW	06H
	DW	0cH
	DW	03H
	DW	0cH
	DW	03H
	DW	04H
	DW	0dH
	DW	02H
	DW	0eH
	DW	02H
	DW	08H
	DW	01H
	DW	011H
	DW	05H
	DW	01H
	DW	010H
	DW	04H
	DW	02H
	DW	02H
	DW	015H
	DW	08H
	DW	09H
	DW	06H
	DW	017H
	DW	014H
	DW	0cH
	DW	019H
	DW	013H
	DW	09H
	DW	026H
	DW	08H
	DW	03H
	DW	015H
	DW	028H
	DW	019H
	DW	021H
	DW	0dH
	DW	04H
	DW	03H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	05H
	DW	01aH
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	09H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	06H
	DW	01H
	DW	08H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	03H
	DW	02H
	DW	07H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	05H
	DW	04H
	DW	0aH
	DW	09H
	DW	04H
	DW	09H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	03H
	DW	02H
	DW	01H
	DW	06H
	DW	04H
	DW	09H
	DW	06H
	DW	01H
	DW	0aH
	DW	02H
	DW	01fH
	DW	011H
	DW	08H
	DW	03H
	DW	07H
	DW	05H
	DW	028H
	DW	01H
	DW	07H
	DW	07H
	DW	01H
	DW	06H
	DW	05H
	DW	02H
	DW	0aH
	DW	07H
	DW	08H
	DW	04H
	DW	0fH
	DW	027H
	DW	019H
	DW	06H
	DW	01cH
	DW	02fH
	DW	012H
	DW	0aH
	DW	07H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	06H
	DW	0aH
	DW	07H
	DW	08H
	DW	06H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	05H
	DW	08H
	DW	07H
	DW	09H
	DW	0cH
	DW	02H
	DW	0fH
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	05H
	DW	06H
	DW	02H
	DW	03H
	DW	02H
	DW	0aH
	DW	01H
	DW	04H
	DW	02H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	0bH
	DW	06H
	DW	01H
	DW	015H
	DW	04H
	DW	010H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	03H
	DW	06H
	DW	05H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	04H
	DW	06H
	DW	01H
	DW	01H
	DW	0aH
	DW	04H
	DW	02H
	DW	07H
	DW	0aH
	DW	04H
	DW	07H
	DW	04H
	DW	02H
	DW	09H
	DW	04H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	08H
	DW	03H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	07H
	DW	02H
	DW	01H
	DW	08H
	DW	01H
	DW	04H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	06H
	DW	02H
	DW	07H
	DW	01H
	DW	0aH
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	0bH
	DW	0aH
	DW	08H
	DW	015H
	DW	04H
	DW	06H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	01H
	DW	02H
	DW	01cH
	DW	05H
	DW	05H
	DW	02H
	DW	03H
	DW	0dH
	DW	01H
	DW	02H
	DW	03H
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	05H
	DW	014H
	DW	03H
	DW	08H
	DW	0bH
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	08H
	DW	0aH
	DW	09H
	DW	02H
	DW	0aH
	DW	09H
	DW	02H
	DW	03H
	DW	01H
	DW	01H
	DW	02H
	DW	04H
	DW	01H
	DW	08H
	DW	03H
	DW	06H
	DW	01H
	DW	07H
	DW	08H
	DW	06H
	DW	0bH
	DW	01H
	DW	04H
	DW	01dH
	DW	08H
	DW	04H
	DW	03H
	DW	01H
	DW	02H
	DW	07H
	DW	0dH
	DW	01H
	DW	04H
	DW	01H
	DW	06H
	DW	02H
	DW	06H
	DW	0cH
	DW	0cH
	DW	02H
	DW	014H
	DW	03H
	DW	02H
	DW	03H
	DW	06H
	DW	04H
	DW	08H
	DW	09H
	DW	02H
	DW	07H
	DW	022H
	DW	05H
	DW	01H
	DW	012H
	DW	06H
	DW	01H
	DW	01H
	DW	04H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	03H
	DW	04H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	019H
	DW	05H
	DW	03H
	DW	06H
	DW	01H
	DW	04H
	DW	06H
	DW	07H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	0dH
	DW	06H
	DW	04H
	DW	04H
	DW	03H
	DW	01H
	DW	05H
	DW	03H
	DW	04H
	DW	04H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	0bH
	DW	01H
	DW	06H
	DW	03H
	DW	01H
	DW	07H
	DW	03H
	DW	06H
	DW	02H
	DW	08H
	DW	08H
	DW	06H
	DW	09H
	DW	03H
	DW	04H
	DW	0bH
	DW	03H
	DW	02H
	DW	0aH
	DW	0cH
	DW	02H
	DW	05H
	DW	0bH
	DW	01H
	DW	06H
	DW	04H
	DW	05H
	DW	03H
	DW	01H
	DW	08H
	DW	05H
	DW	04H
	DW	06H
	DW	06H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	06H
	DW	011H
	DW	0cH
	DW	01H
	DW	0aH
	DW	01H
	DW	06H
	DW	0cH
	DW	01H
	DW	06H
	DW	06H
	DW	013H
	DW	09H
	DW	06H
	DW	010H
	DW	01H
	DW	0dH
	DW	04H
	DW	04H
	DW	0fH
	DW	07H
	DW	011H
	DW	06H
	DW	0bH
	DW	09H
	DW	0fH
	DW	0cH
	DW	06H
	DW	07H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	0fH
	DW	09H
	DW	03H
	DW	015H
	DW	04H
	DW	06H
	DW	031H
	DW	012H
	DW	07H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	08H
	DW	02H
	DW	02H
	DW	06H
	DW	02H
	DW	09H
	DW	01H
	DW	03H
	DW	06H
	DW	04H
	DW	04H
	DW	01H
	DW	02H
	DW	010H
	DW	02H
	DW	05H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	01H
	DW	08H
	DW	06H
	DW	04H
	DW	08H
	DW	0bH
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	0dH
	DW	08H
	DW	04H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	01H
	DW	04H
	DW	01H
	DW	0bH
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	05H
	DW	08H
	DW	06H
	DW	01H
	DW	01H
	DW	07H
	DW	04H
	DW	03H
	DW	08H
	DW	03H
	DW	02H
	DW	07H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	07H
	DW	06H
	DW	02H
	DW	08H
	DW	05H
	DW	01H
	DW	0bH
	DW	04H
	DW	05H
	DW	03H
	DW	06H
	DW	012H
	DW	01H
	DW	02H
	DW	0dH
	DW	03H
	DW	03H
	DW	01H
	DW	015H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	06H
	DW	03H
	DW	0cH
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	06H
	DW	03H
	DW	02H
	DW	04H
	DW	08H
	DW	02H
	DW	02H
	DW	04H
	DW	02H
	DW	07H
	DW	01H
	DW	08H
	DW	09H
	DW	05H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	0dH
	DW	07H
	DW	0eH
	DW	06H
	DW	05H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	04H
	DW	02H
	DW	017H
	DW	02H
	DW	01H
	DW	01H
	DW	06H
	DW	03H
	DW	01H
	DW	04H
	DW	01H
	DW	0fH
	DW	03H
	DW	01H
	DW	07H
	DW	03H
	DW	09H
	DW	0eH
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	01H
	DW	01H
	DW	05H
	DW	08H
	DW	01H
	DW	03H
	DW	08H
	DW	03H
	DW	08H
	DW	0fH
	DW	0bH
	DW	04H
	DW	0eH
	DW	04H
	DW	04H
	DW	02H
	DW	05H
	DW	05H
	DW	01H
	DW	07H
	DW	01H
	DW	06H
	DW	0eH
	DW	07H
	DW	07H
	DW	08H
	DW	05H
	DW	0fH
	DW	04H
	DW	08H
	DW	06H
	DW	05H
	DW	06H
	DW	02H
	DW	01H
	DW	0dH
	DW	01H
	DW	014H
	DW	0fH
	DW	0bH
	DW	09H
	DW	02H
	DW	05H
	DW	06H
	DW	02H
	DW	0bH
	DW	02H
	DW	06H
	DW	02H
	DW	05H
	DW	01H
	DW	05H
	DW	08H
	DW	04H
	DW	0dH
	DW	013H
	DW	019H
	DW	04H
	DW	01H
	DW	01H
	DW	0bH
	DW	01H
	DW	022H
	DW	02H
	DW	05H
	DW	09H
	DW	0eH
	DW	06H
	DW	02H
	DW	02H
	DW	06H
	DW	01H
	DW	01H
	DW	0eH
	DW	01H
	DW	03H
	DW	0eH
	DW	0dH
	DW	01H
	DW	06H
	DW	0cH
	DW	015H
	DW	0eH
	DW	0eH
	DW	06H
	DW	020H
	DW	011H
	DW	08H
	DW	020H
	DW	09H
	DW	01cH
	DW	01H
	DW	02H
	DW	04H
	DW	0bH
	DW	08H
	DW	03H
	DW	01H
	DW	0eH
	DW	02H
	DW	05H
	DW	0fH
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	06H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	0bH
	DW	03H
	DW	01H
	DW	01H
	DW	0bH
	DW	01eH
	DW	01H
	DW	05H
	DW	01H
	DW	04H
	DW	01H
	DW	05H
	DW	08H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	03H
	DW	011H
	DW	023H
	DW	02H
	DW	06H
	DW	0cH
	DW	011H
	DW	03H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	01H
	DW	0cH
	DW	02H
	DW	07H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	010H
	DW	02H
	DW	08H
	DW	03H
	DW	06H
	DW	05H
	DW	04H
	DW	07H
	DW	03H
	DW	03H
	DW	08H
	DW	01H
	DW	09H
	DW	08H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	08H
	DW	01H
	DW	02H
	DW	09H
	DW	0cH
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	08H
	DW	03H
	DW	018H
	DW	0cH
	DW	04H
	DW	03H
	DW	07H
	DW	05H
	DW	08H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	03H
	DW	01H
	DW	017H
	DW	0aH
	DW	03H
	DW	01H
	DW	02H
	DW	02H
	DW	06H
	DW	03H
	DW	01H
	DW	010H
	DW	01H
	DW	010H
	DW	016H
	DW	03H
	DW	0aH
	DW	04H
	DW	0bH
	DW	06H
	DW	09H
	DW	07H
	DW	07H
	DW	03H
	DW	06H
	DW	02H
	DW	02H
	DW	02H
	DW	04H
	DW	0aH
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	08H
	DW	07H
	DW	01H
	DW	06H
	DW	04H
	DW	01H
	DW	03H
	DW	03H
	DW	03H
	DW	05H
	DW	0aH
	DW	0cH
	DW	0cH
	DW	02H
	DW	03H
	DW	0cH
	DW	08H
	DW	0fH
	DW	01H
	DW	01H
	DW	010H
	DW	06H
	DW	06H
	DW	01H
	DW	05H
	DW	09H
	DW	0bH
	DW	04H
	DW	0bH
	DW	04H
	DW	02H
	DW	06H
	DW	0cH
	DW	01H
	DW	011H
	DW	05H
	DW	0dH
	DW	01H
	DW	04H
	DW	09H
	DW	05H
	DW	01H
	DW	0bH
	DW	02H
	DW	01H
	DW	08H
	DW	01H
	DW	05H
	DW	07H
	DW	01cH
	DW	08H
	DW	03H
	DW	05H
	DW	0aH
	DW	02H
	DW	011H
	DW	03H
	DW	026H
	DW	016H
	DW	01H
	DW	02H
	DW	012H
	DW	0cH
	DW	0aH
	DW	04H
	DW	026H
	DW	012H
	DW	01H
	DW	04H
	DW	02cH
	DW	013H
	DW	04H
	DW	01H
	DW	08H
	DW	04H
	DW	01H
	DW	0cH
	DW	01H
	DW	04H
	DW	01fH
	DW	0cH
	DW	01H
	DW	0eH
	DW	07H
	DW	04bH
	DW	07H
	DW	05H
	DW	0aH
	DW	06H
	DW	06H
	DW	0dH
	DW	03H
	DW	02H
	DW	0bH
	DW	0bH
	DW	03H
	DW	02H
	DW	05H
	DW	01cH
	DW	0fH
	DW	06H
	DW	012H
	DW	012H
	DW	05H
	DW	06H
	DW	04H
	DW	03H
	DW	010H
	DW	01H
	DW	07H
	DW	012H
	DW	07H
	DW	024H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	07H
	DW	01H
	DW	09H
	DW	01H
	DW	0aH
	DW	07H
	DW	02H
	DW	04H
	DW	02H
	DW	06H
	DW	02H
	DW	09H
	DW	07H
	DW	04H
	DW	03H
	DW	020H
	DW	0cH
	DW	03H
	DW	07H
	DW	0aH
	DW	02H
	DW	017H
	DW	010H
	DW	03H
	DW	01H
	DW	0cH
	DW	03H
	DW	01fH
	DW	04H
	DW	0bH
	DW	01H
	DW	03H
	DW	08H
	DW	09H
	DW	05H
	DW	01H
	DW	01eH
	DW	0fH
	DW	06H
	DW	0cH
	DW	03H
	DW	02H
	DW	02H
	DW	0bH
	DW	013H
	DW	09H
	DW	0eH
	DW	02H
	DW	06H
	DW	02H
	DW	03H
	DW	013H
	DW	0dH
	DW	011H
	DW	05H
	DW	03H
	DW	03H
	DW	019H
	DW	03H
	DW	0eH
	DW	01H
	DW	01H
	DW	01H
	DW	024H
	DW	01H
	DW	03H
	DW	02H
	DW	013H
	DW	03H
	DW	0dH
	DW	024H
	DW	09H
	DW	0dH
	DW	01fH
	DW	06H
	DW	04H
	DW	010H
	DW	022H
	DW	02H
	DW	05H
	DW	04H
	DW	02H
	DW	03H
	DW	03H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	011H
	DW	03H
	DW	02H
	DW	03H
	DW	05H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	05H
	DW	06H
	DW	03H
	DW	0cH
	DW	0bH
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01aH
	DW	07H
	DW	0cH
	DW	07H
	DW	02H
	DW	0eH
	DW	03H
	DW	03H
	DW	07H
	DW	07H
	DW	0bH
	DW	019H
	DW	019H
	DW	01cH
	DW	010H
	DW	04H
	DW	024H
	DW	01H
	DW	02H
	DW	01H
	DW	06H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	01bH
	DW	011H
	DW	04H
	DW	03H
	DW	04H
	DW	0dH
	DW	04H
	DW	01H
	DW	03H
	DW	02H
	DW	02H
	DW	01H
	DW	0aH
	DW	04H
	DW	02H
	DW	04H
	DW	06H
	DW	03H
	DW	08H
	DW	02H
	DW	01H
	DW	012H
	DW	01H
	DW	01H
	DW	018H
	DW	02H
	DW	02H
	DW	04H
	DW	021H
	DW	02H
	DW	03H
	DW	03fH
	DW	07H
	DW	01H
	DW	06H
	DW	028H
	DW	07H
	DW	03H
	DW	04H
	DW	04H
	DW	02H
	DW	04H
	DW	0fH
	DW	012H
	DW	01H
	DW	010H
	DW	01H
	DW	01H
	DW	0bH
	DW	02H
	DW	029H
	DW	0eH
	DW	01H
	DW	03H
	DW	012H
	DW	0dH
	DW	03H
	DW	02H
	DW	04H
	DW	010H
	DW	02H
	DW	011H
	DW	07H
	DW	0fH
	DW	018H
	DW	07H
	DW	012H
	DW	0dH
	DW	02cH
	DW	02H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	01H
	DW	07H
	DW	05H
	DW	01H
	DW	07H
	DW	01H
	DW	04H
	DW	03H
	DW	03H
	DW	05H
	DW	0aH
	DW	08H
	DW	02H
	DW	03H
	DW	01H
	DW	08H
	DW	01H
	DW	01H
	DW	01bH
	DW	04H
	DW	02H
	DW	01H
	DW	0cH
	DW	01H
	DW	02H
	DW	01H
	DW	0aH
	DW	06H
	DW	01H
	DW	06H
	DW	07H
	DW	05H
	DW	02H
	DW	03H
	DW	07H
	DW	0bH
	DW	05H
	DW	0bH
	DW	03H
	DW	06H
	DW	06H
	DW	02H
	DW	03H
	DW	0fH
	DW	04H
	DW	09H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	0bH
	DW	02H
	DW	08H
	DW	0cH
	DW	08H
	DW	05H
	DW	04H
	DW	02H
	DW	03H
	DW	01H
	DW	05H
	DW	02H
	DW	02H
	DW	01H
	DW	0eH
	DW	01H
	DW	0cH
	DW	0bH
	DW	04H
	DW	01H
	DW	0bH
	DW	011H
	DW	011H
	DW	04H
	DW	03H
	DW	02H
	DW	05H
	DW	05H
	DW	07H
	DW	03H
	DW	01H
	DW	05H
	DW	09H
	DW	09H
	DW	08H
	DW	02H
	DW	05H
	DW	06H
	DW	06H
	DW	0dH
	DW	0dH
	DW	02H
	DW	01H
	DW	02H
	DW	06H
	DW	01H
	DW	02H
	DW	02H
	DW	031H
	DW	04H
	DW	09H
	DW	01H
	DW	02H
	DW	0aH
	DW	010H
	DW	07H
	DW	08H
	DW	04H
	DW	03H
	DW	02H
	DW	017H
	DW	04H
	DW	03aH
	DW	03H
	DW	01dH
	DW	01H
	DW	0eH
	DW	013H
	DW	013H
	DW	0bH
	DW	0bH
	DW	02H
	DW	07H
	DW	05H
	DW	01H
	DW	03H
	DW	04H
	DW	06H
	DW	02H
	DW	012H
	DW	05H
	DW	0cH
	DW	0cH
	DW	011H
	DW	011H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	04H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	09H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	08H
	DW	01H
	DW	01H
	DW	02H
	DW	06H
	DW	04H
	DW	0eH
	DW	03H
	DW	01H
	DW	04H
	DW	0bH
	DW	04H
	DW	01H
	DW	03H
	DW	020H
	DW	01H
	DW	02H
	DW	04H
	DW	0dH
	DW	04H
	DW	01H
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	0bH
	DW	01H
	DW	04H
	DW	02H
	DW	01H
	DW	04H
	DW	04H
	DW	06H
	DW	03H
	DW	05H
	DW	01H
	DW	06H
	DW	05H
	DW	07H
	DW	06H
	DW	03H
	DW	017H
	DW	03H
	DW	05H
	DW	03H
	DW	05H
	DW	03H
	DW	03H
	DW	0dH
	DW	03H
	DW	09H
	DW	0aH
	DW	01H
	DW	0cH
	DW	0aH
	DW	02H
	DW	03H
	DW	012H
	DW	0dH
	DW	07H
	DW	0a0H
	DW	034H
	DW	04H
	DW	02H
	DW	02H
	DW	03H
	DW	02H
	DW	0eH
	DW	05H
	DW	04H
	DW	0cH
	DW	04H
	DW	06H
	DW	04H
	DW	01H
	DW	014H
	DW	04H
	DW	0bH
	DW	06H
	DW	02H
	DW	0cH
	DW	01bH
	DW	01H
	DW	04H
	DW	01H
	DW	02H
	DW	02H
	DW	07H
	DW	04H
	DW	05H
	DW	02H
	DW	01cH
	DW	03H
	DW	07H
	DW	019H
	DW	08H
	DW	03H
	DW	013H
	DW	03H
	DW	06H
	DW	0aH
	DW	02H
	DW	02H
	DW	01H
	DW	0aH
	DW	02H
	DW	05H
	DW	04H
	DW	01H
	DW	03H
	DW	04H
	DW	01H
	DW	05H
	DW	03H
	DW	02H
	DW	06H
	DW	09H
	DW	03H
	DW	06H
	DW	02H
	DW	010H
	DW	03H
	DW	03H
	DW	010H
	DW	04H
	DW	05H
	DW	05H
	DW	03H
	DW	02H
	DW	01H
	DW	02H
	DW	010H
	DW	0fH
	DW	08H
	DW	02H
	DW	06H
	DW	015H
	DW	02H
	DW	04H
	DW	01H
	DW	016H
	DW	05H
	DW	08H
	DW	01H
	DW	01H
	DW	015H
	DW	0bH
	DW	02H
	DW	01H
	DW	0bH
	DW	0bH
	DW	013H
	DW	0dH
	DW	0cH
	DW	04H
	DW	02H
	DW	03H
	DW	02H
	DW	03H
	DW	06H
	DW	01H
	DW	08H
	DW	0bH
	DW	01H
	DW	04H
	DW	02H
	DW	09H
	DW	05H
	DW	02H
	DW	01H
	DW	0bH
	DW	02H
	DW	09H
	DW	01H
	DW	01H
	DW	02H
	DW	0eH
	DW	01fH
	DW	09H
	DW	03H
	DW	04H
	DW	015H
	DW	0eH
	DW	04H
	DW	08H
	DW	01H
	DW	07H
	DW	02H
	DW	02H
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	014H
	DW	03H
	DW	03H
	DW	04H
	DW	0aH
	DW	01H
	DW	0bH
	DW	09H
	DW	08H
	DW	02H
	DW	01H
	DW	04H
	DW	05H
	DW	0eH
	DW	0cH
	DW	0eH
	DW	02H
	DW	011H
	DW	09H
	DW	06H
	DW	01fH
	DW	04H
	DW	0eH
	DW	01H
	DW	014H
	DW	0dH
	DW	01aH
	DW	05H
	DW	02H
	DW	07H
	DW	03H
	DW	06H
	DW	0dH
	DW	02H
	DW	04H
	DW	02H
	DW	013H
	DW	06H
	DW	02H
	DW	02H
	DW	012H
	DW	09H
	DW	03H
	DW	05H
	DW	0cH
	DW	0cH
	DW	0eH
	DW	04H
	DW	06H
	DW	02H
	DW	03H
	DW	06H
	DW	09H
	DW	05H
	DW	016H
	DW	04H
	DW	05H
	DW	019H
	DW	06H
	DW	04H
	DW	08H
	DW	05H
	DW	02H
	DW	06H
	DW	01bH
	DW	02H
	DW	023H
	DW	02H
	DW	010H
	DW	03H
	DW	07H
	DW	08H
	DW	08H
	DW	06H
	DW	06H
	DW	05H
	DW	09H
	DW	011H
	DW	02H
	DW	014H
	DW	06H
	DW	013H
	DW	02H
	DW	0dH
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	011H
	DW	0cH
	DW	02H
	DW	0eH
	DW	07H
	DW	01H
	DW	04H
	DW	012H
	DW	0cH
	DW	026H
	DW	021H
	DW	02H
	DW	0aH
	DW	01H
	DW	01H
	DW	02H
	DW	0dH
	DW	0eH
	DW	011H
	DW	0bH
	DW	032H
	DW	06H
	DW	021H
	DW	014H
	DW	01aH
	DW	04aH
	DW	010H
	DW	017H
	DW	02dH
	DW	032H
	DW	0dH
	DW	026H
	DW	021H
	DW	06H
	DW	06H
	DW	07H
	DW	04H
	DW	04H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	05H
	DW	08H
	DW	07H
	DW	08H
	DW	09H
	DW	03H
	DW	0bH
	DW	015H
	DW	09H
	DW	0dH
	DW	01H
	DW	03H
	DW	0aH
	DW	06H
	DW	07H
	DW	01H
	DW	02H
	DW	02H
	DW	012H
	DW	05H
	DW	05H
	DW	01H
	DW	09H
	DW	09H
	DW	02H
	DW	044H
	DW	09H
	DW	013H
	DW	0dH
	DW	02H
	DW	05H
	DW	01H
	DW	04H
	DW	04H
	DW	07H
	DW	04H
	DW	0dH
	DW	03H
	DW	09H
	DW	0aH
	DW	015H
	DW	011H
	DW	03H
	DW	01aH
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	05H
	DW	04H
	DW	01H
	DW	07H
	DW	04H
	DW	07H
	DW	03H
	DW	04H
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	014H
	DW	04H
	DW	01H
	DW	09H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	014H
	DW	02H
	DW	03H
	DW	01H
	DW	06H
	DW	02H
	DW	03H
	DW	06H
	DW	02H
	DW	04H
	DW	08H
	DW	01H
	DW	03H
	DW	02H
	DW	0aH
	DW	03H
	DW	05H
	DW	03H
	DW	04H
	DW	04H
	DW	03H
	DW	04H
	DW	010H
	DW	01H
	DW	06H
	DW	01H
	DW	0aH
	DW	02H
	DW	04H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	0aH
	DW	0bH
	DW	02H
	DW	02H
	DW	03H
	DW	01H
	DW	018H
	DW	01fH
	DW	04H
	DW	0aH
	DW	0aH
	DW	02H
	DW	05H
	DW	0cH
	DW	010H
	DW	0a4H
	DW	0fH
	DW	04H
	DW	010H
	DW	07H
	DW	09H
	DW	0fH
	DW	013H
	DW	011H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	07H
	DW	02H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	03H
	DW	07H
	DW	08H
	DW	0cH
	DW	05cH
	DW	02H
	DW	0aH
	DW	03H
	DW	01H
	DW	03H
	DW	0eH
	DW	05H
	DW	019H
	DW	010H
	DW	02aH
	DW	04H
	DW	07H
	DW	07H
	DW	04H
	DW	02H
	DW	015H
	DW	05H
	DW	01bH
	DW	01aH
	DW	01bH
	DW	015H
	DW	019H
	DW	01eH
	DW	01fH
	DW	02H
	DW	01H
	DW	05H
	DW	0dH
	DW	03H
	DW	016H
	DW	05H
	DW	06H
	DW	06H
	DW	0bH
	DW	09H
	DW	0cH
	DW	01H
	DW	05H
	DW	09H
	DW	07H
	DW	05H
	DW	05H
	DW	016H
	DW	03cH
	DW	03H
	DW	05H
	DW	0dH
	DW	01H
	DW	01H
	DW	08H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	02H
	DW	01H
	DW	09H
	DW	03H
	DW	03H
	DW	012H
	DW	04H
	DW	01H
	DW	02H
	DW	03H
	DW	07H
	DW	06H
	DW	03H
	DW	01H
	DW	02H
	DW	03H
	DW	09H
	DW	01H
	DW	03H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	0bH
	DW	03H
	DW	01H
	DW	06H
	DW	09H
	DW	01H
	DW	03H
	DW	02H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	05H
	DW	01H
	DW	01H
	DW	04H
	DW	03H
	DW	04H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	04H
	DW	01H
	DW	07H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	03H
	DW	05H
	DW	0dH
	DW	012H
	DW	03H
	DW	04H
	DW	0eH
	DW	09H
	DW	09H
	DW	04H
	DW	010H
	DW	03H
	DW	07H
	DW	05H
	DW	08H
	DW	02H
	DW	06H
	DW	030H
	DW	01cH
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	02H
	DW	0eH
	DW	08H
	DW	02H
	DW	09H
	DW	02H
	DW	01H
	DW	0fH
	DW	02H
	DW	04H
	DW	03H
	DW	02H
	DW	0aH
	DW	010H
	DW	0cH
	DW	08H
	DW	07H
	DW	01H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	07H
	DW	04H
	DW	01H
	DW	06H
	DW	04H
	DW	026H
	DW	027H
	DW	010H
	DW	017H
	DW	07H
	DW	0fH
	DW	0fH
	DW	03H
	DW	02H
	DW	0cH
	DW	07H
	DW	015H
	DW	025H
	DW	01bH
	DW	06H
	DW	05H
	DW	04H
	DW	08H
	DW	02H
	DW	0aH
	DW	08H
	DW	08H
	DW	06H
	DW	05H
	DW	01H
	DW	02H
	DW	01H
	DW	03H
	DW	018H
	DW	01H
	DW	010H
	DW	011H
	DW	09H
	DW	017H
	DW	0aH
	DW	011H
	DW	06H
	DW	01H
	DW	033H
	DW	037H
	DW	02cH
	DW	0dH
	DW	0126H
	DW	09H
	DW	03H
	DW	06H
	DW	02H
	DW	04H
	DW	02H
	DW	02H
	DW	0fH
	DW	01H
	DW	01H
	DW	01H
	DW	0dH
	DW	015H
	DW	011H
	DW	044H
	DW	0eH
	DW	08H
	DW	09H
	DW	04H
	DW	01H
	DW	04H
	DW	09H
	DW	03H
	DW	0bH
	DW	07H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	06H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	03H
	DW	08H
	DW	01H
	DW	02H
	DW	02H
	DW	04H
	DW	01H
	DW	05H
	DW	05H
	DW	02H
	DW	01H
	DW	04H
	DW	03H
	DW	07H
	DW	0dH
	DW	04H
	DW	01H
	DW	04H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	05H
	DW	0aH
	DW	01H
	DW	06H
	DW	01H
	DW	05H
	DW	02H
	DW	01H
	DW	05H
	DW	02H
	DW	04H
	DW	01H
	DW	04H
	DW	05H
	DW	07H
	DW	03H
	DW	012H
	DW	02H
	DW	09H
	DW	0bH
	DW	020H
	DW	04H
	DW	03H
	DW	03H
	DW	02H
	DW	04H
	DW	07H
	DW	0bH
	DW	010H
	DW	09H
	DW	0bH
	DW	08H
	DW	0dH
	DW	026H
	DW	020H
	DW	08H
	DW	04H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	04H
	DW	04H
	DW	01H
	DW	01H
	DW	01H
	DW	04H
	DW	01H
	DW	015H
	DW	03H
	DW	0bH
	DW	01H
	DW	010H
	DW	01H
	DW	01H
	DW	06H
	DW	01H
	DW	03H
	DW	02H
	DW	04H
	DW	09H
	DW	08H
	DW	039H
	DW	07H
	DW	02cH
	DW	01H
	DW	03H
	DW	03H
	DW	0dH
	DW	03H
	DW	0aH
	DW	01H
	DW	01H
	DW	07H
	DW	05H
	DW	02H
	DW	07H
	DW	015H
	DW	02fH
	DW	03fH
	DW	03H
	DW	0fH
	DW	04H
	DW	07H
	DW	01H
	DW	010H
	DW	01H
	DW	01H
	DW	02H
	DW	08H
	DW	02H
	DW	03H
	DW	02aH
	DW	0fH
	DW	04H
	DW	01H
	DW	01dH
	DW	07H
	DW	016H
	DW	0aH
	DW	03H
	DW	04eH
	DW	010H
	DW	0cH
	DW	014H
	DW	012H
	DW	04H
	DW	043H
	DW	0bH
	DW	05H
	DW	01H
	DW	03H
	DW	0fH
	DW	06H
	DW	015H
	DW	01fH
	DW	020H
	DW	01bH
	DW	012H
	DW	0dH
	DW	047H
	DW	023H
	DW	05H
	DW	08eH
	DW	04H
	DW	0aH
	DW	01H
	DW	02H
	DW	032H
	DW	013H
	DW	021H
	DW	010H
	DW	023H
	DW	025H
	DW	010H
	DW	013H
	DW	01bH
	DW	07H
	DW	01H
	DW	085H
	DW	013H
	DW	01H
	DW	04H
	DW	08H
	DW	07H
	DW	014H
	DW	01H
	DW	04H
	DW	04H
	DW	01H
	DW	0aH
	DW	03H
	DW	01H
	DW	06H
	DW	01H
	DW	02H
	DW	033H
	DW	05H
	DW	028H
	DW	0fH
	DW	018H
	DW	02bH
	DW	05990H
	DW	0bH
	DW	01H
	DW	0dH
	DW	09aH
	DW	046H
	DW	03H
	DW	01H
	DW	01H
	DW	07H
	DW	04H
	DW	0aH
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	02H
	DW	01H
	DW	01H
	DW	01H
	DW	01H
	DW	02H
	DW	01H
	DW	01H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesChineseFull'::`2'::ranges
	DW	0ffH
	DW	02000H
	DW	0206fH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
	DW	0fffdH
	DW	0fffdH
	DW	04e00H
	DW	09fafH
	DW	00H
CONST	ENDS
;	COMDAT ?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA
_DATA	SEGMENT
?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ@4PAGA DW 020H ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::base_ranges
	DW	0ffH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
	DW	0fffdH
	DW	0fffdH
_DATA	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesCyrillic'::`2'::ranges
	DW	0ffH
	DW	0400H
	DW	052fH
	DW	02de0H
	DW	02dffH
	DW	0a640H
	DW	0a69fH
	DW	00H
CONST	ENDS
;	COMDAT ??_C@_1CC@BPLGCGDC@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAi?$AAz@
CONST	SEGMENT
??_C@_1CC@BPLGCGDC@?$AAn?$AAe?$AAw?$AA_?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAS?$AAi?$AAz@ DB 'n'
	DB	00H, 'e', 00H, 'w', 00H, '_', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@EGIPGKEG@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAo?$AAu@
CONST	SEGMENT
??_C@_1DG@EGIPGKEG@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAo?$AAu@ DB 's'
	DB	00H, 't', 00H, 'b', 00H, '_', 00H, '_', 00H, 'd', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, 'o', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@GCANDLHA@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@
CONST	SEGMENT
??_C@_1DG@GCANDLHA@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@ DB 's'
	DB	00H, 't', 00H, 'b', 00H, '_', 00H, '_', 00H, 'd', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, 'o', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@
CONST	SEGMENT
??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@ DB 's'
	DB	00H, 't', 00H, 'b', 00H, '_', 00H, '_', 00H, 'd', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'l', 00H, 'e'
	DB	00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, '_'
	DB	00H, 'b', 00H, 'a', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'e', 00H
	DB	'r', 00H, '_', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JM@LKKCKIOL@?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_?$AAc?$AAu?$AAr?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5@
CONST	SEGMENT
??_C@_1JM@LKKCKIOL@?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_?$AAc?$AAu?$AAr?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5@ DB 'm'
	DB	00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, '_', 00H, 'c', 00H
	DB	'u', 00H, 'r', 00H, 's', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	'M', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'C', 00H, 'u'
	DB	00H, 'r', 00H, 's', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'N', 00H
	DB	'o', 00H, 'n', 00H, 'e', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'm', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, '_', 00H
	DB	'c', 00H, 'u', 00H, 'r', 00H, 's', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H
	DB	'i', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'C'
	DB	00H, 'u', 00H, 'r', 00H, 's', 00H, 'o', 00H, 'r', 00H, '_', 00H
	DB	'C', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@OHOOGJPG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAL?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?4?$AAS?$AAi?$AAz@
CONST	SEGMENT
??_C@_1CK@OHOOGJPG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAL?$AAo?$AAo?$AAk?$AAu?$AAp?$AA?4?$AAS?$AAi?$AAz@ DB 'I'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, 'L', 00H, 'o', 00H
	DB	'o', 00H, 'k', 00H, 'u', 00H, 'p', 00H, '.', 00H, 'S', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@HLFAHELG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAX?$AA?4?$AAS@
CONST	SEGMENT
??_C@_1EO@HLFAHELG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAX?$AA?4?$AAS@ DB 'I'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, 'A', 00H, 'd', 00H
	DB	'v', 00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'X', 00H, '.'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x'
	DB	00H, 'L', 00H, 'o', 00H, 'o', 00H, 'k', 00H, 'u', 00H, 'p', 00H
	DB	'.', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@FHBHHKB@?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1CK@FHBHHKB@?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0@ DB 'G'
	DB	00H, 'l', 00H, 'y', 00H, 'p', 00H, 'h', 00H, 's', 00H, '.', 00H
	DB	'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, '0', 00H, 'x', 00H, 'F', 00H, 'F', 00H, 'F', 00H, 'F', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@BJJINGAO@?$AAr?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi@
CONST	SEGMENT
??_C@_1EC@BJJINGAO@?$AAr?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi@ DB 'r'
	DB	00H, '-', 00H, '>', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H
	DB	'-', 00H, '>', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a'
	DB	00H, 'i', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'A', 00H, 't', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'a', 00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HG@JLCPLJIF@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAT?$AAe?$AAx?$AAP?$AAi?$AAx?$AAe?$AAl@
CONST	SEGMENT
??_C@_1HG@JLCPLJIF@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAT?$AAe?$AAx?$AAP?$AAi?$AAx?$AAe?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'T', 00H, 'e', 00H, 'x', 00H, 'P', 00H, 'i', 00H, 'x', 00H, 'e'
	DB	00H, 'l', 00H, 's', 00H, 'A', 00H, 'l', 00H, 'p', 00H, 'h', 00H
	DB	'a', 00H, '8', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H, 'T', 00H, 'e'
	DB	00H, 'x', 00H, 'P', 00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H
	DB	's', 00H, 'R', 00H, 'G', 00H, 'B', 00H, 'A', 00H, '3', 00H, '2'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HO@DLMJCKJA@?$AAp?$AAa?$AAd?$AA_?$AAl?$AAe?$AAf?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAi?$AAn?$AAe@
CONST	SEGMENT
??_C@_1HO@DLMJCKJA@?$AAp?$AAa?$AAd?$AA_?$AAl?$AAe?$AAf?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAi?$AAn?$AAe@ DB 'p'
	DB	00H, 'a', 00H, 'd', 00H, '_', 00H, 'l', 00H, 'e', 00H, 'f', 00H
	DB	't', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 'n'
	DB	00H, 'e', 00H, '_', 00H, 'w', 00H, 'i', 00H, 'd', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'd'
	DB	00H, '_', 00H, 'r', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'r', 00H, '-', 00H, '>'
	DB	00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'y', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'r', 00H, '-', 00H, '>', 00H, 'H', 00H, 'e', 00H, 'i', 00H
	DB	'g', 00H, 'h', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@DBHHBIED@?$AAr?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1EA@DBHHBIED@?$AAr?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG@ DB 'r'
	DB	00H, '-', 00H, '>', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '2', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, '-', 00H, '>', 00H
	DB	'H', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '2', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@PDHEAINP@?$AAr?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN@
CONST	SEGMENT
??_C@_1MA@PDHEAINP@?$AAr?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN@ DB 'r'
	DB	00H, '-', 00H, '>', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'F', 00H, 'O'
	DB	00H, 'N', 00H, 'T', 00H, '_', 00H, 'A', 00H, 'T', 00H, 'L', 00H
	DB	'A', 00H, 'S', 00H, '_', 00H, 'D', 00H, 'E', 00H, 'F', 00H, 'A'
	DB	00H, 'U', 00H, 'L', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'E', 00H
	DB	'X', 00H, '_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, '_'
	DB	00H, 'W', 00H, ' ', 00H, '*', 00H, ' ', 00H, '2', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, '1', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'r', 00H, '-', 00H, '>', 00H, 'H', 00H, 'e', 00H, 'i', 00H
	DB	'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'F', 00H, 'O', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'A', 00H
	DB	'T', 00H, 'L', 00H, 'A', 00H, 'S', 00H, '_', 00H, 'D', 00H, 'E'
	DB	00H, 'F', 00H, 'A', 00H, 'U', 00H, 'L', 00H, 'T', 00H, '_', 00H
	DB	'T', 00H, 'E', 00H, 'X', 00H, '_', 00H, 'D', 00H, 'A', 00H, 'T'
	DB	00H, 'A', 00H, '_', 00H, 'H', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@DDBMCGAE@?$AAr?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI?$AA?$CJ@
CONST	SEGMENT
??_C@_1BM@DDBMCGAE@?$AAr?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI?$AA?$CJ@ DB 'r'
	DB	00H, '-', 00H, '>', 00H, 'I', 00H, 's', 00H, 'P', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, 'e', 00H, 'd', 00H, '(', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@CHFOHLGN@?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAy?$AA?5?$AA?$CL?$AA?5?$AAh@
CONST	SEGMENT
??_C@_1EI@CHFOHLGN@?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAy?$AA?5?$AA?$CL?$AA?5?$AAh@ DB 'y'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'y', 00H, ' ', 00H, '+', 00H, ' '
	DB	00H, 'h', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'a', 00H
	DB	't', 00H, 'l', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H, 'T'
	DB	00H, 'e', 00H, 'x', 00H, 'H', 00H, 'e', 00H, 'i', 00H, 'g', 00H
	DB	'h', 00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@KOLNNAOF@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AAw@
CONST	SEGMENT
??_C@_1EG@KOLNNAOF@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AAw@ DB 'x'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '+', 00H, ' '
	DB	00H, 'w', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'a', 00H
	DB	't', 00H, 'l', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H, 'T'
	DB	00H, 'e', 00H, 'x', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H
	DB	'h', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KE@CBAIECN@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAw@
CONST	SEGMENT
??_C@_1KE@CBAIECN@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAw@ DB 'p'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '[', 00H, 'i', 00H, ']', 00H, '.'
	DB	00H, 'w', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 's', 00H, '[', 00H, 'i', 00H, ']', 00H, '.', 00H
	DB	'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'c', 00H, 'k', 00H
	DB	'_', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '['
	DB	00H, 'i', 00H, ']', 00H, '.', 00H, 'h', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '_'
	DB	00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '[', 00H
	DB	'i', 00H, ']', 00H, '.', 00H, 'H', 00H, 'e', 00H, 'i', 00H, 'g'
	DB	00H, 'h', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@POMOOFJC@?$AAu?$AAs?$AAe?$AAr?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1CK@POMOOFJC@?$AAu?$AAs?$AAe?$AAr?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe@ DB 'u'
	DB	00H, 's', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '.', 00H, 'S', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@FMMHMDCM@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN@
CONST	SEGMENT
??_C@_1CE@FMMHMDCM@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN@ DB 'p'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't', 00H, ' ', 00H, '!'
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@ENBGOGEF@?$AAg?$AAl?$AAy?$AAp?$AAh?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA_?$AAi?$AAn?$AA_@
CONST	SEGMENT
??_C@_1DC@ENBGOGEF@?$AAg?$AAl?$AAy?$AAp?$AAh?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA_?$AAi?$AAn?$AA_@ DB 'g'
	DB	00H, 'l', 00H, 'y', 00H, 'p', 00H, 'h', 00H, '_', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '_', 00H, 'i', 00H, 'n'
	DB	00H, '_', 00H, 'f', 00H, 'o', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@GJGKHCEN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AAL@
CONST	SEGMENT
??_C@_1FO@GJGKHCEN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AAL@ DB 's'
	DB	00H, 'r', 00H, 'c', 00H, '_', 00H, 't', 00H, 'm', 00H, 'p', 00H
	DB	'.', 00H, 'G', 00H, 'l', 00H, 'y', 00H, 'p', 00H, 'h', 00H, 's'
	DB	00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '.', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '_', 00H, 't', 00H, 'm', 00H
	DB	'p', 00H, '.', 00H, 'G', 00H, 'l', 00H, 'y', 00H, 'p', 00H, 'h'
	DB	00H, 's', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@MENENCJI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1JA@MENENCJI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'o', 00H, 'f', 00H
	DB	'f', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H, '>', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'"', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'D', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'r', 00H, 'r', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, ',', 00H, ' ', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'N', 00H, 'o'
	DB	00H, ' ', 00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 'd', 00H, '.', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IFELKFNN@FontData?5is?5incorrect?0?5or?5FontN@
CONST	SEGMENT
??_C@_0DC@IFELKFNN@FontData?5is?5incorrect?0?5or?5FontN@ DB 'FontData is '
	DB	'incorrect, or FontNo cannot be found.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@NKKOCLPN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAD?$AAs?$AAt?$AAI?$AAn?$AAd?$AAe@
CONST	SEGMENT
??_C@_1CO@NKKOCLPN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAD?$AAs?$AAt?$AAI?$AAn?$AAd?$AAe@ DB 's'
	DB	00H, 'r', 00H, 'c', 00H, '_', 00H, 't', 00H, 'm', 00H, 'p', 00H
	DB	'.', 00H, 'D', 00H, 's', 00H, 't', 00H, 'I', 00H, 'n', 00H, 'd'
	DB	00H, 'e', 00H, 'x', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'-', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1KE@NPGLPIC@?$AAc?$AAf?$AAg?$AA?4?$AAD?$AAs?$AAt?$AAF?$AAo?$AAn?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1KE@NPGLPIC@?$AAc?$AAf?$AAg?$AA?4?$AAD?$AAs?$AAt?$AAF?$AAo?$AAn?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ DB 'c'
	DB	00H, 'f', 00H, 'g', 00H, '.', 00H, 'D', 00H, 's', 00H, 't', 00H
	DB	'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '(', 00H, '!', 00H, 'c', 00H, 'f', 00H, 'g', 00H
	DB	'.', 00H, 'D', 00H, 's', 00H, 't', 00H, 'F', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, '-', 00H, '>', 00H, 'I', 00H, 's', 00H, 'L', 00H
	DB	'o', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'd', 00H, '(', 00H, ')'
	DB	00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'c', 00H, 'f', 00H
	DB	'g', 00H, '.', 00H, 'D', 00H, 's', 00H, 't', 00H, 'F', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, '-', 00H, '>', 00H, 'C', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, 'A', 00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@BBHAKCJP@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAD?$AAa@
CONST	SEGMENT
??_C@_1DG@BBHAKCJP@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAD?$AAa@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H
	DB	'C', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'D'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, '.', 00H, 'S', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@JHOLDEIK@?$AAP?$AAa?$AAc?$AAk?$AAI?$AAd?$AAM?$AAo?$AAu?$AAs?$AAe?$AAC?$AAu?$AAr?$AAs@
CONST	SEGMENT
??_C@_1DC@JHOLDEIK@?$AAP?$AAa?$AAc?$AAk?$AAI?$AAd?$AAM?$AAo?$AAu?$AAs?$AAe?$AAC?$AAu?$AAr?$AAs@ DB 'P'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, 'I', 00H, 'd', 00H, 'M', 00H
	DB	'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'C', 00H, 'u', 00H, 'r'
	DB	00H, 's', 00H, 'o', 00H, 'r', 00H, 's', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '-', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DEJIAPCP@?$AAr?$AAe?$AAc?$AAt?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI@
CONST	SEGMENT
??_C@_1CC@DEJIAPCP@?$AAr?$AAe?$AAc?$AAt?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI@ DB 'r'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '-', 00H, '>', 00H, 'I', 00H
	DB	's', 00H, 'P', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 'd'
	DB	00H, '(', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@CMBJAGBP@?$AAT?$AAe?$AAx?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@
CONST	SEGMENT
??_C@_1DM@CMBJAGBP@?$AAT?$AAe?$AAx?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@ DB 'T'
	DB	00H, 'e', 00H, 'x', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H
	DB	'h', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 'H', 00H
	DB	'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@PBFICKNN@?$AAf?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BE@PBFICKNN@?$AAf?$AAo?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@CAIIJEKF@?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh@
CONST	SEGMENT
??_C@_1DO@CAIIJEKF@?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh@ DB 'h'
	DB	00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'h', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '0', 00H, 'x', 00H, 'F'
	DB	00H, 'F', 00H, 'F', 00H, 'F', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@GHLOFHKF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAw?$AAi@
CONST	SEGMENT
??_C@_1DK@GHLOFHKF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAw?$AAi@ DB 'w'
	DB	00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'w'
	DB	00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 'x', 00H, 'F', 00H, 'F', 00H, 'F'
	DB	00H, 'F', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@
CONST	SEGMENT
??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'c', 00H, 'f', 00H
	DB	'g', 00H, '.', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'D'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@
CONST	SEGMENT
??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@ DB '%s, %.0fpx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@KCPDJPKE@?$AA?$CI?$AA0?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn@
CONST	SEGMENT
??_C@_1EG@KCPDJPKE@?$AA?$CI?$AA0?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn@ DB '('
	DB	00H, '0', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'"', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' '
	DB	00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'l', 00H, 'o', 00H
	DB	'a', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'n', 00H, 't'
	DB	00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '!', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
CONST	SEGMENT
??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@ DB 'ProggyClean.ttf, %dpx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HI@KOOOLAEJ@?$AA?$CB?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?4?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?5@
CONST	SEGMENT
??_C@_1HI@KOOOLAEJ@?$AA?$CB?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?4?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?5@ DB '!'
	DB	00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, 's', 00H, '.', 00H
	DB	'e', 00H, 'm', 00H, 'p', 00H, 't', 00H, 'y', 00H, '(', 00H, ')'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'C', 00H
	DB	'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'u'
	DB	00H, 's', 00H, 'e', 00H, ' ', 00H, 'M', 00H, 'e', 00H, 'r', 00H
	DB	'g', 00H, 'e', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't'
	DB	00H, ' ', 00H, 'f', 00H, 'o', 00H, 'n', 00H, 't', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EDBCHFCN@Cannot?5use?5MergeMode?5for?5the?5fi@
CONST	SEGMENT
??_C@_0CI@EDBCHFCN@Cannot?5use?5MergeMode?5for?5the?5fi@ DB 'Cannot use M'
	DB	'ergeMode for the first font', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@LEOIHPJH@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe?$AAP@
CONST	SEGMENT
??_C@_1DI@LEOIHPJH@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe?$AAP@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'c', 00H, 'f', 00H
	DB	'g', 00H, '-', 00H, '>', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 'P', 00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, 's', 00H
	DB	' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@FAHJAOLI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AAD@
CONST	SEGMENT
??_C@_1GM@FAHJAOLI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AAD@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'c', 00H, 'f', 00H
	DB	'g', 00H, '-', 00H, '>', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't'
	DB	00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'n', 00H, 't', 00H, '_', 00H, 'c', 00H
	DB	'f', 00H, 'g', 00H, '-', 00H, '>', 00H, 'F', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, 'S', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
CONST	SEGMENT
??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@ DB '!'
	DB	00H, 'L', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'C', 00H, 'a'
	DB	00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'm', 00H
	DB	'o', 00H, 'd', 00H, 'i', 00H, 'f', 00H, 'y', 00H, ' ', 00H, 'a'
	DB	00H, ' ', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'I', 00H, 'm', 00H, 'F', 00H, 'o', 00H, 'n'
	DB	00H, 't', 00H, 'A', 00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	' ', 00H, 'b', 00H, 'e', 00H, 't', 00H, 'w', 00H, 'e', 00H, 'e'
	DB	00H, 'n', 00H, ' ', 00H, 'N', 00H, 'e', 00H, 'w', 00H, 'F', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	'd', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, '/'
	DB	00H, 'R', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	'(', 00H, ')', 00H, '!', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@
CONST	SEGMENT
??_C@_0EN@DLIEKEGM@Cannot?5modify?5a?5locked?5ImFontAt@ DB 'Cannot modify'
	DB	' a locked ImFontAtlas between NewFrame() and EndFrame/Render('
	DB	')!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@ILGGLBID@?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAd?$AAx@
CONST	SEGMENT
??_C@_1DC@ILGGLBID@?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAd?$AAx@ DB 'i'
	DB	00H, 'd', 00H, 'x', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'i', 00H, 'd'
	DB	00H, 'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, '_', 00H, 'C', 00H
	DB	'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAE@LAENHIMB@?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1BAE@LAENHIMB@?$AA_?$AAC?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG@ DB '_'
	DB	00H, 'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'C', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, '1', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '"', 00H
	DB	'N', 00H, 'e', 00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'c', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H
	DB	'l', 00H, ' ', 00H, 's', 00H, 'p', 00H, 'l', 00H, 'i', 00H, 't'
	DB	00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'i', 00H
	DB	's', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 's'
	DB	00H, 'u', 00H, 'p', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	'e', 00H, 'd', 00H, '.', 00H, ' ', 00H, 'P', 00H, 'l', 00H, 'e'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'u', 00H, 's', 00H
	DB	'e', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'p', 00H, 'a', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'I', 00H, 'm', 00H
	DB	'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'L', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'S', 00H, 'p', 00H, 'l', 00H, 'i', 00H, 't', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, '.', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@FGMHMEOI@Nested?5channel?5splitting?5is?5not@
CONST	SEGMENT
??_C@_0GA@FGMHMEOI@Nested?5channel?5splitting?5is?5not@ DB 'Nested channe'
	DB	'l splitting is not supported. Please use separate instances o'
	DB	'f ImDrawListSplitter.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@CIGOLMNM@?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr@
CONST	SEGMENT
??_C@_1GI@CIGOLMNM@?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr@ DB 'f'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, '-', 00H, '>', 00H, 'C', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, 'A', 00H, 't', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	'-', 00H, '>', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 'I', 00H, 'D'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '_', 00H, 'C', 00H
	DB	'm', 00H, 'd', 00H, 'H', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, '.', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'u', 00H, 'r', 00H, 'e', 00H, 'I', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JM@GAJOFMMN@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AA0?$AAF?$AA?$CJ?$AA?5@
CONST	SEGMENT
??_C@_1JM@GAJOFMMN@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AA0?$AAF?$AA?$CJ?$AA?5@ DB '('
	DB	00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H
	DB	'&', 00H, ' ', 00H, '0', 00H, 'x', 00H, '0', 00H, 'F', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, '"', 00H, 'M', 00H, 'i', 00H, 's'
	DB	00H, 'u', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'l', 00H, 'e', 00H, 'g', 00H, 'a', 00H, 'c', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'I', 00H, 'm'
	DB	00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'C', 00H, 'o', 00H
	DB	'r', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'u', 00H, 'e', 00H, 's', 00H, '!', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FNKJFHEE@Misuse?5of?5legacy?5hardcoded?5ImDr@
CONST	SEGMENT
??_C@_0DF@FNKJFHEE@Misuse?5of?5legacy?5hardcoded?5ImDr@ DB 'Misuse of leg'
	DB	'acy hardcoded ImDrawCornerFlags values!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@FGNNAPCK@?$AAc?$AAu?$AAr?$AAr?$AA_?$AAc?$AAm?$AAd?$AA?9?$AA?$DO?$AAU?$AAs?$AAe?$AAr?$AAC@
CONST	SEGMENT
??_C@_1DI@FGNNAPCK@?$AAc?$AAu?$AAr?$AAr?$AA_?$AAc?$AAm?$AAd?$AA?9?$AA?$DO?$AAU?$AAs?$AAe?$AAr?$AAC@ DB 'c'
	DB	00H, 'u', 00H, 'r', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'm', 00H
	DB	'd', 00H, '-', 00H, '>', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, 'C', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'b', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1LC@MAEAJCLC@?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAm?$AAd?$AA?4?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe@
CONST	SEGMENT
??_C@_1LC@MAEAJCLC@?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAm?$AAd?$AA?4?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe@ DB 'd'
	DB	00H, 'r', 00H, 'a', 00H, 'w', 00H, '_', 00H, 'c', 00H, 'm', 00H
	DB	'd', 00H, '.', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p', 00H, 'R'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '.', 00H, 'x', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w'
	DB	00H, '_', 00H, 'c', 00H, 'm', 00H, 'd', 00H, '.', 00H, 'C', 00H
	DB	'l', 00H, 'i', 00H, 'p', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, '.', 00H, 'z', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H, '_', 00H, 'c', 00H, 'm'
	DB	00H, 'd', 00H, '.', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'p', 00H
	DB	'R', 00H, 'e', 00H, 'c', 00H, 't', 00H, '.', 00H, 'y', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'a', 00H
	DB	'w', 00H, '_', 00H, 'c', 00H, 'm', 00H, 'd', 00H, '.', 00H, 'C'
	DB	00H, 'l', 00H, 'i', 00H, 'p', 00H, 'R', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, '.', 00H, 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JCMOPDC@?$AAm?$AAa?$AAx?$AA_?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0@
CONST	SEGMENT
??_C@_1CC@JCMOPDC@?$AAm?$AAa?$AAx?$AA_?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0@ DB 'm'
	DB	00H, 'a', 00H, 'x', 00H, '_', 00H, 'e', 00H, 'r', 00H, 'r', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.'
	DB	00H, '0', 00H, 'f', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
CONST	SEGMENT
??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'v', 00H, 'i', 00H, 'n', 00H, '\', 00H, 'D'
	DB	00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H, 'o', 00H, 'a', 00H
	DB	'd', 00H, 's', 00H, '\', 00H, 'A', 00H, 'p', 00H, 'e', 00H, 'x'
	DB	00H, 'I', 00H, 's', 00H, 'A', 00H, 's', 00H, 's', 00H, 'W', 00H
	DB	'i', 00H, 't', 00H, 'h', 00H, 'E', 00H, 'A', 00H, 'C', 00H, '-'
	DB	00H, 'm', 00H, 'a', 00H, 'i', 00H, 'n', 00H, '\', 00H, 'A', 00H
	DB	'p', 00H, 'e', 00H, 'x', 00H, 'I', 00H, 's', 00H, 'A', 00H, 's'
	DB	00H, 's', 00H, 'W', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'E', 00H
	DB	'A', 00H, 'C', 00H, '-', 00H, 'm', 00H, 'a', 00H, 'i', 00H, 'n'
	DB	00H, '\', 00H, 'I', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H, '_'
	DB	00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H, '.', 00H, 'c', 00H
	DB	'p', 00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@IGKGDOM@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?5?$AA?$CK?$AA?5?$AAs?$AAt?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EC@IGKGDOM@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?5?$AA?$CK?$AA?5?$AAs?$AAt?$AAr?$AAi@ DB 'p'
	DB	00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, 's', 00H, '[', 00H
	DB	'i', 00H, ' ', 00H, '*', 00H, ' ', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'i', 00H, 'n', 00H
	DB	'_', 00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ']'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@BDJAMAMF@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BO@BDJAMAMF@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ DB 'p'
	DB	00H, 'i', 00H, 'x', 00H, 'e', 00H, 'l', 00H, 's', 00H, '[', 00H
	DB	'i', 00H, ']', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@PMJHELI@?$AAz?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAc?$AAa?$AAn?$AA_?$AAy@
CONST	SEGMENT
??_C@_1CI@PMJHELI@?$AAz?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAc?$AAa?$AAn?$AA_?$AAy@ DB 'z'
	DB	00H, '-', 00H, '>', 00H, 'e', 00H, 'y', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'n', 00H, '_'
	DB	00H, 'y', 00H, '_', 00H, 't', 00H, 'o', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@LMAHJHLI@?$AAz?$AA?9?$AA?$DO?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn@
CONST	SEGMENT
??_C@_1BK@LMAHJHLI@?$AAz?$AA?9?$AA?$DO?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn@ DB 'z'
	DB	00H, '-', 00H, '>', 00H, 'd', 00H, 'i', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@PHOJNIKI@?$AAf?$AAa?$AAb?$AAs?$AAf?$AA?$CI?$AAa?$AAr?$AAe?$AAa?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1CK@PHOJNIKI@?$AAf?$AAa?$AAb?$AAs?$AAf?$AA?$CI?$AAa?$AAr?$AAe?$AAa?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5@ DB 'f'
	DB	00H, 'a', 00H, 'b', 00H, 's', 00H, 'f', 00H, '(', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, ')', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, '1', 00H, '.', 00H, '0', 00H, '1', 00H, 'f', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@GDDDMDCC@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AAl@
CONST	SEGMENT
??_C@_1CE@GDDDMDCC@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AAl@ DB 'x'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'l', 00H, 'e', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@KOIFPDFH@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAy?$AA_?$AAb?$AAo?$AAt?$AAt@
CONST	SEGMENT
??_C@_1EI@KOIFPDFH@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAy?$AA_?$AAb?$AAo?$AAt?$AAt@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 's', 00H, 'y', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 'y', 00H, '_', 00H, 'b', 00H, 'o', 00H, 't'
	DB	00H, 't', 00H, 'o', 00H, 'm', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'e', 00H, '-', 00H, '>', 00H, 'e', 00H, 'y', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, 'y', 00H, '_', 00H, 't', 00H
	DB	'o', 00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MDBOACOJ@?$AAe?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAy?$AA_?$AAt?$AAo?$AAp@
CONST	SEGMENT
??_C@_1BO@MDBOACOJ@?$AAe?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAy?$AA_?$AAt?$AAo?$AAp@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 'e', 00H, 'y', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, 'y', 00H, '_', 00H, 't', 00H, 'o', 00H, 'p'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@IACIBKNK@?$AAx?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA0?$AA?5?$AA?$DM@
CONST	SEGMENT
??_C@_1GC@IACIBKNK@?$AAx?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA0?$AA?5?$AA?$DM@ DB 'x'
	DB	00H, '0', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '0', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '+', 00H
	DB	' ', 00H, '1', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x'
	DB	00H, '1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '1', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '+', 00H
	DB	' ', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@IKFPJDAK@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA1?$AA?5?$AA?$DM@
CONST	SEGMENT
??_C@_1CO@IKFPJDAK@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA1?$AA?5?$AA?$DM@ DB 'x'
	DB	00H, '1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'x', 00H, '1', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, ' ', 00H, '+', 00H
	DB	' ', 00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@NMCMAHDB@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AA1@
CONST	SEGMENT
??_C@_1BI@NMCMAHDB@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AA1@ DB 'x'
	DB	00H, '1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	' ', 00H, '+', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@FEPJEPJJ@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx@
CONST	SEGMENT
??_C@_1BA@FEPJEPJJ@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx@ DB 'x', 00H
	DB	'1', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@FAAMJPKE@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx@
CONST	SEGMENT
??_C@_1BA@FAAMJPKE@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx@ DB 'x', 00H
	DB	'1', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'x', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@NJPIGMLC@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AA1@
CONST	SEGMENT
??_C@_1BI@NJPIGMLC@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AA1@ DB 'x'
	DB	00H, '1', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H
	DB	' ', 00H, '+', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@JGPMADBG@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AA?9?$AA?$DO?$AAe?$AAy@
CONST	SEGMENT
??_C@_1BO@JGPMADBG@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AA?9?$AA?$DO?$AAe?$AAy@ DB 'e'
	DB	00H, '-', 00H, '>', 00H, 's', 00H, 'y', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 'e', 00H, '-', 00H, '>', 00H, 'e', 00H, 'y'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@ENLNFFAM@?$AAy?$AA0?$AA?5?$AA?$DM?$AA?5?$AAy?$AA1@
CONST	SEGMENT
??_C@_1BA@ENLNFFAM@?$AAy?$AA0?$AA?5?$AA?$DM?$AA?5?$AAy?$AA1@ DB 'y', 00H, '0'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'y', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@EHPNOHML@?$AAz?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1O@EHPNOHML@?$AAz?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@ DB 'z', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GE@KABFAMEA@?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAc?$AAt?$AAx?$AA?4?$AAn?$AAu?$AAm?$AA_@
CONST	SEGMENT
??_C@_1GE@KABFAMEA@?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAc?$AAt?$AAx?$AA?4?$AAn?$AAu?$AAm?$AA_@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, '_', 00H
	DB	'c', 00H, 't', 00H, 'x', 00H, '.', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, '_', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'i', 00H
	DB	'c', 00H, 'e', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, '_', 00H
	DB	'c', 00H, 't', 00H, 'x', 00H, '.', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, '_', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'i', 00H
	DB	'c', 00H, 'e', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@MDABGEPC@?$AA?$CB?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAc?$AAf?$AAf?$AA?4?$AAs?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1CA@MDABGEPC@?$AA?$CB?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAc?$AAf?$AAf?$AA?4?$AAs?$AAi?$AAz?$AAe@ DB '!'
	DB	00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, '-', 00H, '>', 00H
	DB	'c', 00H, 'f', 00H, 'f', 00H, '.', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@BLOLDBDN@?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAc?$AAo?$AAd?$AAe?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1HE@BLOLDBDN@?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAc?$AAo?$AAd?$AAe?$AAp?$AAo?$AAi@ DB 'u'
	DB	00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, 't', 00H, 't', 00H, 'U', 00H, 'S', 00H, 'H', 00H, 'O'
	DB	00H, 'R', 00H, 'T', 00H, '(', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'd'
	DB	00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, '2', 00H, ' ', 00H, '*', 00H, ' ', 00H, 'i'
	DB	00H, 't', 00H, 'e', 00H, 'm', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KODIGLGG@maxp@
CONST	SEGMENT
??_C@_04KODIGLGG@maxp@ DB 'maxp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJGCPIEK@CFF?5@
CONST	SEGMENT
??_C@_04HJGCPIEK@CFF?5@ DB 'CFF ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCFDEHHD@GPOS@
CONST	SEGMENT
??_C@_04PCFDEHHD@GPOS@ DB 'GPOS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HHMMLDJI@kern@
CONST	SEGMENT
??_C@_04HHMMLDJI@kern@ DB 'kern', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ONMNCIMC@hmtx@
CONST	SEGMENT
??_C@_04ONMNCIMC@hmtx@ DB 'hmtx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMPHLIKP@hhea@
CONST	SEGMENT
??_C@_04FMPHLIKP@hhea@ DB 'hhea', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLIHEPK@glyf@
CONST	SEGMENT
??_C@_04LLIHEPK@glyf@ DB 'glyf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEODDMOL@head@
CONST	SEGMENT
??_C@_04NEODDMOL@head@ DB 'head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DACNFKGE@loca@
CONST	SEGMENT
??_C@_04DACNFKGE@loca@ DB 'loca', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EICJPCEA@cmap@
CONST	SEGMENT
??_C@_04EICJPCEA@cmap@ DB 'cmap', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KIOEMAHO@ttcf@
CONST	SEGMENT
??_C@_04KIOEMAHO@ttcf@ DB 'ttcf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LLEFIKCJ@OTTO@
CONST	SEGMENT
??_C@_04LLEFIKCJ@OTTO@ DB 'OTTO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBBEMOBJ@typ1@
CONST	SEGMENT
??_C@_04LBBEMOBJ@typ1@ DB 'typ1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@PFMEGAIA@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1CI@PFMEGAIA@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAc@ DB 'i'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KDMJFGHG@?$AAb?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA8@
CONST	SEGMENT
??_C@_1BC@KDMJFGHG@?$AAb?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA8@ DB 'b'
	DB	00H, '0', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '2', 00H
	DB	'8', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@
CONST	SEGMENT
??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@ DB 'o'
	DB	00H, 'f', 00H, 'f', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 'f', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' '
	DB	00H, '4', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@EPOLDKHI@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx?$AA4?$AA0?$AA0?$AA0?$AA0?$AA0@
CONST	SEGMENT
??_C@_1CE@EPOLDKHI@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx?$AA4?$AA0?$AA0?$AA0?$AA0?$AA0@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'0', 00H, 'x', 00H, '4', 00H, '0', 00H, '0', 00H, '0', 00H, '0'
	DB	00H, '0', 00H, '0', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@OMFGMKMB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1CC@OMFGMKMB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5@ DB 'n'
	DB	00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, '4', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
CONST	SEGMENT
??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@ DB '!'
	DB	00H, '(', 00H, 'o', 00H, ' ', 00H, '>', 00H, ' ', 00H, 'b', 00H
	DB	'-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' '
	DB	00H, '|', 00H, '|', 00H, ' ', 00H, 'o', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, '0', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
CONST	SEGMENT
??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'v', 00H, 'i', 00H, 'n', 00H, '\', 00H, 'D'
	DB	00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H, 'o', 00H, 'a', 00H
	DB	'd', 00H, 's', 00H, '\', 00H, 'A', 00H, 'p', 00H, 'e', 00H, 'x'
	DB	00H, 'I', 00H, 's', 00H, 'A', 00H, 's', 00H, 's', 00H, 'W', 00H
	DB	'i', 00H, 't', 00H, 'h', 00H, 'E', 00H, 'A', 00H, 'C', 00H, '-'
	DB	00H, 'm', 00H, 'a', 00H, 'i', 00H, 'n', 00H, '\', 00H, 'A', 00H
	DB	'p', 00H, 'e', 00H, 'x', 00H, 'I', 00H, 's', 00H, 'A', 00H, 's'
	DB	00H, 's', 00H, 'W', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'E', 00H
	DB	'A', 00H, 'C', 00H, '-', 00H, 'm', 00H, 'a', 00H, 'i', 00H, 'n'
	DB	00H, '\', 00H, 'I', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 's', 00H, 't', 00H, 'b', 00H, '_'
	DB	00H, 't', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@JNFMLHFF@?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAe?$AAs?$AAt?$AA_?$AAy@
CONST	SEGMENT
??_C@_1BI@JNFMLHFF@?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAb?$AAe?$AAs?$AAt?$AA_?$AAy@ DB 'y'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'b', 00H, 'e', 00H
	DB	's', 00H, 't', 00H, '_', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@GPDJEJHP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@
CONST	SEGMENT
??_C@_1FA@GPDJEJHP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, '-', 00H, '>', 00H, 'x', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, 'x', 00H, 'p', 00H, 'o', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, '-', 00H, '>', 00H, 'x', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 'x', 00H, 'p', 00H, 'o', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@MNLKNDNL@?$AAx?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BE@MNLKNDNL@?$AAx?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@ DB 'x'
	DB	00H, 'p', 00H, 'o', 00H, 's', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@LEHAODMI@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AAc?$AA?9?$AA?$DO?$AAa?$AAl?$AAi?$AAg@
CONST	SEGMENT
??_C@_1CM@LEHAODMI@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AAc?$AA?9?$AA?$DO?$AAa?$AAl?$AAi?$AAg@ DB 'w'
	DB	00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '%', 00H
	DB	' ', 00H, 'c', 00H, '-', 00H, '>', 00H, 'a', 00H, 'l', 00H, 'i'
	DB	00H, 'g', 00H, 'n', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@JHJLEEND@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@
CONST	SEGMENT
??_C@_1BM@JHJLEEND@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '-', 00H, '>', 00H, 'x', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@BDIGDJGP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@
CONST	SEGMENT
??_C@_1CG@BDIGDJGP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, '-', 00H, '>', 00H, 'x', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, 'x', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@KBODBKOH@?$AAf?$AAi?$AAr?$AAs?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@
CONST	SEGMENT
??_C@_1BO@KBODBKOH@?$AAf?$AAi?$AAr?$AAs?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@ DB 'f'
	DB	00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, '-', 00H, '>', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'x', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@NNJKMECF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AAf?$AAf?$AAf@
CONST	SEGMENT
??_C@_1EI@NNJKMECF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AAf?$AAf?$AAf@ DB 'w'
	DB	00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 'x', 00H, 'f', 00H, 'f', 00H, 'f'
	DB	00H, 'f', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'h', 00H
	DB	'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 'x', 00H, 'f', 00H, 'f', 00H
	DB	'f', 00H, 'f', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
CONST	SEGMENT
??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'v', 00H, 'i', 00H, 'n', 00H, '\', 00H, 'D'
	DB	00H, 'o', 00H, 'w', 00H, 'n', 00H, 'l', 00H, 'o', 00H, 'a', 00H
	DB	'd', 00H, 's', 00H, '\', 00H, 'A', 00H, 'p', 00H, 'e', 00H, 'x'
	DB	00H, 'I', 00H, 's', 00H, 'A', 00H, 's', 00H, 's', 00H, 'W', 00H
	DB	'i', 00H, 't', 00H, 'h', 00H, 'E', 00H, 'A', 00H, 'C', 00H, '-'
	DB	00H, 'm', 00H, 'a', 00H, 'i', 00H, 'n', 00H, '\', 00H, 'A', 00H
	DB	'p', 00H, 'e', 00H, 'x', 00H, 'I', 00H, 's', 00H, 'A', 00H, 's'
	DB	00H, 's', 00H, 'W', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'E', 00H
	DB	'A', 00H, 'C', 00H, '-', 00H, 'm', 00H, 'a', 00H, 'i', 00H, 'n'
	DB	00H, '\', 00H, 'I', 00H, 'm', 00H, 'g', 00H, 'u', 00H, 'i', 00H
	DB	'\', 00H, 'i', 00H, 'm', 00H, 's', 00H, 't', 00H, 'b', 00H, '_'
	DB	00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'p', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@HCNHOFJN@?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAo?$AAr?$AAa?$AAg?$AAe?$AA?4?$AAS?$AAi@
CONST	SEGMENT
??_C@_1DA@HCNHOFJN@?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAo?$AAr?$AAa?$AAg?$AAe?$AA?4?$AAS?$AAi@ DB 'n'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, 'S', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'S'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, '<', 00H
	DB	' ', 00H, '5', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@HMJJDGFN@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BG@HMJJDGFN@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@ DB 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
?proggy_clean_ttf_compressed_data_base85@@3QBDB DB '7])#######hV0qs''/###'
	DB	'[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`'
	DB	'$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb'';9Crc6tgXmKVeU2cD4Eo3R/2'
	DB	'*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:'
	DB	'U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(l'
	DB	'f(r/7GrRgwV%MS=C#`8ND>Qo#t''X#(v#Y9w0#1D$CIf;W''#pWUPXOuxXuU('
	DB	'H9M(1<q-UE31#^-V''8IRUo7Qf./L>=Ke$$''5F%)]0^#0X@U.a<r:QLtFsLc'
	DB	'L6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uLi@^rMl9t=cWq6##weg>$FB'
	DB	'jVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N''[0#7RL_&#w'
	DB	'+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`Nkfi'
	DB	'mM2J,W-jXS:)r0wK#@Fge$U>`w''N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%'
	DB	'?76%^GMHePW-Z5l''&GiF#$956:rS?dA#fiK:)Yr+`&#0j@''DbG&#^$PG.Ll'
	DB	'+DNa<XCMKEV*N)LN/N*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl''&hF;;$<_'
	DB	'=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp'
	DB	'5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)tm+/Us9pG)XPu`<0s-)WTt(g'
	DB	'CRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW'
	DB	'$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CXow0i(?'
	DB	'$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q'
	DB	'^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQ'
	DB	'k.a>D[.e;mc.x]Ip.PH^''/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ''NQ(3_PL'
	DB	'hE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZ'
	DB	'q]DAbkU*JqkL+nwX@@47`5>w=4h(9.`GCRUxHPeR`5Mjol(dUWxZa(>STrPkr'
	DB	'JiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HO'
	DB	'IZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).''2($5FNP&EQ(,)U]W]+fh18.'
	DB	'vsai00);D3@4ku5P?DP8aJt+;qUM]=+b''8@;mViBKx0DE[-auGl8:PJ&Dj+M'
	DB	'6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$U'
	DB	'V(?#P6YY#''/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]''/4C#v$U`0#V.[0>'
	DB	'xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.'
	DB	'kK/HSB==-''Ie/QTtG?-.*^N-4B/ZM_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]'
	DB	'$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw''.,MRsqVr.L;aN&#/EgJ)PBc[-f'
	DB	'>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`guFt(c%=;Am_Qs'
	DB	'@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8''=l_f-b49''UOqkLu7-##oDY2L('
	DB	'te+Mch&gLYtJ,MEtJfLh''x''M=$CS-ZZ%P]8bZ>#S?YY#%Q&q''3^Fw&?D)U'
	DB	'DNrocM3A76//oL?#h7gl85[qW/NDOk%16ij;+:1a''iNIdb-ou8.P*w,v5#EI'
	DB	'$TWS>Pot-R*H''-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>2'
	DB	'9sp3dt-52U%VM#q7''DHpg+#Z9%H[K<L%a2E-grWVM3@2=-k22tL]4$##6We'''
	DB	'8UJCKE[d_=%wI;''6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&'
	DB	'#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#OQFKNX@QI'''
	DB	'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c''[0#(s1X&xm$Y%B7*K:eDA32'
	DB	'3j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682'
	DB	'-SjMXJK)(h$hxua_K]ul92%''BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDP'
	DB	'mL<LYs8i#XwJOYaKPKc1h:''9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuY'
	DB	'a%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5ho;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB'
	DB	'3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]'
	DB	']u-[=99tts1.qb#q72g1WJO81q+eN''03''eM>&1XxY-caEnOj%2n8)),?ILR'
	DB	'5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew''He]h:sI[2LM$[guka'
	DB	'3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1'
	DB	']MupW^-sj_$%[HK%''F####QRZJ::Y3EGl4''@%FkiAOg#p[##O`gukTfBHag'
	DB	'L<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg'
	DB	'*%K8ln(wcf3/''DW-$.lR?n[nCH-eXOONTJlh:.RYF%3''p6sq:UIMA945&^H'
	DB	'FS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP''vh1/R&O_J9''u'
	DB	'm,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56''hl;.s5CUrxjOM7-##.l+Au'''
	DB	'A&O:-T72L]P`&=;ctp''XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B'
	DB	'*P:Rowwm-`0PKjYDDM''3]d39VZHEl4,.j'']Pk-M.h^&:0FACm$maq-&sgw0'
	DB	't7/6(^xtk%LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P''$M<Jnq79VsJW'
	DB	'/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_'
	DB	'-Sj9,VK3M.*''&0D[Ca]J9gp8,kAW]%(?A%R$f<->Zts''^kn=-^@c4%-pY6q'
	DB	'I%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%'
	DB	'KYo8fRULNd2.>%m]UK:n%r$''sw]J;5pAoO_#2mO3n,''=H5(etHg*`+RLgv>'
	DB	'=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ'':+Q_k+uvOSLiEo(<aD/K<'
	DB	'CCc`''Lx>''?;++O''>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRb'
	DB	'A#Kjm%upV1g:a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'
	DB	'''ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X''e?YLfjM[VO0MbuFp7;>Q'
	DB	'&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL($/V,;(kXZejWO`<[5??ewY(*9=%wD'
	DB	'c;,u<''9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.k'
	DB	'Lg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI''o8)b<nKnw''Ho8'
	DB	'C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE'
	DB	'5^V8O(x<<aG/1N$#FX$0V5Y6x''aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM'
	DB	'(=/M0:JxG''?7WhH%o''a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-'
	DB	'e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?''(<S:68tq*'
	DB	'WoDfZu'';mM?8X[ma8W%*`-=;D.(nc7/;)g:T1=^J$&BRV(-lTmNB6xqB[@0*'
	DB	'o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u'
	DB	'75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3MD?@f&1''BW'
	DB	'-)Ju<L25gl8uhVm1hL$##*8###''A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmW'
	DB	'CMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD''QdWoY-F$BtUwmfe'
	DB	'$YqL''8(PWX(P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w''KD`LP5IbH;rTV'
	DB	'>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO'
	DB	'*5NK,((W-i:$,kp''UDAO(G0Sq7MVjJsbIu)''Z,*[>br5fX^:FPAWr-m2KgL'
	DB	'<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6''8uTG&#1T5'
	DB	'g)uLv:873UpTLgH+#FgpH''_o1780Ph8KmxQJ8#H72L4@768@Tm&Qh4CB/5Ov'
	DB	'mA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&'
	DB	'&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z''<$#4H)6,>e0jT6''N#(q%.'
	DB	'O=?2S]u*(m<-V8J''(1)G][68hW$5''q[GC&5j`TE?m''esFGNRM)j,ffZ?-q'
	DB	'x8;->g4t*:CIP/[Qap7/9''#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFF'
	DB	'cL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5isZ88+dKQ)W6>J%CL<KE>`.d*(B`'
	DB	'-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv''?>-XV1q[''-5k''cAZ69'
	DB	'e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7.m7jil'
	DB	'Q02''0-VWAg<a/''''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2''v:^;-DIBW,B4E'
	DB	'68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW''b)T'
	DB	'q7VT9q^*^$$.:&N@@$&)WHtPm*5_rO0&e%K&#-30j(E4#''Zb.o/(Tpm$>K'''
	DB	'f@[PvFl,hfINTNU6u''0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'''
	DB	'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*hv^BFpQj:K''#SJ,sB-''#]'
	DB	'(j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&Gj'
	DB	'UR=1D8QaS3Up&@*9wP?+lo7b?@%''k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u@-'
	DB	'W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAK'
	DB	'jKjseK</xKT*)B,N9X3]krc12t''pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8c'
	DB	'Y#YZ?=,`Wdxu/ae&#w6)R89tI#6@s''(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,'
	DB	';^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D##'
	DB	'#EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#u1p]ovUKW&Y%q]''>$1@-[xfn'
	DB	'$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%'
	DB	')$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0d=j.LQ'
	DB	'f./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c'
	DB	')QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrL'
	DB	'W-1pG_&2UdB86e%B/:=>)N4xeW.*wft-;$''58-ESqr<b?UI(_%@[P46>#U`'''
	DB	'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc'
	DB	'%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#b0v=Pjer]$gG&JXDf->''StvU7505l'
	DB	'9$AFvgYRI^&<^b68?j#q9QX4SM''RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'
	DB	'''bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''''X.`$#8+1GD:k$YUWs'
	DB	'bn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4'
	DB	')''$Ab(Nof%V''8hL&#<NEdtg(n''=S1A(Q1/I&4([%dM`,Iu''1:_hL>SfD0'
	DB	'7&6D<fp8dHM7/g+tlPN9J*rKaPct&?''uBCem^jn%9_K)<,C5K3s=5g&GmJb*'
	DB	'[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m''vi`3?%'
	DB	'Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*$3WoJSCLweV[aZ''MQIjO<7;X-'
	DB	'X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68L'
	DB	'vEA''q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7:d[/;r'
	DB	'_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup''D'
	DB	'#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr''_wgH)NUIR8a1n#S?Yej''h8^58'
	DB	'UbZd+^FKD*T@;6A7aQC[K8d-(v6GI$x:T<&''Gp5Uf>@M.*J:;$-rv29''M]8'
	DB	'qMv-tLp,''886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu''QvBT.#=)0ukru'
	DB	'V&.)3=(^1`o*Pj4<-<aN((^7(''#Z0wK#5GX@7u][`*S^43933A4rl][`*O4C'
	DB	'gLEl]v$1Q3AeF37dbXk,.)vj#x''d`;qgbQR%FW,2(?LO=s%Sc68%NP''##Ao'
	DB	'tl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f''f/&_mt&F)XdF<9t4)Qa.*kTLw'
	DB	'Q''(TTB9.xH''>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72Ln'
	DB	'Yl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2''I'
	DB	'M%L3I)X((e/dl2&8''<M:^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En''CR.q7'
	DB	'E)p''/kle2HM,u;^%OKC-N+Ll%F9CF<Nf''^#t2L,;27W:0O@6##U6W7:$rJf'
	DB	'LWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>_>@kXQtMacfD.m-VAb8;'
	DB	'IReM3$wf0''''hra*so568''Ip&vRs849''MRYSp%:t:h5qSgwpEr$B>Q,;s('
	DB	'C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP''##p#C0c%-'
	DB	'Gb%hd+<-j''Ai*x&&HMkT]C''OSl##5RG[JXaHN;d''uA#x._U;.`PU@(Z3dt'
	DB	'4r152@:v,''R.Sj''w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%'
	DB	'>.G690a:$##<,);?;72#?x9+d;^V''9;jY@;)br#q^YQpx:X#Te$Z^''=-=bG'
	DB	'hLf:D6&bNwZ9-ZD#n^9HhLMr5G;'']d&6''wYmTFmL<LD)F^%[tC''8;+9E#C'
	DB	'$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s''B;K-M6$EB%is00:+A4[7xks.Lr'
	DB	'Nk0&E)wILYF@2L''0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT''<-,v`3;_)I9M'
	DB	'^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k'
	DB	'11IM1c^j%9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8''je''D7k`e;)'
	DB	'2pYwPA''_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^(''7fB&Hq-:sf,sNj'
	DB	'8xq^>$U4O]GKx''m9)b@p7YsvK3w^YR-CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp'
	DB	'^iI9O8KnTj,]H?D*r7''M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnr'
	DB	'U(4&8/P+:hLSKj$#U%]49t''I:rgMi''FL@a:0Y-uA[39'',(vbma*hU%<-SR'
	DB	'F`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>T'
	DB	'i1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*V'
	DB	'j>SsD<U4JHY8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK''-x?''(:siIfL<$p'
	DB	'FM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa'
	DB	'8wD8=^GlPa8TKI1CjhsCTSLJM''/Wl>-S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n'
	DB	'<bhPmUkMw>%t<)''mEVE''''n`WnJra$^TKvX5B>;_aSEK'',(hwa0:i4G?.B'
	DB	'ci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs''6,''85`0?t/'''
	DB	'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%O'
	DB	'tJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<RO'
	DB	'u7cL5l;-[A]%/+fsd;l#SafT/f*W]0=O''$(Tb<[)*@e775R-:Yob%g*>l*:x'
	DB	'P?Yb.5)%w_I?7uk5JC+FS(m#i''k.''a0i)9<7b''fs''59hq$*5Uhv##pi^8'
	DB	'+hIEBF`nvo`;''l0.^S1<-wUK2/Coh58KKhLjM=SO*rfO`+qC`W-On.=AJ56>'
	DB	'>i2@2LH6A:&5q`?9I3@@''04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c'
	DB	'<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V?6*C('
	DB	')dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+Aur'
	DB	'K<m86QIth*#v;-OBqi+L7wDE-Ir8K[''m+DDSLwK&/.?-V%U_%3:qKNu$_b*B'
	DB	'-kp7NaD''QdWQPKYq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vm'
	DB	'J80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/''+'
	DB	'1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa>gXm8YB`1d@K#n]76-a$U,mF<fX'
	DB	']idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&'
	DB	'c$ooQUj]Exd*3ZM@-WGW2%s'',B-_M%>%Ul:#/''xoFM9QX-$.QN''>[%$Z$u'
	DB	'F6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o''$?X3B</R90;'
	DB	'eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*''3E>=-<'
	DB	')Gt*Iw)''QG:`@IwOf7&]1i''S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/'
	DB	'6Aj7:''1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0''1<Vc52=u`3^o-n1'
	DB	'''g4v58Hj&6_t7$##?M)c<$bgQ_''SY((-xkA#Y(,p''H9rIVY-b,''%bCPF7'
	DB	'.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs'
	DB	',eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$Mlv'
	DB	'AF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo''RS1R84=@paTKt)>=%&1[)*v'
	DB	'p''u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u''m0dr9l,<*wMK*Oe=g8lV_KEBF'
	DB	'kO''oU]^=[-792#ok,)i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K'
	DB	'1<-rGdO''$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw''DJN:)Ss;wGn9A32ijw%FL'
	DB	'+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo1*c-(aY168o<`JsSbk-,1N'
	DB	';$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+S'
	DB	'TRxX''q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W''$PiD'
	DB	'DG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7'
	DB	'fSkgl6-++D:''A,uq7SvlB$pcpH''q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF'
	DB	'6##$l84N1w?AO>''IAOURQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi'
	DB	'68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne'
	DB	'_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#;u.T%fAr%4tJ8&><1=GHZ_+m'
	DB	'9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx='
	DB	'T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>w$)F./'
	DB	'^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;'
	DB	'P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*'
	DB	'A#]-=A#a9OA#d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%'
	DB	'#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k''MS.o?.5/sWel/wpEM0%3'''
	DB	'/1)K^f1-d>G21&v(35>V`39V7A4=onx4A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,'
	DB	';WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#'
	DB	'2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#''9$C#+E6C#/QHC#3^ZC#'
	DB	'7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L'
	DB	'-d3#rWM4#Hga1#,<w0#T.j<#O#''2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`'
	DB	'+78#4uI-#m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%'
	DB	'X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$'
	DB	'0#n`-0#sf60#(F24#wrH0#%/e0#TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G'
	DB	'3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiC'
	DB	'f&0g2''tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP'
	DB	'GT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5K'
	DB	'TB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI''O'
	DB	'?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?'
	DB	';xpO?;xp;7q-#lLYI:xvD=#', 00H		; proggy_clean_ttf_compressed_data_base85
	ORG $+3
?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB DB '..-         -XXXXXXX-    X'
	DB	'    -           X           -XXXXXXX          -          XXXX'
	DB	'XXX-     XX          - XX       XX ..-         -X.....X-   X.'
	DB	'X   -          X.X          -X.....X          -          X...'
	DB	'..X-    X..X         -X..X     X..X---         -XXX.XXX-  X..'
	DB	'.X  -         X...X         -X....X           -           X..'
	DB	'..X-    X..X         -X...X   X...XX           -  X.X  - X...'
	DB	'..X -        X.....X        -X...X            -            X.'
	DB	'..X-    X..X         - X...X X...X XX          -  X.X  -X....'
	DB	'...X-       X.......X       -X..X.X           -           X.X'
	DB	'..X-    X..X         -  X...X...X  X.X         -  X.X  -XXXX.'
	DB	'XXXX-       XXXX.XXXX       -X.X X.X          -          X.X '
	DB	'X.X-    X..XXX       -   X.....X   X..X        -  X.X  -   X.'
	DB	'X   -          X.X          -XX   X.X         -         X.X  '
	DB	' XX-    X..X..XXX    -    X...X    X...X       -  X.X  -   X.'
	DB	'X   -    XX    X.X    XX    -      X.X        -        X.X   '
	DB	'   -    X..X..X..XX  -     X.X     X....X      -  X.X  -   X.'
	DB	'X   -   X.X    X.X    X.X   -       X.X       -       X.X    '
	DB	'   -    X..X..X..X.X -    X...X    X.....X     -  X.X  -   X.'
	DB	'X   -  X..X    X.X    X..X  -        X.X      -      X.X     '
	DB	'   -XXX X..X..X..X..X-   X.....X   X......X    -  X.X  -   X.'
	DB	'X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X      '
	DB	'   -X..XX........X..X-  X...X...X  X.......X   -  X.X  -   X.'
	DB	'X   -X.....................X-          X.X X.X-X.X X.X       '
	DB	'   -X...X...........X- X...X X...X X........X  -  X.X  -   X.'
	DB	'X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X        '
	DB	'   - X..............X-X...X   X...XX.........X -XXX.XXX-   X.'
	DB	'X   -  X..X    X.X    X..X  -            X...X-X...X         '
	DB	'   -  X.............X-X..X     X..XX..........X-X.....X-   X.'
	DB	'X   -   X.X    X.X    X.X   -           X....X-X....X        '
	DB	'   -  X.............X- XX       XX X......XXXXX-XXXXXXX-   X.'
	DB	'X   -    XX    X.X    XX    -          X.....X-X.....X       '
	DB	'   -   X............X--------------X...X..X    ---------   X.'
	DB	'X   -          X.X          -          XXXXXXX-XXXXXXX       '
	DB	'   -   X...........X -             X..X X..X   -       -XXXX.'
	DB	'XXXX-       XXXX.XXXX       ---------------------------------'
	DB	'----    X..........X -             X.X  X..X   -       -X....'
	DB	'...X-       X.......X       -    XX           XX    -        '
	DB	'   -    X..........X -             XX    X..X  -       - X...'
	DB	'..X -        X.....X        -   X.X           X.X   -        '
	DB	'   -     X........X  -                   X..X  -       -  X..'
	DB	'.X  -         X...X         -  X..X           X..X  -        '
	DB	'   -     X........X  -                    XX   -       -   X.'
	DB	'X   -          X.X          - X...XXXXXXXXXXXXX...X -        '
	DB	'   -     XXXXXXXXXX  -             -------------       -    X'
	DB	'    -           X           -X.....................X-        '
	DB	'   -------------------                                 ------'
	DB	'----------------------------- X...XXXXXXXXXXXXX...X -        '
	DB	'                                                             '
	DB	'                            -  X..X           X..X  -        '
	DB	'                                                             '
	DB	'                            -   X.X           X.X   -        '
	DB	'                                                             '
	DB	'                            -    XX           XX    -        '
	DB	'                                   ', 00H	; FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS
PUBLIC	??_GImFont@@QEAAPEAXI@Z				; ImFont::`scalar deleting destructor'
PUBLIC	??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z	; IM_DELETE<ImFont>
PUBLIC	?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z ; ImVector<ImDrawVert>::_grow_capacity
PUBLIC	?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z	; ImVector<ImVec4>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z		; ImVector<ImVec4>::reserve
PUBLIC	?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z	; ImVector<void *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PEAX@@QEAAXH@Z		; ImVector<void *>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QEBAHH@Z ; ImVector<ImFontAtlasCustomRect>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z ; ImVector<ImFontAtlasCustomRect>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z ; ImVector<ImFontConfig>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z	; ImVector<ImFontConfig>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z ; ImVector<ImFontGlyph>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z	; ImVector<ImFontGlyph>::reserve
PUBLIC	?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ ; ImVector<ImFontBuildSrcData>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z ; ImVector<ImFontBuildSrcData>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ; ImVector<ImFontBuildSrcData>::reserve
PUBLIC	?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z ; ImVector<ImFontBuildDstData>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ; ImVector<ImFontBuildDstData>::reserve
PUBLIC	?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z ; ImVector<stbrp_rect>::_grow_capacity
PUBLIC	?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z	; ImVector<stbrp_rect>::reserve
PUBLIC	?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z ; ImVector<stbtt_packedchar>::_grow_capacity
PUBLIC	?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ; ImVector<stbtt_packedchar>::reserve
PUBLIC	??1ImBitVector@@QEAA@XZ				; ImBitVector::~ImBitVector
PUBLIC	??1ImFontBuildSrcData@@QEAA@XZ			; ImFontBuildSrcData::~ImFontBuildSrcData
PUBLIC	??_GImFontBuildSrcData@@QEAAPEAXI@Z		; ImFontBuildSrcData::`scalar deleting destructor'
PUBLIC	?empty@?$ImVector@G@@QEBA_NXZ			; ImVector<unsigned short>::empty
PUBLIC	?resize@?$ImVector@G@@QEAAXHAEBG@Z		; ImVector<unsigned short>::resize
PUBLIC	?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ		; ImVector<ImDrawCmd>::clear
PUBLIC	?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z	; ImVector<ImDrawCmd>::resize
PUBLIC	?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z ; ImVector<ImDrawCmd>::erase
PUBLIC	??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ	; ImVector<ImDrawVert>::clear
PUBLIC	?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z	; ImVector<ImDrawVert>::resize
PUBLIC	?clear@?$ImVector@UImVec4@@@@QEAAXXZ		; ImVector<ImVec4>::clear
PUBLIC	?resize@?$ImVector@UImVec4@@@@QEAAXH@Z		; ImVector<ImVec4>::resize
PUBLIC	?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z ; ImVector<ImVec4>::push_back
PUBLIC	?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ		; ImVector<ImVec4>::pop_back
PUBLIC	?clear@?$ImVector@PEAX@@QEAAXXZ			; ImVector<void *>::clear
PUBLIC	?resize@?$ImVector@PEAX@@QEAAXH@Z		; ImVector<void *>::resize
PUBLIC	?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z	; ImVector<void *>::push_back
PUBLIC	?pop_back@?$ImVector@PEAX@@QEAAXXZ		; ImVector<void *>::pop_back
PUBLIC	?empty@?$ImVector@I@@QEBA_NXZ			; ImVector<unsigned int>::empty
PUBLIC	?begin@?$ImVector@I@@QEBAPEBIXZ			; ImVector<unsigned int>::begin
PUBLIC	?end@?$ImVector@I@@QEBAPEBIXZ			; ImVector<unsigned int>::end
PUBLIC	?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ	; ImVector<ImFont *>::clear_delete
PUBLIC	??0?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ	; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>
PUBLIC	??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ	; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
PUBLIC	?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ ; ImVector<ImFontAtlasCustomRect>::clear
PUBLIC	??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z ; ImVector<ImFontAtlasCustomRect>::operator[]
PUBLIC	?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back
PUBLIC	??0?$ImVector@UImFontConfig@@@@QEAA@XZ		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
PUBLIC	??1?$ImVector@UImFontConfig@@@@QEAA@XZ		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
PUBLIC	?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ	; ImVector<ImFontConfig>::clear
PUBLIC	??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
PUBLIC	?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ ; ImVector<ImFontConfig>::back
PUBLIC	?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z ; ImVector<ImFontConfig>::push_back
PUBLIC	?resize@?$ImVector@M@@QEAAXHAEBM@Z		; ImVector<float>::resize
PUBLIC	??0?$ImVector@UImFontGlyph@@@@QEAA@XZ		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
PUBLIC	??1?$ImVector@UImFontGlyph@@@@QEAA@XZ		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
PUBLIC	?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ	; ImVector<ImFontGlyph>::clear
PUBLIC	??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z ; ImVector<ImFontGlyph>::operator[]
PUBLIC	?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ ; ImVector<ImFontGlyph>::back
PUBLIC	?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z	; ImVector<ImFontGlyph>::resize
PUBLIC	??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
PUBLIC	??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
PUBLIC	?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ ; ImVector<ImFontBuildSrcData>::clear_destruct
PUBLIC	?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ ; ImVector<ImFontBuildSrcData>::size_in_bytes
PUBLIC	??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ; ImVector<ImFontBuildSrcData>::operator[]
PUBLIC	?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ; ImVector<ImFontBuildSrcData>::resize
PUBLIC	??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
PUBLIC	??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
PUBLIC	?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ ; ImVector<ImFontBuildDstData>::clear
PUBLIC	?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ ; ImVector<ImFontBuildDstData>::size_in_bytes
PUBLIC	??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z ; ImVector<ImFontBuildDstData>::operator[]
PUBLIC	?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ; ImVector<ImFontBuildDstData>::resize
PUBLIC	??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
PUBLIC	??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
PUBLIC	?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ	; ImVector<stbrp_rect>::clear
PUBLIC	?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ ; ImVector<stbrp_rect>::size_in_bytes
PUBLIC	??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
PUBLIC	?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z	; ImVector<stbrp_rect>::resize
PUBLIC	??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ	; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
PUBLIC	??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ	; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
PUBLIC	?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ ; ImVector<stbtt_packedchar>::size_in_bytes
PUBLIC	??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z ; ImVector<stbtt_packedchar>::operator[]
PUBLIC	?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ; ImVector<stbtt_packedchar>::resize
PUBLIC	?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z ; ImGui::RenderArrow
PUBLIC	?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
PUBLIC	?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
PUBLIC	?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z ; ImFont::AddGlyph
PUBLIC	?GrowIndex@ImFont@@QEAAXH@Z			; ImFont::GrowIndex
PUBLIC	?SetGlyphVisible@ImFont@@QEAAXG_N@Z		; ImFont::SetGlyphVisible
PUBLIC	?BuildLookupTable@ImFont@@QEAAXXZ		; ImFont::BuildLookupTable
PUBLIC	?ClearOutputData@ImFont@@QEAAXXZ		; ImFont::ClearOutputData
PUBLIC	?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ	; ImFontAtlas::GetGlyphRangesDefault
PUBLIC	?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z	; ImFontAtlasBuildFinish
PUBLIC	?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z	; ImFontAtlasBuildInit
PUBLIC	?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z ; ImFontAtlasBuildRender32bppRectFromString
PUBLIC	?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z ; ImFontAtlasBuildRender8bppRectFromString
PUBLIC	?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z ; ImFontAtlasBuildPackCustomRects
PUBLIC	?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z ; ImFontAtlasBuildSetupFont
PUBLIC	?ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ ; ImFontAtlasGetBuilderForStbTruetype
PUBLIC	?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z ; ImFontAtlasBuildMultiplyRectAlpha8
PUBLIC	?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z ; ImFontAtlasBuildMultiplyCalcLookupTable
PUBLIC	?Build@ImFontAtlas@@QEAA_NXZ			; ImFontAtlas::Build
PUBLIC	?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z ; ImFontAtlas::GetMouseCursorTexData
PUBLIC	?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z ; ImFontAtlas::CalcCustomRectUV
PUBLIC	?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z	; ImFontAtlas::AddCustomRectRegular
PUBLIC	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
PUBLIC	?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF
PUBLIC	?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
PUBLIC	?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromFileTTF
PUBLIC	?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ; ImFontAtlas::AddFontDefault
PUBLIC	?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ; ImFontAtlas::AddFont
PUBLIC	?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32
PUBLIC	?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ; ImFontAtlas::GetTexDataAsAlpha8
PUBLIC	?Clear@ImFontAtlas@@QEAAXXZ			; ImFontAtlas::Clear
PUBLIC	?ClearFonts@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::ClearFonts
PUBLIC	?ClearTexData@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::ClearTexData
PUBLIC	?ClearInputData@ImFontAtlas@@QEAAXXZ		; ImFontAtlas::ClearInputData
PUBLIC	??0ImFontConfig@@QEAA@XZ			; ImFontConfig::ImFontConfig
PUBLIC	?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel
PUBLIC	?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z ; ImDrawListSplitter::Merge
PUBLIC	?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
PUBLIC	?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::AddQuadFilled
PUBLIC	?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z	; ImDrawList::AddQuad
PUBLIC	?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z	; ImDrawList::PathRect
PUBLIC	?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
PUBLIC	?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
PUBLIC	?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z	; ImDrawList::PrimRectUV
PUBLIC	?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z	; ImDrawList::PrimRect
PUBLIC	?PrimReserve@ImDrawList@@QEAAXHH@Z		; ImDrawList::PrimReserve
PUBLIC	?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ	; ImDrawList::_OnChangedVtxOffset
PUBLIC	?_OnChangedTextureID@ImDrawList@@QEAAXXZ	; ImDrawList::_OnChangedTextureID
PUBLIC	?_OnChangedClipRect@ImDrawList@@QEAAXXZ		; ImDrawList::_OnChangedClipRect
PUBLIC	?SetBit@ImBitVector@@QEAAXH@Z			; ImBitVector::SetBit
PUBLIC	?TestBit@ImBitVector@@QEBA_NH@Z			; ImBitVector::TestBit
PUBLIC	?Clear@ImBitVector@@QEAAXXZ			; ImBitVector::Clear
PUBLIC	?Create@ImBitVector@@QEAAXH@Z			; ImBitVector::Create
PUBLIC	?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z ; ImFontAtlas::GetCustomRectByIndex
PUBLIC	?IsPacked@ImFontAtlasCustomRect@@QEBA_NXZ	; ImFontAtlasCustomRect::IsPacked
PUBLIC	??0ImFontAtlasCustomRect@@QEAA@XZ		; ImFontAtlasCustomRect::ImFontAtlasCustomRect
PUBLIC	?Clear@ImDrawListSplitter@@QEAAXXZ		; ImDrawListSplitter::Clear
PUBLIC	??0ImDrawCmd@@QEAA@XZ				; ImDrawCmd::ImDrawCmd
PUBLIC	?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ; ImDrawList::_CalcCircleAutoSegmentCount
PUBLIC	?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
PUBLIC	?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z	; ImDrawList::AddCircle
PUBLIC	?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
PUBLIC	?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z ; ImDrawList::AddTriangle
PUBLIC	?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ; ImFont::CalcTextSizeA
PUBLIC	?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z ; ImFont::FindGlyphNoFallback
PUBLIC	?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z	; ImFont::FindGlyph
PUBLIC	??1ImFont@@QEAA@XZ				; ImFont::~ImFont
PUBLIC	??0ImFont@@QEAA@XZ				; ImFont::ImFont
PUBLIC	?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ	; ImDrawListSplitter::ClearFreeMemory
PUBLIC	?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ		; ImDrawList::_PopUnusedDrawCmd
PUBLIC	?_ClearFreeMemory@ImDrawList@@QEAAXXZ		; ImDrawList::_ClearFreeMemory
PUBLIC	?_ResetForNewFrame@ImDrawList@@QEAAXXZ		; ImDrawList::_ResetForNewFrame
PUBLIC	?AddDrawCmd@ImDrawList@@QEAAXXZ			; ImDrawList::AddDrawCmd
PUBLIC	?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
PUBLIC	?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z	; ImDrawList::PathArcTo
PUBLIC	?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
PUBLIC	?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
PUBLIC	?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z	; ImDrawList::AddText
PUBLIC	?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ; ImDrawList::AddText
PUBLIC	?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
PUBLIC	?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z	; ImDrawList::AddRect
PUBLIC	?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z	; ImDrawList::AddLine
PUBLIC	?PopTextureID@ImDrawList@@QEAAXXZ		; ImDrawList::PopTextureID
PUBLIC	?PushTextureID@ImDrawList@@QEAAXPEAX@Z		; ImDrawList::PushTextureID
PUBLIC	?PopClipRect@ImDrawList@@QEAAXXZ		; ImDrawList::PopClipRect
PUBLIC	?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z	; ImDrawList::PushClipRect
PUBLIC	?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z ; ImDrawListSharedData::SetCircleTessellationMaxError
PUBLIC	??0ImDrawListSharedData@@QEAA@XZ		; ImDrawListSharedData::ImDrawListSharedData
PUBLIC	??1ImFontAtlas@@QEAA@XZ				; ImFontAtlas::~ImFontAtlas
PUBLIC	??0ImFontAtlas@@QEAA@XZ				; ImFontAtlas::ImFontAtlas
PUBLIC	?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z ; ImGui::RenderMouseCursor
PUBLIC	?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z	; ImGui::StyleColorsDark
PUBLIC	?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z ; ImGui::RenderBullet
?stb__barrier_in_b@@3PEBEEB DQ 01H DUP (?)		; stb__barrier_in_b
_BSS	ENDS
;	COMDAT ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A
_BSS	SEGMENT
?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A DQ 01H DUP (?) ; `ImFontAtlasGetBuilderForStbTruetype'::`2'::io
?stb__barrier_out_e@@3PEAEEA DQ 01H DUP (?)		; stb__barrier_out_e
?stb__barrier_out_b@@3PEAEEA DQ 01H DUP (?)		; stb__barrier_out_b
?stb__dout@@3PEAEEA DQ 01H DUP (?)			; stb__dout
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImFont@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??_GImFont@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z DD imagerel $LN18
	DD	imagerel $LN18+51
	DD	imagerel $unwind$??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN21+28
	DD	imagerel $LN21+129
	DD	imagerel $chain$0$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN21+129
	DD	imagerel $LN21+140
	DD	imagerel $chain$1$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN21+28
	DD	imagerel $LN21+129
	DD	imagerel $chain$0$?reserve@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN21+129
	DD	imagerel $LN21+140
	DD	imagerel $chain$1$?reserve@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD imagerel $LN21+28
	DD	imagerel $LN21+129
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD imagerel $LN21+129
	DD	imagerel $LN21+140
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD imagerel $LN21+28
	DD	imagerel $LN21+132
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD imagerel $LN21+132
	DD	imagerel $LN21+143
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN21+28
	DD	imagerel $LN21+134
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN21+134
	DD	imagerel $LN21+145
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN21+28
	DD	imagerel $LN21+132
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN21+132
	DD	imagerel $LN21+143
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN21+28
	DD	imagerel $LN21+129
	DD	imagerel $chain$0$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN21+129
	DD	imagerel $LN21+140
	DD	imagerel $chain$1$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN21+28
	DD	imagerel $LN21+129
	DD	imagerel $chain$0$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN21+129
	DD	imagerel $LN21+140
	DD	imagerel $chain$1$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN21+28
	DD	imagerel $LN21+126
	DD	imagerel $chain$0$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN21+126
	DD	imagerel $LN21+137
	DD	imagerel $chain$1$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImBitVector@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+43
	DD	imagerel $unwind$??1ImBitVector@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImFontBuildSrcData@@QEAA@XZ DD imagerel $LN33
	DD	imagerel $LN33+89
	DD	imagerel $unwind$??1ImFontBuildSrcData@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImFontBuildSrcData@@QEAAPEAXI@Z DD imagerel $LN37
	DD	imagerel $LN37+92
	DD	imagerel $unwind$??_GImFontBuildSrcData@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@G@@QEAAXHAEBG@Z DD imagerel $LN19
	DD	imagerel $LN19+118
	DD	imagerel $unwind$?resize@?$ImVector@G@@QEAAXHAEBG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z DD imagerel $LN10
	DD	imagerel $LN10+70
	DD	imagerel $unwind$?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z DD imagerel $LN8
	DD	imagerel $LN8+153
	DD	imagerel $unwind$?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z DD imagerel $LN10
	DD	imagerel $LN10+70
	DD	imagerel $unwind$?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImVec4@@@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@UImVec4@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImVec4@@@@QEAAXH@Z DD imagerel $LN10
	DD	imagerel $LN10+52
	DD	imagerel $unwind$?resize@?$ImVector@UImVec4@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z DD imagerel $LN9
	DD	imagerel $LN9+99
	DD	imagerel $unwind$?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@PEAX@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@PEAX@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@PEAX@@QEAAXH@Z DD imagerel $LN10
	DD	imagerel $LN10+52
	DD	imagerel $unwind$?resize@?$ImVector@PEAX@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z DD imagerel $LN9
	DD	imagerel $LN9+96
	DD	imagerel $unwind$?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_back@?$ImVector@PEAX@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$?pop_back@?$ImVector@PEAX@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD imagerel $LN76
	DD	imagerel $LN76+276
	DD	imagerel $unwind$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD imagerel $LN28
	DD	imagerel $LN28+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD imagerel $LN28+72
	DD	imagerel $LN28+173
	DD	imagerel $chain$0$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD imagerel $LN28+173
	DD	imagerel $LN28+219
	DD	imagerel $chain$1$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontConfig@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD imagerel $LN28
	DD	imagerel $LN28+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD imagerel $LN28+72
	DD	imagerel $LN28+179
	DD	imagerel $chain$0$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD imagerel $LN28+179
	DD	imagerel $LN28+298
	DD	imagerel $chain$1$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@M@@QEAAXHAEBM@Z DD imagerel $LN19
	DD	imagerel $LN19+116
	DD	imagerel $unwind$?resize@?$ImVector@M@@QEAAXHAEBM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+73
	DD	imagerel $unwind$??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ DD imagerel $LN5
	DD	imagerel $LN5+66
	DD	imagerel $unwind$?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN31+26
	DD	imagerel $LN31+200
	DD	imagerel $chain$1$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN31+200
	DD	imagerel $LN31+218
	DD	imagerel $chain$3$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD imagerel $LN31+218
	DD	imagerel $LN31+231
	DD	imagerel $chain$4$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DD imagerel $LN56
	DD	imagerel $LN56+194
	DD	imagerel $unwind$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN31+26
	DD	imagerel $LN31+198
	DD	imagerel $chain$1$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN31+198
	DD	imagerel $LN31+216
	DD	imagerel $chain$3$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD imagerel $LN31+216
	DD	imagerel $LN31+229
	DD	imagerel $chain$4$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN31+26
	DD	imagerel $LN31+188
	DD	imagerel $chain$1$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN31+188
	DD	imagerel $LN31+206
	DD	imagerel $chain$3$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD imagerel $LN31+206
	DD	imagerel $LN31+219
	DD	imagerel $chain$4$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN31+26
	DD	imagerel $LN31+188
	DD	imagerel $chain$1$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN31+188
	DD	imagerel $LN31+206
	DD	imagerel $chain$3$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD imagerel $LN31+206
	DD	imagerel $LN31+219
	DD	imagerel $chain$4$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+35
	DD	imagerel $unwind$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z DD imagerel $LN6
	DD	imagerel $LN6+69
	DD	imagerel $unwind$??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN31+26
	DD	imagerel $LN31+188
	DD	imagerel $chain$1$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN31+188
	DD	imagerel $LN31+206
	DD	imagerel $chain$3$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD imagerel $LN31+206
	DD	imagerel $LN31+219
	DD	imagerel $chain$4$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?stb_decompress@@YAIPEAEPEBEI@Z DD imagerel ?stb_decompress@@YAIPEAEPEBEI@Z
	DD	imagerel ?stb_decompress@@YAIPEAEPEBEI@Z+440
	DD	imagerel $unwind$?stb_decompress@@YAIPEAEPEBEI@Z
$pdata$?stb_adler32@@YAIIPEAEI@Z DD imagerel ?stb_adler32@@YAIIPEAEI@Z
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+51
	DD	imagerel $unwind$?stb_adler32@@YAIIPEAEI@Z
$pdata$0$?stb_adler32@@YAIIPEAEI@Z DD imagerel ?stb_adler32@@YAIIPEAEI@Z+51
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+316
	DD	imagerel $chain$0$?stb_adler32@@YAIIPEAEI@Z
$pdata$1$?stb_adler32@@YAIIPEAEI@Z DD imagerel ?stb_adler32@@YAIIPEAEI@Z+316
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+331
	DD	imagerel $chain$1$?stb_adler32@@YAIIPEAEI@Z
$pdata$?stb_decompress_token@@YAPEBEPEBE@Z DD imagerel ?stb_decompress_token@@YAPEBEPEBE@Z
	DD	imagerel ?stb_decompress_token@@YAPEBEPEBE@Z+583
	DD	imagerel $unwind$?stb_decompress_token@@YAPEBEPEBE@Z
$pdata$?stb__lit@@YAXPEBEI@Z DD imagerel ?stb__lit@@YAXPEBEI@Z
	DD	imagerel ?stb__lit@@YAXPEBEI@Z+162
	DD	imagerel $unwind$?stb__lit@@YAXPEBEI@Z
$pdata$?stb__match@@YAXPEBEI@Z DD imagerel ?stb__match@@YAXPEBEI@Z
	DD	imagerel ?stb__match@@YAXPEBEI@Z+181
	DD	imagerel $unwind$?stb__match@@YAXPEBEI@Z
$pdata$?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z DD imagerel $LN76
	DD	imagerel $LN76+580
	DD	imagerel $unwind$?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z
$pdata$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN91
	DD	imagerel $LN91+154
	DD	imagerel $unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$pdata$4$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN91+154
	DD	imagerel $LN91+456
	DD	imagerel $chain$4$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$pdata$6$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN91+456
	DD	imagerel $LN91+555
	DD	imagerel $chain$6$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$pdata$9$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN91+555
	DD	imagerel $LN91+1519
	DD	imagerel $chain$9$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$pdata$10$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN91+1519
	DD	imagerel $LN91+1664
	DD	imagerel $chain$10$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$pdata$11$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN91+1664
	DD	imagerel $LN91+1707
	DD	imagerel $chain$11$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$pdata$12$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD imagerel $LN91+1707
	DD	imagerel $LN91+1741
	DD	imagerel $chain$12$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$pdata$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD imagerel $LN44
	DD	imagerel $LN44+68
	DD	imagerel $unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$pdata$0$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD imagerel $LN44+68
	DD	imagerel $LN44+343
	DD	imagerel $chain$0$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$pdata$1$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD imagerel $LN44+343
	DD	imagerel $LN44+368
	DD	imagerel $chain$1$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$pdata$2$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD imagerel $LN44+368
	DD	imagerel $LN44+390
	DD	imagerel $chain$2$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$pdata$3$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD imagerel $LN44+390
	DD	imagerel $LN44+395
	DD	imagerel $chain$3$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$pdata$?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z DD imagerel $LN27
	DD	imagerel $LN27+560
	DD	imagerel $unwind$?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z
$pdata$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN36
	DD	imagerel $LN36+69
	DD	imagerel $unwind$?GrowIndex@ImFont@@QEAAXH@Z
$pdata$0$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN36+69
	DD	imagerel $LN36+74
	DD	imagerel $chain$0$?GrowIndex@ImFont@@QEAAXH@Z
$pdata$1$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN36+74
	DD	imagerel $LN36+230
	DD	imagerel $chain$1$?GrowIndex@ImFont@@QEAAXH@Z
$pdata$2$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN36+230
	DD	imagerel $LN36+280
	DD	imagerel $chain$2$?GrowIndex@ImFont@@QEAAXH@Z
$pdata$3$?GrowIndex@ImFont@@QEAAXH@Z DD imagerel $LN36+280
	DD	imagerel $LN36+288
	DD	imagerel $chain$3$?GrowIndex@ImFont@@QEAAXH@Z
$pdata$?BuildLookupTable@ImFont@@QEAAXXZ DD imagerel $LN194
	DD	imagerel $LN194+31
	DD	imagerel $unwind$?BuildLookupTable@ImFont@@QEAAXXZ
$pdata$1$?BuildLookupTable@ImFont@@QEAAXXZ DD imagerel $LN194+31
	DD	imagerel $LN194+44
	DD	imagerel $chain$1$?BuildLookupTable@ImFont@@QEAAXXZ
$pdata$4$?BuildLookupTable@ImFont@@QEAAXXZ DD imagerel $LN194+44
	DD	imagerel $LN194+972
	DD	imagerel $chain$4$?BuildLookupTable@ImFont@@QEAAXXZ
$pdata$5$?BuildLookupTable@ImFont@@QEAAXXZ DD imagerel $LN194+972
	DD	imagerel $LN194+1535
	DD	imagerel $chain$5$?BuildLookupTable@ImFont@@QEAAXXZ
$pdata$7$?BuildLookupTable@ImFont@@QEAAXXZ DD imagerel $LN194+1535
	DD	imagerel $LN194+1651
	DD	imagerel $chain$7$?BuildLookupTable@ImFont@@QEAAXXZ
$pdata$6$?BuildLookupTable@ImFont@@QEAAXXZ DD imagerel $LN194+1651
	DD	imagerel $LN194+1678
	DD	imagerel $chain$6$?BuildLookupTable@ImFont@@QEAAXXZ
$pdata$?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z DD imagerel ?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z
	DD	imagerel ?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z+137
	DD	imagerel $unwind$?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z
$pdata$?ClearOutputData@ImFont@@QEAAXXZ DD imagerel $LN37
	DD	imagerel $LN37+171
	DD	imagerel $unwind$?ClearOutputData@ImFont@@QEAAXXZ
$pdata$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN51
	DD	imagerel $LN51+18
	DD	imagerel $unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$pdata$1$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN51+18
	DD	imagerel $LN51+101
	DD	imagerel $chain$1$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$pdata$7$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN51+101
	DD	imagerel $LN51+584
	DD	imagerel $chain$7$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$pdata$8$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN51+584
	DD	imagerel $LN51+599
	DD	imagerel $chain$8$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$pdata$9$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN51+599
	DD	imagerel $LN51+744
	DD	imagerel $chain$9$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$pdata$?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z DD imagerel $LN10
	DD	imagerel $LN10+98
	DD	imagerel $unwind$?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z
$pdata$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+27
	DD	imagerel $unwind$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
$pdata$7$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+27
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+552
	DD	imagerel $chain$7$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
$pdata$8$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+552
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+559
	DD	imagerel $chain$8$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
$pdata$?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z+504
	DD	imagerel $unwind$?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z
$pdata$?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z DD imagerel $LN29
	DD	imagerel $LN29+250
	DD	imagerel $unwind$?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z
$pdata$?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z DD imagerel $LN33
	DD	imagerel $LN33+240
	DD	imagerel $unwind$?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z
$pdata$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DD imagerel $LN151
	DD	imagerel $LN151+865
	DD	imagerel $unwind$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
$pdata$?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z DD imagerel $LN6
	DD	imagerel $LN6+113
	DD	imagerel $unwind$?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z
$pdata$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DD imagerel ?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z+6157
	DD	imagerel $unwind$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
$pdata$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+38
	DD	imagerel $unwind$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
$pdata$3$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+38
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+211
	DD	imagerel $chain$3$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
$pdata$4$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+211
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+223
	DD	imagerel $chain$4$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
$pdata$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
$pdata$0$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD imagerel $LN18+41
	DD	imagerel $LN18+101
	DD	imagerel $chain$0$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
$pdata$1$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD imagerel $LN18+101
	DD	imagerel $LN18+103
	DD	imagerel $chain$1$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
$pdata$?Build@ImFontAtlas@@QEAA_NXZ DD imagerel $LN25
	DD	imagerel $LN25+457
	DD	imagerel $unwind$?Build@ImFontAtlas@@QEAA_NXZ
$pdata$?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z DD imagerel $LN38
	DD	imagerel $LN38+333
	DD	imagerel $unwind$?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z
$pdata$?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z DD imagerel $LN13
	DD	imagerel $LN13+224
	DD	imagerel $unwind$?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z
$pdata$?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z DD imagerel $LN16
	DD	imagerel $LN16+165
	DD	imagerel $unwind$?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z
$pdata$?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD imagerel $LN48
	DD	imagerel $LN48+398
	DD	imagerel $unwind$?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z
$pdata$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN54
	DD	imagerel $LN54+75
	DD	imagerel $unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$pdata$1$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN54+75
	DD	imagerel $LN54+233
	DD	imagerel $chain$1$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$pdata$2$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN54+233
	DD	imagerel $LN54+475
	DD	imagerel $chain$2$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$pdata$3$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN54+475
	DD	imagerel $LN54+488
	DD	imagerel $chain$3$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$pdata$4$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN54+488
	DD	imagerel $LN54+771
	DD	imagerel $chain$4$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$pdata$5$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN54+771
	DD	imagerel $LN54+869
	DD	imagerel $chain$5$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$pdata$?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z DD imagerel $LN19
	DD	imagerel $LN19+490
	DD	imagerel $unwind$?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z
$pdata$?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD imagerel $LN26
	DD	imagerel $LN26+473
	DD	imagerel $unwind$?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z
$pdata$?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN17
	DD	imagerel $LN17+374
	DD	imagerel $unwind$?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
$pdata$?Decode85@@YAXPEBEPEAE@Z DD imagerel ?Decode85@@YAXPEBEPEAE@Z
	DD	imagerel ?Decode85@@YAXPEBEPEAE@Z+198
	DD	imagerel $unwind$?Decode85@@YAXPEBEPEAE@Z
$pdata$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD imagerel $LN76
	DD	imagerel $LN76+825
	DD	imagerel $unwind$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z
$pdata$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN53+40
	DD	imagerel $LN53+47
	DD	imagerel $chain$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN53+47
	DD	imagerel $LN53+68
	DD	imagerel $chain$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$2$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN53+68
	DD	imagerel $LN53+581
	DD	imagerel $chain$2$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$3$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN53+581
	DD	imagerel $LN53+601
	DD	imagerel $chain$3$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$4$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN53+601
	DD	imagerel $LN53+620
	DD	imagerel $chain$4$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$5$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN53+620
	DD	imagerel $LN53+648
	DD	imagerel $chain$5$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD imagerel $LN32
	DD	imagerel $LN32+493
	DD	imagerel $unwind$?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$pdata$?Clear@ImFontAtlas@@QEAAXXZ DD imagerel $LN83
	DD	imagerel $LN83+328
	DD	imagerel $unwind$?Clear@ImFontAtlas@@QEAAXXZ
$pdata$?ClearFonts@ImFontAtlas@@QEAAXXZ DD imagerel $LN81
	DD	imagerel $LN81+325
	DD	imagerel $unwind$?ClearFonts@ImFontAtlas@@QEAAXXZ
$pdata$?ClearTexData@ImFontAtlas@@QEAAXXZ DD imagerel $LN24
	DD	imagerel $LN24+126
	DD	imagerel $unwind$?ClearTexData@ImFontAtlas@@QEAAXXZ
$pdata$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN95
	DD	imagerel $LN95+17
	DD	imagerel $unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ
$pdata$1$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN95+17
	DD	imagerel $LN95+70
	DD	imagerel $chain$1$?ClearInputData@ImFontAtlas@@QEAAXXZ
$pdata$2$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN95+70
	DD	imagerel $LN95+329
	DD	imagerel $chain$2$?ClearInputData@ImFontAtlas@@QEAAXXZ
$pdata$3$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN95+329
	DD	imagerel $LN95+612
	DD	imagerel $chain$3$?ClearInputData@ImFontAtlas@@QEAAXXZ
$pdata$4$?ClearInputData@ImFontAtlas@@QEAAXXZ DD imagerel $LN95+612
	DD	imagerel $LN95+707
	DD	imagerel $chain$4$?ClearInputData@ImFontAtlas@@QEAAXXZ
$pdata$?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD imagerel $LN16
	DD	imagerel $LN16+272
	DD	imagerel $unwind$?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z
$pdata$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN104
	DD	imagerel $LN104+31
	DD	imagerel $unwind$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
$pdata$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN104+31
	DD	imagerel $LN104+38
	DD	imagerel $chain$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
$pdata$5$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN104+38
	DD	imagerel $LN104+1108
	DD	imagerel $chain$5$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
$pdata$6$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN104+1108
	DD	imagerel $LN104+1212
	DD	imagerel $chain$6$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
$pdata$7$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD imagerel $LN104+1212
	DD	imagerel $LN104+1291
	DD	imagerel $chain$7$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
$pdata$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD imagerel $LN7
	DD	imagerel $LN7+46
	DD	imagerel $unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
$pdata$0$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD imagerel $LN7+46
	DD	imagerel $LN7+128
	DD	imagerel $chain$0$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
$pdata$1$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD imagerel $LN7+128
	DD	imagerel $LN7+156
	DD	imagerel $chain$1$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
$pdata$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD imagerel $LN43
	DD	imagerel $LN43+47
	DD	imagerel $unwind$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
$pdata$1$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD imagerel $LN43+47
	DD	imagerel $LN43+393
	DD	imagerel $chain$1$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
$pdata$2$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD imagerel $LN43+393
	DD	imagerel $LN43+408
	DD	imagerel $chain$2$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
$pdata$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z DD imagerel $LN43
	DD	imagerel $LN43+47
	DD	imagerel $unwind$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z
$pdata$1$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z DD imagerel $LN43+47
	DD	imagerel $LN43+416
	DD	imagerel $chain$1$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z
$pdata$2$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z DD imagerel $LN43+416
	DD	imagerel $LN43+431
	DD	imagerel $chain$2$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z
$pdata$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN129
	DD	imagerel $LN129+228
	DD	imagerel $unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$pdata$0$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN129+228
	DD	imagerel $LN129+244
	DD	imagerel $chain$0$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$pdata$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN129+244
	DD	imagerel $LN129+344
	DD	imagerel $chain$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$pdata$2$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN129+344
	DD	imagerel $LN129+891
	DD	imagerel $chain$2$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$pdata$3$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD imagerel $LN129+891
	DD	imagerel $LN129+1377
	DD	imagerel $chain$3$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$pdata$?FixRectCornerFlags@@YAHH@Z DD imagerel ?FixRectCornerFlags@@YAHH@Z
	DD	imagerel ?FixRectCornerFlags@@YAHH@Z+98
	DD	imagerel $unwind$?FixRectCornerFlags@@YAHH@Z
$pdata$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN30
	DD	imagerel $LN30+121
	DD	imagerel $unwind$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN30+121
	DD	imagerel $LN30+170
	DD	imagerel $chain$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$5$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN30+170
	DD	imagerel $LN30+398
	DD	imagerel $chain$5$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$6$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN30+398
	DD	imagerel $LN30+414
	DD	imagerel $chain$6$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$7$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN30+414
	DD	imagerel $LN30+437
	DD	imagerel $chain$7$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN54
	DD	imagerel $LN54+139
	DD	imagerel $unwind$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
$pdata$0$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN54+139
	DD	imagerel $LN54+147
	DD	imagerel $chain$0$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
$pdata$2$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN54+147
	DD	imagerel $LN54+381
	DD	imagerel $chain$2$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
$pdata$3$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN54+381
	DD	imagerel $LN54+620
	DD	imagerel $chain$3$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
$pdata$4$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD imagerel $LN54+620
	DD	imagerel $LN54+722
	DD	imagerel $chain$4$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
$pdata$?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD imagerel $LN12
	DD	imagerel $LN12+334
	DD	imagerel $unwind$?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
$pdata$?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z DD imagerel $LN8
	DD	imagerel $LN8+284
	DD	imagerel $unwind$?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z
$pdata$?PrimReserve@ImDrawList@@QEAAXHH@Z DD imagerel $LN23
	DD	imagerel $LN23+307
	DD	imagerel $unwind$?PrimReserve@ImDrawList@@QEAAXHH@Z
$pdata$?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+105
	DD	imagerel $unwind$?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ
$pdata$?_OnChangedTextureID@ImDrawList@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+67
	DD	imagerel $unwind$?_OnChangedTextureID@ImDrawList@@QEAAXXZ
$pdata$0$?_OnChangedTextureID@ImDrawList@@QEAAXXZ DD imagerel $LN10+67
	DD	imagerel $LN10+179
	DD	imagerel $chain$0$?_OnChangedTextureID@ImDrawList@@QEAAXXZ
$pdata$2$?_OnChangedTextureID@ImDrawList@@QEAAXXZ DD imagerel $LN10+179
	DD	imagerel $LN10+206
	DD	imagerel $chain$2$?_OnChangedTextureID@ImDrawList@@QEAAXXZ
$pdata$?_OnChangedClipRect@ImDrawList@@QEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+219
	DD	imagerel $unwind$?_OnChangedClipRect@ImDrawList@@QEAAXXZ
$pdata$stbtt_PackFontRangesRenderIntoRects DD imagerel stbtt_PackFontRangesRenderIntoRects
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+330
	DD	imagerel $unwind$stbtt_PackFontRangesRenderIntoRects
$pdata$1$stbtt_PackFontRangesRenderIntoRects DD imagerel stbtt_PackFontRangesRenderIntoRects+330
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+399
	DD	imagerel $chain$1$stbtt_PackFontRangesRenderIntoRects
$pdata$6$stbtt_PackFontRangesRenderIntoRects DD imagerel stbtt_PackFontRangesRenderIntoRects+399
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+1520
	DD	imagerel $chain$6$stbtt_PackFontRangesRenderIntoRects
$pdata$7$stbtt_PackFontRangesRenderIntoRects DD imagerel stbtt_PackFontRangesRenderIntoRects+1520
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+1597
	DD	imagerel $chain$7$stbtt_PackFontRangesRenderIntoRects
$pdata$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+76
	DD	imagerel $unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
$pdata$2$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+76
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+696
	DD	imagerel $chain$2$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
$pdata$3$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+696
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+722
	DD	imagerel $chain$3$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
$pdata$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+71
	DD	imagerel $unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
$pdata$3$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+71
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+691
	DD	imagerel $chain$3$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
$pdata$4$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+691
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+716
	DD	imagerel $chain$4$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
$pdata$stbtt_PackEnd DD imagerel stbtt_PackEnd
	DD	imagerel stbtt_PackEnd+81
	DD	imagerel $unwind$stbtt_PackEnd
$pdata$stbtt_PackBegin DD imagerel stbtt_PackBegin
	DD	imagerel stbtt_PackBegin+280
	DD	imagerel $unwind$stbtt_PackBegin
$pdata$stbtt_MakeGlyphBitmapSubpixel DD imagerel stbtt_MakeGlyphBitmapSubpixel
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+11
	DD	imagerel $unwind$stbtt_MakeGlyphBitmapSubpixel
$pdata$2$stbtt_MakeGlyphBitmapSubpixel DD imagerel stbtt_MakeGlyphBitmapSubpixel+11
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+33
	DD	imagerel $chain$2$stbtt_MakeGlyphBitmapSubpixel
$pdata$10$stbtt_MakeGlyphBitmapSubpixel DD imagerel stbtt_MakeGlyphBitmapSubpixel+33
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+482
	DD	imagerel $chain$10$stbtt_MakeGlyphBitmapSubpixel
$pdata$11$stbtt_MakeGlyphBitmapSubpixel DD imagerel stbtt_MakeGlyphBitmapSubpixel+482
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+774
	DD	imagerel $chain$11$stbtt_MakeGlyphBitmapSubpixel
$pdata$12$stbtt_MakeGlyphBitmapSubpixel DD imagerel stbtt_MakeGlyphBitmapSubpixel+774
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+810
	DD	imagerel $chain$12$stbtt_MakeGlyphBitmapSubpixel
$pdata$stbtt_Rasterize DD imagerel stbtt_Rasterize
	DD	imagerel stbtt_Rasterize+293
	DD	imagerel $unwind$stbtt_Rasterize
$pdata$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+188
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
$pdata$3$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+188
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+897
	DD	imagerel $chain$3$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
$pdata$4$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+897
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+930
	DD	imagerel $chain$4$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
$pdata$5$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+930
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+993
	DD	imagerel $chain$5$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
$pdata$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+421
	DD	imagerel $unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
$pdata$0$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+421
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+1112
	DD	imagerel $chain$0$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
$pdata$1$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+1112
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+1180
	DD	imagerel $chain$1$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
$pdata$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+220
	DD	imagerel $unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
$pdata$0$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+220
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+430
	DD	imagerel $chain$0$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
$pdata$1$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+430
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+491
	DD	imagerel $chain$1$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
$pdata$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+292
	DD	imagerel $unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$pdata$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+292
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+311
	DD	imagerel $chain$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$pdata$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+311
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+370
	DD	imagerel $chain$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$pdata$3$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+370
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+643
	DD	imagerel $chain$3$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$pdata$4$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+643
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+670
	DD	imagerel $chain$4$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$pdata$5$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+670
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+857
	DD	imagerel $chain$5$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$pdata$6$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+857
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+903
	DD	imagerel $chain$6$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$pdata$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z+192
	DD	imagerel $unwind$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z
$pdata$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+15
	DD	imagerel $unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
$pdata$3$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+15
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+465
	DD	imagerel $chain$3$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
$pdata$4$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+465
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+466
	DD	imagerel $chain$4$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
$pdata$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+31
	DD	imagerel $unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
$pdata$0$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+31
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+192
	DD	imagerel $chain$0$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
$pdata$1$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+192
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+193
	DD	imagerel $chain$1$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
$pdata$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+30
	DD	imagerel $unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$pdata$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+30
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+34
	DD	imagerel $chain$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$pdata$8$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+34
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+230
	DD	imagerel $chain$8$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$pdata$15$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+230
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1151
	DD	imagerel $chain$15$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$pdata$16$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1151
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1216
	DD	imagerel $chain$16$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$pdata$17$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1216
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1285
	DD	imagerel $chain$17$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$pdata$18$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1285
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+1338
	DD	imagerel $chain$18$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$pdata$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+80
	DD	imagerel $unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
$pdata$9$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+80
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+1808
	DD	imagerel $chain$9$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
$pdata$10$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+1808
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+1839
	DD	imagerel $chain$10$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
$pdata$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+181
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
$pdata$2$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+181
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+639
	DD	imagerel $chain$2$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
$pdata$3$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+639
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+675
	DD	imagerel $chain$3$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
$pdata$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z DD imagerel ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z
	DD	imagerel ?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z+325
	DD	imagerel $unwind$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z
$pdata$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+12
	DD	imagerel $unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
$pdata$0$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+12
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+57
	DD	imagerel $chain$0$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
$pdata$1$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+57
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+62
	DD	imagerel $chain$1$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
$pdata$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z DD imagerel ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z
	DD	imagerel ?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z+123
	DD	imagerel $unwind$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z
$pdata$stbtt_GetGlyphBitmapBox DD imagerel stbtt_GetGlyphBitmapBox
	DD	imagerel stbtt_GetGlyphBitmapBox+81
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBox
$pdata$stbtt_GetGlyphBitmapBoxSubpixel DD imagerel stbtt_GetGlyphBitmapBoxSubpixel
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+259
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBoxSubpixel
$pdata$0$stbtt_GetGlyphBitmapBoxSubpixel DD imagerel stbtt_GetGlyphBitmapBoxSubpixel+259
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+496
	DD	imagerel $chain$0$stbtt_GetGlyphBitmapBoxSubpixel
$pdata$1$stbtt_GetGlyphBitmapBoxSubpixel DD imagerel stbtt_GetGlyphBitmapBoxSubpixel+496
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+588
	DD	imagerel $chain$1$stbtt_GetGlyphBitmapBoxSubpixel
$pdata$stbtt_GetFontVMetrics DD imagerel stbtt_GetFontVMetrics
	DD	imagerel stbtt_GetFontVMetrics+169
	DD	imagerel $unwind$stbtt_GetFontVMetrics
$pdata$stbtt_GetGlyphHMetrics DD imagerel stbtt_GetGlyphHMetrics
	DD	imagerel stbtt_GetGlyphHMetrics+295
	DD	imagerel $unwind$stbtt_GetGlyphHMetrics
$pdata$stbtt_GetGlyphShape DD imagerel stbtt_GetGlyphShape
	DD	imagerel stbtt_GetGlyphShape+45
	DD	imagerel $unwind$stbtt_GetGlyphShape
$pdata$0$stbtt_GetGlyphShape DD imagerel stbtt_GetGlyphShape+45
	DD	imagerel stbtt_GetGlyphShape+248
	DD	imagerel $chain$0$stbtt_GetGlyphShape
$pdata$1$stbtt_GetGlyphShape DD imagerel stbtt_GetGlyphShape+248
	DD	imagerel stbtt_GetGlyphShape+269
	DD	imagerel $chain$1$stbtt_GetGlyphShape
$pdata$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z DD imagerel ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z
	DD	imagerel ?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z+170
	DD	imagerel $unwind$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z
$pdata$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD imagerel ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	imagerel ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z+233
	DD	imagerel $unwind$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
$pdata$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z DD imagerel ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
	DD	imagerel ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z+3556
	DD	imagerel $unwind$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z
$pdata$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z DD imagerel ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z
	DD	imagerel ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z+511
	DD	imagerel $unwind$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z
$pdata$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z DD imagerel ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
	DD	imagerel ?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z+236
	DD	imagerel $unwind$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z
$pdata$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z DD imagerel ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z
	DD	imagerel ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z+145
	DD	imagerel $unwind$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z
$pdata$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z DD imagerel ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z
	DD	imagerel ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z+200
	DD	imagerel $unwind$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z
$pdata$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+24
	DD	imagerel $unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
$pdata$1$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+24
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+234
	DD	imagerel $chain$1$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
$pdata$2$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+234
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+304
	DD	imagerel $chain$2$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
$pdata$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD imagerel ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
	DD	imagerel ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z+3344
	DD	imagerel $unwind$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z
$pdata$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+24
	DD	imagerel $unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
$pdata$0$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+24
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+151
	DD	imagerel $chain$0$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
$pdata$1$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+151
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+240
	DD	imagerel $chain$1$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
$pdata$stbtt_GetGlyphBox DD imagerel stbtt_GetGlyphBox
	DD	imagerel stbtt_GetGlyphBox+381
	DD	imagerel $unwind$stbtt_GetGlyphBox
$pdata$?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z DD imagerel ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z
	DD	imagerel ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z+290
	DD	imagerel $unwind$?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z
$pdata$stbtt_FindGlyphIndex DD imagerel stbtt_FindGlyphIndex
	DD	imagerel stbtt_FindGlyphIndex+359
	DD	imagerel $unwind$stbtt_FindGlyphIndex
$pdata$0$stbtt_FindGlyphIndex DD imagerel stbtt_FindGlyphIndex+359
	DD	imagerel stbtt_FindGlyphIndex+510
	DD	imagerel $chain$0$stbtt_FindGlyphIndex
$pdata$1$stbtt_FindGlyphIndex DD imagerel stbtt_FindGlyphIndex+510
	DD	imagerel stbtt_FindGlyphIndex+973
	DD	imagerel $chain$1$stbtt_FindGlyphIndex
$pdata$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z DD imagerel ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z
	DD	imagerel ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z+1394
	DD	imagerel $unwind$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z
$pdata$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z DD imagerel ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
	DD	imagerel ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z+360
	DD	imagerel $unwind$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z
$pdata$?stbtt__find_table@@YAIPEAEIPEBD@Z DD imagerel ?stbtt__find_table@@YAIPEAEIPEBD@Z
	DD	imagerel ?stbtt__find_table@@YAIPEAEIPEBD@Z+182
	DD	imagerel $unwind$?stbtt__find_table@@YAIPEAEIPEBD@Z
$pdata$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z DD imagerel ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
	DD	imagerel ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z+414
	DD	imagerel $unwind$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z
$pdata$?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z+138
	DD	imagerel $unwind$?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z
$pdata$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z DD imagerel ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z
	DD	imagerel ?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z+101
	DD	imagerel $unwind$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z
$pdata$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z DD imagerel ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z
	DD	imagerel ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z+557
	DD	imagerel $unwind$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z
$pdata$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+54
	DD	imagerel $unwind$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
$pdata$0$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+54
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+190
	DD	imagerel $chain$0$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
$pdata$2$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+190
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+204
	DD	imagerel $chain$2$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
$pdata$3$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+204
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+243
	DD	imagerel $chain$3$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
$pdata$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z+358
	DD	imagerel $unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z
$pdata$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+27
	DD	imagerel $unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$pdata$0$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+27
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+96
	DD	imagerel $chain$0$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$pdata$1$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+96
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+260
	DD	imagerel $chain$1$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$pdata$2$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+260
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+345
	DD	imagerel $chain$2$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$pdata$3$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+345
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+393
	DD	imagerel $chain$3$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$pdata$?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z DD imagerel ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z
	DD	imagerel ?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z+69
	DD	imagerel $unwind$?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z
$pdata$?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z DD imagerel ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z
	DD	imagerel ?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z+91
	DD	imagerel $unwind$?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z
$pdata$?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z DD imagerel ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z
	DD	imagerel ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z+128
	DD	imagerel $unwind$?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z
$pdata$?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z DD imagerel ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z
	DD	imagerel ?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z+94
	DD	imagerel $unwind$?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z
$pdata$?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z DD imagerel ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z
	DD	imagerel ?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z+91
	DD	imagerel $unwind$?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z
$pdata$stbrp_pack_rects DD imagerel stbrp_pack_rects
	DD	imagerel stbrp_pack_rects+20
	DD	imagerel $unwind$stbrp_pack_rects
$pdata$0$stbrp_pack_rects DD imagerel stbrp_pack_rects+20
	DD	imagerel stbrp_pack_rects+110
	DD	imagerel $chain$0$stbrp_pack_rects
$pdata$2$stbrp_pack_rects DD imagerel stbrp_pack_rects+110
	DD	imagerel stbrp_pack_rects+464
	DD	imagerel $chain$2$stbrp_pack_rects
$pdata$3$stbrp_pack_rects DD imagerel stbrp_pack_rects+464
	DD	imagerel stbrp_pack_rects+474
	DD	imagerel $chain$3$stbrp_pack_rects
$pdata$4$stbrp_pack_rects DD imagerel stbrp_pack_rects+474
	DD	imagerel stbrp_pack_rects+572
	DD	imagerel $chain$4$stbrp_pack_rects
$pdata$?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+240
	DD	imagerel $unwind$?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
$pdata$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+142
	DD	imagerel $unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
$pdata$1$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+142
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+691
	DD	imagerel $chain$1$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
$pdata$2$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+691
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+716
	DD	imagerel $chain$2$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
$pdata$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+160
	DD	imagerel $unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
$pdata$0$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+160
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+302
	DD	imagerel $chain$0$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
$pdata$1$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+302
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+333
	DD	imagerel $chain$1$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
$pdata$stbrp_init_target DD imagerel stbrp_init_target
	DD	imagerel stbrp_init_target+24
	DD	imagerel $unwind$stbrp_init_target
$pdata$0$stbrp_init_target DD imagerel stbrp_init_target+24
	DD	imagerel stbrp_init_target+141
	DD	imagerel $chain$0$stbrp_init_target
$pdata$1$stbrp_init_target DD imagerel stbrp_init_target+141
	DD	imagerel stbrp_init_target+329
	DD	imagerel $chain$1$stbrp_init_target
$pdata$2$stbrp_init_target DD imagerel stbrp_init_target+329
	DD	imagerel stbrp_init_target+345
	DD	imagerel $chain$2$stbrp_init_target
$pdata$3$stbrp_init_target DD imagerel stbrp_init_target+345
	DD	imagerel stbrp_init_target+517
	DD	imagerel $chain$3$stbrp_init_target
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetBit@ImBitVector@@QEAAXH@Z DD imagerel $LN7
	DD	imagerel $LN7+88
	DD	imagerel $unwind$?SetBit@ImBitVector@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TestBit@ImBitVector@@QEBA_NH@Z DD imagerel $LN7
	DD	imagerel $LN7+86
	DD	imagerel $unwind$?TestBit@ImBitVector@@QEBA_NH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clear@ImBitVector@@QEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?Clear@ImBitVector@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Create@ImBitVector@@QEAAXH@Z DD imagerel $LN11
	DD	imagerel $LN11+93
	DD	imagerel $unwind$?Create@ImBitVector@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z DD imagerel $LN9
	DD	imagerel $LN9+101
	DD	imagerel $unwind$?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z DD imagerel $LN14
	DD	imagerel $LN14+139
	DD	imagerel $unwind$?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z
$pdata$?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z DD imagerel $LN16
	DD	imagerel $LN16+182
	DD	imagerel $unwind$?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z
$pdata$?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z DD imagerel $LN15
	DD	imagerel $LN15+128
	DD	imagerel $unwind$?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z
$pdata$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD imagerel $LN34
	DD	imagerel $LN34+48
	DD	imagerel $unwind$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z
$pdata$1$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD imagerel $LN34+48
	DD	imagerel $LN34+316
	DD	imagerel $chain$1$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z
$pdata$2$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD imagerel $LN34+316
	DD	imagerel $LN34+332
	DD	imagerel $chain$2$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z
$pdata$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD imagerel $LN34
	DD	imagerel $LN34+48
	DD	imagerel $unwind$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z
$pdata$1$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD imagerel $LN34+48
	DD	imagerel $LN34+336
	DD	imagerel $chain$1$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z
$pdata$2$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD imagerel $LN34+336
	DD	imagerel $LN34+352
	DD	imagerel $chain$2$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z
$pdata$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD imagerel $LN64
	DD	imagerel $LN64+542
	DD	imagerel $unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z
$pdata$??1ImFont@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+123
	DD	imagerel $unwind$??1ImFont@@QEAA@XZ
$pdata$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN62
	DD	imagerel $LN62+15
	DD	imagerel $unwind$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
$pdata$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN62+15
	DD	imagerel $LN62+33
	DD	imagerel $chain$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
$pdata$2$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN62+33
	DD	imagerel $LN62+299
	DD	imagerel $chain$2$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
$pdata$3$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN62+299
	DD	imagerel $LN62+322
	DD	imagerel $chain$3$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
$pdata$4$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD imagerel $LN62+322
	DD	imagerel $LN62+365
	DD	imagerel $chain$4$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
$pdata$?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+86
	DD	imagerel $unwind$?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ
$pdata$?_ClearFreeMemory@ImDrawList@@QEAAXXZ DD imagerel $LN70
	DD	imagerel $LN70+300
	DD	imagerel $unwind$?_ClearFreeMemory@ImDrawList@@QEAAXXZ
$pdata$?_ResetForNewFrame@ImDrawList@@QEAAXXZ DD imagerel $LN59
	DD	imagerel $LN59+413
	DD	imagerel $unwind$?_ResetForNewFrame@ImDrawList@@QEAAXXZ
$pdata$?AddDrawCmd@ImDrawList@@QEAAXXZ DD imagerel $LN17
	DD	imagerel $LN17+242
	DD	imagerel $unwind$?AddDrawCmd@ImDrawList@@QEAAXXZ
$pdata$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD imagerel $LN12
	DD	imagerel $LN12+20
	DD	imagerel $unwind$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z
$pdata$0$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD imagerel $LN12+20
	DD	imagerel $LN12+107
	DD	imagerel $chain$0$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z
$pdata$1$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD imagerel $LN12+107
	DD	imagerel $LN12+141
	DD	imagerel $chain$1$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z
$pdata$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78
	DD	imagerel $LN78+182
	DD	imagerel $unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$1$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78+182
	DD	imagerel $LN78+227
	DD	imagerel $chain$1$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$2$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78+227
	DD	imagerel $LN78+235
	DD	imagerel $chain$2$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$6$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78+235
	DD	imagerel $LN78+586
	DD	imagerel $chain$6$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$7$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78+586
	DD	imagerel $LN78+725
	DD	imagerel $chain$7$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$8$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78+725
	DD	imagerel $LN78+774
	DD	imagerel $chain$8$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$9$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78+774
	DD	imagerel $LN78+904
	DD	imagerel $chain$9$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$10$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78+904
	DD	imagerel $LN78+918
	DD	imagerel $chain$10$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$11$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78+918
	DD	imagerel $LN78+951
	DD	imagerel $chain$11$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$12$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD imagerel $LN78+951
	DD	imagerel $LN78+1069
	DD	imagerel $chain$12$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$pdata$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD imagerel $LN70
	DD	imagerel $LN70+1412
	DD	imagerel $unwind$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z
$pdata$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD imagerel $LN253
	DD	imagerel $LN253+3795
	DD	imagerel $unwind$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z
$pdata$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD imagerel $LN36
	DD	imagerel $LN36+27
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$pdata$0$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD imagerel $LN36+27
	DD	imagerel $LN36+80
	DD	imagerel $chain$0$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$pdata$2$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD imagerel $LN36+80
	DD	imagerel $LN36+226
	DD	imagerel $chain$2$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$pdata$3$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD imagerel $LN36+226
	DD	imagerel $LN36+251
	DD	imagerel $chain$3$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$pdata$4$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD imagerel $LN36+251
	DD	imagerel $LN36+252
	DD	imagerel $chain$4$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$pdata$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD imagerel $LN33
	DD	imagerel $LN33+53
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z
$pdata$1$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD imagerel $LN33+53
	DD	imagerel $LN33+379
	DD	imagerel $chain$1$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z
$pdata$2$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD imagerel $LN33+379
	DD	imagerel $LN33+402
	DD	imagerel $chain$2$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z
$pdata$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD imagerel $LN17
	DD	imagerel $LN17+128
	DD	imagerel $unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
$pdata$0$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD imagerel $LN17+128
	DD	imagerel $LN17+395
	DD	imagerel $chain$0$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
$pdata$1$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD imagerel $LN17+395
	DD	imagerel $LN17+416
	DD	imagerel $chain$1$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
$pdata$?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z DD imagerel $LN35
	DD	imagerel $LN35+242
	DD	imagerel $unwind$?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z
$pdata$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN38
	DD	imagerel $LN38+48
	DD	imagerel $unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$pdata$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN38+48
	DD	imagerel $LN38+63
	DD	imagerel $chain$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$pdata$2$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN38+63
	DD	imagerel $LN38+218
	DD	imagerel $chain$2$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$pdata$3$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN38+218
	DD	imagerel $LN38+351
	DD	imagerel $chain$3$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$pdata$4$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD imagerel $LN38+351
	DD	imagerel $LN38+352
	DD	imagerel $chain$4$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$pdata$?PopTextureID@ImDrawList@@QEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+91
	DD	imagerel $unwind$?PopTextureID@ImDrawList@@QEAAXXZ
$pdata$?PushTextureID@ImDrawList@@QEAAXPEAX@Z DD imagerel $LN11
	DD	imagerel $LN11+122
	DD	imagerel $unwind$?PushTextureID@ImDrawList@@QEAAXPEAX@Z
$pdata$?PopClipRect@ImDrawList@@QEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+98
	DD	imagerel $unwind$?PopClipRect@ImDrawList@@QEAAXXZ
$pdata$?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z DD imagerel $LN26
	DD	imagerel $LN26+283
	DD	imagerel $unwind$?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z
$pdata$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD imagerel $LN28
	DD	imagerel $LN28+33
	DD	imagerel $unwind$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
$pdata$3$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD imagerel $LN28+33
	DD	imagerel $LN28+279
	DD	imagerel $chain$3$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
$pdata$4$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD imagerel $LN28+279
	DD	imagerel $LN28+290
	DD	imagerel $chain$4$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
$pdata$??0ImDrawListSharedData@@QEAA@XZ DD imagerel $LN35
	DD	imagerel $LN35+255
	DD	imagerel $unwind$??0ImDrawListSharedData@@QEAA@XZ
$pdata$??1ImFontAtlas@@QEAA@XZ DD imagerel $LN123
	DD	imagerel $LN123+475
	DD	imagerel $unwind$??1ImFontAtlas@@QEAA@XZ
$pdata$??0ImFontAtlas@@QEAA@XZ DD imagerel $LN32
	DD	imagerel $LN32+124
	DD	imagerel $unwind$??0ImFontAtlas@@QEAA@XZ
$pdata$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD imagerel $LN141
	DD	imagerel $LN141+62
	DD	imagerel $unwind$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$pdata$0$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD imagerel $LN141+62
	DD	imagerel $LN141+165
	DD	imagerel $chain$0$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$pdata$6$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD imagerel $LN141+165
	DD	imagerel $LN141+810
	DD	imagerel $chain$6$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$pdata$7$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD imagerel $LN141+810
	DD	imagerel $LN141+932
	DD	imagerel $chain$7$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$pdata$8$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD imagerel $LN141+932
	DD	imagerel $LN141+1027
	DD	imagerel $chain$8$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$pdata$9$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD imagerel $LN141+1027
	DD	imagerel $LN141+1059
	DD	imagerel $chain$9$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$pdata$?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z DD imagerel $LN120
	DD	imagerel $LN120+1336
	DD	imagerel $unwind$?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z
$pdata$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z DD imagerel $LN83
	DD	imagerel $LN83+127
	DD	imagerel $unwind$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Create@ImBitVector@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@ImBitVector@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TestBit@ImBitVector@@QEBA_NH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetBit@ImBitVector@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
xdata	SEGMENT
$unwind$?stb_decompress@@YAIPEAEPEBEI@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
$unwind$?stb_adler32@@YAIIPEAEI@Z DD 030601H
	DD	033406H
	DD	06006H
$chain$0$?stb_adler32@@YAIIPEAEI@Z DD 020521H
	DD	027405H
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+51
	DD	imagerel $unwind$?stb_adler32@@YAIIPEAEI@Z
$chain$1$?stb_adler32@@YAIIPEAEI@Z DD 021H
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z
	DD	imagerel ?stb_adler32@@YAIIPEAEI@Z+51
	DD	imagerel $unwind$?stb_adler32@@YAIIPEAEI@Z
$unwind$?stb_decompress_token@@YAPEBEPEBE@Z DD 020601H
	DD	030023206H
$unwind$?stb__lit@@YAXPEBEI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?stb__match@@YAXPEBEI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z DD 0155601H
	DD	04d856H
	DD	05c844H
	DD	06b83bH
	DD	07a832H
	DD	08982aH
	DD	098822H
	DD	0a781aH
	DD	0b6813H
	DD	01c340fH
	DD	018010fH
	DD	07008H
$unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 0d4301H
	DD	09b843H
	DD	0aa837H
	DD	0d782fH
	DD	0200115H
	DD	0c00cf00eH
	DD	05009700aH
	DD	03008H
$chain$4$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 0a4821H
	DD	08c848H
	DD	0b9836H
	DD	0c8822H
	DD	0e6813H
	DD	0266408H
	DD	imagerel $LN91
	DD	imagerel $LN91+154
	DD	imagerel $unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$chain$6$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 041021H
	DD	01ee410H
	DD	01fd408H
	DD	imagerel $LN91+154
	DD	imagerel $LN91+456
	DD	imagerel $chain$4$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$chain$9$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 061621H
	DD	06e816H
	DD	07d810H
	DD	05f806H
	DD	imagerel $LN91+456
	DD	imagerel $LN91+555
	DD	imagerel $chain$6$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$chain$10$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 021H
	DD	imagerel $LN91+456
	DD	imagerel $LN91+555
	DD	imagerel $chain$6$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$chain$11$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 021H
	DD	imagerel $LN91+154
	DD	imagerel $LN91+456
	DD	imagerel $chain$4$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$chain$12$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z DD 021H
	DD	imagerel $LN91
	DD	imagerel $LN91+154
	DD	imagerel $unwind$?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z
$unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD 0a1801H
	DD	0b6418H
	DD	0a5418H
	DD	093418H
	DD	0f0143218H
	DD	07010e012H
$chain$0$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD 020521H
	DD	08c405H
	DD	imagerel $LN44
	DD	imagerel $LN44+68
	DD	imagerel $unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$chain$1$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+68
	DD	imagerel $unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$chain$2$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD 020021H
	DD	08c400H
	DD	imagerel $LN44
	DD	imagerel $LN44+68
	DD	imagerel $unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$chain$3$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+68
	DD	imagerel $unwind$?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z
$unwind$?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z DD 0c2201H
	DD	028822H
	DD	03781cH
	DD	046814H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
$unwind$?GrowIndex@ImFont@@QEAAXH@Z DD 040801H
	DD	070043208H
	DD	030026003H
$chain$0$?GrowIndex@ImFont@@QEAAXH@Z DD 020521H
	DD	085405H
	DD	imagerel $LN36
	DD	imagerel $LN36+69
	DD	imagerel $unwind$?GrowIndex@ImFont@@QEAAXH@Z
$chain$1$?GrowIndex@ImFont@@QEAAXH@Z DD 020521H
	DD	0ae405H
	DD	imagerel $LN36+69
	DD	imagerel $LN36+74
	DD	imagerel $chain$0$?GrowIndex@ImFont@@QEAAXH@Z
$chain$2$?GrowIndex@ImFont@@QEAAXH@Z DD 021H
	DD	imagerel $LN36+69
	DD	imagerel $LN36+74
	DD	imagerel $chain$0$?GrowIndex@ImFont@@QEAAXH@Z
$chain$3$?GrowIndex@ImFont@@QEAAXH@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+69
	DD	imagerel $unwind$?GrowIndex@ImFont@@QEAAXH@Z
$unwind$?BuildLookupTable@ImFont@@QEAAXXZ DD 051a19H
	DD	07007c20bH
	DD	050056006H
	DD	03004H
	DD	imagerel __GSHandlerCheck
	DD	030H
$chain$1$?BuildLookupTable@ImFont@@QEAAXXZ DD 040b21H
	DD	014d40bH
	DD	013c404H
	DD	imagerel $LN194
	DD	imagerel $LN194+31
	DD	imagerel $unwind$?BuildLookupTable@ImFont@@QEAAXXZ
$chain$4$?BuildLookupTable@ImFont@@QEAAXXZ DD 06e521H
	DD	0568e5H
	DD	0cf40eH
	DD	015e404H
	DD	imagerel $LN194+31
	DD	imagerel $LN194+44
	DD	imagerel $chain$1$?BuildLookupTable@ImFont@@QEAAXXZ
$chain$5$?BuildLookupTable@ImFont@@QEAAXXZ DD 020021H
	DD	056800H
	DD	imagerel $LN194+31
	DD	imagerel $LN194+44
	DD	imagerel $chain$1$?BuildLookupTable@ImFont@@QEAAXXZ
$chain$7$?BuildLookupTable@ImFont@@QEAAXXZ DD 020521H
	DD	047805H
	DD	imagerel $LN194+1651
	DD	imagerel $LN194+1678
	DD	imagerel $chain$6$?BuildLookupTable@ImFont@@QEAAXXZ
$chain$6$?BuildLookupTable@ImFont@@QEAAXXZ DD 020021H
	DD	056800H
	DD	imagerel $LN194
	DD	imagerel $LN194+31
	DD	imagerel $unwind$?BuildLookupTable@ImFont@@QEAAXXZ
$unwind$?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
$unwind$?ClearOutputData@ImFont@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 040a01H
	DD	013010aH
	DD	030026003H
$chain$1$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 043621H
	DD	0177436H
	DD	019e408H
	DD	imagerel $LN51
	DD	imagerel $LN51+18
	DD	imagerel $unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$chain$7$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 0c3621H
	DD	068836H
	DD	077830H
	DD	08682bH
	DD	012f420H
	DD	018c412H
	DD	0165408H
	DD	imagerel $LN51+18
	DD	imagerel $LN51+101
	DD	imagerel $chain$1$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$chain$8$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 021H
	DD	imagerel $LN51+18
	DD	imagerel $LN51+101
	DD	imagerel $chain$1$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$chain$9$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z DD 020021H
	DD	0177400H
	DD	imagerel $LN51
	DD	imagerel $LN51+18
	DD	imagerel $unwind$?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z
$unwind$?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z DD 020601H
	DD	030023206H
$unwind$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD 020901H
	DD	0f005b209H
$chain$7$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD 0105e21H
	DD	08e45eH
	DD	03681cH
	DD	09d418H
	DD	0ac414H
	DD	0b7410H
	DD	010640cH
	DD	0f5408H
	DD	0e3404H
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+27
	DD	imagerel $unwind$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
$chain$8$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z DD 021H
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
	DD	imagerel ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z+27
	DD	imagerel $unwind$?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z
$unwind$?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
$unwind$?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DD 0a1911H
	DD	0103419H
	DD	0f0155219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
$cppxdata$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
	DD	imagerel $ip2state$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z
$stateUnwindMap$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
	DB	040H
	DB	03eH
	DD	imagerel __imp___std_terminate
$ip2state$?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z DB 00H
$cppxdata$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
	DD	imagerel $ip2state$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
$stateUnwindMap$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DB 01aH
	DB	0aH
	DD	imagerel ??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
	DB	0a1H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
	DB	021H
	DB	03H
	DB	070H
	DB	080H
	DB	080H
	DB	090H
	DB	05aH
	DD	imagerel ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
	DB	061H
	DB	03H
	DB	03aH
	DD	imagerel ??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
	DB	01H
	DB	04H
	DB	03eH
	DD	imagerel __imp___std_terminate
	DB	09eH
	DD	imagerel __imp___std_terminate
	DB	03dH
	DB	02H
	DD	imagerel __imp___std_terminate
	DB	0dH
	DB	03H
	DD	imagerel __imp___std_terminate
	DB	07dH
	DB	03H
	DD	imagerel __imp___std_terminate
$unwind$?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z DD 081c01H
	DD	02681cH
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
$unwind$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DD 01d6619H
	DD	02ad855H
	DD	02bc84dH
	DD	02cb845H
	DD	02da83dH
	DD	02e9838H
	DD	02f8833H
	DD	030782eH
	DD	031682aH
	DD	06d7426H
	DD	06c6426H
	DD	06b3426H
	DD	0640126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z
	DD	0292H
$ip2state$?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z DB 010H
	DB	0e9H, 02H
	DB	00H
	DB	0b6H
	DB	02H
	DB	08dH, 0eH
	DB	04H
	DB	0edH, 0fH
	DB	0eH
	DB	'5', 0dH
	DB	010H
	DB	'U*'
	DB	012H
	DB	')', 02H
	DB	010H
	DB	081H, 02H
	DB	00H
$unwind$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD 050c01H
	DD	0e008420cH
	DD	0c004d006H
	DD	07002H
$chain$3$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD 081421H
	DD	04f414H
	DD	0c640fH
	DD	0b540aH
	DD	0a3405H
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+38
	DD	imagerel $unwind$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
$chain$4$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z DD 021H
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
	DD	imagerel ?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z+38
	DD	imagerel $unwind$?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z
$unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD 010201H
	DD	03002H
$chain$0$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD 020521H
	DD	027405H
	DD	imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
$chain$1$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z
$unwind$?Build@ImFontAtlas@@QEAA_NXZ DD 052019H
	DD	02f3412H
	DD	02c0112H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
$unwind$?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD 0a1901H
	DD	036819H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
$unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 092b19H
	DD	017681dH
	DD	0320118H
	DD	0c008f00aH
	DD	060057006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$chain$1$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 041521H
	DD	030e415H
	DD	03a3404H
	DD	imagerel $LN54
	DD	imagerel $LN54+75
	DD	imagerel $unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$chain$2$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 020821H
	DD	031d408H
	DD	imagerel $LN54+75
	DD	imagerel $LN54+233
	DD	imagerel $chain$1$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$chain$3$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 021H
	DD	imagerel $LN54+75
	DD	imagerel $LN54+233
	DD	imagerel $chain$1$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$chain$4$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 020021H
	DD	030e400H
	DD	imagerel $LN54
	DD	imagerel $LN54+75
	DD	imagerel $unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$chain$5$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z DD 021H
	DD	imagerel $LN54
	DD	imagerel $LN54+75
	DD	imagerel $unwind$?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z
$unwind$?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z DD 0a2b19H
	DD	015681dH
	DD	02d0115H
	DD	0e007f009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z DD 092a19H
	DD	017681cH
	DD	0373414H
	DD	0300114H
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 052019H
	DD	02f3412H
	DD	02c0112H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$?Decode85@@YAXPEBEPEAE@Z DD 020501H
	DD	013405H
$unwind$?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z DD 0a1801H
	DD	0b6418H
	DD	0a5418H
	DD	093418H
	DD	0f0143218H
	DD	07010e012H
$unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 052019H
	DD	0300112H
	DD	030056006H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$chain$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 020421H
	DD	02ee404H
	DD	imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$chain$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 020421H
	DD	02df404H
	DD	imagerel $LN53+40
	DD	imagerel $LN53+47
	DD	imagerel $chain$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$chain$2$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 020421H
	DD	02f7404H
	DD	imagerel $LN53+47
	DD	imagerel $LN53+68
	DD	imagerel $chain$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$chain$3$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 021H
	DD	imagerel $LN53+47
	DD	imagerel $LN53+68
	DD	imagerel $chain$1$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$chain$4$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 021H
	DD	imagerel $LN53+40
	DD	imagerel $LN53+47
	DD	imagerel $chain$0$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$chain$5$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+40
	DD	imagerel $unwind$?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z
$unwind$?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z DD 072519H
	DD	0317417H
	DD	0303417H
	DD	02c0117H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$?Clear@ImFontAtlas@@QEAAXXZ DD 081511H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?Clear@ImFontAtlas@@QEAAXXZ
$cppxdata$?Clear@ImFontAtlas@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?Clear@ImFontAtlas@@QEAAXXZ
	DD	imagerel $ip2state$?Clear@ImFontAtlas@@QEAAXXZ
$stateUnwindMap$?Clear@ImFontAtlas@@QEAAXXZ DB 04H
	DB	0eH
	DD	imagerel __imp___std_terminate
	DB	02eH
	DD	imagerel __imp___std_terminate
$ip2state$?Clear@ImFontAtlas@@QEAAXXZ DB 06H
	DB	'0'
	DB	00H
	DB	098H
	DB	02H
	DB	012H
	DB	04H
$cppxdata$?ClearFonts@ImFontAtlas@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?ClearFonts@ImFontAtlas@@QEAAXXZ
	DD	imagerel $ip2state$?ClearFonts@ImFontAtlas@@QEAAXXZ
$unwind$?ClearFonts@ImFontAtlas@@QEAAXXZ DD 081511H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?ClearFonts@ImFontAtlas@@QEAAXXZ
$stateUnwindMap$?ClearFonts@ImFontAtlas@@QEAAXXZ DB 04H
	DB	0eH
	DD	imagerel __imp___std_terminate
	DB	02eH
	DD	imagerel __imp___std_terminate
$ip2state$?ClearFonts@ImFontAtlas@@QEAAXXZ DB 02H
	DB	0c8H
	DB	02H
$cppxdata$??1ImFont@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1ImFont@@QEAA@XZ
	DD	imagerel $ip2state$??1ImFont@@QEAA@XZ
$cppxdata$??1ImFontAtlas@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1ImFontAtlas@@QEAA@XZ
	DD	imagerel $ip2state$??1ImFontAtlas@@QEAA@XZ
$unwind$?ClearTexData@ImFontAtlas@@QEAAXXZ DD 020601H
	DD	030023206H
$unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 040a01H
	DD	09340aH
	DD	05006320aH
$chain$1$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 042b21H
	DD	06642bH
	DD	077405H
	DD	imagerel $LN95
	DD	imagerel $LN95+17
	DD	imagerel $unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ
$chain$2$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 020521H
	DD	08e405H
	DD	imagerel $LN95+17
	DD	imagerel $LN95+70
	DD	imagerel $chain$1$?ClearInputData@ImFontAtlas@@QEAAXXZ
$chain$3$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 021H
	DD	imagerel $LN95+17
	DD	imagerel $LN95+70
	DD	imagerel $chain$1$?ClearInputData@ImFontAtlas@@QEAAXXZ
$chain$4$?ClearInputData@ImFontAtlas@@QEAAXXZ DD 021H
	DD	imagerel $LN95
	DD	imagerel $LN95+17
	DD	imagerel $unwind$?ClearInputData@ImFontAtlas@@QEAAXXZ
$unwind$?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 030f01H
	DD	0f00be20fH
	DD	0c009H
$chain$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 020421H
	DD	0e3404H
	DD	imagerel $LN104
	DD	imagerel $LN104+31
	DD	imagerel $unwind$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
$chain$5$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 0a1421H
	DD	09e414H
	DD	0ad410H
	DD	0b740cH
	DD	0c6408H
	DD	0d5404H
	DD	imagerel $LN104+31
	DD	imagerel $LN104+38
	DD	imagerel $chain$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
$chain$6$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 021H
	DD	imagerel $LN104+31
	DD	imagerel $LN104+38
	DD	imagerel $chain$0$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
$chain$7$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z DD 021H
	DD	imagerel $LN104
	DD	imagerel $LN104+31
	DD	imagerel $unwind$?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z
$unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD 081301H
	DD	0c5413H
	DD	0b3413H
	DD	0f00f5213H
	DD	0700be00dH
$chain$0$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD 020521H
	DD	0a6405H
	DD	imagerel $LN7
	DD	imagerel $LN7+46
	DD	imagerel $unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
$chain$1$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+46
	DD	imagerel $unwind$?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z
$unwind$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD 060e01H
	DD	0a540eH
	DD	0e00a320eH
	DD	06006c008H
$chain$1$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD 040a21H
	DD	09740aH
	DD	083405H
	DD	imagerel $LN43
	DD	imagerel $LN43+47
	DD	imagerel $unwind$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
$chain$2$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+47
	DD	imagerel $unwind$?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z
$unwind$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z DD 060e01H
	DD	0c540eH
	DD	0e00a520eH
	DD	06006c008H
$chain$1$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z DD 040a21H
	DD	0b740aH
	DD	0a3405H
	DD	imagerel $LN43
	DD	imagerel $LN43+47
	DD	imagerel $unwind$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z
$chain$2$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+47
	DD	imagerel $unwind$?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z
$unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 0e3e01H
	DD	04883eH
	DD	05782aH
	DD	066822H
	DD	0146413H
	DD	0123413H
	DD	0f00fd213H
	DD	0700be00dH
$chain$0$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 020621H
	DD	039806H
	DD	imagerel $LN129
	DD	imagerel $LN129+228
	DD	imagerel $unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$chain$1$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 021H
	DD	imagerel $LN129
	DD	imagerel $LN129+228
	DD	imagerel $unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$chain$2$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 020021H
	DD	039800H
	DD	imagerel $LN129
	DD	imagerel $LN129+228
	DD	imagerel $unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$chain$3$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z DD 021H
	DD	imagerel $LN129
	DD	imagerel $LN129+228
	DD	imagerel $unwind$?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z
$unwind$?FixRectCornerFlags@@YAHH@Z DD 020601H
	DD	030023206H
$unwind$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 082401H
	DD	049824H
	DD	067818H
	DD	0f005f20cH
	DD	030026003H
$chain$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 041321H
	DD	016e413H
	DD	0145408H
	DD	imagerel $LN30
	DD	imagerel $LN30+121
	DD	imagerel $unwind$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$5$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 082821H
	DD	03a828H
	DD	058818H
	DD	076812H
	DD	0157408H
	DD	imagerel $LN30+121
	DD	imagerel $LN30+170
	DD	imagerel $chain$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$6$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 021H
	DD	imagerel $LN30+121
	DD	imagerel $LN30+170
	DD	imagerel $chain$1$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$7$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+121
	DD	imagerel $unwind$?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$unwind$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 081c01H
	DD	02681cH
	DD	0e008520cH
	DD	07004d006H
	DD	030025003H
$chain$0$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN54
	DD	imagerel $LN54+139
	DD	imagerel $unwind$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
$chain$2$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 040a21H
	DD	0ff40aH
	DD	0dc405H
	DD	imagerel $LN54+139
	DD	imagerel $LN54+147
	DD	imagerel $chain$0$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
$chain$3$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 021H
	DD	imagerel $LN54+139
	DD	imagerel $LN54+147
	DD	imagerel $chain$0$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
$chain$4$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z DD 021H
	DD	imagerel $LN54
	DD	imagerel $LN54+139
	DD	imagerel $unwind$?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z
$unwind$?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z DD 0a5801H
	DD	09858H
	DD	01884aH
	DD	02783eH
	DD	03682aH
	DD	030027206H
$unwind$?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z DD 043501H
	DD	06835H
	DD	030021206H
$unwind$?PrimReserve@ImDrawList@@QEAAXHH@Z DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
$unwind$?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?_OnChangedTextureID@ImDrawList@@QEAAXXZ DD 040a01H
	DD	07340aH
	DD	07006320aH
$chain$0$?_OnChangedTextureID@ImDrawList@@QEAAXXZ DD 020521H
	DD	066405H
	DD	imagerel $LN10
	DD	imagerel $LN10+67
	DD	imagerel $unwind$?_OnChangedTextureID@ImDrawList@@QEAAXXZ
$chain$2$?_OnChangedTextureID@ImDrawList@@QEAAXXZ DD 020021H
	DD	066400H
	DD	imagerel $LN10
	DD	imagerel $LN10+67
	DD	imagerel $unwind$?_OnChangedTextureID@ImDrawList@@QEAAXXZ
$unwind$?_OnChangedClipRect@ImDrawList@@QEAAXXZ DD 085f01H
	DD	06645fH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
$unwind$stbtt_PackFontRangesRenderIntoRects DD 011fb01H
	DD	0cb8fbH
	DD	0ad83cH
	DD	0bc830H
	DD	0e9822H
	DD	0f881aH
	DD	0260115H
	DD	0c00cf00eH
	DD	06009700aH
	DD	05008H
$chain$1$stbtt_PackFontRangesRenderIntoRects DD 020921H
	DD	0da809H
	DD	imagerel stbtt_PackFontRangesRenderIntoRects
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+330
	DD	imagerel $unwind$stbtt_PackFontRangesRenderIntoRects
$chain$6$stbtt_PackFontRangesRenderIntoRects DD 0a3921H
	DD	0107839H
	DD	0116831H
	DD	025d426H
	DD	024e41aH
	DD	02d3408H
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+330
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+399
	DD	imagerel $chain$1$stbtt_PackFontRangesRenderIntoRects
$chain$7$stbtt_PackFontRangesRenderIntoRects DD 021H
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+330
	DD	imagerel stbtt_PackFontRangesRenderIntoRects+399
	DD	imagerel $chain$1$stbtt_PackFontRangesRenderIntoRects
$unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD 061e19H
	DD	0f00b920fH
	DD	0c007e009H
	DD	060047005H
	DD	imagerel __GSHandlerCheck
	DD	038H
$chain$2$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD 061521H
	DD	08d415H
	DD	09540aH
	DD	0113404H
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+76
	DD	imagerel $unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
$chain$3$?stbtt__v_prefilter@@YAXPEAEHHHI@Z DD 021H
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__v_prefilter@@YAXPEAEHHHI@Z+76
	DD	imagerel $unwind$?stbtt__v_prefilter@@YAXPEAEHHHI@Z
$unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD 051d19H
	DD	0f00a820eH
	DD	0c006e008H
	DD	05004H
	DD	imagerel __GSHandlerCheck
	DD	038H
$chain$3$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD 081621H
	DD	08d416H
	DD	011740fH
	DD	010640bH
	DD	0f3404H
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+71
	DD	imagerel $unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
$chain$4$?stbtt__h_prefilter@@YAXPEAEHHHI@Z DD 021H
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z
	DD	imagerel ?stbtt__h_prefilter@@YAXPEAEHHHI@Z+71
	DD	imagerel $unwind$?stbtt__h_prefilter@@YAXPEAEHHHI@Z
$unwind$stbtt_PackEnd DD 020601H
	DD	030023206H
$unwind$stbtt_PackBegin DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
$unwind$stbtt_MakeGlyphBitmapSubpixel DD 030b01H
	DD	024010bH
	DD	07004H
$chain$2$stbtt_MakeGlyphBitmapSubpixel DD 060f21H
	DD	022640fH
	DD	023540bH
	DD	0273404H
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+11
	DD	imagerel $unwind$stbtt_MakeGlyphBitmapSubpixel
$chain$10$stbtt_MakeGlyphBitmapSubpixel DD 0103121H
	DD	0b9831H
	DD	0c882cH
	DD	0d7827H
	DD	0e6820H
	DD	01ef41aH
	DD	01fe413H
	DD	020d40bH
	DD	021c404H
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+11
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+33
	DD	imagerel $chain$2$stbtt_MakeGlyphBitmapSubpixel
$chain$11$stbtt_MakeGlyphBitmapSubpixel DD 0c0021H
	DD	0b9800H
	DD	0c8800H
	DD	0d7800H
	DD	0e6800H
	DD	01ef400H
	DD	01fe400H
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+11
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+33
	DD	imagerel $chain$2$stbtt_MakeGlyphBitmapSubpixel
$chain$12$stbtt_MakeGlyphBitmapSubpixel DD 021H
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel
	DD	imagerel stbtt_MakeGlyphBitmapSubpixel+11
	DD	imagerel $unwind$stbtt_MakeGlyphBitmapSubpixel
$unwind$stbtt_Rasterize DD 082a01H
	DD	06782aH
	DD	076816H
	DD	012640fH
	DD	07008f20fH
$unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 0d2501H
	DD	06a825H
	DD	020341cH
	DD	016011cH
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
$chain$3$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 081f21H
	DD	07981fH
	DD	088819H
	DD	097810H
	DD	0a6808H
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+188
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
$chain$4$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 021H
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+188
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
$chain$5$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z DD 080021H
	DD	079800H
	DD	088800H
	DD	097800H
	DD	0a6800H
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
	DD	imagerel ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z+188
	DD	imagerel $unwind$?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z
$unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD 019a101H
	DD	06f8a1H
	DD	07e87aH
	DD	09c86fH
	DD	0ab866H
	DD	0ba861H
	DD	0c985cH
	DD	0d8854H
	DD	0e7840H
	DD	0f6839H
	DD	023641dH
	DD	022341dH
	DD	020011dH
	DD	07016H
$chain$0$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD 020921H
	DD	08d809H
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+421
	DD	imagerel $unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
$chain$1$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z DD 021H
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z+421
	DD	imagerel $unwind$?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z
$unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD 0157f01H
	DD	05d87fH
	DD	06c866H
	DD	07b857H
	DD	08a852H
	DD	099849H
	DD	0b7834H
	DD	0c6821H
	DD	01d6413H
	DD	01c3413H
	DD	01a0113H
	DD	0700cH
$chain$0$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD 020521H
	DD	0a8805H
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+220
	DD	imagerel $unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
$chain$1$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z DD 021H
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
	DD	imagerel ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z+220
	DD	imagerel $unwind$?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z
$unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 082119H
	DD	076812H
	DD	013010dH
	DD	07004e006H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	068H
$chain$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 041021H
	DD	012c410H
	DD	0196408H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+292
	DD	imagerel $unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$chain$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 020821H
	DD	010f408H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+292
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+311
	DD	imagerel $chain$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$chain$3$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 020821H
	DD	011d408H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+311
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+370
	DD	imagerel $chain$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$chain$4$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+311
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+370
	DD	imagerel $chain$2$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$chain$5$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+292
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+311
	DD	imagerel $chain$1$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$chain$6$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z+292
	DD	imagerel $unwind$?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z
$unwind$?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z DD 041919H
	DD	0c340aH
	DD	07006720aH
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD 030f01H
	DD	0600b420fH
	DD	0500aH
$chain$3$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD 081921H
	DD	04f419H
	DD	0ae414H
	DD	09740cH
	DD	083405H
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+15
	DD	imagerel $unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
$chain$4$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z DD 021H
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z+15
	DD	imagerel $unwind$?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z
$unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD 011c19H
	DD	0420dH
	DD	imagerel __GSHandlerCheck
	DD	018H
$chain$0$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD 020521H
	DD	043405H
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+31
	DD	imagerel $unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
$chain$1$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z DD 021H
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
	DD	imagerel ?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z+31
	DD	imagerel $unwind$?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z
$unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 021c19H
	DD	067010aH
	DD	imagerel __GSHandlerCheck
	DD	0270H
$chain$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 020421H
	DD	06b3404H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+30
	DD	imagerel $unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$chain$8$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 0103421H
	DD	02c9834H
	DD	060f42cH
	DD	061e425H
	DD	062d41eH
	DD	063c417H
	DD	0647411H
	DD	065640aH
	DD	0665404H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+30
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+34
	DD	imagerel $chain$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$chain$15$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 0e5b21H
	DD	028d85bH
	DD	029c849H
	DD	02ab837H
	DD	02ba825H
	DD	02d881cH
	DD	02e7810H
	DD	02f6808H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+34
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+230
	DD	imagerel $chain$8$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$chain$16$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+34
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+230
	DD	imagerel $chain$8$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$chain$17$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 020021H
	DD	060f400H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+30
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+34
	DD	imagerel $chain$0$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$chain$18$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z DD 021H
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
	DD	imagerel ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z+30
	DD	imagerel $unwind$?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z
$unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD 0b1f01H
	DD	08b81fH
	DD	0d6817H
	DD	0226413H
	DD	01c0113H
	DD	0e00af00cH
	DD	07008H
$chain$9$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD 0143621H
	DD	05e836H
	DD	04f830H
	DD	06d82aH
	DD	07c824H
	DD	09a81eH
	DD	0a9819H
	DD	0b8814H
	DD	0c780fH
	DD	021540bH
	DD	0203404H
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+80
	DD	imagerel $unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
$chain$10$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z DD 021H
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
	DD	imagerel ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z+80
	DD	imagerel $unwind$?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z
$unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 0c3601H
	DD	02b836H
	DD	05882cH
	DD	076817H
	DD	0136412H
	DD	0123412H
	DD	0700bf212H
$chain$2$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 061a21H
	DD	03a81aH
	DD	049814H
	DD	067805H
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+181
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
$chain$3$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z DD 021H
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
	DD	imagerel ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z+181
	DD	imagerel $unwind$?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z
$unwind$?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z DD 081b01H
	DD	02681bH
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
$unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD 010401H
	DD	04204H
$chain$0$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD 020521H
	DD	043405H
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+12
	DD	imagerel $unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
$chain$1$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z DD 021H
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
	DD	imagerel ?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z+12
	DD	imagerel $unwind$?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z
$unwind$?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z DD 020601H
	DD	030023206H
$unwind$stbtt_GetGlyphBitmapBox DD 010401H
	DD	0a204H
$unwind$stbtt_GetGlyphBitmapBoxSubpixel DD 092201H
	DD	068822H
	DD	07781aH
	DD	014340fH
	DD	012010fH
	DD	07008H
$chain$0$stbtt_GetGlyphBitmapBoxSubpixel DD 020821H
	DD	086808H
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+259
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBoxSubpixel
$chain$1$stbtt_GetGlyphBitmapBoxSubpixel DD 021H
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel
	DD	imagerel stbtt_GetGlyphBitmapBoxSubpixel+259
	DD	imagerel $unwind$stbtt_GetGlyphBitmapBoxSubpixel
$unwind$stbtt_GetFontVMetrics DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
$unwind$stbtt_GetGlyphHMetrics DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0e016f018H
$unwind$stbtt_GetGlyphShape DD 071201H
	DD	0166412H
	DD	0155412H
	DD	0120112H
	DD	0700bH
$chain$0$stbtt_GetGlyphShape DD 020821H
	DD	0143408H
	DD	imagerel stbtt_GetGlyphShape
	DD	imagerel stbtt_GetGlyphShape+45
	DD	imagerel $unwind$stbtt_GetGlyphShape
$chain$1$stbtt_GetGlyphShape DD 021H
	DD	imagerel stbtt_GetGlyphShape
	DD	imagerel stbtt_GetGlyphShape+45
	DD	imagerel $unwind$stbtt_GetGlyphShape
$unwind$?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z DD 061001H
	DD	0f6410H
	DD	0e3410H
	DD	0700cb210H
$unwind$?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD 091701H
	DD	0166417H
	DD	0155417H
	DD	0143417H
	DD	0120117H
	DD	07010H
$unwind$?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z DD 01fab19H
	DD	02988abH
	DD	022f85fH
	DD	023e857H
	DD	024d84fH
	DD	025c847H
	DD	026b83fH
	DD	027a837H
	DD	028982fH
	DD	02a782aH
	DD	02b6825H
	DD	0633420H
	DD	0580120H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __GSHandlerCheck
	DD	0210H
$unwind$?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z DD 0a1801H
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0f0149218H
	DD	07010e012H
$unwind$?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
$unwind$?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z DD 030c01H
	DD	04680cH
	DD	0a204H
$unwind$?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z DD 010401H
	DD	04204H
$unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD 010201H
	DD	06002H
$chain$1$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD 040a21H
	DD	03740aH
	DD	023405H
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+24
	DD	imagerel $unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
$chain$2$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z DD 021H
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
	DD	imagerel ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z+24
	DD	imagerel $unwind$?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z
$unwind$?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z DD 01d6701H
	DD	09e867H
	DD	0ad85fH
	DD	0bc857H
	DD	0cb84fH
	DD	0da847H
	DD	0e983fH
	DD	0f8837H
	DD	010782fH
	DD	0116828H
	DD	02d341dH
	DD	024011dH
	DD	0e014f016H
	DD	0c010d012H
	DD	0600d700eH
	DD	0500cH
$unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD 010401H
	DD	0204H
$chain$0$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD 020421H
	DD	03404H
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+24
	DD	imagerel $unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
$chain$1$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z DD 021H
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
	DD	imagerel ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z+24
	DD	imagerel $unwind$?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z
$unwind$stbtt_GetGlyphBox DD 081501H
	DD	0107415H
	DD	0f6415H
	DD	0e3415H
	DD	0e011b215H
$unwind$?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$stbtt_FindGlyphIndex DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0e0123216H
	DD	0c00ed010H
	DD	0600b700cH
$chain$0$stbtt_FindGlyphIndex DD 020521H
	DD	0af405H
	DD	imagerel stbtt_FindGlyphIndex
	DD	imagerel stbtt_FindGlyphIndex+359
	DD	imagerel $unwind$stbtt_FindGlyphIndex
$chain$1$stbtt_FindGlyphIndex DD 021H
	DD	imagerel stbtt_FindGlyphIndex
	DD	imagerel stbtt_FindGlyphIndex+359
	DD	imagerel $unwind$stbtt_FindGlyphIndex
$unwind$?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z DD 091801H
	DD	0f011e218H
	DD	0d00de00fH
	DD	07009c00bH
	DD	030076008H
	DD	05006H
$unwind$?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z DD 081201H
	DD	0e5412H
	DD	0d3412H
	DD	0e00e7212H
	DD	0600b700cH
$unwind$?stbtt__find_table@@YAIPEAEIPEBD@Z DD 040a01H
	DD	02740aH
	DD	013405H
$unwind$?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
$unwind$?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z DD 020601H
	DD	030023206H
$unwind$?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
$unwind$?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z DD 0a4801H
	DD	0a3448H
	DD	0c6413H
	DD	0b5413H
	DD	0f00f5213H
	DD	0700be00dH
$unwind$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD 020601H
	DD	070023206H
$chain$0$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD 020521H
	DD	063405H
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+54
	DD	imagerel $unwind$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
$chain$2$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD 020021H
	DD	063400H
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+54
	DD	imagerel $unwind$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
$chain$3$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z DD 021H
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
	DD	imagerel ?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z+54
	DD	imagerel $unwind$?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z
$unwind$?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z DD 010401H
	DD	04204H
$unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 060d01H
	DD	0c340dH
	DD	0e009520dH
	DD	060067007H
$chain$0$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 020521H
	DD	0a5405H
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+27
	DD	imagerel $unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$chain$1$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 020521H
	DD	0bf405H
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+27
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+96
	DD	imagerel $chain$0$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$chain$2$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 021H
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+27
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+96
	DD	imagerel $chain$0$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$chain$3$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z DD 021H
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
	DD	imagerel ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z+27
	DD	imagerel $unwind$?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z
$unwind$?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z DD 010401H
	DD	02204H
$unwind$?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$stbrp_pack_rects DD 061101H
	DD	0f00d9211H
	DD	0c009e00bH
	DD	030066007H
$chain$0$stbrp_pack_rects DD 020521H
	DD	097405H
	DD	imagerel stbrp_pack_rects
	DD	imagerel stbrp_pack_rects+20
	DD	imagerel $unwind$stbrp_pack_rects
$chain$2$stbrp_pack_rects DD 041121H
	DD	08d411H
	DD	0105408H
	DD	imagerel stbrp_pack_rects+20
	DD	imagerel stbrp_pack_rects+110
	DD	imagerel $chain$0$stbrp_pack_rects
$chain$3$stbrp_pack_rects DD 021H
	DD	imagerel stbrp_pack_rects+20
	DD	imagerel stbrp_pack_rects+110
	DD	imagerel $chain$0$stbrp_pack_rects
$chain$4$stbrp_pack_rects DD 021H
	DD	imagerel stbrp_pack_rects
	DD	imagerel stbrp_pack_rects+20
	DD	imagerel $unwind$stbrp_pack_rects
$unwind$?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
$unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 071c01H
	DD	0f018c21cH
	DD	0d014e016H
	DD	050116012H
	DD	03010H
$chain$1$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 040e21H
	DD	0bc40eH
	DD	0c7405H
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+142
	DD	imagerel $unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
$chain$2$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z DD 021H
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
	DD	imagerel ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z+142
	DD	imagerel $unwind$?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z
$unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD 081301H
	DD	0a5413H
	DD	093413H
	DD	0f00f3213H
	DD	0600be00dH
$chain$0$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD 020521H
	DD	087405H
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+160
	DD	imagerel $unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
$chain$1$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z DD 021H
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
	DD	imagerel ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z+160
	DD	imagerel $unwind$?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z
$unwind$stbrp_init_target DD 0a1801H
	DD	0e6418H
	DD	0d5418H
	DD	0c3418H
	DD	0f0147218H
	DD	07010e012H
$chain$0$stbrp_init_target DD 020521H
	DD	036805H
	DD	imagerel stbrp_init_target
	DD	imagerel stbrp_init_target+24
	DD	imagerel $unwind$stbrp_init_target
$chain$1$stbrp_init_target DD 020521H
	DD	027805H
	DD	imagerel stbrp_init_target+24
	DD	imagerel stbrp_init_target+141
	DD	imagerel $chain$0$stbrp_init_target
$chain$2$stbrp_init_target DD 021H
	DD	imagerel stbrp_init_target+24
	DD	imagerel stbrp_init_target+141
	DD	imagerel $chain$0$stbrp_init_target
$chain$3$stbrp_init_target DD 021H
	DD	imagerel stbrp_init_target
	DD	imagerel stbrp_init_target+24
	DD	imagerel $unwind$stbrp_init_target
$unwind$?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z DD 010401H
	DD	04204H
$unwind$?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z DD 041701H
	DD	083417H
	DD	070135217H
$unwind$?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z DD 041301H
	DD	083413H
	DD	0700f5213H
$unwind$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD 060f01H
	DD	0a640fH
	DD	0f00b320fH
	DD	0c007e009H
$chain$1$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD 040a21H
	DD	09740aH
	DD	083405H
	DD	imagerel $LN34
	DD	imagerel $LN34+48
	DD	imagerel $unwind$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z
$chain$2$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+48
	DD	imagerel $unwind$?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z
$unwind$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD 060f01H
	DD	0c640fH
	DD	0f00b520fH
	DD	0c007e009H
$chain$1$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD 040a21H
	DD	0b740aH
	DD	0a3405H
	DD	imagerel $LN34
	DD	imagerel $LN34+48
	DD	imagerel $unwind$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z
$chain$2$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+48
	DD	imagerel $unwind$?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z
$unwind$?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z DD 0175001H
	DD	03b850H
	DD	04a84bH
	DD	059846H
	DD	068841H
	DD	077839H
	DD	086835H
	DD	018641bH
	DD	017541bH
	DD	016341bH
	DD	012011bH
	DD	0e012f014H
	DD	07010H
$unwind$??1ImFont@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImFont@@QEAA@XZ
$stateUnwindMap$??1ImFont@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
$ip2state$??1ImFont@@QEAA@XZ DB 02H
	DB	012H
	DB	00H
$stateUnwindMap$??1ImFontAtlas@@QEAA@XZ DB 04H
	DB	0eH
	DD	imagerel __imp___std_terminate
	DB	02eH
	DD	imagerel __imp___std_terminate
$unwind$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 040a01H
	DD	09540aH
	DD	07006320aH
$chain$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN62
	DD	imagerel $LN62+15
	DD	imagerel $unwind$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
$chain$2$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 040a21H
	DD	08e40aH
	DD	076405H
	DD	imagerel $LN62+15
	DD	imagerel $LN62+33
	DD	imagerel $chain$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
$chain$3$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 021H
	DD	imagerel $LN62+15
	DD	imagerel $LN62+33
	DD	imagerel $chain$0$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
$chain$4$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ DD 021H
	DD	imagerel $LN62
	DD	imagerel $LN62+15
	DD	imagerel $unwind$?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ
$unwind$?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ DD 020601H
	DD	030023206H
$unwind$?_ClearFreeMemory@ImDrawList@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?_ResetForNewFrame@ImDrawList@@QEAAXXZ DD 060f01H
	DD	0f640fH
	DD	0e340fH
	DD	0700bb20fH
$unwind$?AddDrawCmd@ImDrawList@@QEAAXXZ DD 064d01H
	DD	06784dH
	DD	076818H
	DD	03002f209H
$unwind$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD 020601H
	DD	070025206H
$chain$0$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD 020521H
	DD	083405H
	DD	imagerel $LN12
	DD	imagerel $LN12+20
	DD	imagerel $unwind$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z
$chain$1$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+20
	DD	imagerel $unwind$?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z
$unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 0c2b01H
	DD	05a82bH
	DD	06981eH
	DD	087815H
	DD	015010dH
	DD	07004e006H
	DD	030025003H
$chain$1$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 040e21H
	DD	07880eH
	DD	096808H
	DD	imagerel $LN78
	DD	imagerel $LN78+182
	DD	imagerel $unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$2$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 020821H
	DD	01a6408H
	DD	imagerel $LN78+182
	DD	imagerel $LN78+227
	DD	imagerel $chain$1$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$6$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 081e21H
	DD	04b81eH
	DD	014f418H
	DD	01dd410H
	DD	01bc408H
	DD	imagerel $LN78+227
	DD	imagerel $LN78+235
	DD	imagerel $chain$2$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$7$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 060021H
	DD	04b800H
	DD	014f400H
	DD	01dd400H
	DD	imagerel $LN78+227
	DD	imagerel $LN78+235
	DD	imagerel $chain$2$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$8$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 060021H
	DD	04b800H
	DD	014f400H
	DD	01dd400H
	DD	imagerel $LN78+182
	DD	imagerel $LN78+227
	DD	imagerel $chain$1$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$9$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 020021H
	DD	04b800H
	DD	imagerel $LN78+182
	DD	imagerel $LN78+227
	DD	imagerel $chain$1$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$10$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 021H
	DD	imagerel $LN78+182
	DD	imagerel $LN78+227
	DD	imagerel $chain$1$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$11$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 021H
	DD	imagerel $LN78
	DD	imagerel $LN78+182
	DD	imagerel $unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$chain$12$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z DD 040021H
	DD	078800H
	DD	096800H
	DD	imagerel $LN78
	DD	imagerel $LN78+182
	DD	imagerel $unwind$?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z
$unwind$?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z DD 025185019H
	DD	04a842H
	DD	05983dH
	DD	068838H
	DD	077833H
	DD	08682fH
	DD	01a742bH
	DD	0196424H
	DD	018341dH
	DD	01112316H
	DD	0f00a0012H
	DD	0d006e008H
	DD	05002c004H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z DD 0251e6e19H
	DD	07d860H
	DD	08c85bH
	DD	09b856H
	DD	0aa851H
	DD	0b9849H
	DD	0c8841H
	DD	0d7839H
	DD	0e6832H
	DD	026742bH
	DD	0256424H
	DD	024341dH
	DD	01112316H
	DD	0f00a001eH
	DD	0d006e008H
	DD	05002c004H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD 061b01H
	DD	014641bH
	DD	0f017d21bH
	DD	07013e015H
$chain$0$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD 020821H
	DD	0123408H
	DD	imagerel $LN36
	DD	imagerel $LN36+27
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$chain$2$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD 040d21H
	DD	06680dH
	DD	0135408H
	DD	imagerel $LN36+27
	DD	imagerel $LN36+80
	DD	imagerel $chain$0$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$chain$3$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD 021H
	DD	imagerel $LN36+27
	DD	imagerel $LN36+80
	DD	imagerel $chain$0$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$chain$4$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+27
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z
$unwind$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD 081f01H
	DD	06681fH
	DD	0145410H
	DD	0f00cd210H
	DD	06008e00aH
$chain$1$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD 041021H
	DD	0137410H
	DD	0123404H
	DD	imagerel $LN33
	DD	imagerel $LN33+53
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z
$chain$2$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+53
	DD	imagerel $unwind$?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z
$unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD 082101H
	DD	0c6421H
	DD	0b5421H
	DD	0a3421H
	DD	0701d7221H
$chain$0$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD 020521H
	DD	036805H
	DD	imagerel $LN17
	DD	imagerel $LN17+128
	DD	imagerel $unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
$chain$1$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z DD 021H
	DD	imagerel $LN17
	DD	imagerel $LN17+128
	DD	imagerel $unwind$?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z
$unwind$?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z DD 041901H
	DD	0a3419H
	DD	060157219H
$unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 061d01H
	DD	0f641dH
	DD	0e541dH
	DD	0e019921dH
$chain$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 040a21H
	DD	0d740aH
	DD	0c3405H
	DD	imagerel $LN38
	DD	imagerel $LN38+48
	DD	imagerel $unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$chain$2$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 020521H
	DD	046805H
	DD	imagerel $LN38+48
	DD	imagerel $LN38+63
	DD	imagerel $chain$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$chain$3$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 021H
	DD	imagerel $LN38+48
	DD	imagerel $LN38+63
	DD	imagerel $chain$1$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$chain$4$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z DD 020021H
	DD	0d7400H
	DD	imagerel $LN38
	DD	imagerel $LN38+48
	DD	imagerel $unwind$?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z
$unwind$?PopTextureID@ImDrawList@@QEAAXXZ DD 020601H
	DD	030023206H
$unwind$?PushTextureID@ImDrawList@@QEAAXPEAX@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?PopClipRect@ImDrawList@@QEAAXXZ DD 020601H
	DD	030023206H
$unwind$?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z DD 040c01H
	DD	0d340cH
	DD	07008720cH
$unwind$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD 041301H
	DD	036813H
	DD	060027206H
$chain$3$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD 081a21H
	DD	02781aH
	DD	0c7415H
	DD	0b5410H
	DD	0a3405H
	DD	imagerel $LN28
	DD	imagerel $LN28+33
	DD	imagerel $unwind$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
$chain$4$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+33
	DD	imagerel $unwind$?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z
$unwind$??0ImDrawListSharedData@@QEAA@XZ DD 0e2e01H
	DD	02982eH
	DD	038825H
	DD	04781dH
	DD	056814H
	DD	0f640fH
	DD	0e340fH
	DD	0700bb20fH
$unwind$??1ImFontAtlas@@QEAA@XZ DD 081519H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImFontAtlas@@QEAA@XZ
$ip2state$??1ImFontAtlas@@QEAA@XZ DB 06H
	DB	'v'
	DB	00H
	DB	0acH
	DB	02H
	DB	012H
	DB	04H
$cppxdata$??0ImFontAtlas@@QEAA@XZ DB 028H
	DD	imagerel $stateUnwindMap$??0ImFontAtlas@@QEAA@XZ
	DD	imagerel $ip2state$??0ImFontAtlas@@QEAA@XZ
$unwind$??0ImFontAtlas@@QEAA@XZ DD 020611H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImFontAtlas@@QEAA@XZ
$stateUnwindMap$??0ImFontAtlas@@QEAA@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA
$ip2state$??0ImFontAtlas@@QEAA@XZ DB 00H
	ORG $+3
$unwind$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD 072719H
	DD	08c819H
	DD	01e0110H
	DD	030036004H
	DD	05002H
	DD	imagerel __GSHandlerCheck
	DD	078H
$chain$0$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD 020821H
	DD	0247408H
	DD	imagerel $LN141
	DD	imagerel $LN141+62
	DD	imagerel $unwind$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$chain$6$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD 0c3421H
	DD	09b834H
	DD	0aa82bH
	DD	0b9822H
	DD	0c8819H
	DD	0d7810H
	DD	0e6808H
	DD	imagerel $LN141+62
	DD	imagerel $LN141+165
	DD	imagerel $chain$0$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$chain$7$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD 040021H
	DD	09b800H
	DD	0aa800H
	DD	imagerel $LN141+62
	DD	imagerel $LN141+165
	DD	imagerel $chain$0$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$chain$8$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD 021H
	DD	imagerel $LN141+62
	DD	imagerel $LN141+165
	DD	imagerel $chain$0$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$chain$9$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z DD 021H
	DD	imagerel $LN141
	DD	imagerel $LN141+62
	DD	imagerel $unwind$?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z
$unwind$?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z DD 071401H
	DD	038814H
	DD	04780eH
	DD	056809H
	DD	0c204H
$unwind$?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z DD 041301H
	DD	0a3413H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 043021H
	DD	065430H
	DD	076405H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 043021H
	DD	065430H
	DD	076405H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 043021H
	DD	065430H
	DD	076405H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 043421H
	DD	065434H
	DD	076405H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
	DD	imagerel $ip2state$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DD 081411H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 020021H
	DD	076400H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 043421H
	DD	065434H
	DD	076405H
	DD	imagerel $LN31
	DD	imagerel $LN31+26
	DD	imagerel $unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@M@@QEAAXHAEBM@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD 020521H
	DD	065405H
	DD	imagerel $LN28
	DD	imagerel $LN28+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontConfig@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontConfig@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontConfig@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD 020521H
	DD	066405H
	DD	imagerel $LN28
	DD	imagerel $LN28+72
	DD	imagerel $unwind$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ DD 019H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DB 02H
	DB	'r'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DB 04H
	DB	0eH
	DD	imagerel __imp___std_terminate
	DB	02eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DB 028H
	DD	imagerel $stateUnwindMap$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
	DD	imagerel $ip2state$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ DD 081511H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_back@?$ImVector@PEAX@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@PEAX@@QEAAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@PEAX@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImVec4@@@@QEAAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImVec4@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@G@@QEAAXHAEBG@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GImFontBuildSrcData@@QEAAPEAXI@Z DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GImFontBuildSrcData@@QEAAPEAXI@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_GImFontBuildSrcData@@QEAAPEAXI@Z DB 068H
	DD	imagerel $stateUnwindMap$??_GImFontBuildSrcData@@QEAAPEAXI@Z
	DD	imagerel $ip2state$??_GImFontBuildSrcData@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImFontBuildSrcData@@QEAAPEAXI@Z DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_GImFontBuildSrcData@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImFontBuildSrcData@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImFontBuildSrcData@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImFontBuildSrcData@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1ImFontBuildSrcData@@QEAA@XZ
	DD	imagerel $ip2state$??1ImFontBuildSrcData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImFontBuildSrcData@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImFontBuildSrcData@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1ImBitVector@@QEAA@XZ DB 00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1ImBitVector@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1ImBitVector@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1ImBitVector@@QEAA@XZ
	DD	imagerel $ip2state$??1ImBitVector@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImBitVector@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1ImBitVector@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@PEAX@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN21
	DD	imagerel $LN21+28
	DD	imagerel $unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z DD 020a01H
	DD	03006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImFont@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A DD 000000000r ; 0 ; FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA
	DD	040400000r			; 3
	DD	041400000r			; 12
	DD	041980000r			; 19
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	041500000r			; 13
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	041800000r			; 16
	DD	03f800000r			; 1
	DD	041000000r			; 8
	DD	041f80000r			; 31
	DD	000000000r			; 0
	DD	041b80000r			; 23
	DD	041b80000r			; 23
	DD	041300000r			; 11
	DD	041300000r			; 11
	DD	041a80000r			; 21
	DD	000000000r			; 0
	DD	041100000r			; 9
	DD	041b80000r			; 23
	DD	040800000r			; 4
	DD	041300000r			; 11
	DD	0425c0000r			; 55
	DD	041900000r			; 18
	DD	041b80000r			; 23
	DD	041100000r			; 9
	DD	041300000r			; 11
	DD	040800000r			; 4
	DD	042920000r			; 73
	DD	000000000r			; 0
	DD	041880000r			; 17
	DD	041880000r			; 17
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	0425c0000r			; 55
	DD	000000000r			; 0
	DD	041880000r			; 17
	DD	041880000r			; 17
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	042b60000r			; 91
	DD	000000000r			; 0
	DD	041880000r			; 17
	DD	041b00000r			; 22
	DD	040a00000r			; 5
	DD	000000000r			; 0
	DD	042da0000r			; 109
	DD	000000000r			; 0
	DD	041500000r			; 13
	DD	041700000r			; 15
	DD	040c00000r			; 6
	DD	040e00000r			; 7
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
pos$ = 48
draw_list$ = 80
col$ = 96
?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z PROC ; ImGui::RenderBullet

; 3785 : {

$LN83:

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius <= 0.0f)

  00000	41 f7 c0 00 00
	00 ff		 test	 r8d, -16777216		; ff000000H
  00007	74 75		 je	 SHORT $LN81@RenderBull
  00009	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3786 :     draw_list->AddCircleFilled(pos, draw_list->_Data->FontSize * 0.20f, col, 8);

  00013	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00017	0f 57 db	 xorps	 xmm3, xmm3
  0001a	41 8b f8	 mov	 edi, r8d
  0001d	48 89 54 24 30	 mov	 QWORD PTR pos$[rsp], rdx
  00022	48 8b d9	 mov	 rbx, rcx
  00025	f3 0f 10 50 10	 movss	 xmm2, DWORD PTR [rax+16]
  0002a	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@3e4ccccd

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius <= 0.0f)

  00032	0f 2f da	 comiss	 xmm3, xmm2
  00035	73 3d		 jae	 SHORT $LN5@RenderBull

; 1189 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

  00037	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40afede0
  0003f	48 8d 54 24 30	 lea	 rdx, QWORD PTR pos$[rsp]
  00044	c7 44 24 28 07
	00 00 00	 mov	 DWORD PTR [rsp+40], 7
  0004c	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00052	e8 00 00 00 00	 call	 ?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2569 :     inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  00057	44 8b 43 78	 mov	 r8d, DWORD PTR [rbx+120]
  0005b	44 8b cf	 mov	 r9d, edi
  0005e	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 ?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
  0006d	c7 43 78 00 00
	00 00		 mov	 DWORD PTR [rbx+120], 0
$LN5@RenderBull:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3787 : }

  00074	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00079	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007d	5f		 pop	 rdi
$LN81@RenderBull:
  0007e	c3		 ret	 0
?RenderBullet@ImGui@@YAXPEAUImDrawList@@UImVec2@@I@Z ENDP ; ImGui::RenderBullet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
dst$ = 112
?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z PROC	; ImGui::StyleColorsDark

; 191  : {

$LN120:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00004	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  00009	0f 29 7c 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm7
  0000e	44 0f 29 44 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm8

; 192  :     ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();

  00014	48 85 c9	 test	 rcx, rcx
  00017	75 34		 jne	 SHORT $LN4@StyleColor
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 2729 :     IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?");

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00020	48 85 c9	 test	 rcx, rcx
  00023	75 21		 jne	 SHORT $LN8@StyleColor
  00025	41 b8 a9 0a 00
	00		 mov	 r8d, 2729		; 00000aa9H
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KG@OOKDKDDA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1NE@MGLAEJCB@?$AAG?$AAI?$AAm?$AAG?$AAu?$AAi?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
$LN8@StyleColor:

; 2730 :     return GImGui->Style;

  00046	48 81 c1 78 37
	00 00		 add	 rcx, 14200		; 00003778H
$LN4@StyleColor:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0004d	0f 28 15 00 00
	00 00		 movaps	 xmm2, XMMWORD PTR __xmm@3e9eb8523f7ae1483f170a3d3e851eb8
  00054	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
  0005b	44 0f 28 05 00
	00 00 00	 movaps	 xmm8, XMMWORD PTR __xmm@3f8000003ef5c28f3e947ae13e23d70a
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00063	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f4ccccd
  0006b	41 0f 28 e0	 movaps	 xmm4, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0006f	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003f0000003f0000003f000000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00076	41 0f 28 e8	 movaps	 xmm5, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0007a	0f 28 1d 00 00
	00 00		 movaps	 xmm3, XMMWORD PTR __xmm@3f0000003f0000003edc28f63edc28f6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00081	f3 0f 5c ea	 subss	 xmm5, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00085	0f 28 35 00 00
	00 00		 movaps	 xmm6, XMMWORD PTR __xmm@3f4ccccd3f7ae1483f170a3d3e851eb8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 195  :     colors[ImGuiCol_Text] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

  0008c	0f 11 81 c8 00
	00 00		 movups	 XMMWORD PTR [rcx+200], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00093	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f70a3d73d75c28f3d75c28f3d75c28f
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 197  :     colors[ImGuiCol_WindowBg] = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);

  0009a	0f 11 81 e8 00
	00 00		 movups	 XMMWORD PTR [rcx+232], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  000a1	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f70a3d73da3d70a3da3d70a3da3d70a
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 199  :     colors[ImGuiCol_PopupBg] = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);

  000a8	0f 11 81 08 01
	00 00		 movups	 XMMWORD PTR [rcx+264], xmm0
  000af	0f 11 89 d8 00
	00 00		 movups	 XMMWORD PTR [rcx+216], xmm1
  000b6	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  000b9	0f c6 e4 55	 shufps	 xmm4, xmm4, 85		; 00000055H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 201  :     colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

  000bd	0f 11 81 28 01
	00 00		 movups	 XMMWORD PTR [rcx+296], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  000c4	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3ecccccd3f7ae1483f170a3d3e851eb8
  000cb	0f 57 c9	 xorps	 xmm1, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 203  :     colors[ImGuiCol_FrameBgHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

  000ce	0f 11 81 48 01
	00 00		 movups	 XMMWORD PTR [rcx+328], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  000d5	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003d23d70a3d23d70a3d23d70a
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 198  :     colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

  000dc	0f 11 89 f8 00
	00 00		 movups	 XMMWORD PTR [rcx+248], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  000e3	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f0a3d713ef5c28f3e947ae13e23d70a
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 205  :     colors[ImGuiCol_TitleBg] = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);

  000ea	0f 11 81 68 01
	00 00		 movups	 XMMWORD PTR [rcx+360], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  000f1	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f028f5c000000000000000000000000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 202  :     colors[ImGuiCol_FrameBg] = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);

  000f8	0f 11 89 38 01
	00 00		 movups	 XMMWORD PTR [rcx+312], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  000ff	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f2b851f3f7ae1483f170a3d3e851eb8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 207  :     colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);

  00106	0f 11 81 88 01
	00 00		 movups	 XMMWORD PTR [rcx+392], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0010d	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f07ae143ca3d70a3ca3d70a3ca3d70a
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 204  :     colors[ImGuiCol_FrameBgActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

  00114	0f 11 89 58 01
	00 00		 movups	 XMMWORD PTR [rcx+344], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0011b	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003e0f5c293e0f5c293e0f5c29
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 209  :     colors[ImGuiCol_ScrollbarBg] = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);

  00122	0f 11 81 a8 01
	00 00		 movups	 XMMWORD PTR [rcx+424], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00129	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003ed1eb853ed1eb853ed1eb85
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 208  :     colors[ImGuiCol_MenuBarBg] = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);

  00130	0f 11 89 98 01
	00 00		 movups	 XMMWORD PTR [rcx+408], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00137	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003e9eb8523e9eb8523e9eb852
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 211  :     colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);

  0013e	0f 11 81 c8 01
	00 00		 movups	 XMMWORD PTR [rcx+456], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00145	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003f7ae1483f170a3d3e851eb8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 210  :     colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);

  0014c	0f 11 89 b8 01
	00 00		 movups	 XMMWORD PTR [rcx+440], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00153	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003f028f5c3f028f5c3f028f5c
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 213  :     colors[ImGuiCol_CheckMark] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  0015a	0f 11 81 e8 01
	00 00		 movups	 XMMWORD PTR [rcx+488], xmm0

; 215  :     colors[ImGuiCol_SliderGrabActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  00161	0f 11 81 08 02
	00 00		 movups	 XMMWORD PTR [rcx+520], xmm0

; 217  :     colors[ImGuiCol_ButtonHovered] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  00168	0f 11 81 28 02
	00 00		 movups	 XMMWORD PTR [rcx+552], xmm0

; 221  :     colors[ImGuiCol_HeaderActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  0016f	0f 11 81 68 02
	00 00		 movups	 XMMWORD PTR [rcx+616], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00176	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f47ae143f4000003ecccccd3dcccccd
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 212  :     colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);

  0017d	0f 11 89 d8 01
	00 00		 movups	 XMMWORD PTR [rcx+472], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00184	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003f6147ae3f051eb83e75c28f
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 223  :     colors[ImGuiCol_SeparatorHovered] = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);

  0018b	0f 11 81 88 02
	00 00		 movups	 XMMWORD PTR [rcx+648], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00192	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3e4ccccd3f7ae1483f170a3d3e851eb8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 214  :     colors[ImGuiCol_SliderGrab] = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);

  00199	0f 11 89 f8 01
	00 00		 movups	 XMMWORD PTR [rcx+504], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  001a0	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3ecccccd3f7ae1483f170a3d3e851eb8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 225  :     colors[ImGuiCol_ResizeGrip] = ImVec4(0.26f, 0.59f, 0.98f, 0.20f);

  001a7	0f 11 81 a8 02
	00 00		 movups	 XMMWORD PTR [rcx+680], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  001ae	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f7333333f7ae1483f170a3d3e851eb8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 216  :     colors[ImGuiCol_Button] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);

  001b5	0f 11 89 18 02
	00 00		 movups	 XMMWORD PTR [rcx+536], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  001bc	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003f7ae1483f07ae143d75c28f
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 200  :     colors[ImGuiCol_Border] = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);

  001c3	0f 11 99 18 01
	00 00		 movups	 XMMWORD PTR [rcx+280], xmm3

; 222  :     colors[ImGuiCol_Separator] = colors[ImGuiCol_Border];

  001ca	0f 11 99 78 02
	00 00		 movups	 XMMWORD PTR [rcx+632], xmm3

; 227  :     colors[ImGuiCol_ResizeGripActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);

  001d1	0f 11 81 c8 02
	00 00		 movups	 XMMWORD PTR [rcx+712], xmm0
  001d8	0f 11 89 38 02
	00 00		 movups	 XMMWORD PTR [rcx+568], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  001df	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003f4000003ecccccd3dcccccd
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  001e6	0f 28 c2	 movaps	 xmm0, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 224  :     colors[ImGuiCol_SeparatorActive] = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);

  001e9	0f 11 89 98 02
	00 00		 movups	 XMMWORD PTR [rcx+664], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  001f0	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f2b851f3f7ae1483f170a3d3e851eb8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 220  :     colors[ImGuiCol_HeaderHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);

  001f7	0f 11 b1 58 02
	00 00		 movups	 XMMWORD PTR [rcx+600], xmm6

; 226  :     colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);

  001fe	0f 11 89 b8 02
	00 00		 movups	 XMMWORD PTR [rcx+696], xmm1
  00205	0f 11 91 48 02
	00 00		 movups	 XMMWORD PTR [rcx+584], xmm2
  0020c	44 0f 11 81 78
	01 00 00	 movups	 XMMWORD PTR [rcx+376], xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00214	f3 0f 10 99 80
	01 00 00	 movss	 xmm3, DWORD PTR [rcx+384]
  0021c	f3 0f 10 89 54
	02 00 00	 movss	 xmm1, DWORD PTR [rcx+596]
  00224	0f c6 c0 55	 shufps	 xmm0, xmm0, 85		; 00000055H
  00228	f3 0f 5c e0	 subss	 xmm4, xmm0
  0022c	f3 0f 59 ef	 mulss	 xmm5, xmm7
  00230	f3 0f 58 ea	 addss	 xmm5, xmm2
  00234	f3 0f 10 91 84
	01 00 00	 movss	 xmm2, DWORD PTR [rcx+388]
  0023c	f3 0f 59 e7	 mulss	 xmm4, xmm7
  00240	f3 0f 58 e0	 addss	 xmm4, xmm0
  00244	f3 0f 10 81 50
	02 00 00	 movss	 xmm0, DWORD PTR [rcx+592]
  0024c	f3 0f 5c d8	 subss	 xmm3, xmm0
  00250	f3 0f 59 df	 mulss	 xmm3, xmm7
  00254	f3 0f 58 d8	 addss	 xmm3, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 228  :     colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.80f);

  00258	0f c6 ed e1	 shufps	 xmm5, xmm5, 225		; 000000e1H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  0025c	f3 0f 5c d1	 subss	 xmm2, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 228  :     colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.80f);

  00260	f3 0f 10 ec	 movss	 xmm5, xmm4
  00264	0f c6 ed c6	 shufps	 xmm5, xmm5, 198		; 000000c6H
  00268	f3 0f 10 eb	 movss	 xmm5, xmm3

; 229  :     colors[ImGuiCol_TabHovered] = colors[ImGuiCol_HeaderHovered];

  0026c	0f 11 b1 e8 02
	00 00		 movups	 XMMWORD PTR [rcx+744], xmm6
  00273	0f c6 ed 27	 shufps	 xmm5, xmm5, 39		; 00000027H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00277	f3 0f 59 d7	 mulss	 xmm2, xmm7
  0027b	f3 0f 58 d1	 addss	 xmm2, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 228  :     colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.80f);

  0027f	f3 0f 10 ea	 movss	 xmm5, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00283	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f19999a
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 228  :     colors[ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_Header], colors[ImGuiCol_TitleBgActive], 0.80f);

  0028b	0f c6 ed 39	 shufps	 xmm5, xmm5, 57		; 00000039H
  0028f	0f 11 a9 d8 02
	00 00		 movups	 XMMWORD PTR [rcx+728], xmm5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00296	f3 0f 10 81 68
	02 00 00	 movss	 xmm0, DWORD PTR [rcx+616]
  0029e	f3 0f 10 89 70
	02 00 00	 movss	 xmm1, DWORD PTR [rcx+624]
  002a6	f3 44 0f 5c c0	 subss	 xmm8, xmm0
  002ab	f3 0f 10 a9 7c
	01 00 00	 movss	 xmm5, DWORD PTR [rcx+380]
  002b3	f3 0f 10 a1 80
	01 00 00	 movss	 xmm4, DWORD PTR [rcx+384]
  002bb	f3 0f 10 99 84
	01 00 00	 movss	 xmm3, DWORD PTR [rcx+388]
  002c3	f3 0f 5c e1	 subss	 xmm4, xmm1
  002c7	f3 44 0f 59 c2	 mulss	 xmm8, xmm2
  002cc	f3 0f 59 e2	 mulss	 xmm4, xmm2
  002d0	f3 44 0f 58 c0	 addss	 xmm8, xmm0
  002d5	f3 0f 10 81 6c
	02 00 00	 movss	 xmm0, DWORD PTR [rcx+620]
  002dd	f3 0f 5c e8	 subss	 xmm5, xmm0
  002e1	f3 0f 58 e1	 addss	 xmm4, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 230  :     colors[ImGuiCol_TabActive] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

  002e5	45 0f c6 c0 e1	 shufps	 xmm8, xmm8, 225		; 000000e1H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  002ea	f3 0f 59 ea	 mulss	 xmm5, xmm2
  002ee	f3 0f 58 e8	 addss	 xmm5, xmm0
  002f2	f3 0f 10 81 74
	02 00 00	 movss	 xmm0, DWORD PTR [rcx+628]
  002fa	f3 0f 5c d8	 subss	 xmm3, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 230  :     colors[ImGuiCol_TabActive] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

  002fe	f3 44 0f 10 c5	 movss	 xmm8, xmm5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00303	f3 0f 59 da	 mulss	 xmm3, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 230  :     colors[ImGuiCol_TabActive] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

  00307	45 0f c6 c0 c6	 shufps	 xmm8, xmm8, 198		; 000000c6H
  0030c	f3 44 0f 10 c4	 movss	 xmm8, xmm4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00311	f3 0f 58 d8	 addss	 xmm3, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 230  :     colors[ImGuiCol_TabActive] = ImLerp(colors[ImGuiCol_HeaderActive], colors[ImGuiCol_TitleBgActive], 0.60f);

  00315	45 0f c6 c0 27	 shufps	 xmm8, xmm8, 39		; 00000027H
  0031a	f3 44 0f 10 c3	 movss	 xmm8, xmm3
  0031f	45 0f c6 c0 39	 shufps	 xmm8, xmm8, 57		; 00000039H
  00324	44 0f 11 81 f8
	02 00 00	 movups	 XMMWORD PTR [rcx+760], xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  0032c	f3 0f 10 81 d8
	02 00 00	 movss	 xmm0, DWORD PTR [rcx+728]
  00334	f3 0f 10 89 dc
	02 00 00	 movss	 xmm1, DWORD PTR [rcx+732]
  0033c	f3 0f 10 b1 68
	01 00 00	 movss	 xmm6, DWORD PTR [rcx+360]
  00344	f3 0f 10 a1 6c
	01 00 00	 movss	 xmm4, DWORD PTR [rcx+364]
  0034c	0f 28 ee	 movaps	 xmm5, xmm6
  0034f	f3 0f 10 99 70
	01 00 00	 movss	 xmm3, DWORD PTR [rcx+368]
  00357	f3 0f 5c e8	 subss	 xmm5, xmm0
  0035b	f3 0f 10 91 74
	01 00 00	 movss	 xmm2, DWORD PTR [rcx+372]
  00363	f3 0f 5c e1	 subss	 xmm4, xmm1
  00367	f3 0f 59 ef	 mulss	 xmm5, xmm7
  0036b	f3 0f 59 e7	 mulss	 xmm4, xmm7
  0036f	f3 0f 58 e8	 addss	 xmm5, xmm0
  00373	f3 0f 10 81 e0
	02 00 00	 movss	 xmm0, DWORD PTR [rcx+736]
  0037b	f3 0f 5c d8	 subss	 xmm3, xmm0
  0037f	f3 0f 58 e1	 addss	 xmm4, xmm1
  00383	f3 0f 10 89 e4
	02 00 00	 movss	 xmm1, DWORD PTR [rcx+740]
  0038b	f3 0f 5c d1	 subss	 xmm2, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 231  :     colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);

  0038f	0f c6 ed e1	 shufps	 xmm5, xmm5, 225		; 000000e1H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00393	f3 0f 59 df	 mulss	 xmm3, xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 231  :     colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);

  00397	f3 0f 10 ec	 movss	 xmm5, xmm4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  0039b	f3 0f 59 d7	 mulss	 xmm2, xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 231  :     colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);

  0039f	0f c6 ed c6	 shufps	 xmm5, xmm5, 198		; 000000c6H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  003a3	f3 0f 58 d8	 addss	 xmm3, xmm0
  003a7	f3 0f 58 d1	 addss	 xmm2, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 231  :     colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);

  003ab	f3 0f 10 eb	 movss	 xmm5, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  003af	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3ecccccd
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 231  :     colors[ImGuiCol_TabUnfocused] = ImLerp(colors[ImGuiCol_Tab], colors[ImGuiCol_TitleBg], 0.80f);

  003b7	0f c6 ed 27	 shufps	 xmm5, xmm5, 39		; 00000027H
  003bb	f3 0f 10 ea	 movss	 xmm5, xmm2
  003bf	0f c6 ed 39	 shufps	 xmm5, xmm5, 57		; 00000039H
  003c3	0f 11 a9 08 03
	00 00		 movups	 XMMWORD PTR [rcx+776], xmm5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  003ca	f3 0f 10 81 f8
	02 00 00	 movss	 xmm0, DWORD PTR [rcx+760]
  003d2	f3 0f 10 a9 6c
	01 00 00	 movss	 xmm5, DWORD PTR [rcx+364]
  003da	f3 0f 5c f0	 subss	 xmm6, xmm0
  003de	f3 0f 10 89 00
	03 00 00	 movss	 xmm1, DWORD PTR [rcx+768]
  003e6	f3 0f 10 a1 70
	01 00 00	 movss	 xmm4, DWORD PTR [rcx+368]
  003ee	f3 0f 59 f3	 mulss	 xmm6, xmm3
  003f2	f3 0f 58 f0	 addss	 xmm6, xmm0
  003f6	f3 0f 10 81 fc
	02 00 00	 movss	 xmm0, DWORD PTR [rcx+764]
  003fe	f3 0f 5c e8	 subss	 xmm5, xmm0
  00402	f3 0f 59 eb	 mulss	 xmm5, xmm3
  00406	f3 0f 58 e8	 addss	 xmm5, xmm0
  0040a	f3 0f 10 81 04
	03 00 00	 movss	 xmm0, DWORD PTR [rcx+772]
  00412	f3 0f 5c e1	 subss	 xmm4, xmm1
  00416	f3 0f 10 91 74
	01 00 00	 movss	 xmm2, DWORD PTR [rcx+372]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 248  : }

  0041e	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00423	f3 0f 5c d0	 subss	 xmm2, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 248  : }

  00427	44 0f 28 44 24
	30		 movaps	 xmm8, XMMWORD PTR [rsp+48]
  0042d	0f c6 f6 e1	 shufps	 xmm6, xmm6, 225		; 000000e1H
  00431	f3 0f 10 f5	 movss	 xmm6, xmm5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00435	f3 0f 59 e3	 mulss	 xmm4, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 232  :     colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);

  00439	0f c6 f6 c6	 shufps	 xmm6, xmm6, 198		; 000000c6H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  0043d	f3 0f 59 d3	 mulss	 xmm2, xmm3
  00441	f3 0f 58 e1	 addss	 xmm4, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00445	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003eb333333edc28f63f800000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 234  :     colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);

  0044c	0f 11 89 38 03
	00 00		 movups	 XMMWORD PTR [rcx+824], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00453	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f800000000000003f19999a3f800000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  0045a	f3 0f 58 d0	 addss	 xmm2, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0045e	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003f1c28f63f1c28f63f1c28f6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 233  :     colors[ImGuiCol_PlotLines] = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);

  00465	0f 11 81 28 03
	00 00		 movups	 XMMWORD PTR [rcx+808], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0046c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f800000000000003f3333333f666666
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 232  :     colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);

  00473	f3 0f 10 f4	 movss	 xmm6, xmm4

; 235  :     colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);

  00477	0f 11 81 48 03
	00 00		 movups	 XMMWORD PTR [rcx+840], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0047e	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003e4ccccd3e428f5c3e428f5c
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 237  :     colors[ImGuiCol_TableHeaderBg] = ImVec4(0.19f, 0.19f, 0.20f, 1.00f);

  00485	0f 11 81 68 03
	00 00		 movups	 XMMWORD PTR [rcx+872], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0048c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003e8000003e6b851f3e6b851f
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 236  :     colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);

  00493	0f 11 89 58 03
	00 00		 movups	 XMMWORD PTR [rcx+856], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0049a	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003eb333333e9eb8523e9eb852
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 239  :     colors[ImGuiCol_TableBorderLight] = ImVec4(0.23f, 0.23f, 0.25f, 1.00f);   // Prefer using Alpha=1.0 here

  004a1	0f 11 81 88 03
	00 00		 movups	 XMMWORD PTR [rcx+904], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  004a8	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3d75c28f3f8000003f8000003f800000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 238  :     colors[ImGuiCol_TableBorderStrong] = ImVec4(0.31f, 0.31f, 0.35f, 1.00f);   // Prefer using Alpha=1.0 here

  004af	0f 11 89 78 03
	00 00		 movups	 XMMWORD PTR [rcx+888], xmm1
  004b6	0f 57 c9	 xorps	 xmm1, xmm1
  004b9	0f c6 f6 27	 shufps	 xmm6, xmm6, 39		; 00000027H

; 241  :     colors[ImGuiCol_TableRowBgAlt] = ImVec4(1.00f, 1.00f, 1.00f, 0.06f);

  004bd	0f 11 81 a8 03
	00 00		 movups	 XMMWORD PTR [rcx+936], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  004c4	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f666666000000003f8000003f800000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 232  :     colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);

  004cb	f3 0f 10 f2	 movss	 xmm6, xmm2

; 240  :     colors[ImGuiCol_TableRowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

  004cf	0f 11 89 98 03
	00 00		 movups	 XMMWORD PTR [rcx+920], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  004d6	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3eb333333f7ae1483f170a3d3e851eb8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 243  :     colors[ImGuiCol_DragDropTarget] = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);

  004dd	0f 11 81 c8 03
	00 00		 movups	 XMMWORD PTR [rcx+968], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  004e4	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f3333333f8000003f8000003f800000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 242  :     colors[ImGuiCol_TextSelectedBg] = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);

  004eb	0f 11 89 b8 03
	00 00		 movups	 XMMWORD PTR [rcx+952], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  004f2	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003f7ae1483f170a3d3e851eb8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 232  :     colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);

  004f9	0f c6 f6 39	 shufps	 xmm6, xmm6, 57		; 00000039H

; 245  :     colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);

  004fd	0f 11 81 e8 03
	00 00		 movups	 XMMWORD PTR [rcx+1000], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00504	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3eb333333f4ccccd3f4ccccd3f4ccccd
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 244  :     colors[ImGuiCol_NavHighlight] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);

  0050b	0f 11 89 d8 03
	00 00		 movups	 XMMWORD PTR [rcx+984], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00512	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3e4ccccd3f4ccccd3f4ccccd3f4ccccd
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 232  :     colors[ImGuiCol_TabUnfocusedActive] = ImLerp(colors[ImGuiCol_TabActive], colors[ImGuiCol_TitleBg], 0.40f);

  00519	0f 11 b1 18 03
	00 00		 movups	 XMMWORD PTR [rcx+792], xmm6

; 248  : }

  00520	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  00525	0f 11 81 08 04
	00 00		 movups	 XMMWORD PTR [rcx+1032], xmm0
  0052c	0f 11 89 f8 03
	00 00		 movups	 XMMWORD PTR [rcx+1016], xmm1
  00533	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00537	c3		 ret	 0
?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z ENDP	; ImGui::StyleColorsDark
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
pos$ = 72
$T10 = 80
$T11 = 80
uv$ = 88
__$ArrayPad$ = 120
draw_list$ = 272
scale$ = 288
mouse_cursor$ = 296
col_fill$dead$ = 304
col_border$dead$ = 312
col_shadow$dead$ = 320
?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z PROC ; ImGui::RenderMouseCursor

; 3805 : {

$LN141:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	48 8d 6c 24 d1	 lea	 rbp, QWORD PTR [rsp-47]
  00009	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  00010	44 0f 29 a4 24
	80 00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm12
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 45 b7	 mov	 QWORD PTR __$ArrayPad$[rbp-193], rax
  00027	49 63 f1	 movsxd	 rsi, r9d
  0002a	44 0f 28 e2	 movaps	 xmm12, xmm2
  0002e	48 89 55 87	 mov	 QWORD PTR pos$[rbp-193], rdx
  00032	48 8b d9	 mov	 rbx, rcx

; 3806 :     if (mouse_cursor == ImGuiMouseCursor_None)

  00035	83 fe ff	 cmp	 esi, -1
  00038	0f 84 c5 03 00
	00		 je	 $LN3@RenderMous

; 3807 :         return;
; 3808 :     IM_ASSERT(mouse_cursor > ImGuiMouseCursor_None && mouse_cursor < ImGuiMouseCursor_COUNT);

  0003e	48 89 bc 24 20
	01 00 00	 mov	 QWORD PTR [rsp+288], rdi
  00046	83 fe 08	 cmp	 esi, 8
  00049	76 1a		 jbe	 SHORT $LN6@RenderMous
  0004b	41 b8 e0 0e 00
	00		 mov	 r8d, 3808		; 00000ee0H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JM@LKKCKIOL@?$AAm?$AAo?$AAu?$AAs?$AAe?$AA_?$AAc?$AAu?$AAr?$AAs?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5@
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN6@RenderMous:

; 3809 : 
; 3810 :     ImFontAtlas* font_atlas = draw_list->_Data->Font->ContainerAtlas;

  00065	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00069	33 d2		 xor	 edx, edx
  0006b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 3811 :     ImVec2 offset, size, uv[4];

  0006f	48 8d 45 97	 lea	 rax, QWORD PTR uv$[rbp-193]
  00073	48 8b 79 40	 mov	 rdi, QWORD PTR [rcx+64]
  00077	b9 04 00 00 00	 mov	 ecx, 4
  0007c	0f 1f 40 00	 npad	 4
$LL134@RenderMous:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 252  :     ImVec2() { x = y = 0.0f; }

  00080	48 89 10	 mov	 QWORD PTR [rax], rdx
  00083	48 8d 40 08	 lea	 rax, QWORD PTR [rax+8]
  00087	48 83 e9 01	 sub	 rcx, 1
  0008b	75 f3		 jne	 SHORT $LL134@RenderMous
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2241 :     if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)

  0008d	83 fe 08	 cmp	 esi, 8
  00090	0f 87 65 03 00
	00		 ja	 $LN139@RenderMous

; 2242 :         return false;
; 2243 :     if (Flags & ImFontAtlasFlags_NoMouseCursors)

  00096	f6 07 02	 test	 BYTE PTR [rdi], 2
  00099	0f 85 5c 03 00
	00		 jne	 $LN139@RenderMous

; 2244 :         return false;
; 2245 : 
; 2246 :     IM_ASSERT(PackIdMouseCursors != -1);

  0009f	8b 97 84 04 00
	00		 mov	 edx, DWORD PTR [rdi+1156]
  000a5	0f 29 b4 24 e0
	00 00 00	 movaps	 XMMWORD PTR [rsp+224], xmm6
  000ad	0f 29 bc 24 d0
	00 00 00	 movaps	 XMMWORD PTR [rsp+208], xmm7
  000b5	44 0f 29 84 24
	c0 00 00 00	 movaps	 XMMWORD PTR [rsp+192], xmm8
  000be	44 0f 29 8c 24
	b0 00 00 00	 movaps	 XMMWORD PTR [rsp+176], xmm9
  000c7	44 0f 29 94 24
	a0 00 00 00	 movaps	 XMMWORD PTR [rsp+160], xmm10
  000d0	44 0f 29 9c 24
	90 00 00 00	 movaps	 XMMWORD PTR [rsp+144], xmm11
  000d9	83 fa ff	 cmp	 edx, -1
  000dc	75 20		 jne	 SHORT $LN24@RenderMous
  000de	41 b8 c6 08 00
	00		 mov	 r8d, 2246		; 000008c6H
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@JHOLDEIK@?$AAP?$AAa?$AAc?$AAk?$AAI?$AAd?$AAM?$AAo?$AAu?$AAs?$AAe?$AAC?$AAu?$AAr?$AAs@
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f8	8b 97 84 04 00
	00		 mov	 edx, DWORD PTR [rdi+1156]
$LN24@RenderMous:

; 2247 :     ImFontAtlasCustomRect* r = GetCustomRectByIndex(PackIdMouseCursors);

  000fe	48 8b cf	 mov	 rcx, rdi
  00101	e8 00 00 00 00	 call	 ?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z ; ImFontAtlas::GetCustomRectByIndex
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 361  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

  00106	f3 44 0f 10 45
	87		 movss	 xmm8, DWORD PTR pos$[rbp-193]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2248 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);

  0010c	48 8d 14 76	 lea	 rdx, QWORD PTR [rsi+rsi*2]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 361  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

  00110	f3 44 0f 10 4d
	8b		 movss	 xmm9, DWORD PTR pos$[rbp-189]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2248 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);

  00116	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A

; 2249 :     ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];

  0011d	f3 45 0f 10 54
	d0 08		 movss	 xmm10, DWORD PTR [r8+rdx*8+8]
  00124	0f b7 48 04	 movzx	 ecx, WORD PTR [rax+4]
  00128	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  0012c	f3 45 0f 10 5c
	d0 0c		 movss	 xmm11, DWORD PTR [r8+rdx*8+12]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 361  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

  00133	f3 45 0f 5c 44
	d0 10		 subss	 xmm8, DWORD PTR [r8+rdx*8+16]
  0013a	f3 45 0f 5c 4c
	d0 14		 subss	 xmm9, DWORD PTR [r8+rdx*8+20]
  00141	66 0f 6e e1	 movd	 xmm4, ecx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3816 :         draw_list->PushTextureID(tex_id);

  00145	48 8b cb	 mov	 rcx, rbx

; 2248 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);

  00148	0f 5b e4	 cvtdq2ps xmm4, xmm4
  0014b	66 0f 6e d8	 movd	 xmm3, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  0014f	f3 41 0f 58 24
	d0		 addss	 xmm4, DWORD PTR [r8+rdx*8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2248 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);

  00155	0f 5b db	 cvtdq2ps xmm3, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  00158	0f 28 cc	 movaps	 xmm1, xmm4

; 361  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

  0015b	f3 44 0f 11 45
	87		 movss	 DWORD PTR pos$[rbp-193], xmm8

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  00161	f3 0f 59 4f 38	 mulss	 xmm1, DWORD PTR [rdi+56]

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00166	f3 41 0f 58 5c
	d0 04		 addss	 xmm3, DWORD PTR [r8+rdx*8+4]

; 361  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

  0016d	f3 44 0f 11 4d
	8b		 movss	 DWORD PTR pos$[rbp-189], xmm9

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  00173	0f 28 c3	 movaps	 xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00176	0f 28 d3	 movaps	 xmm2, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  00179	f3 0f 59 47 3c	 mulss	 xmm0, DWORD PTR [rdi+60]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0017e	f3 41 0f 58 d3	 addss	 xmm2, xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2252 :     out_uv_border[0] = (pos)*TexUvScale;

  00183	f3 0f 11 4d 97	 movss	 DWORD PTR uv$[rbp-193], xmm1
  00188	0f 28 cc	 movaps	 xmm1, xmm4

; 2253 :     out_uv_border[1] = (pos + size) * TexUvScale;

  0018b	f3 0f 58 25 00
	00 00 00	 addss	 xmm4, DWORD PTR __real@42f60000
  00193	f3 0f 11 45 9b	 movss	 DWORD PTR uv$[rbp-189], xmm0
  00198	f3 41 0f 58 ca	 addss	 xmm1, xmm10
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  0019d	0f 28 c2	 movaps	 xmm0, xmm2
  001a0	f3 0f 59 47 3c	 mulss	 xmm0, DWORD PTR [rdi+60]
  001a5	f3 0f 59 4f 38	 mulss	 xmm1, DWORD PTR [rdi+56]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2253 :     out_uv_border[1] = (pos + size) * TexUvScale;

  001aa	f3 0f 11 45 a3	 movss	 DWORD PTR uv$[rbp-181], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  001af	0f 28 c4	 movaps	 xmm0, xmm4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2255 :     out_uv_fill[0] = (pos)*TexUvScale;

  001b2	f3 41 0f 58 e2	 addss	 xmm4, xmm10
  001b7	f3 0f 11 4d 9f	 movss	 DWORD PTR uv$[rbp-185], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  001bc	f3 0f 59 47 38	 mulss	 xmm0, DWORD PTR [rdi+56]
  001c1	f3 0f 59 5f 3c	 mulss	 xmm3, DWORD PTR [rdi+60]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2255 :     out_uv_fill[0] = (pos)*TexUvScale;

  001c6	f3 0f 11 45 a7	 movss	 DWORD PTR uv$[rbp-177], xmm0
  001cb	f3 0f 11 5d ab	 movss	 DWORD PTR uv$[rbp-173], xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  001d0	f3 0f 59 67 38	 mulss	 xmm4, DWORD PTR [rdi+56]
  001d5	f3 0f 59 57 3c	 mulss	 xmm2, DWORD PTR [rdi+60]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2256 :     out_uv_fill[1] = (pos + size) * TexUvScale;

  001da	f3 0f 11 65 af	 movss	 DWORD PTR uv$[rbp-169], xmm4
  001df	f3 0f 11 55 b3	 movss	 DWORD PTR uv$[rbp-165], xmm2

; 3812 :     if (font_atlas->GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))
; 3813 :     {
; 3814 :         pos -= offset;
; 3815 :         ImTextureID tex_id = font_atlas->TexID;

  001e4	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]

; 3816 :         draw_list->PushTextureID(tex_id);

  001e8	48 8b d7	 mov	 rdx, rdi
  001eb	e8 00 00 00 00	 call	 ?PushTextureID@ImDrawList@@QEAAXPEAX@Z ; ImDrawList::PushTextureID
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  001f0	41 0f 28 c2	 movaps	 xmm0, xmm10
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3817 :         draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow);

  001f4	c7 44 24 30 00
	00 00 30	 mov	 DWORD PTR [rsp+48], 805306368 ; 30000000H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  001fc	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00204	0f 57 c9	 xorps	 xmm1, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3817 :         draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow);

  00207	48 8d 45 af	 lea	 rax, QWORD PTR uv$[rbp-169]
  0020b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00210	4c 8d 4d 8f	 lea	 r9, QWORD PTR $T11[rbp-193]
  00214	48 8d 45 a7	 lea	 rax, QWORD PTR uv$[rbp-177]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00218	41 0f 28 fb	 movaps	 xmm7, xmm11
  0021c	f3 0f 58 f9	 addss	 xmm7, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3817 :         draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow);

  00220	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00225	f3 41 0f 59 c4	 mulss	 xmm0, xmm12
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3817 :         draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow);

  0022a	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T9[rsp]
  0022f	48 8b d7	 mov	 rdx, rdi
  00232	48 8b cb	 mov	 rcx, rbx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00235	41 0f 28 f4	 movaps	 xmm6, xmm12
  00239	f3 0f 59 f1	 mulss	 xmm6, xmm1
  0023d	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  00242	f3 41 0f 59 fc	 mulss	 xmm7, xmm12
  00247	f3 41 0f 58 f1	 addss	 xmm6, xmm9
  0024c	f3 41 0f 58 f9	 addss	 xmm7, xmm9
  00251	f3 0f 11 45 8f	 movss	 DWORD PTR $T11[rbp-193], xmm0
  00256	41 0f 28 c0	 movaps	 xmm0, xmm8
  0025a	f3 41 0f 58 c4	 addss	 xmm0, xmm12
  0025f	f3 0f 11 75 83	 movss	 DWORD PTR $T9[rbp-189], xmm6
  00264	f3 0f 11 7d 93	 movss	 DWORD PTR $T11[rbp-189], xmm7
  00269	f3 0f 11 44 24
	40		 movss	 DWORD PTR $T9[rsp], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3817 :         draw_list->AddImage(tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow);

  0026f	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00274	41 0f 28 c2	 movaps	 xmm0, xmm10
  00278	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00280	f3 41 0f 59 c4	 mulss	 xmm0, xmm12
  00285	f3 41 0f 58 c0	 addss	 xmm0, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3818 :         draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);

  0028a	c7 44 24 30 00
	00 00 30	 mov	 DWORD PTR [rsp+48], 805306368 ; 30000000H
  00292	48 8d 45 af	 lea	 rax, QWORD PTR uv$[rbp-169]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00296	f3 0f 11 7d 83	 movss	 DWORD PTR $T8[rbp-189], xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3818 :         draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);

  0029b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002a0	4c 8d 4c 24 40	 lea	 r9, QWORD PTR $T8[rsp]
  002a5	48 8d 45 a7	 lea	 rax, QWORD PTR uv$[rbp-177]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  002a9	f3 0f 11 75 93	 movss	 DWORD PTR $T10[rbp-189], xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3818 :         draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);

  002ae	4c 8d 45 8f	 lea	 r8, QWORD PTR $T10[rbp-193]
  002b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  002b7	f3 0f 11 44 24
	40		 movss	 DWORD PTR $T8[rsp], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3818 :         draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);

  002bd	48 8b d7	 mov	 rdx, rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  002c0	41 0f 28 c4	 movaps	 xmm0, xmm12
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3818 :         draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);

  002c4	48 8b cb	 mov	 rcx, rbx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  002c7	f3 41 0f 58 c4	 addss	 xmm0, xmm12
  002cc	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  002d1	f3 0f 11 45 8f	 movss	 DWORD PTR $T10[rbp-193], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3818 :         draw_list->AddImage(tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow);

  002d6	e8 00 00 00 00	 call	 ?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ; ImDrawList::AddImage

; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

  002db	48 8b b3 98 00
	00 00		 mov	 rsi, QWORD PTR [rbx+152]
  002e2	0f 28 bc 24 d0
	00 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+208]
  002ea	0f 28 b4 24 e0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+224]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  002f2	f3 45 0f 59 d4	 mulss	 xmm10, xmm12
  002f7	f3 45 0f 59 dc	 mulss	 xmm11, xmm12
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  002fc	f3 45 0f 58 d0	 addss	 xmm10, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

  00301	44 0f 28 84 24
	c0 00 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+192]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0030a	f3 45 0f 58 d9	 addss	 xmm11, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

  0030f	44 0f 28 8c 24
	b0 00 00 00	 movaps	 xmm9, XMMWORD PTR [rsp+176]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00318	f3 44 0f 11 54
	24 40		 movss	 DWORD PTR $T7[rsp], xmm10
  0031f	f3 44 0f 11 5d
	83		 movss	 DWORD PTR $T7[rbp-189], xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1616 :     if (push_texture_id)

  00325	48 3b fe	 cmp	 rdi, rsi
  00328	74 0b		 je	 SHORT $LN115@RenderMous

; 1617 :         PushTextureID(user_texture_id);

  0032a	48 8b d7	 mov	 rdx, rdi
  0032d	48 8b cb	 mov	 rcx, rbx
  00330	e8 00 00 00 00	 call	 ?PushTextureID@ImDrawList@@QEAAXPEAX@Z ; ImDrawList::PushTextureID
$LN115@RenderMous:

; 1618 : 
; 1619 :     PrimReserve(6, 4);

  00335	ba 06 00 00 00	 mov	 edx, 6
  0033a	48 8b cb	 mov	 rcx, rbx
  0033d	44 8d 42 fe	 lea	 r8d, QWORD PTR [rdx-2]
  00341	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve

; 1620 :     PrimRectUV(p_min, p_max, uv_min, uv_max, col);

  00346	48 8d 45 af	 lea	 rax, QWORD PTR uv$[rbp-169]
  0034a	c7 44 24 28 00
	00 00 ff	 mov	 DWORD PTR [rsp+40], -16777216 ; ff000000H
  00352	4c 8d 4d a7	 lea	 r9, QWORD PTR uv$[rbp-177]
  00356	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0035b	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T7[rsp]
  00360	48 8b cb	 mov	 rcx, rbx
  00363	48 8d 55 87	 lea	 rdx, QWORD PTR pos$[rbp-193]
  00367	e8 00 00 00 00	 call	 ?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV

; 1621 : 
; 1622 :     if (push_texture_id)

  0036c	48 3b fe	 cmp	 rdi, rsi
  0036f	74 08		 je	 SHORT $LN116@RenderMous

; 1623 :         PopTextureID();

  00371	48 8b cb	 mov	 rcx, rbx
  00374	e8 00 00 00 00	 call	 ?PopTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::PopTextureID
$LN116@RenderMous:

; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

  00379	48 8b b3 98 00
	00 00		 mov	 rsi, QWORD PTR [rbx+152]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00380	f3 44 0f 11 54
	24 40		 movss	 DWORD PTR $T6[rsp], xmm10
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

  00387	44 0f 28 94 24
	a0 00 00 00	 movaps	 xmm10, XMMWORD PTR [rsp+160]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00390	f3 44 0f 11 5d
	83		 movss	 DWORD PTR $T6[rbp-189], xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

  00396	44 0f 28 9c 24
	90 00 00 00	 movaps	 xmm11, XMMWORD PTR [rsp+144]

; 1616 :     if (push_texture_id)

  0039f	48 3b fe	 cmp	 rdi, rsi
  003a2	74 0b		 je	 SHORT $LN128@RenderMous

; 1617 :         PushTextureID(user_texture_id);

  003a4	48 8b d7	 mov	 rdx, rdi
  003a7	48 8b cb	 mov	 rcx, rbx
  003aa	e8 00 00 00 00	 call	 ?PushTextureID@ImDrawList@@QEAAXPEAX@Z ; ImDrawList::PushTextureID
$LN128@RenderMous:

; 1618 : 
; 1619 :     PrimReserve(6, 4);

  003af	ba 06 00 00 00	 mov	 edx, 6
  003b4	48 8b cb	 mov	 rcx, rbx
  003b7	44 8d 42 fe	 lea	 r8d, QWORD PTR [rdx-2]
  003bb	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve

; 1620 :     PrimRectUV(p_min, p_max, uv_min, uv_max, col);

  003c0	48 8d 45 9f	 lea	 rax, QWORD PTR uv$[rbp-185]
  003c4	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR [rsp+40], -1	; ffffffffH
  003cc	4c 8d 4d 97	 lea	 r9, QWORD PTR uv$[rbp-193]
  003d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d5	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T6[rsp]
  003da	48 8b cb	 mov	 rcx, rbx
  003dd	48 8d 55 87	 lea	 rdx, QWORD PTR pos$[rbp-193]
  003e1	e8 00 00 00 00	 call	 ?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV

; 1621 : 
; 1622 :     if (push_texture_id)

  003e6	48 3b fe	 cmp	 rdi, rsi
  003e9	74 08		 je	 SHORT $LN129@RenderMous

; 1623 :         PopTextureID();

  003eb	48 8b cb	 mov	 rcx, rbx
  003ee	e8 00 00 00 00	 call	 ?PopTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::PopTextureID
$LN129@RenderMous:

; 3819 :         draw_list->AddImage(tex_id, pos, pos + size * scale, uv[2], uv[3], col_border);
; 3820 :         draw_list->AddImage(tex_id, pos, pos + size * scale, uv[0], uv[1], col_fill);
; 3821 :         draw_list->PopTextureID();

  003f3	48 8b cb	 mov	 rcx, rbx
  003f6	e8 00 00 00 00	 call	 ?PopTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::PopTextureID
$LN139@RenderMous:
  003fb	48 8b bc 24 20
	01 00 00	 mov	 rdi, QWORD PTR [rsp+288]
$LN3@RenderMous:

; 3822 :     }
; 3823 : }

  00403	48 8b 4d b7	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-193]
  00407	48 33 cc	 xor	 rcx, rsp
  0040a	e8 00 00 00 00	 call	 __security_check_cookie
  0040f	44 0f 28 a4 24
	80 00 00 00	 movaps	 xmm12, XMMWORD PTR [rsp+128]
  00418	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  0041f	5e		 pop	 rsi
  00420	5b		 pop	 rbx
  00421	5d		 pop	 rbp
  00422	c3		 ret	 0
?RenderMouseCursor@ImGui@@YAXPEAUImDrawList@@UImVec2@@MHIII@Z ENDP ; ImGui::RenderMouseCursor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
??0ImFontAtlas@@QEAA@XZ PROC				; ImFontAtlas::ImFontAtlas

; 1976 : {

$LN32:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 252  :     ImVec2() { x = y = 0.0f; }

  00009	33 d2		 xor	 edx, edx
  0000b	48 89 51 38	 mov	 QWORD PTR [rcx+56], rdx
  0000f	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00013	48 89 51 48	 mov	 QWORD PTR [rcx+72], rdx
  00017	48 89 51 50	 mov	 QWORD PTR [rcx+80], rdx
  0001b	48 89 51 58	 mov	 QWORD PTR [rcx+88], rdx
  0001f	48 89 51 60	 mov	 QWORD PTR [rcx+96], rdx
  00023	48 89 51 68	 mov	 QWORD PTR [rcx+104], rdx
  00027	48 89 51 70	 mov	 QWORD PTR [rcx+112], rdx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1976 : {

  0002b	48 8d 41 78	 lea	 rax, QWORD PTR [rcx+120]
  0002f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00034	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL27@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 265  :     ImVec4() { x = y = z = w = 0.0f; }

  00040	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx
  00044	48 89 10	 mov	 QWORD PTR [rax], rdx
  00047	48 8d 40 10	 lea	 rax, QWORD PTR [rax+16]
  0004b	48 83 e9 01	 sub	 rcx, 1
  0004f	75 ef		 jne	 SHORT $LL27@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1977 :     memset(this, 0, sizeof(*this));

  00051	33 d2		 xor	 edx, edx
  00053	41 b8 90 04 00
	00		 mov	 r8d, 1168		; 00000490H
  00059	48 8b cb	 mov	 rcx, rbx
  0005c	e8 00 00 00 00	 call	 memset

; 1978 :     TexGlyphPadding = 1;

  00061	c7 43 14 01 00
	00 00		 mov	 DWORD PTR [rbx+20], 1

; 1979 :     PackIdMouseCursors = PackIdLines = -1;

  00068	48 c7 83 84 04
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rbx+1156], -1

; 1980 : }

  00073	48 8b c3	 mov	 rax, rbx
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
??0ImFontAtlas@@QEAA@XZ ENDP				; ImFontAtlas::ImFontAtlas
_TEXT	ENDS
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$0
  00000	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 48	 add	 rcx, 72			; 00000048H
  0000b	e9 00 00 00 00	 jmp	 ??1?$ImVector@PEAUImFont@@@@QEAA@XZ ; ImVector<ImFont *>::~ImVector<ImFont *>
?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$0
this$ = 48
?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$1
  00010	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00017	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0001b	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ ; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$1
this$ = 48
?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$2
  00020	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00027	48 83 c1 68	 add	 rcx, 104		; 00000068H
  0002b	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontConfig@@@@QEAA@XZ ; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
this$ = 48
?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$0
  00000	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 48	 add	 rcx, 72			; 00000048H
  0000b	e9 00 00 00 00	 jmp	 ??1?$ImVector@PEAUImFont@@@@QEAA@XZ ; ImVector<ImFont *>::~ImVector<ImFont *>
?dtor$0@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
this$ = 48
?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$1
  00010	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00017	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0001b	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ ; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
?dtor$1@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
this$ = 48
?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA PROC		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$2
  00020	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00027	48 83 c1 68	 add	 rcx, 104		; 00000068H
  0002b	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontConfig@@@@QEAA@XZ ; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
?dtor$2@?0???0ImFontAtlas@@QEAA@XZ@4HA ENDP		; `ImFontAtlas::ImFontAtlas'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
??1ImFontAtlas@@QEAA@XZ PROC				; ImFontAtlas::~ImFontAtlas

; 1983 : {

$LN123:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	48 8b d9	 mov	 rbx, rcx

; 1984 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00018	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  0001c	74 1a		 je	 SHORT $LN4@ImFontAtla
  0001e	41 b8 c0 07 00
	00		 mov	 r8d, 1984		; 000007c0H
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@ImFontAtla:

; 2033 :     ClearInputData();

  00038	48 8b cb	 mov	 rcx, rbx
  0003b	e8 00 00 00 00	 call	 ?ClearInputData@ImFontAtlas@@QEAAXXZ ; ImFontAtlas::ClearInputData

; 2034 :     ClearTexData();

  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 ?ClearTexData@ImFontAtlas@@QEAAXXZ ; ImFontAtlas::ClearTexData

; 2026 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00048	80 7b 18 00	 cmp	 BYTE PTR [rbx+24], 0
  0004c	74 1a		 je	 SHORT $LN10@ImFontAtla
  0004e	41 b8 ea 07 00
	00		 mov	 r8d, 2026		; 000007eaH
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN10@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1786 :     inline void         clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

  00068	33 f6		 xor	 esi, esi
  0006a	39 73 48	 cmp	 DWORD PTR [rbx+72], esi
  0006d	0f 8e b7 00 00
	00		 jle	 $LN13@ImFontAtla
  00073	45 33 f6	 xor	 r14d, r14d
  00076	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL14@ImFontAtla:
  00080	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00084	49 8b 3c 06	 mov	 rdi, QWORD PTR [r14+rax]

; 1753 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

  00088	48 85 ff	 test	 rdi, rdi
  0008b	0f 84 8a 00 00
	00		 je	 $LN12@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3125 :     ClearOutputData();

  00091	48 8b cf	 mov	 rcx, rdi
  00094	e8 00 00 00 00	 call	 ?ClearOutputData@ImFont@@QEAAXXZ ; ImFont::ClearOutputData
  00099	90		 npad	 1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0009a	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  0009e	48 85 c9	 test	 rcx, rcx
  000a1	74 19		 je	 SHORT $LN33@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000aa	48 85 c0	 test	 rax, rax
  000ad	74 06		 je	 SHORT $LN31@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000af	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN31@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000bb	90		 npad	 1
$LN33@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  000bc	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  000c0	48 85 c9	 test	 rcx, rcx
  000c3	74 19		 je	 SHORT $LN45@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000cc	48 85 c0	 test	 rax, rax
  000cf	74 06		 je	 SHORT $LN43@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000d1	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN43@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000dd	90		 npad	 1
$LN45@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  000de	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  000e2	48 85 c9	 test	 rcx, rcx
  000e5	74 19		 je	 SHORT $LN57@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000ee	48 85 c0	 test	 rax, rax
  000f1	74 06		 je	 SHORT $LN55@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000f3	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN55@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000ff	90		 npad	 1
$LN57@ImFontAtla:

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00100	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00107	48 85 c0	 test	 rax, rax
  0010a	74 06		 je	 SHORT $LN63@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0010c	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN63@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00112	48 8b cf	 mov	 rcx, rdi
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN12@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1786 :     inline void         clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

  0011b	ff c6		 inc	 esi
  0011d	49 83 c6 08	 add	 r14, 8
  00121	3b 73 48	 cmp	 esi, DWORD PTR [rbx+72]
  00124	0f 8c 56 ff ff
	ff		 jl	 $LL14@ImFontAtla
$LN13@ImFontAtla:

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0012a	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  0012e	48 85 c9	 test	 rcx, rcx
  00131	74 28		 je	 SHORT $LN70@ImFontAtla
  00133	48 c7 43 48 00
	00 00 00	 mov	 QWORD PTR [rbx+72], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0013b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00142	48 85 c0	 test	 rax, rax
  00145	74 06		 je	 SHORT $LN74@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00147	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN74@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00153	48 c7 43 50 00
	00 00 00	 mov	 QWORD PTR [rbx+80], 0
$LN70@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2028 :     TexReady = false;

  0015b	c6 43 19 00	 mov	 BYTE PTR [rbx+25], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0015f	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00163	48 85 c9	 test	 rcx, rcx
  00166	74 19		 je	 SHORT $LN88@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00168	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0016f	48 85 c0	 test	 rax, rax
  00172	74 06		 je	 SHORT $LN86@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00174	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN86@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00180	90		 npad	 1
$LN88@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00181	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00185	48 85 c9	 test	 rcx, rcx
  00188	74 19		 je	 SHORT $LN100@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0018a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00191	48 85 c0	 test	 rax, rax
  00194	74 06		 je	 SHORT $LN98@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00196	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN98@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001a2	90		 npad	 1
$LN100@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  001a3	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  001a7	48 85 c9	 test	 rcx, rcx
  001aa	74 19		 je	 SHORT $LN120@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  001ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  001b3	48 85 c0	 test	 rax, rax
  001b6	74 06		 je	 SHORT $LN110@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  001b8	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN110@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001c4	90		 npad	 1
$LN120@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1986 : }

  001c5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001ca	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001cf	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  001d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d8	41 5e		 pop	 r14
  001da	c3		 ret	 0
??1ImFontAtlas@@QEAA@XZ ENDP				; ImFontAtlas::~ImFontAtlas
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 112
??0ImDrawListSharedData@@QEAA@XZ PROC			; ImDrawListSharedData::ImDrawListSharedData

; 376  : {

$LN35:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 720  :     ImDrawListFlags InitialFlags;               // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)

  00014	48 8d 71 30	 lea	 rsi, QWORD PTR [rcx+48]
  00018	0f 29 7c 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 265  :     ImVec4() { x = y = z = w = 0.0f; }

  0001d	33 db		 xor	 ebx, ebx
  0001f	44 0f 29 44 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 376  : {

  00025	48 8b f9	 mov	 rdi, rcx
  00028	44 0f 29 4c 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 720  :     ImDrawListFlags InitialFlags;               // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)

  0002e	48 8b c6	 mov	 rax, rsi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 265  :     ImVec4() { x = y = z = w = 0.0f; }

  00031	48 89 59 24	 mov	 QWORD PTR [rcx+36], rbx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 376  : {

  00035	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 265  :     ImVec4() { x = y = z = w = 0.0f; }

  0003a	89 59 20	 mov	 DWORD PTR [rcx+32], ebx
  0003d	0f 1f 00	 npad	 3
$LL29@ImDrawList:

; 252  :     ImVec2() { x = y = 0.0f; }

  00040	48 89 18	 mov	 QWORD PTR [rax], rbx
  00043	48 8d 40 08	 lea	 rax, QWORD PTR [rax+8]
  00047	48 83 ea 01	 sub	 rdx, 1
  0004b	75 f3		 jne	 SHORT $LL29@ImDrawList
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 377  :     memset(this, 0, sizeof(*this));

  0004d	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00053	e8 00 00 00 00	 call	 memset
  00058	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@40490fdb
  00061	f3 44 0f 10 0d
	00 00 00 00	 movss	 xmm9, DWORD PTR __real@42400000
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL4@ImDrawList:

; 378  :     for (int i = 0; i < IM_ARRAYSIZE(ArcFastVtx); i++)
; 379  :     {
; 380  :         const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(ArcFastVtx);

  00070	66 0f 6e fb	 movd	 xmm7, ebx
  00074	0f 5b ff	 cvtdq2ps xmm7, xmm7
  00077	f3 0f 58 ff	 addss	 xmm7, xmm7
  0007b	f3 41 0f 59 f8	 mulss	 xmm7, xmm8
  00080	f3 41 0f 5e f9	 divss	 xmm7, xmm9

; 381  :         ArcFastVtx[i] = ImVec2(ImCos(a), ImSin(a));

  00085	0f 28 c7	 movaps	 xmm0, xmm7
  00088	e8 00 00 00 00	 call	 cosf
  0008d	0f 28 f0	 movaps	 xmm6, xmm0
  00090	0f 28 c7	 movaps	 xmm0, xmm7
  00093	e8 00 00 00 00	 call	 sinf
  00098	f3 0f 11 46 04	 movss	 DWORD PTR [rsi+4], xmm0
  0009d	ff c3		 inc	 ebx
  0009f	f3 0f 11 36	 movss	 DWORD PTR [rsi], xmm6
  000a3	48 83 c6 08	 add	 rsi, 8
  000a7	83 fb 30	 cmp	 ebx, 48			; 00000030H
  000aa	7c c4		 jl	 SHORT $LL4@ImDrawList

; 382  :     }
; 383  :     ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);

  000ac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d860a92
  000b4	f3 0f 10 77 18	 movss	 xmm6, DWORD PTR [rdi+24]
  000b9	e8 00 00 00 00	 call	 cosf
  000be	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000

; 384  : }

  000c6	48 8b c7	 mov	 rax, rdi
  000c9	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000ce	f3 0f 5c c8	 subss	 xmm1, xmm0
  000d2	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  000d7	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]
  000dc	44 0f 28 44 24
	30		 movaps	 xmm8, XMMWORD PTR [rsp+48]
  000e2	44 0f 28 4c 24
	20		 movaps	 xmm9, XMMWORD PTR [rsp+32]
  000e8	f3 0f 5e f1	 divss	 xmm6, xmm1
  000ec	f3 0f 11 b7 b0
	01 00 00	 movss	 DWORD PTR [rdi+432], xmm6
  000f4	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  000f9	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
??0ImDrawListSharedData@@QEAA@XZ ENDP			; ImDrawListSharedData::ImDrawListSharedData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 80
max_error$ = 88
?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z PROC ; ImDrawListSharedData::SetCircleTessellationMaxError

; 387  : {

$LN28:
  00000	40 56		 push	 rsi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 388  :     if (CircleSegmentMaxError == max_error)

  00006	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [rcx+24]
  0000b	48 8b f1	 mov	 rsi, rcx
  0000e	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00013	0f 28 f1	 movaps	 xmm6, xmm1
  00016	0f 2e c6	 ucomiss xmm0, xmm6
  00019	7a 06		 jp	 SHORT $LN26@SetCircleT
  0001b	0f 84 f6 00 00
	00		 je	 $LN1@SetCircleT
$LN26@SetCircleT:
  00021	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00026	0f 57 c0	 xorps	 xmm0, xmm0

; 389  :         return;
; 390  : 
; 391  :     IM_ASSERT(max_error > 0.0f);

  00029	0f 2f f0	 comiss	 xmm6, xmm0
  0002c	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00031	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00036	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  0003b	77 1a		 ja	 SHORT $LN7@SetCircleT
  0003d	41 b8 87 01 00
	00		 mov	 r8d, 391		; 00000187H
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@JCMOPDC@?$AAm?$AAa?$AAx?$AA_?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0@
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN7@SetCircleT:

; 392  :     CircleSegmentMaxError = max_error;

  00057	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@40490fdb
  0005f	48 8d be b4 01
	00 00		 lea	 rdi, QWORD PTR [rsi+436]
  00066	f3 0f 11 76 18	 movss	 DWORD PTR [rsi+24], xmm6
  0006b	33 db		 xor	 ebx, ebx
  0006d	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3f800000
  00075	bd 00 02 00 00	 mov	 ebp, 512		; 00000200H
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL4@SetCircleT:

; 393  :     for (int i = 0; i < IM_ARRAYSIZE(CircleSegmentCounts); i++)
; 394  :     {
; 395  :         const float radius = (float)i;

  00080	66 0f 6e c3	 movd	 xmm0, ebx
  00084	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 396  :         CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : 0);

  00087	85 db		 test	 ebx, ebx
  00089	74 48		 je	 SHORT $LN8@SetCircleT
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 424  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

  0008b	f3 0f 10 4e 18	 movss	 xmm1, DWORD PTR [rsi+24]
  00090	f3 0f 5d c8	 minss	 xmm1, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 396  :         CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : 0);

  00094	f3 0f 5e c8	 divss	 xmm1, xmm0
  00098	0f 28 c6	 movaps	 xmm0, xmm6
  0009b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0009f	e8 00 00 00 00	 call	 acosf
  000a4	0f 28 cf	 movaps	 xmm1, xmm7
  000a7	f3 0f 5e c8	 divss	 xmm1, xmm0
  000ab	0f 28 c1	 movaps	 xmm0, xmm1
  000ae	e8 00 00 00 00	 call	 ceilf
  000b3	f3 0f 2c c0	 cvttss2si eax, xmm0
  000b7	ff c0		 inc	 eax
  000b9	99		 cdq
  000ba	2b c2		 sub	 eax, edx
  000bc	d1 f8		 sar	 eax, 1
  000be	03 c0		 add	 eax, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 426  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

  000c0	83 f8 04	 cmp	 eax, 4
  000c3	7d 07		 jge	 SHORT $LN16@SetCircleT
  000c5	b8 04 00 00 00	 mov	 eax, 4
  000ca	eb 09		 jmp	 SHORT $LN9@SetCircleT
$LN16@SetCircleT:
  000cc	3b c5		 cmp	 eax, ebp
  000ce	0f 4f c5	 cmovg	 eax, ebp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 396  :         CircleSegmentCounts[i] = (ImU8)((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, CircleSegmentMaxError) : 0);

  000d1	eb 02		 jmp	 SHORT $LN9@SetCircleT
$LN8@SetCircleT:
  000d3	33 c0		 xor	 eax, eax
$LN9@SetCircleT:
  000d5	88 07		 mov	 BYTE PTR [rdi], al
  000d7	ff c3		 inc	 ebx
  000d9	48 ff c7	 inc	 rdi
  000dc	83 fb 40	 cmp	 ebx, 64			; 00000040H
  000df	7c 9f		 jl	 SHORT $LL4@SetCircleT

; 397  :     }
; 398  :     ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, CircleSegmentMaxError);

  000e1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d860a92
  000e9	e8 00 00 00 00	 call	 cosf
  000ee	f3 0f 10 4e 18	 movss	 xmm1, DWORD PTR [rsi+24]
  000f3	f3 0f 5c f0	 subss	 xmm6, xmm0
  000f7	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  000fc	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00101	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00106	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0010b	f3 0f 5e ce	 divss	 xmm1, xmm6
  0010f	f3 0f 11 8e b0
	01 00 00	 movss	 DWORD PTR [rsi+432], xmm1
$LN1@SetCircleT:

; 399  : }

  00117	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0011c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00120	5e		 pop	 rsi
  00121	c3		 ret	 0
?SetCircleTessellationMaxError@ImDrawListSharedData@@QEAAXM@Z ENDP ; ImDrawListSharedData::SetCircleTessellationMaxError
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
current$1 = 32
cr_max$ = 32
cr$ = 48
cr_min$ = 80
this$ = 80
intersect_with_current_clip_rect$ = 104
?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z PROC	; ImDrawList::PushClipRect

; 584  : {

$LN26:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 20	 mov	 QWORD PTR [rax+32], rbx
  00007	57		 push	 rdi
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000c	48 89 54 24 50	 mov	 QWORD PTR cr_min$[rsp], rdx
  00011	48 8b f9	 mov	 rdi, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00014	f3 0f 10 4c 24
	50		 movss	 xmm1, DWORD PTR cr_min$[rsp]
  0001a	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR cr_min$[rsp+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 584  : {

  00020	4c 89 44 24 20	 mov	 QWORD PTR cr_max$[rsp], r8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  00025	f3 0f 10 5c 24
	20		 movss	 xmm3, DWORD PTR cr_max$[rsp]
  0002b	f3 0f 10 54 24
	24		 movss	 xmm2, DWORD PTR cr_max$[rsp+4]
  00031	f3 0f 11 48 e8	 movss	 DWORD PTR [rax-24], xmm1
  00036	f3 0f 11 40 ec	 movss	 DWORD PTR [rax-20], xmm0
  0003b	f3 0f 11 58 f0	 movss	 DWORD PTR [rax-16], xmm3
  00040	f3 0f 11 50 f4	 movss	 DWORD PTR [rax-12], xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 586  :     if (intersect_with_current_clip_rect)

  00045	45 84 c9	 test	 r9b, r9b
  00048	74 54		 je	 SHORT $LN6@PushClipRe

; 587  :     {
; 588  :         ImVec4 current = _CmdHeader.ClipRect;

  0004a	0f 10 a1 88 00
	00 00		 movups	 xmm4, XMMWORD PTR [rcx+136]

; 589  :         if (cr.x < current.x) cr.x = current.x;

  00051	0f 2f e1	 comiss	 xmm4, xmm1
  00054	0f 11 60 d8	 movups	 XMMWORD PTR [rax-40], xmm4
  00058	76 08		 jbe	 SHORT $LN3@PushClipRe
  0005a	f3 0f 11 60 e8	 movss	 DWORD PTR [rax-24], xmm4
  0005f	0f 28 cc	 movaps	 xmm1, xmm4
$LN3@PushClipRe:

; 590  :         if (cr.y < current.y) cr.y = current.y;

  00062	f3 0f 10 64 24
	24		 movss	 xmm4, DWORD PTR current$1[rsp+4]
  00068	0f 2f e0	 comiss	 xmm4, xmm0
  0006b	76 09		 jbe	 SHORT $LN4@PushClipRe
  0006d	f3 0f 11 64 24
	34		 movss	 DWORD PTR cr$[rsp+4], xmm4
  00073	0f 28 c4	 movaps	 xmm0, xmm4
$LN4@PushClipRe:

; 591  :         if (cr.z > current.z) cr.z = current.z;

  00076	f3 0f 10 64 24
	28		 movss	 xmm4, DWORD PTR current$1[rsp+8]
  0007c	0f 2f dc	 comiss	 xmm3, xmm4
  0007f	76 09		 jbe	 SHORT $LN5@PushClipRe
  00081	f3 0f 11 64 24
	38		 movss	 DWORD PTR cr$[rsp+8], xmm4
  00087	0f 28 dc	 movaps	 xmm3, xmm4
$LN5@PushClipRe:

; 592  :         if (cr.w > current.w) cr.w = current.w;

  0008a	f3 0f 10 64 24
	2c		 movss	 xmm4, DWORD PTR current$1[rsp+12]
  00090	0f 2f d4	 comiss	 xmm2, xmm4
  00093	76 09		 jbe	 SHORT $LN6@PushClipRe
  00095	f3 0f 11 64 24
	3c		 movss	 DWORD PTR cr$[rsp+12], xmm4
  0009b	0f 28 d4	 movaps	 xmm2, xmm4
$LN6@PushClipRe:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  0009e	0f 2f cb	 comiss	 xmm1, xmm3
  000a1	72 06		 jb	 SHORT $LN12@PushClipRe
  000a3	f3 0f 11 4c 24
	38		 movss	 DWORD PTR cr$[rsp+8], xmm1
$LN12@PushClipRe:
  000a9	0f 2f c2	 comiss	 xmm0, xmm2
  000ac	72 06		 jb	 SHORT $LN16@PushClipRe
  000ae	f3 0f 11 44 24
	3c		 movss	 DWORD PTR cr$[rsp+12], xmm0
$LN16@PushClipRe:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000b4	8b 41 58	 mov	 eax, DWORD PTR [rcx+88]
  000b7	8b 49 5c	 mov	 ecx, DWORD PTR [rcx+92]
  000ba	3b c1		 cmp	 eax, ecx
  000bc	75 2e		 jne	 SHORT $LN19@PushClipRe
  000be	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000c2	85 c9		 test	 ecx, ecx
  000c4	74 0b		 je	 SHORT $LN23@PushClipRe
  000c6	8b c1		 mov	 eax, ecx
  000c8	99		 cdq
  000c9	2b c2		 sub	 eax, edx
  000cb	d1 f8		 sar	 eax, 1
  000cd	03 c1		 add	 eax, ecx
  000cf	eb 05		 jmp	 SHORT $LN24@PushClipRe
$LN23@PushClipRe:
  000d1	b8 08 00 00 00	 mov	 eax, 8
$LN24@PushClipRe:
  000d6	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000d9	48 8d 4f 58	 lea	 rcx, QWORD PTR [rdi+88]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000dd	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000e1	41 8b d0	 mov	 edx, r8d
  000e4	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z ; ImVector<ImVec4>::reserve
  000e9	8b 47 58	 mov	 eax, DWORD PTR [rdi+88]
$LN19@PushClipRe:
  000ec	0f 10 44 24 30	 movups	 xmm0, XMMWORD PTR cr$[rsp]
  000f1	48 63 c8	 movsxd	 rcx, eax
  000f4	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  000f8	48 03 c9	 add	 rcx, rcx
  000fb	0f 11 04 c8	 movups	 XMMWORD PTR [rax+rcx*8], xmm0
  000ff	ff 47 58	 inc	 DWORD PTR [rdi+88]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 599  :     _OnChangedClipRect();

  00102	48 8b cf	 mov	 rcx, rdi
  00105	0f 11 87 88 00
	00 00		 movups	 XMMWORD PTR [rdi+136], xmm0

; 600  : }

  0010c	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00111	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00115	5f		 pop	 rdi

; 599  :     _OnChangedClipRect();

  00116	e9 00 00 00 00	 jmp	 ?_OnChangedClipRect@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedClipRect
?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z ENDP	; ImDrawList::PushClipRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?PopClipRect@ImDrawList@@QEAAXXZ PROC			; ImDrawList::PopClipRect

; 608  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1815 :     inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

  00006	8b 41 58	 mov	 eax, DWORD PTR [rcx+88]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 608  : {

  00009	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1815 :     inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

  0000c	85 c0		 test	 eax, eax
  0000e	7f 1d		 jg	 SHORT $LN7@PopClipRec
  00010	41 b8 17 07 00
	00		 mov	 r8d, 1815		; 00000717H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002a	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
$LN7@PopClipRec:
  0002d	83 e8 01	 sub	 eax, 1
  00030	89 43 58	 mov	 DWORD PTR [rbx+88], eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 610  :     _CmdHeader.ClipRect = (_ClipRectStack.Size == 0) ? _Data->ClipRectFullscreen : _ClipRectStack.Data[_ClipRectStack.Size - 1];

  00033	75 0a		 jne	 SHORT $LN3@PopClipRec
  00035	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00039	48 83 c0 1c	 add	 rax, 28
  0003d	eb 0c		 jmp	 SHORT $LN4@PopClipRec
$LN3@PopClipRec:
  0003f	ff c8		 dec	 eax
  00041	48 98		 cdqe
  00043	48 c1 e0 04	 shl	 rax, 4
  00047	48 03 43 60	 add	 rax, QWORD PTR [rbx+96]
$LN4@PopClipRec:
  0004b	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]

; 611  :     _OnChangedClipRect();

  0004e	48 8b cb	 mov	 rcx, rbx
  00051	0f 11 83 88 00
	00 00		 movups	 XMMWORD PTR [rbx+136], xmm0

; 612  : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5b		 pop	 rbx

; 611  :     _OnChangedClipRect();

  0005d	e9 00 00 00 00	 jmp	 ?_OnChangedClipRect@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedClipRect
?PopClipRect@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::PopClipRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
texture_id$ = 56
?PushTextureID@ImDrawList@@QEAAXPEAX@Z PROC		; ImDrawList::PushTextureID

; 615  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0000f	8b 41 68	 mov	 eax, DWORD PTR [rcx+104]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 615  : {

  00012	48 8b f2	 mov	 rsi, rdx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00015	44 8b 41 6c	 mov	 r8d, DWORD PTR [rcx+108]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 615  : {

  00019	48 8b f9	 mov	 rdi, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0001c	41 3b c0	 cmp	 eax, r8d
  0001f	75 2d		 jne	 SHORT $LN4@PushTextur
  00021	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00024	45 85 c0	 test	 r8d, r8d
  00027	74 0d		 je	 SHORT $LN8@PushTextur
  00029	41 8b c0	 mov	 eax, r8d
  0002c	99		 cdq
  0002d	2b c2		 sub	 eax, edx
  0002f	d1 f8		 sar	 eax, 1
  00031	41 03 c0	 add	 eax, r8d
  00034	eb 05		 jmp	 SHORT $LN9@PushTextur
$LN8@PushTextur:
  00036	b8 08 00 00 00	 mov	 eax, 8
$LN9@PushTextur:
  0003b	3b c1		 cmp	 eax, ecx
  0003d	0f 4f c8	 cmovg	 ecx, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00040	8b d1		 mov	 edx, ecx
  00042	48 8d 4f 68	 lea	 rcx, QWORD PTR [rdi+104]
  00046	e8 00 00 00 00	 call	 ?reserve@?$ImVector@PEAX@@QEAAXH@Z ; ImVector<void *>::reserve
  0004b	8b 47 68	 mov	 eax, DWORD PTR [rdi+104]
$LN4@PushTextur:
  0004e	48 63 c8	 movsxd	 rcx, eax
  00051	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00055	48 89 34 c8	 mov	 QWORD PTR [rax+rcx*8], rsi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 618  :     _OnChangedTextureID();

  00059	48 8b cf	 mov	 rcx, rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0005c	ff 47 68	 inc	 DWORD PTR [rdi+104]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 617  :     _CmdHeader.TextureId = texture_id;

  0005f	48 89 b7 98 00
	00 00		 mov	 QWORD PTR [rdi+152], rsi

; 619  : }

  00066	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi

; 618  :     _OnChangedTextureID();

  00075	e9 00 00 00 00	 jmp	 ?_OnChangedTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedTextureID
?PushTextureID@ImDrawList@@QEAAXPEAX@Z ENDP		; ImDrawList::PushTextureID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?PopTextureID@ImDrawList@@QEAAXXZ PROC			; ImDrawList::PopTextureID

; 622  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1815 :     inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

  00009	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  0000c	85 c9		 test	 ecx, ecx
  0000e	7f 1d		 jg	 SHORT $LN7@PopTexture
  00010	41 b8 17 07 00
	00		 mov	 r8d, 1815		; 00000717H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002a	8b 4b 68	 mov	 ecx, DWORD PTR [rbx+104]
$LN7@PopTexture:
  0002d	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00030	89 43 68	 mov	 DWORD PTR [rbx+104], eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 624  :     _CmdHeader.TextureId = (_TextureIdStack.Size == 0) ? (ImTextureID)NULL : _TextureIdStack.Data[_TextureIdStack.Size - 1];

  00033	85 c0		 test	 eax, eax
  00035	75 04		 jne	 SHORT $LN3@PopTexture
  00037	33 c0		 xor	 eax, eax
  00039	eb 0c		 jmp	 SHORT $LN4@PopTexture
$LN3@PopTexture:
  0003b	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  0003f	48 63 c9	 movsxd	 rcx, ecx
  00042	48 8b 44 c8 f0	 mov	 rax, QWORD PTR [rax+rcx*8-16]
$LN4@PopTexture:

; 625  :     _OnChangedTextureID();

  00047	48 8b cb	 mov	 rcx, rbx
  0004a	48 89 83 98 00
	00 00		 mov	 QWORD PTR [rbx+152], rax

; 626  : }

  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5b		 pop	 rbx

; 625  :     _OnChangedTextureID();

  00056	e9 00 00 00 00	 jmp	 ?_OnChangedTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::_OnChangedTextureID
?PopTextureID@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::PopTextureID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
this$ = 96
p1$ = 104
p2$ = 112
col$ = 120
thickness$ = 128
?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z PROC	; ImDrawList::AddLine

; 1383 : {

$LN38:

; 1384 :     if ((col & IM_COL32_A_MASK) == 0)

  00000	41 f7 c1 00 00
	00 ff		 test	 r9d, -16777216		; ff000000H
  00007	0f 84 52 01 00
	00		 je	 $LN36@AddLine
  0000d	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00012	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00017	41 56		 push	 r14
  00019	48 83 ec 50	 sub	 rsp, 80			; 00000050H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  0001d	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1383 : {

  00021	48 8b f1	 mov	 rsi, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00024	8b 41 78	 mov	 eax, DWORD PTR [rcx+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1383 : {

  00027	41 8b e9	 mov	 ebp, r9d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0002a	8b 49 7c	 mov	 ecx, DWORD PTR [rcx+124]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1383 : {

  0002d	4d 8b f0	 mov	 r14, r8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00030	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00035	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0003a	bf 08 00 00 00	 mov	 edi, 8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  0003f	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  00044	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3f000000
  0004c	f3 0f 58 c6	 addss	 xmm0, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00050	f3 0f 11 44 24
	30		 movss	 DWORD PTR $T2[rsp], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00056	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [rdx+4]
  0005b	f3 0f 58 c6	 addss	 xmm0, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0005f	f3 0f 11 44 24
	34		 movss	 DWORD PTR $T2[rsp+4], xmm0

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00065	3b c1		 cmp	 eax, ecx
  00067	75 2b		 jne	 SHORT $LN13@AddLine
  00069	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0006d	85 c9		 test	 ecx, ecx
  0006f	74 0b		 je	 SHORT $LN17@AddLine
  00071	8b c1		 mov	 eax, ecx
  00073	99		 cdq
  00074	2b c2		 sub	 eax, edx
  00076	d1 f8		 sar	 eax, 1
  00078	03 c1		 add	 eax, ecx
  0007a	eb 02		 jmp	 SHORT $LN18@AddLine
$LN17@AddLine:
  0007c	8b c7		 mov	 eax, edi
$LN18@AddLine:
  0007e	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00081	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00085	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00089	41 8b d0	 mov	 edx, r8d
  0008c	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00091	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN13@AddLine:
  00094	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  0009b	48 63 d0	 movsxd	 rdx, eax
  0009e	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp]
  000a3	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  000a7	ff 46 78	 inc	 DWORD PTR [rsi+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  000aa	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  000af	f3 41 0f 10 4e
	04		 movss	 xmm1, DWORD PTR [r14+4]
  000b5	f3 0f 58 c6	 addss	 xmm0, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000b9	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  000bc	f3 0f 58 ce	 addss	 xmm1, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000c0	44 8b 46 7c	 mov	 r8d, DWORD PTR [rsi+124]
  000c4	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  000c9	f3 0f 11 44 24
	30		 movss	 DWORD PTR $T1[rsp], xmm0
  000cf	f3 0f 11 4c 24
	34		 movss	 DWORD PTR $T1[rsp+4], xmm1

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000d5	41 3b c0	 cmp	 eax, r8d
  000d8	75 27		 jne	 SHORT $LN28@AddLine
  000da	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000dd	45 85 c0	 test	 r8d, r8d
  000e0	74 0c		 je	 SHORT $LN32@AddLine
  000e2	41 8b c0	 mov	 eax, r8d
  000e5	99		 cdq
  000e6	2b c2		 sub	 eax, edx
  000e8	d1 f8		 sar	 eax, 1
  000ea	41 8d 3c 00	 lea	 edi, DWORD PTR [r8+rax]
$LN32@AddLine:
  000ee	3b f9		 cmp	 edi, ecx
  000f0	0f 4f cf	 cmovg	 ecx, edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000f3	8b d1		 mov	 edx, ecx
  000f5	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  000f9	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  000fe	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN28@AddLine:
  00101	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  00108	33 ff		 xor	 edi, edi
  0010a	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR thickness$[rsp]
  00113	44 8b cd	 mov	 r9d, ebp

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00116	48 63 d0	 movsxd	 rdx, eax
  00119	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  0011e	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00124	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00128	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  0012c	48 8b ce	 mov	 rcx, rsi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0012f	ff 46 78	 inc	 DWORD PTR [rsi+120]

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  00132	44 8b 46 78	 mov	 r8d, DWORD PTR [rsi+120]
  00136	48 8b 96 80 00
	00 00		 mov	 rdx, QWORD PTR [rsi+128]
  0013d	e8 00 00 00 00	 call	 ?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
  00142	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1389 : }

  00147	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  0014c	89 7e 78	 mov	 DWORD PTR [rsi+120], edi
  0014f	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1389 : }

  00154	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00159	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0015d	41 5e		 pop	 r14
$LN36@AddLine:
  0015f	c3		 ret	 0
?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z ENDP	; ImDrawList::AddLine
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
this$ = 80
p_min$ = 88
p_max$ = 96
col$ = 104
rounding$ = 112
flags$dead$ = 120
thickness$ = 128
?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z PROC	; ImDrawList::AddRect

; 1394 : {

$LN35:

; 1395 :     if ((col & IM_COL32_A_MASK) == 0)

  00000	41 f7 c1 00 00
	00 ff		 test	 r9d, -16777216		; ff000000H
  00007	0f 84 e4 00 00
	00		 je	 $LN32@AddRect
  0000d	48 8b c4	 mov	 rax, rsp
  00010	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00014	56		 push	 rsi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1396 :         return;
; 1397 :     if (Flags & ImDrawListFlags_AntiAliasedLines)

  00019	f6 41 30 01	 test	 BYTE PTR [rcx+48], 1
  0001d	41 8b f1	 mov	 esi, r9d
  00020	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00028	48 8b d9	 mov	 rbx, rcx
  0002b	f3 0f 10 1a	 movss	 xmm3, DWORD PTR [rdx]
  0002f	f3 0f 10 62 04	 movss	 xmm4, DWORD PTR [rdx+4]
  00034	f3 0f 58 d8	 addss	 xmm3, xmm0
  00038	f3 41 0f 10 08	 movss	 xmm1, DWORD PTR [r8]
  0003d	f3 0f 58 e0	 addss	 xmm4, xmm0
  00041	f3 41 0f 10 50
	04		 movss	 xmm2, DWORD PTR [r8+4]
  00047	c7 40 d8 00 00
	00 00		 mov	 DWORD PTR [rax-40], 0
  0004e	74 26		 je	 SHORT $LN3@AddRect
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00050	f3 0f 5c c8	 subss	 xmm1, xmm0
  00054	f3 0f 11 58 f0	 movss	 DWORD PTR [rax-16], xmm3
  00059	f3 0f 5c d0	 subss	 xmm2, xmm0
  0005d	f3 0f 11 60 f4	 movss	 DWORD PTR [rax-12], xmm4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1398 :         PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);

  00062	4c 8d 40 e8	 lea	 r8, QWORD PTR [rax-24]
  00066	48 8d 50 f0	 lea	 rdx, QWORD PTR [rax-16]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0006a	f3 0f 11 48 e8	 movss	 DWORD PTR [rax-24], xmm1
  0006f	f3 0f 11 50 ec	 movss	 DWORD PTR [rax-20], xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1398 :         PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.50f, 0.50f), rounding, flags);

  00074	eb 32		 jmp	 SHORT $LN33@AddRect
$LN3@AddRect:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00076	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3efae148
  0007e	f3 0f 5c 15 00
	00 00 00	 subss	 xmm2, DWORD PTR __real@3efae148
  00086	f3 0f 11 5c 24
	30		 movss	 DWORD PTR $T1[rsp], xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1400 :         PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.

  0008c	4c 8d 44 24 38	 lea	 r8, QWORD PTR $T2[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00091	f3 0f 11 64 24
	34		 movss	 DWORD PTR $T1[rsp+4], xmm4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1400 :         PathRect(p_min + ImVec2(0.50f, 0.50f), p_max - ImVec2(0.49f, 0.49f), rounding, flags); // Better looking lower-right corner and rounded non-AA shapes.

  00097	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0009c	f3 0f 11 4c 24
	38		 movss	 DWORD PTR $T2[rsp], xmm1
  000a2	f3 0f 11 54 24
	3c		 movss	 DWORD PTR $T2[rsp+4], xmm2
$LN33@AddRect:

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  000a8	f3 0f 10 5c 24
	70		 movss	 xmm3, DWORD PTR rounding$[rsp]
  000ae	e8 00 00 00 00	 call	 ?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ; ImDrawList::PathRect
  000b3	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR thickness$[rsp]
  000bc	44 8b ce	 mov	 r9d, esi
  000bf	44 8b 43 78	 mov	 r8d, DWORD PTR [rbx+120]
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  000cd	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  000d3	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000db	e8 00 00 00 00	 call	 ?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
  000e0	c7 43 78 00 00
	00 00		 mov	 DWORD PTR [rbx+120], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1402 : }

  000e7	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ec	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f0	5e		 pop	 rsi
$LN32@AddRect:
  000f1	c3		 ret	 0
?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z ENDP	; ImDrawList::AddRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 80
p_min$ = 88
p_max$ = 96
col$ = 104
rounding$ = 112
flags$ = 120
?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z PROC	; ImDrawList::AddRectFilled

; 1405 : {

$LN17:

; 1406 :     if ((col & IM_COL32_A_MASK) == 0)

  00000	41 f7 c1 00 00
	00 ff		 test	 r9d, -16777216		; ff000000H
  00007	0f 84 92 01 00
	00		 je	 $LN15@AddRectFil
  0000d	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00012	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00017	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0001c	57		 push	 rdi
  0001d	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1407 :         return;
; 1408 :     if (rounding <= 0.0f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)

  00021	f3 0f 10 5c 24
	70		 movss	 xmm3, DWORD PTR rounding$[rsp]
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	0f 2f c3	 comiss	 xmm0, xmm3
  0002d	41 8b f9	 mov	 edi, r9d
  00030	49 8b f0	 mov	 rsi, r8
  00033	48 8b ea	 mov	 rbp, rdx
  00036	48 8b d9	 mov	 rbx, rcx
  00039	73 40		 jae	 SHORT $LN5@AddRectFil
  0003b	8b 4c 24 78	 mov	 ecx, DWORD PTR flags$[rsp]
  0003f	8b c1		 mov	 eax, ecx
  00041	25 f0 01 00 00	 and	 eax, 496		; 000001f0H
  00046	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0004b	74 2e		 je	 SHORT $LN5@AddRectFil

; 1411 :         PrimRect(p_min, p_max, col);
; 1412 :     }
; 1413 :     else
; 1414 :     {
; 1415 :         PathRect(p_min, p_max, rounding, flags);

  0004d	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 ?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ; ImDrawList::PathRect
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2569 :     inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  00059	44 8b 43 78	 mov	 r8d, DWORD PTR [rbx+120]
  0005d	44 8b cf	 mov	 r9d, edi
  00060	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  00067	48 8b cb	 mov	 rcx, rbx
  0006a	e8 00 00 00 00	 call	 ?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
  0006f	c7 43 78 00 00
	00 00		 mov	 DWORD PTR [rbx+120], 0
  00076	e9 10 01 00 00	 jmp	 $LN4@AddRectFil
$LN5@AddRectFil:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1410 :         PrimReserve(6, 4);

  0007b	ba 06 00 00 00	 mov	 edx, 6
  00080	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00085	48 8b cb	 mov	 rcx, rbx
  00088	44 8d 42 fe	 lea	 r8d, QWORD PTR [rdx-2]
  0008c	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve

; 671  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

  00091	0f b7 53 34	 movzx	 edx, WORD PTR [rbx+52]
  00095	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00099	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [rsi]
  0009d	f3 0f 10 55 04	 movss	 xmm2, DWORD PTR [rbp+4]
  000a2	f3 0f 10 5d 00	 movss	 xmm3, DWORD PTR [rbp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 672  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

  000a7	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
  000aa	f3 0f 10 70 04	 movss	 xmm6, DWORD PTR [rax+4]
  000af	f3 0f 10 28	 movss	 xmm5, DWORD PTR [rax]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  000b3	f3 0f 10 66 04	 movss	 xmm4, DWORD PTR [rsi+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 672  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

  000b8	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000bc	66 89 10	 mov	 WORD PTR [rax], dx
  000bf	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000c3	66 89 48 02	 mov	 WORD PTR [rax+2], cx
  000c7	8d 4a 02	 lea	 ecx, DWORD PTR [rdx+2]
  000ca	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000ce	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 673  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx + 3);

  000d2	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000d6	66 89 50 06	 mov	 WORD PTR [rax+6], dx
  000da	66 83 c2 03	 add	 dx, 3
  000de	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000e2	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  000e6	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000ea	66 89 50 0a	 mov	 WORD PTR [rax+10], dx

; 674  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

  000ee	f2 0f 10 45 00	 movsd	 xmm0, QWORD PTR [rbp]
  000f3	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000f7	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  000fb	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000ff	f3 0f 11 68 08	 movss	 DWORD PTR [rax+8], xmm5
  00104	f3 0f 11 70 0c	 movss	 DWORD PTR [rax+12], xmm6
  00109	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  0010d	89 78 10	 mov	 DWORD PTR [rax+16], edi

; 675  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

  00110	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00114	f3 0f 11 48 14	 movss	 DWORD PTR [rax+20], xmm1
  00119	f3 0f 11 50 18	 movss	 DWORD PTR [rax+24], xmm2
  0011e	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00122	f3 0f 11 68 1c	 movss	 DWORD PTR [rax+28], xmm5
  00127	f3 0f 11 70 20	 movss	 DWORD PTR [rax+32], xmm6
  0012c	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00130	89 78 24	 mov	 DWORD PTR [rax+36], edi

; 676  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

  00133	f2 0f 10 06	 movsd	 xmm0, QWORD PTR [rsi]
  00137	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  0013b	f2 0f 11 40 28	 movsd	 QWORD PTR [rax+40], xmm0
  00140	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00144	f3 0f 11 68 30	 movss	 DWORD PTR [rax+48], xmm5
  00149	f3 0f 11 70 34	 movss	 DWORD PTR [rax+52], xmm6
  0014e	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00152	89 78 38	 mov	 DWORD PTR [rax+56], edi

; 677  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

  00155	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00159	f3 0f 11 58 3c	 movss	 DWORD PTR [rax+60], xmm3
  0015e	f3 0f 11 60 40	 movss	 DWORD PTR [rax+64], xmm4
  00163	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00167	f3 0f 11 68 44	 movss	 DWORD PTR [rax+68], xmm5
  0016c	f3 0f 11 70 48	 movss	 DWORD PTR [rax+72], xmm6
  00171	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]

; 678  :     _VtxWritePtr += 4;
; 679  :     _VtxCurrentIdx += 4;
; 680  :     _IdxWritePtr += 6;

  00175	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0017a	89 78 4c	 mov	 DWORD PTR [rax+76], edi
  0017d	48 83 43 48 50	 add	 QWORD PTR [rbx+72], 80	; 00000050H
  00182	83 43 34 04	 add	 DWORD PTR [rbx+52], 4
  00186	48 83 43 50 0c	 add	 QWORD PTR [rbx+80], 12
$LN4@AddRectFil:

; 1416 :         PathFillConvex(col);
; 1417 :     }
; 1418 : }

  0018b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00190	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00195	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0019a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0019e	5f		 pop	 rdi
$LN15@AddRectFil:
  0019f	c3		 ret	 0
?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z ENDP	; ImDrawList::AddRectFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
clip_rect$ = 80
this$ = 144
font$ = 152
font_size$ = 160
pos$ = 168
col$ = 176
text_begin$ = 184
text_end$ = 192
wrap_width$ = 200
cpu_fine_clip_rect$ = 208
?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z PROC ; ImDrawList::AddText

; 1577 : {

$LN33:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  00007	56		 push	 rsi
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

  00010	44 8b b4 24 b0
	00 00 00	 mov	 r14d, DWORD PTR col$[rsp]
  00018	4d 8b f9	 mov	 r15, r9
  0001b	0f 29 70 d8	 movaps	 XMMWORD PTR [rax-40], xmm6
  0001f	0f 28 f2	 movaps	 xmm6, xmm2
  00022	48 8b ea	 mov	 rbp, rdx
  00025	48 8b f1	 mov	 rsi, rcx
  00028	41 f7 c6 00 00
	00 ff		 test	 r14d, -16777216		; ff000000H
  0002f	0f 84 46 01 00
	00		 je	 $LN1@AddText

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)

  00035	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00039	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR text_end$[rsp]
  00041	48 89 78 10	 mov	 QWORD PTR [rax+16], rdi
  00045	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR text_begin$[rsp]
  0004d	48 85 db	 test	 rbx, rbx
  00050	75 1a		 jne	 SHORT $LN3@AddText

; 1582 :         text_end = text_begin + strlen(text_begin);

  00052	48 c7 c3 ff ff
	ff ff		 mov	 rbx, -1
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL28@AddText:
  00060	48 ff c3	 inc	 rbx
  00063	80 3c 1f 00	 cmp	 BYTE PTR [rdi+rbx], 0
  00067	75 f7		 jne	 SHORT $LL28@AddText
  00069	48 03 df	 add	 rbx, rdi
$LN3@AddText:

; 1583 :     if (text_begin == text_end)

  0006c	48 3b fb	 cmp	 rdi, rbx
  0006f	0f 84 f6 00 00
	00		 je	 $LN30@AddText

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)

  00075	48 85 d2	 test	 rdx, rdx
  00078	75 08		 jne	 SHORT $LN27@AddText

; 1588 :         font = _Data->Font;

  0007a	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0007e	48 8b 68 08	 mov	 rbp, QWORD PTR [rax+8]
$LN27@AddText:

; 1589 :     if (font_size == 0.0f)

  00082	0f 57 c0	 xorps	 xmm0, xmm0
  00085	0f 2e d0	 ucomiss xmm2, xmm0
  00088	7a 0b		 jp	 SHORT $LN6@AddText
  0008a	75 09		 jne	 SHORT $LN6@AddText

; 1590 :         font_size = _Data->FontSize;

  0008c	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00090	f3 0f 10 70 10	 movss	 xmm6, DWORD PTR [rax+16]
$LN6@AddText:

; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

  00095	48 8b 4d 40	 mov	 rcx, QWORD PTR [rbp+64]
  00099	48 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [rsi+152]
  000a0	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  000a4	74 1a		 je	 SHORT $LN9@AddText
  000a6	41 b8 38 06 00
	00		 mov	 r8d, 1592		; 00000638H
  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GI@CIGOLMNM@?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr@
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN9@AddText:

; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;

  000c0	0f 10 86 88 00
	00 00		 movups	 xmm0, XMMWORD PTR [rsi+136]

; 1595 :     if (cpu_fine_clip_rect)

  000c7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR cpu_fine_clip_rect$[rsp]
  000cf	0f 11 44 24 50	 movups	 XMMWORD PTR clip_rect$[rsp], xmm0
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 52		 je	 SHORT $LN31@AddText

; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);

  000d9	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  000dd	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR clip_rect$[rsp]
  000e3	0f 2f c1	 comiss	 xmm0, xmm1
  000e6	73 06		 jae	 SHORT $LN13@AddText
  000e8	f3 0f 11 4c 24
	50		 movss	 DWORD PTR clip_rect$[rsp], xmm1
$LN13@AddText:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);

  000ee	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [rax+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  000f3	f3 0f 10 44 24
	54		 movss	 xmm0, DWORD PTR clip_rect$[rsp+4]
  000f9	0f 2f c1	 comiss	 xmm0, xmm1
  000fc	73 06		 jae	 SHORT $LN17@AddText
  000fe	f3 0f 11 4c 24
	54		 movss	 DWORD PTR clip_rect$[rsp+4], xmm1
$LN17@AddText:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);

  00104	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 424  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

  00109	0f 2f 44 24 58	 comiss	 xmm0, DWORD PTR clip_rect$[rsp+8]
  0010e	77 06		 ja	 SHORT $LN21@AddText
  00110	f3 0f 11 44 24
	58		 movss	 DWORD PTR clip_rect$[rsp+8], xmm0
$LN21@AddText:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);

  00116	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 424  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

  0011b	0f 2f 44 24 5c	 comiss	 xmm0, DWORD PTR clip_rect$[rsp+12]
  00120	77 06		 ja	 SHORT $LN25@AddText
  00122	f3 0f 11 44 24
	5c		 movss	 DWORD PTR clip_rect$[rsp+12], xmm0
$LN25@AddText:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

  00128	48 85 c0	 test	 rax, rax
$LN31@AddText:
  0012b	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR wrap_width$[rsp]
  00134	0f 95 c0	 setne	 al
  00137	4d 8b 0f	 mov	 r9, QWORD PTR [r15]
  0013a	0f 28 d6	 movaps	 xmm2, xmm6
  0013d	88 44 24 48	 mov	 BYTE PTR [rsp+72], al
  00141	48 8b d6	 mov	 rdx, rsi
  00144	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  0014a	48 8d 44 24 50	 lea	 rax, QWORD PTR clip_rect$[rsp]
  0014f	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00154	48 8b cd	 mov	 rcx, rbp
  00157	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0015c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00161	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00166	e8 00 00 00 00	 call	 ?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
$LN30@AddText:
  0016b	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  00173	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR [rsp+152]
$LN1@AddText:

; 1603 : }

  0017b	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+160]
  00183	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  00188	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0018c	41 5f		 pop	 r15
  0018e	41 5e		 pop	 r14
  00190	5e		 pop	 rsi
  00191	c3		 ret	 0
?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z ENDP ; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
clip_rect$1 = 80
this$ = 144
pos$ = 152
col$ = 160
text_begin$ = 168
text_end$dead$ = 176
?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z PROC	; ImDrawList::AddText

; 1606 : {

$LN36:

; 1578 :     if ((col & IM_COL32_A_MASK) == 0)

  00000	41 f7 c0 00 00
	00 ff		 test	 r8d, -16777216		; ff000000H
  00007	0f 84 ee 00 00
	00		 je	 $LN34@AddText
  0000d	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00012	57		 push	 rdi
  00013	41 56		 push	 r14
  00015	41 57		 push	 r15
  00017	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 1579 :         return;
; 1580 : 
; 1581 :     if (text_end == NULL)
; 1582 :         text_end = text_begin + strlen(text_begin);

  0001b	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx

; 1606 : {

  00023	49 8b f9	 mov	 rdi, r9

; 1582 :         text_end = text_begin + strlen(text_begin);

  00026	48 c7 c3 ff ff
	ff ff		 mov	 rbx, -1

; 1606 : {

  0002d	45 8b f0	 mov	 r14d, r8d
  00030	4c 8b fa	 mov	 r15, rdx
  00033	48 8b f1	 mov	 rsi, rcx
$LL32@AddText:

; 1582 :         text_end = text_begin + strlen(text_begin);

  00036	48 ff c3	 inc	 rbx
  00039	41 80 3c 19 00	 cmp	 BYTE PTR [r9+rbx], 0
  0003e	75 f6		 jne	 SHORT $LL32@AddText
  00040	48 03 df	 add	 rbx, rdi

; 1583 :     if (text_begin == text_end)

  00043	48 3b fb	 cmp	 rdi, rbx
  00046	0f 84 96 00 00
	00		 je	 $LN33@AddText

; 1584 :         return;
; 1585 : 
; 1586 :     // Pull default font/size from the shared ImDrawListSharedData instance
; 1587 :     if (font == NULL)
; 1588 :         font = _Data->Font;

  0004c	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00050	48 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbp
  00058	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  0005d	48 8b 68 08	 mov	 rbp, QWORD PTR [rax+8]

; 1589 :     if (font_size == 0.0f)
; 1590 :         font_size = _Data->FontSize;

  00061	f3 0f 10 70 10	 movss	 xmm6, DWORD PTR [rax+16]

; 1591 : 
; 1592 :     IM_ASSERT(font->ContainerAtlas->TexID == _CmdHeader.TextureId);  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

  00066	48 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [rsi+152]
  0006d	48 8b 4d 40	 mov	 rcx, QWORD PTR [rbp+64]
  00071	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00075	74 1a		 je	 SHORT $LN11@AddText
  00077	41 b8 38 06 00
	00		 mov	 r8d, 1592		; 00000638H
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GI@CIGOLMNM@?$AAf?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr@
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN11@AddText:

; 1593 : 
; 1594 :     ImVec4 clip_rect = _CmdHeader.ClipRect;

  00091	0f 10 86 88 00
	00 00		 movups	 xmm0, XMMWORD PTR [rsi+136]

; 1595 :     if (cpu_fine_clip_rect)
; 1596 :     {
; 1597 :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
; 1598 :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
; 1599 :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
; 1600 :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
; 1601 :     }
; 1602 :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

  00098	4d 8b 0f	 mov	 r9, QWORD PTR [r15]
  0009b	48 8d 44 24 50	 lea	 rax, QWORD PTR clip_rect$1[rsp]
  000a0	c6 44 24 48 00	 mov	 BYTE PTR [rsp+72], 0
  000a5	0f 57 c9	 xorps	 xmm1, xmm1
  000a8	f3 0f 11 4c 24
	40		 movss	 DWORD PTR [rsp+64], xmm1
  000ae	0f 28 d6	 movaps	 xmm2, xmm6
  000b1	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  000b6	48 8b d6	 mov	 rdx, rsi
  000b9	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  000be	48 8b cd	 mov	 rcx, rbp
  000c1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c6	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  000cb	0f 11 44 24 50	 movups	 XMMWORD PTR clip_rect$1[rsp], xmm0
  000d0	e8 00 00 00 00	 call	 ?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ; ImFont::RenderText
  000d5	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  000da	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
$LN33@AddText:
  000e2	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 1607 :     AddText(NULL, 0.0f, pos, col, text_begin, text_end);
; 1608 : }

  000ea	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+160]
  000f2	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000f6	41 5f		 pop	 r15
  000f8	41 5e		 pop	 r14
  000fa	5f		 pop	 rdi
$LN34@AddText:
  000fb	c3		 ret	 0
?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z ENDP	; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv5731 = 0
tv5733 = 1
thick_line$1$ = 2
idx2$1$ = 8
idx1$1$ = 8
i1$1$ = 8
tv5542 = 8
col$1$ = 16
tv5195 = 20
col_trans$1$ = 24
tv5557 = 32
tv5555 = 32
tv5194 = 32
tex_uvs$15 = 32
tv5196 = 48
integer_thickness$1$ = 56
tv5275 = 64
__$ArrayPad$ = 72
this$ = 256
points$ = 264
points_count$ = 272
col$ = 280
flags$ = 288
thickness$ = 296
?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z PROC	; ImDrawList::AddPolyline

; 722  : {

$LN253:
  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 89 9d 00 01
	00 00		 mov	 QWORD PTR [rbp+256], rbx
  0001d	48 89 b5 08 01
	00 00		 mov	 QWORD PTR [rbp+264], rsi
  00024	48 89 bd 10 01
	00 00		 mov	 QWORD PTR [rbp+272], rdi
  0002b	0f 29 b5 c0 00
	00 00		 movaps	 XMMWORD PTR [rbp+192], xmm6
  00032	0f 29 bd b0 00
	00 00		 movaps	 XMMWORD PTR [rbp+176], xmm7
  00039	44 0f 29 85 a0
	00 00 00	 movaps	 XMMWORD PTR [rbp+160], xmm8
  00041	44 0f 29 8d 90
	00 00 00	 movaps	 XMMWORD PTR [rbp+144], xmm9
  00049	44 0f 29 95 80
	00 00 00	 movaps	 XMMWORD PTR [rbp+128], xmm10
  00051	44 0f 29 5d 70	 movaps	 XMMWORD PTR [rbp+112], xmm11
  00056	44 0f 29 65 60	 movaps	 XMMWORD PTR [rbp+96], xmm12
  0005b	44 0f 29 6d 50	 movaps	 XMMWORD PTR [rbp+80], xmm13
  00060	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00067	48 33 c5	 xor	 rax, rbp
  0006a	48 89 45 48	 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  0006e	4d 63 f0	 movsxd	 r14, r8d
  00071	45 8b e1	 mov	 r12d, r9d
  00074	44 89 4d 10	 mov	 DWORD PTR col$1$[rbp], r9d
  00078	48 8b fa	 mov	 rdi, rdx
  0007b	48 8b d9	 mov	 rbx, rcx

; 723  :     if (points_count < 2)

  0007e	41 83 fe 02	 cmp	 r14d, 2
  00082	0f 8c e4 0d 00
	00		 jl	 $LN21@AddPolylin

; 724  :         return;
; 725  : 
; 726  :     const bool closed = (flags & ImDrawFlags_Closed) != 0;
; 727  :     const ImVec2 opaque_uv = _Data->TexUvWhitePixel;

  00088	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]

; 728  :     const int count = closed ? points_count : points_count - 1; // The number of line segments we need to draw
; 729  :     const bool thick_line = (thickness > _FringeScale);

  0008c	41 8d 4e ff	 lea	 ecx, DWORD PTR [r14-1]
  00090	80 a5 20 01 00
	00 01		 and	 BYTE PTR flags$[rbp], 1
  00097	f3 44 0f 10 8b
	c0 00 00 00	 movss	 xmm9, DWORD PTR [rbx+192]
  000a0	f3 44 0f 10 85
	28 01 00 00	 movss	 xmm8, DWORD PTR thickness$[rbp]
  000a9	f3 0f 10 30	 movss	 xmm6, DWORD PTR [rax]
  000ad	f3 0f 10 78 04	 movss	 xmm7, DWORD PTR [rax+4]
  000b2	41 8b c6	 mov	 eax, r14d

; 730  : 
; 731  :     if (Flags & ImDrawListFlags_AntiAliasedLines)

  000b5	8b 53 30	 mov	 edx, DWORD PTR [rbx+48]
  000b8	0f 44 c1	 cmove	 eax, ecx
  000bb	45 0f 2f c1	 comiss	 xmm8, xmm9
  000bf	4c 63 f8	 movsxd	 r15, eax
  000c2	4c 89 7d 30	 mov	 QWORD PTR tv5196[rbp], r15
  000c6	41 0f 97 c0	 seta	 r8b
  000ca	44 88 45 02	 mov	 BYTE PTR thick_line$1$[rbp], r8b
  000ce	f6 c2 01	 test	 dl, 1
  000d1	0f 84 b2 0b 00
	00		 je	 $LN24@AddPolylin
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  000d7	f3 44 0f 10 2d
	00 00 00 00	 movss	 xmm13, DWORD PTR __real@3f800000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 735  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;

  000e0	41 8b c9	 mov	 ecx, r9d
  000e3	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  000e9	f3 45 0f 5f c5	 maxss	 xmm8, xmm13
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 735  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;

  000ee	89 4d 18	 mov	 DWORD PTR col_trans$1$[rbp], ecx

; 736  : 
; 737  :         // Thicknesses <1.0 should behave like thickness 1.0
; 738  :         thickness = ImMax(thickness, 1.0f);
; 739  :         const int integer_thickness = (int)thickness;

  000f1	f3 41 0f 2c c8	 cvttss2si ecx, xmm8
  000f6	89 4d 38	 mov	 DWORD PTR integer_thickness$1$[rbp], ecx

; 741  : 
; 742  :         // Do we want to draw this line using a texture?
; 743  :         // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
; 744  :         // - If AA_SIZE is not 1.0f we cannot use the texture path.
; 745  :         const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);

  000f9	f6 c2 02	 test	 dl, 2
  000fc	74 43		 je	 SHORT $LN45@AddPolylin
  000fe	83 f9 3f	 cmp	 ecx, 63			; 0000003fH
  00101	7d 3e		 jge	 SHORT $LN45@AddPolylin

; 740  :         const float fractional_thickness = thickness - integer_thickness;

  00103	66 0f 6e c1	 movd	 xmm0, ecx
  00107	41 0f 28 c8	 movaps	 xmm1, xmm8
  0010b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0010e	f3 0f 5c c8	 subss	 xmm1, xmm0

; 741  : 
; 742  :         // Do we want to draw this line using a texture?
; 743  :         // - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
; 744  :         // - If AA_SIZE is not 1.0f we cannot use the texture path.
; 745  :         const bool use_texture = (Flags & ImDrawListFlags_AntiAliasedLinesUseTex) && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001f) && (AA_SIZE == 1.0f);

  00112	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3727c5ac
  0011a	0f 2f c1	 comiss	 xmm0, xmm1
  0011d	72 22		 jb	 SHORT $LN45@AddPolylin
  0011f	45 0f 2e cd	 ucomiss xmm9, xmm13
  00123	7a 1c		 jp	 SHORT $LN45@AddPolylin
  00125	75 1a		 jne	 SHORT $LN45@AddPolylin

; 751  :         const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);

  00127	47 8d 2c 36	 lea	 r13d, DWORD PTR [r14+r14]
  0012b	c6 45 01 01	 mov	 BYTE PTR tv5733[rbp], 1
  0012f	8d 14 40	 lea	 edx, DWORD PTR [rax+rax*2]
  00132	44 89 6d 14	 mov	 DWORD PTR tv5195[rbp], r13d
  00136	03 d2		 add	 edx, edx
  00138	c6 45 00 01	 mov	 BYTE PTR tv5731[rbp], 1
  0013c	45 8b c5	 mov	 r8d, r13d
  0013f	eb 46		 jmp	 SHORT $LN250@AddPolylin
$LN45@AddPolylin:

; 746  : 
; 747  :         // We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
; 748  :         IM_ASSERT_PARANOID(!use_texture || !(_Data->Font->ContainerAtlas->Flags & ImFontAtlasFlags_NoBakedLines));
; 749  : 
; 750  :         const int idx_count = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12);

  00141	33 f6		 xor	 esi, esi
  00143	40 88 75 01	 mov	 BYTE PTR tv5733[rbp], sil
  00147	45 84 c0	 test	 r8b, r8b
  0014a	74 29		 je	 SHORT $LN47@AddPolylin

; 751  :         const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);

  0014c	46 8d 2c b5 00
	00 00 00	 lea	 r13d, DWORD PTR [r14*4]
  00154	48 8b cb	 mov	 rcx, rbx
  00157	8d 14 c0	 lea	 edx, DWORD PTR [rax+rax*8]
  0015a	44 89 6d 14	 mov	 DWORD PTR tv5195[rbp], r13d
  0015e	03 d2		 add	 edx, edx
  00160	45 8b c5	 mov	 r8d, r13d
  00163	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve

; 752  :         PrimReserve(idx_count, vtx_count);
; 753  : 
; 754  :         // Temporary buffer
; 755  :         // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
; 756  :         ImVec2* temp_normals = (ImVec2*)alloca(points_count * ((use_texture || !thick_line) ? 3 : 5) * sizeof(ImVec2)); //-V630

  00168	8d 46 05	 lea	 eax, QWORD PTR [rsi+5]
  0016b	40 88 75 00	 mov	 BYTE PTR tv5731[rbp], sil
  0016f	40 88 75 01	 mov	 BYTE PTR tv5733[rbp], sil
  00173	eb 1f		 jmp	 SHORT $LN56@AddPolylin
$LN47@AddPolylin:

; 751  :         const int vtx_count = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3);

  00175	47 8d 04 76	 lea	 r8d, DWORD PTR [r14+r14*2]
  00179	40 88 75 00	 mov	 BYTE PTR tv5731[rbp], sil
  0017d	8d 14 40	 lea	 edx, DWORD PTR [rax+rax*2]
  00180	44 89 45 14	 mov	 DWORD PTR tv5195[rbp], r8d
  00184	c1 e2 02	 shl	 edx, 2
$LN250@AddPolylin:

; 752  :         PrimReserve(idx_count, vtx_count);
; 753  : 
; 754  :         // Temporary buffer
; 755  :         // The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
; 756  :         ImVec2* temp_normals = (ImVec2*)alloca(points_count * ((use_texture || !thick_line) ? 3 : 5) * sizeof(ImVec2)); //-V630

  00187	48 8b cb	 mov	 rcx, rbx
  0018a	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve
  0018f	b8 03 00 00 00	 mov	 eax, 3
$LN56@AddPolylin:
  00194	41 0f af c6	 imul	 eax, r14d
  00198	48 98		 cdqe
  0019a	48 c1 e0 03	 shl	 rax, 3
  0019e	48 8d 48 0f	 lea	 rcx, QWORD PTR [rax+15]
  001a2	48 3b c8	 cmp	 rcx, rax
  001a5	77 0a		 ja	 SHORT $LN249@AddPolylin
  001a7	48 b9 f0 ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846960 ; 0ffffffffffffff0H
$LN249@AddPolylin:
  001b1	48 83 e1 f0	 and	 rcx, -16
  001b5	48 8b c1	 mov	 rax, rcx
  001b8	e8 00 00 00 00	 call	 __chkstk

; 757  :         ImVec2* temp_points = temp_normals + points_count;
; 758  : 
; 759  :         // Calculate normals (tangents) for each line segment
; 760  :         for (int i1 = 0; i1 < count; i1++)

  001bd	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __xmm@80000000800000008000000080000000
  001c5	48 2b e1	 sub	 rsp, rcx
  001c8	45 33 d2	 xor	 r10d, r10d
  001cb	4d 8b ee	 mov	 r13, r14
  001ce	41 8b ca	 mov	 ecx, r10d
  001d1	45 8b c2	 mov	 r8d, r10d
  001d4	0f 57 ed	 xorps	 xmm5, xmm5
  001d7	4c 8d 5c 24 20	 lea	 r11, QWORD PTR [rsp+32]
  001dc	4b 8d 34 f3	 lea	 rsi, QWORD PTR [r11+r14*8]
  001e0	49 83 ff 04	 cmp	 r15, 4
  001e4	0f 8c ad 01 00
	00		 jl	 $LC218@AddPolylin
  001ea	49 8d 47 fd	 lea	 rax, QWORD PTR [r15-3]
  001ee	44 8b e1	 mov	 r12d, ecx
  001f1	4c 8b e8	 mov	 r13, rax
  001f4	41 bf 02 00 00
	00		 mov	 r15d, 2
  001fa	66 0f 1f 44 00
	00		 npad	 6
$LL231@AddPolylin:

; 761  :         {
; 762  :             const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
; 763  :             float dx = points[i2].x - points[i1].x;

  00200	4e 8d 0c c7	 lea	 r9, QWORD PTR [rdi+r8*8]
  00204	49 8b d2	 mov	 rdx, r10
  00207	41 8d 4f ff	 lea	 ecx, DWORD PTR [r15-1]
  0020b	41 3b ce	 cmp	 ecx, r14d
  0020e	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  00212	48 0f 45 d0	 cmovne	 rdx, rax
  00216	f3 0f 10 0c d7	 movss	 xmm1, DWORD PTR [rdi+rdx*8]

; 764  :             float dy = points[i2].y - points[i1].y;

  0021b	f3 0f 10 54 d7
	04		 movss	 xmm2, DWORD PTR [rdi+rdx*8+4]
  00221	f3 41 0f 5c 09	 subss	 xmm1, DWORD PTR [r9]
  00226	f3 41 0f 5c 51
	04		 subss	 xmm2, DWORD PTR [r9+4]

; 765  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  0022c	0f 28 c1	 movaps	 xmm0, xmm1
  0022f	0f 28 da	 movaps	 xmm3, xmm2
  00232	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00236	f3 0f 59 da	 mulss	 xmm3, xmm2
  0023a	f3 0f 58 d8	 addss	 xmm3, xmm0
  0023e	0f 2f dd	 comiss	 xmm3, xmm5
  00241	76 0c		 jbe	 SHORT $LN221@AddPolylin
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  00243	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 765  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  00247	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0024b	f3 0f 59 d0	 mulss	 xmm2, xmm0
$LN221@AddPolylin:

; 766  :             temp_normals[i1].x = dy;

  0024f	f3 43 0f 11 14
	c3		 movss	 DWORD PTR [r11+r8*8], xmm2
  00255	4b 8d 14 c3	 lea	 rdx, QWORD PTR [r11+r8*8]

; 767  :             temp_normals[i1].y = -dx;

  00259	0f 57 cc	 xorps	 xmm1, xmm4
  0025c	49 8d 48 02	 lea	 rcx, QWORD PTR [r8+2]
  00260	f3 0f 11 4a 04	 movss	 DWORD PTR [rdx+4], xmm1
  00265	45 3b fe	 cmp	 r15d, r14d
  00268	49 8b c2	 mov	 rax, r10
  0026b	48 0f 45 c1	 cmovne	 rax, rcx
  0026f	f3 0f 10 0c c7	 movss	 xmm1, DWORD PTR [rdi+rax*8]
  00274	f3 0f 10 54 c7
	04		 movss	 xmm2, DWORD PTR [rdi+rax*8+4]
  0027a	f3 41 0f 5c 49
	08		 subss	 xmm1, DWORD PTR [r9+8]
  00280	f3 41 0f 5c 51
	0c		 subss	 xmm2, DWORD PTR [r9+12]
  00286	0f 28 c1	 movaps	 xmm0, xmm1
  00289	0f 28 da	 movaps	 xmm3, xmm2
  0028c	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00290	f3 0f 59 da	 mulss	 xmm3, xmm2
  00294	f3 0f 58 d8	 addss	 xmm3, xmm0
  00298	0f 2f dd	 comiss	 xmm3, xmm5
  0029b	76 0c		 jbe	 SHORT $LN224@AddPolylin
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  0029d	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 765  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  002a1	f3 0f 59 c8	 mulss	 xmm1, xmm0
  002a5	f3 0f 59 d0	 mulss	 xmm2, xmm0
$LN224@AddPolylin:

; 766  :             temp_normals[i1].x = dy;

  002a9	f3 0f 11 52 08	 movss	 DWORD PTR [rdx+8], xmm2
  002ae	49 8d 40 03	 lea	 rax, QWORD PTR [r8+3]

; 767  :             temp_normals[i1].y = -dx;

  002b2	0f 57 cc	 xorps	 xmm1, xmm4
  002b5	48 89 45 08	 mov	 QWORD PTR tv5542[rbp], rax
  002b9	f3 0f 11 4a 0c	 movss	 DWORD PTR [rdx+12], xmm1
  002be	41 8d 47 01	 lea	 eax, DWORD PTR [r15+1]
  002c2	41 3b c6	 cmp	 eax, r14d
  002c5	49 8b ca	 mov	 rcx, r10
  002c8	48 0f 45 4d 08	 cmovne	 rcx, QWORD PTR tv5542[rbp]
  002cd	f3 0f 10 0c cf	 movss	 xmm1, DWORD PTR [rdi+rcx*8]
  002d2	f3 0f 10 54 cf
	04		 movss	 xmm2, DWORD PTR [rdi+rcx*8+4]
  002d8	f3 42 0f 5c 4c
	c7 10		 subss	 xmm1, DWORD PTR [rdi+r8*8+16]
  002df	f3 41 0f 5c 51
	14		 subss	 xmm2, DWORD PTR [r9+20]
  002e5	0f 28 c1	 movaps	 xmm0, xmm1
  002e8	0f 28 da	 movaps	 xmm3, xmm2
  002eb	f3 0f 59 c1	 mulss	 xmm0, xmm1
  002ef	f3 0f 59 da	 mulss	 xmm3, xmm2
  002f3	f3 0f 58 d8	 addss	 xmm3, xmm0
  002f7	0f 2f dd	 comiss	 xmm3, xmm5
  002fa	76 0c		 jbe	 SHORT $LN227@AddPolylin
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  002fc	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 765  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  00300	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00304	f3 0f 59 d0	 mulss	 xmm2, xmm0
$LN227@AddPolylin:

; 766  :             temp_normals[i1].x = dy;

  00308	f3 43 0f 11 54
	c3 10		 movss	 DWORD PTR [r11+r8*8+16], xmm2
  0030f	41 8d 47 02	 lea	 eax, DWORD PTR [r15+2]
  00313	49 83 c0 04	 add	 r8, 4

; 767  :             temp_normals[i1].y = -dx;

  00317	0f 57 cc	 xorps	 xmm1, xmm4
  0031a	f3 0f 11 4a 14	 movss	 DWORD PTR [rdx+20], xmm1
  0031f	41 3b c6	 cmp	 eax, r14d
  00322	48 8b 45 08	 mov	 rax, QWORD PTR tv5542[rbp]
  00326	49 8b ca	 mov	 rcx, r10
  00329	49 0f 45 c8	 cmovne	 rcx, r8
  0032d	f3 0f 10 0c cf	 movss	 xmm1, DWORD PTR [rdi+rcx*8]
  00332	f3 0f 10 54 cf
	04		 movss	 xmm2, DWORD PTR [rdi+rcx*8+4]
  00338	f3 0f 5c 0c c7	 subss	 xmm1, DWORD PTR [rdi+rax*8]
  0033d	f3 41 0f 5c 51
	1c		 subss	 xmm2, DWORD PTR [r9+28]
  00343	0f 28 c1	 movaps	 xmm0, xmm1
  00346	0f 28 da	 movaps	 xmm3, xmm2
  00349	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0034d	f3 0f 59 da	 mulss	 xmm3, xmm2
  00351	f3 0f 58 d8	 addss	 xmm3, xmm0
  00355	0f 2f dd	 comiss	 xmm3, xmm5
  00358	76 0c		 jbe	 SHORT $LN230@AddPolylin
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  0035a	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 765  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  0035e	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00362	f3 0f 59 d0	 mulss	 xmm2, xmm0
$LN230@AddPolylin:

; 767  :             temp_normals[i1].y = -dx;

  00366	41 83 c4 04	 add	 r12d, 4
  0036a	f3 41 0f 11 14
	c3		 movss	 DWORD PTR [r11+rax*8], xmm2
  00370	41 83 c7 04	 add	 r15d, 4
  00374	0f 57 cc	 xorps	 xmm1, xmm4
  00377	f3 0f 11 4a 1c	 movss	 DWORD PTR [rdx+28], xmm1
  0037c	4d 3b c5	 cmp	 r8, r13
  0037f	0f 8c 7b fe ff
	ff		 jl	 $LL231@AddPolylin
  00385	4c 8b 7d 30	 mov	 r15, QWORD PTR tv5196[rbp]
  00389	4d 8b ee	 mov	 r13, r14
  0038c	44 89 65 08	 mov	 DWORD PTR i1$1$[rbp], r12d
  00390	8b 4d 08	 mov	 ecx, DWORD PTR i1$1$[rbp]
  00393	44 8b 65 10	 mov	 r12d, DWORD PTR col$1$[rbp]
$LC218@AddPolylin:

; 757  :         ImVec2* temp_points = temp_normals + points_count;
; 758  : 
; 759  :         // Calculate normals (tangents) for each line segment
; 760  :         for (int i1 = 0; i1 < count; i1++)

  00397	4d 3b c7	 cmp	 r8, r15
  0039a	7d 65		 jge	 SHORT $LN217@AddPolylin
  0039c	ff c1		 inc	 ecx
$LC4@AddPolylin:

; 761  :         {
; 762  :             const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
; 763  :             float dx = points[i2].x - points[i1].x;

  0039e	41 3b ce	 cmp	 ecx, r14d
  003a1	49 8d 50 01	 lea	 rdx, QWORD PTR [r8+1]
  003a5	49 8b c2	 mov	 rax, r10
  003a8	48 0f 45 c2	 cmovne	 rax, rdx
  003ac	f3 0f 10 0c c7	 movss	 xmm1, DWORD PTR [rdi+rax*8]

; 764  :             float dy = points[i2].y - points[i1].y;

  003b1	f3 0f 10 54 c7
	04		 movss	 xmm2, DWORD PTR [rdi+rax*8+4]
  003b7	f3 42 0f 5c 0c
	c7		 subss	 xmm1, DWORD PTR [rdi+r8*8]
  003bd	f3 42 0f 5c 54
	c7 04		 subss	 xmm2, DWORD PTR [rdi+r8*8+4]

; 765  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  003c4	0f 28 c1	 movaps	 xmm0, xmm1
  003c7	0f 28 da	 movaps	 xmm3, xmm2
  003ca	f3 0f 59 c1	 mulss	 xmm0, xmm1
  003ce	f3 0f 59 da	 mulss	 xmm3, xmm2
  003d2	f3 0f 58 d8	 addss	 xmm3, xmm0
  003d6	0f 2f dd	 comiss	 xmm3, xmm5
  003d9	76 0c		 jbe	 SHORT $LN26@AddPolylin
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  003db	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 765  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  003df	f3 0f 59 c8	 mulss	 xmm1, xmm0
  003e3	f3 0f 59 d0	 mulss	 xmm2, xmm0
$LN26@AddPolylin:

; 767  :             temp_normals[i1].y = -dx;

  003e7	0f 57 cc	 xorps	 xmm1, xmm4
  003ea	f3 43 0f 11 14
	c3		 movss	 DWORD PTR [r11+r8*8], xmm2
  003f0	ff c1		 inc	 ecx
  003f2	f3 43 0f 11 4c
	c3 04		 movss	 DWORD PTR [r11+r8*8+4], xmm1
  003f9	4c 8b c2	 mov	 r8, rdx
  003fc	49 3b d7	 cmp	 rdx, r15
  003ff	7c 9d		 jl	 SHORT $LC4@AddPolylin
$LN217@AddPolylin:

; 768  :         }
; 769  :         if (!closed)

  00401	0f b6 85 20 01
	00 00		 movzx	 eax, BYTE PTR flags$[rbp]
  00408	84 c0		 test	 al, al
  0040a	75 0e		 jne	 SHORT $LN232@AddPolylin

; 770  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

  0040c	f2 43 0f 10 44
	eb f0		 movsd	 xmm0, QWORD PTR [r11+r13*8-16]
  00413	f2 43 0f 11 44
	eb f8		 movsd	 QWORD PTR [r11+r13*8-8], xmm0
$LN232@AddPolylin:

; 771  : 
; 772  :         // If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
; 773  :         if (use_texture || !thick_line)

  0041a	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  00422	44 38 55 00	 cmp	 BYTE PTR tv5731[rbp], r10b
  00426	0f 85 92 04 00
	00		 jne	 $LN243@AddPolylin
  0042c	44 38 55 02	 cmp	 BYTE PTR thick_line$1$[rbp], r10b
  00430	0f 84 96 04 00
	00		 je	 $LN60@AddPolylin

; 868  :                 }
; 869  :             }
; 870  :         }
; 871  :         else
; 872  :         {
; 873  :             // [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
; 874  :             const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;

  00436	f3 45 0f 5c c1	 subss	 xmm8, xmm9
  0043b	44 0f 28 d4	 movaps	 xmm10, xmm4
  0043f	f3 45 0f 59 c2	 mulss	 xmm8, xmm10

; 875  : 
; 876  :             // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
; 877  :             if (!closed)

  00444	45 0f 28 d8	 movaps	 xmm11, xmm8
  00448	f3 45 0f 58 d9	 addss	 xmm11, xmm9
  0044d	84 c0		 test	 al, al
  0044f	0f 85 81 01 00
	00		 jne	 $LN38@AddPolylin
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00455	41 0f 28 c3	 movaps	 xmm0, xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 884  :                 temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

  00459	42 8d 04 b5 fc
	ff ff ff	 lea	 eax, DWORD PTR [r14*4-4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00461	f3 41 0f 59 43
	04		 mulss	 xmm0, DWORD PTR [r11+4]
  00467	41 0f 28 cb	 movaps	 xmm1, xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 884  :                 temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

  0046b	48 63 c8	 movsxd	 rcx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  0046e	f3 41 0f 59 0b	 mulss	 xmm1, DWORD PTR [r11]
  00473	41 0f 28 d0	 movaps	 xmm2, xmm8

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00477	f3 0f 58 47 04	 addss	 xmm0, DWORD PTR [rdi+4]
  0047c	f3 0f 58 0f	 addss	 xmm1, DWORD PTR [rdi]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 880  :                 temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);

  00480	f3 0f 11 46 04	 movss	 DWORD PTR [rsi+4], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00485	41 0f 28 c0	 movaps	 xmm0, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 880  :                 temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);

  00489	f3 0f 11 0e	 movss	 DWORD PTR [rsi], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  0048d	41 0f 28 c8	 movaps	 xmm1, xmm8
  00491	f3 41 0f 59 43
	04		 mulss	 xmm0, DWORD PTR [r11+4]
  00497	f3 41 0f 59 13	 mulss	 xmm2, DWORD PTR [r11]

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  0049c	f3 0f 58 47 04	 addss	 xmm0, DWORD PTR [rdi+4]
  004a1	f3 0f 58 17	 addss	 xmm2, DWORD PTR [rdi]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 881  :                 temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);

  004a5	f3 0f 11 46 0c	 movss	 DWORD PTR [rsi+12], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  004aa	41 0f 28 c0	 movaps	 xmm0, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 881  :                 temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);

  004ae	f3 0f 11 56 08	 movss	 DWORD PTR [rsi+8], xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  004b3	f3 41 0f 59 03	 mulss	 xmm0, DWORD PTR [r11]
  004b8	f3 41 0f 59 4b
	04		 mulss	 xmm1, DWORD PTR [r11+4]

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  004be	f3 0f 10 17	 movss	 xmm2, DWORD PTR [rdi]
  004c2	f3 0f 5c d0	 subss	 xmm2, xmm0
  004c6	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [rdi+4]
  004cb	f3 0f 5c c1	 subss	 xmm0, xmm1

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  004cf	41 0f 28 cb	 movaps	 xmm1, xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 882  :                 temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);

  004d3	f3 0f 11 56 10	 movss	 DWORD PTR [rsi+16], xmm2
  004d8	f3 0f 11 46 14	 movss	 DWORD PTR [rsi+20], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  004dd	41 0f 28 c3	 movaps	 xmm0, xmm11
  004e1	f3 41 0f 59 03	 mulss	 xmm0, DWORD PTR [r11]
  004e6	f3 41 0f 59 4b
	04		 mulss	 xmm1, DWORD PTR [r11+4]

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  004ec	f3 0f 10 17	 movss	 xmm2, DWORD PTR [rdi]
  004f0	f3 0f 5c d0	 subss	 xmm2, xmm0
  004f4	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [rdi+4]
  004f9	f3 0f 5c c1	 subss	 xmm0, xmm1

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  004fd	41 0f 28 cb	 movaps	 xmm1, xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 883  :                 temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);

  00501	f3 0f 11 56 18	 movss	 DWORD PTR [rsi+24], xmm2
  00506	f3 0f 11 46 1c	 movss	 DWORD PTR [rsi+28], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  0050b	41 0f 28 c3	 movaps	 xmm0, xmm11
  0050f	f3 43 0f 59 44
	eb fc		 mulss	 xmm0, DWORD PTR [r11+r13*8-4]
  00516	f3 43 0f 59 4c
	eb f8		 mulss	 xmm1, DWORD PTR [r11+r13*8-8]

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  0051d	f3 42 0f 58 44
	ef fc		 addss	 xmm0, DWORD PTR [rdi+r13*8-4]
  00524	f3 42 0f 58 4c
	ef f8		 addss	 xmm1, DWORD PTR [rdi+r13*8-8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 884  :                 temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

  0052b	f3 0f 11 44 ce
	04		 movss	 DWORD PTR [rsi+rcx*8+4], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00531	41 0f 28 c0	 movaps	 xmm0, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 884  :                 temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

  00535	f3 0f 11 0c ce	 movss	 DWORD PTR [rsi+rcx*8], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  0053a	41 0f 28 c8	 movaps	 xmm1, xmm8
  0053e	f3 43 0f 59 44
	eb fc		 mulss	 xmm0, DWORD PTR [r11+r13*8-4]
  00545	f3 43 0f 59 4c
	eb f8		 mulss	 xmm1, DWORD PTR [r11+r13*8-8]

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  0054c	f3 42 0f 58 44
	ef fc		 addss	 xmm0, DWORD PTR [rdi+r13*8-4]
  00553	f3 42 0f 58 4c
	ef f8		 addss	 xmm1, DWORD PTR [rdi+r13*8-8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 885  :                 temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);

  0055a	f3 0f 11 44 ce
	0c		 movss	 DWORD PTR [rsi+rcx*8+12], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00560	41 0f 28 c0	 movaps	 xmm0, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 885  :                 temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness);

  00564	f3 0f 11 4c ce
	08		 movss	 DWORD PTR [rsi+rcx*8+8], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  0056a	41 0f 28 c8	 movaps	 xmm1, xmm8
  0056e	f3 43 0f 59 44
	eb f8		 mulss	 xmm0, DWORD PTR [r11+r13*8-8]
  00575	f3 43 0f 59 4c
	eb fc		 mulss	 xmm1, DWORD PTR [r11+r13*8-4]

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  0057c	f3 42 0f 10 54
	ef f8		 movss	 xmm2, DWORD PTR [rdi+r13*8-8]
  00583	f3 0f 5c d0	 subss	 xmm2, xmm0
  00587	f3 42 0f 10 44
	ef fc		 movss	 xmm0, DWORD PTR [rdi+r13*8-4]
  0058e	f3 0f 5c c1	 subss	 xmm0, xmm1

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00592	41 0f 28 cb	 movaps	 xmm1, xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 886  :                 temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness);

  00596	f3 0f 11 54 ce
	10		 movss	 DWORD PTR [rsi+rcx*8+16], xmm2
  0059c	f3 0f 11 44 ce
	14		 movss	 DWORD PTR [rsi+rcx*8+20], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  005a2	41 0f 28 c3	 movaps	 xmm0, xmm11
  005a6	f3 43 0f 59 44
	eb f8		 mulss	 xmm0, DWORD PTR [r11+r13*8-8]

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  005ad	f3 42 0f 10 54
	ef f8		 movss	 xmm2, DWORD PTR [rdi+r13*8-8]

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  005b4	f3 43 0f 59 4c
	eb fc		 mulss	 xmm1, DWORD PTR [r11+r13*8-4]

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  005bb	f3 0f 5c d0	 subss	 xmm2, xmm0
  005bf	f3 42 0f 10 44
	ef fc		 movss	 xmm0, DWORD PTR [rdi+r13*8-4]
  005c6	f3 0f 5c c1	 subss	 xmm0, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 887  :                 temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE);

  005ca	f3 0f 11 54 ce
	18		 movss	 DWORD PTR [rsi+rcx*8+24], xmm2
  005d0	f3 0f 11 44 ce
	1c		 movss	 DWORD PTR [rsi+rcx*8+28], xmm0
$LN38@AddPolylin:

; 888  :             }
; 889  : 
; 890  :             // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
; 891  :             // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
; 892  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 893  :             unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment

  005d6	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  005d9	89 45 08	 mov	 DWORD PTR idx1$1$[rbp], eax

; 894  :             for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment

  005dc	4d 85 ff	 test	 r15, r15
  005df	0f 8e 10 02 00
	00		 jle	 $LN15@AddPolylin

; 770  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

  005e5	f3 44 0f 10 25
	00 00 00 00	 movss	 xmm12, DWORD PTR __real@358637bd
  005ee	49 8b d2	 mov	 rdx, r10
  005f1	f3 44 0f 10 0d
	00 00 00 00	 movss	 xmm9, DWORD PTR __real@42c80000
  005fa	41 bf 01 00 00
	00		 mov	 r15d, 1
  00600	4c 8b 65 30	 mov	 r12, QWORD PTR tv5196[rbp]
  00604	44 8b e8	 mov	 r13d, eax
  00607	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL16@AddPolylin:

; 895  :             {
; 896  :                 const int i2 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
; 897  :                 const unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment

  00610	48 8d 4a 01	 lea	 rcx, QWORD PTR [rdx+1]
  00614	45 3b fe	 cmp	 r15d, r14d
  00617	49 8b c2	 mov	 rax, r10
  0061a	48 89 4d 20	 mov	 QWORD PTR tv5555[rbp], rcx
  0061e	48 0f 45 c1	 cmovne	 rax, rcx
  00622	75 06		 jne	 SHORT $LN67@AddPolylin
  00624	44 8b 43 34	 mov	 r8d, DWORD PTR [rbx+52]
  00628	eb 04		 jmp	 SHORT $LN251@AddPolylin
$LN67@AddPolylin:
  0062a	45 8d 45 04	 lea	 r8d, DWORD PTR [r13+4]
$LN251@AddPolylin:

; 898  : 
; 899  :                 // Average normals
; 900  :                 float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;
; 901  :                 float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;

  0062e	f3 41 0f 10 6c
	d3 04		 movss	 xmm5, DWORD PTR [r11+rdx*8+4]
  00635	48 8d 0c c5 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*8]
  0063d	f3 42 0f 10 24
	19		 movss	 xmm4, DWORD PTR [rcx+r11]
  00643	f3 41 0f 58 24
	d3		 addss	 xmm4, DWORD PTR [r11+rdx*8]
  00649	f3 42 0f 58 6c
	19 04		 addss	 xmm5, DWORD PTR [rcx+r11+4]
  00650	44 89 45 08	 mov	 DWORD PTR idx2$1$[rbp], r8d
  00654	f3 41 0f 59 e2	 mulss	 xmm4, xmm10
  00659	f3 41 0f 59 ea	 mulss	 xmm5, xmm10

; 902  :                 IM_FIXNORMAL2F(dm_x, dm_y);

  0065e	0f 28 c4	 movaps	 xmm0, xmm4
  00661	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00665	0f 28 cd	 movaps	 xmm1, xmm5
  00668	f3 0f 59 cd	 mulss	 xmm1, xmm5
  0066c	f3 0f 58 c8	 addss	 xmm1, xmm0
  00670	41 0f 2f cc	 comiss	 xmm1, xmm12
  00674	76 18		 jbe	 SHORT $LN39@AddPolylin
  00676	41 0f 28 c5	 movaps	 xmm0, xmm13
  0067a	f3 0f 5e c1	 divss	 xmm0, xmm1
  0067e	41 0f 28 c9	 movaps	 xmm1, xmm9
  00682	f3 0f 5d c8	 minss	 xmm1, xmm0
  00686	f3 0f 59 e1	 mulss	 xmm4, xmm1
  0068a	f3 0f 59 e9	 mulss	 xmm5, xmm1
$LN39@AddPolylin:

; 903  :                 float dm_out_x = dm_x * (half_inner_thickness + AA_SIZE);
; 904  :                 float dm_out_y = dm_y * (half_inner_thickness + AA_SIZE);
; 905  :                 float dm_in_x = dm_x * half_inner_thickness;
; 906  :                 float dm_in_y = dm_y * half_inner_thickness;
; 907  : 
; 908  :                 // Add temporary vertices
; 909  :                 ImVec2* out_vtx = &temp_points[i2 * 4];

  0068e	48 c1 e0 05	 shl	 rax, 5

; 910  :                 out_vtx[0].x = points[i2].x + dm_out_x;
; 911  :                 out_vtx[0].y = points[i2].y + dm_out_y;
; 912  :                 out_vtx[1].x = points[i2].x + dm_in_x;
; 913  :                 out_vtx[1].y = points[i2].y + dm_in_y;
; 914  :                 out_vtx[2].x = points[i2].x - dm_in_x;
; 915  :                 out_vtx[2].y = points[i2].y - dm_in_y;
; 916  :                 out_vtx[3].x = points[i2].x - dm_out_x;
; 917  :                 out_vtx[3].y = points[i2].y - dm_out_y;
; 918  : 
; 919  :                 // Add indexes
; 920  :                 _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2);

  00692	41 8d 55 02	 lea	 edx, DWORD PTR [r13+2]
  00696	48 03 c6	 add	 rax, rsi
  00699	45 8d 48 01	 lea	 r9d, DWORD PTR [r8+1]
  0069d	0f 28 d4	 movaps	 xmm2, xmm4
  006a0	0f 28 dd	 movaps	 xmm3, xmm5
  006a3	f3 41 0f 59 d3	 mulss	 xmm2, xmm11

; 921  :                 _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 1);

  006a8	66 41 83 c0 02	 add	 r8w, 2
  006ad	41 ff c7	 inc	 r15d
  006b0	f3 41 0f 59 db	 mulss	 xmm3, xmm11
  006b5	0f 28 c2	 movaps	 xmm0, xmm2
  006b8	f3 41 0f 59 e0	 mulss	 xmm4, xmm8
  006bd	f3 0f 58 04 39	 addss	 xmm0, DWORD PTR [rcx+rdi]
  006c2	0f 28 cb	 movaps	 xmm1, xmm3
  006c5	f3 41 0f 59 e8	 mulss	 xmm5, xmm8
  006ca	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  006ce	0f 28 c4	 movaps	 xmm0, xmm4
  006d1	f3 0f 58 4c 39
	04		 addss	 xmm1, DWORD PTR [rcx+rdi+4]
  006d7	f3 0f 11 48 04	 movss	 DWORD PTR [rax+4], xmm1
  006dc	0f 28 cd	 movaps	 xmm1, xmm5
  006df	f3 0f 58 04 39	 addss	 xmm0, DWORD PTR [rcx+rdi]
  006e4	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0
  006e9	f3 0f 58 4c 39
	04		 addss	 xmm1, DWORD PTR [rcx+rdi+4]
  006ef	f3 0f 11 48 0c	 movss	 DWORD PTR [rax+12], xmm1
  006f4	f3 0f 10 04 39	 movss	 xmm0, DWORD PTR [rcx+rdi]
  006f9	f3 0f 5c c4	 subss	 xmm0, xmm4
  006fd	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
  00702	f3 0f 10 4c 39
	04		 movss	 xmm1, DWORD PTR [rcx+rdi+4]
  00708	f3 0f 5c cd	 subss	 xmm1, xmm5
  0070c	f3 0f 11 48 14	 movss	 DWORD PTR [rax+20], xmm1
  00711	f3 0f 10 04 39	 movss	 xmm0, DWORD PTR [rcx+rdi]
  00716	f3 0f 5c c2	 subss	 xmm0, xmm2
  0071a	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0
  0071f	f3 0f 10 4c 39
	04		 movss	 xmm1, DWORD PTR [rcx+rdi+4]
  00725	41 8d 4d 01	 lea	 ecx, DWORD PTR [r13+1]
  00729	f3 0f 5c cb	 subss	 xmm1, xmm3
  0072d	f3 0f 11 48 1c	 movss	 DWORD PTR [rax+28], xmm1
  00732	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00736	66 44 89 08	 mov	 WORD PTR [rax], r9w
  0073a	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0073e	66 89 48 02	 mov	 WORD PTR [rax+2], cx
  00742	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00746	66 89 50 04	 mov	 WORD PTR [rax+4], dx
  0074a	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0074e	66 89 50 06	 mov	 WORD PTR [rax+6], dx
  00752	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00756	66 44 89 40 08	 mov	 WORD PTR [rax+8], r8w
  0075b	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0075f	66 44 89 48 0a	 mov	 WORD PTR [rax+10], r9w

; 922  :                 _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0);

  00764	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00768	66 44 89 48 0c	 mov	 WORD PTR [rax+12], r9w
  0076d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00771	66 89 48 0e	 mov	 WORD PTR [rax+14], cx
  00775	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]

; 923  :                 _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);

  00779	8b 4d 08	 mov	 ecx, DWORD PTR idx2$1$[rbp]
  0077c	66 44 89 68 10	 mov	 WORD PTR [rax+16], r13w
  00781	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00785	66 44 89 68 12	 mov	 WORD PTR [rax+18], r13w

; 924  :                 _IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);

  0078a	66 41 83 c5 03	 add	 r13w, 3
  0078f	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00793	66 89 48 14	 mov	 WORD PTR [rax+20], cx

; 925  :                 _IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);

  00797	66 83 c1 03	 add	 cx, 3
  0079b	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0079f	66 44 89 48 16	 mov	 WORD PTR [rax+22], r9w
  007a4	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  007a8	66 44 89 40 18	 mov	 WORD PTR [rax+24], r8w
  007ad	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  007b1	66 89 50 1a	 mov	 WORD PTR [rax+26], dx
  007b5	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  007b9	48 8b 55 20	 mov	 rdx, QWORD PTR tv5555[rbp]
  007bd	66 44 89 68 1c	 mov	 WORD PTR [rax+28], r13w
  007c2	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  007c6	66 44 89 68 1e	 mov	 WORD PTR [rax+30], r13w
  007cb	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]

; 926  :                 _IdxWritePtr += 18;
; 927  : 
; 928  :                 idx1 = idx2;

  007cf	44 8b 6d 08	 mov	 r13d, DWORD PTR idx2$1$[rbp]
  007d3	66 89 48 20	 mov	 WORD PTR [rax+32], cx
  007d7	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  007db	66 44 89 40 22	 mov	 WORD PTR [rax+34], r8w
  007e0	48 83 43 50 24	 add	 QWORD PTR [rbx+80], 36	; 00000024H
  007e5	49 3b d4	 cmp	 rdx, r12
  007e8	0f 8c 22 fe ff
	ff		 jl	 $LL16@AddPolylin
  007ee	44 8b 65 10	 mov	 r12d, DWORD PTR col$1$[rbp]
  007f2	4d 8b ee	 mov	 r13, r14
$LN15@AddPolylin:

; 929  :             }
; 930  : 
; 931  :             // Add vertices
; 932  :             for (int i = 0; i < points_count; i++)

  007f5	4d 85 ed	 test	 r13, r13
  007f8	0f 84 7f 04 00
	00		 je	 $LN12@AddPolylin

; 770  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

  007fe	8b 4d 18	 mov	 ecx, DWORD PTR col_trans$1$[rbp]
  00801	48 83 c6 10	 add	 rsi, 16
  00805	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL19@AddPolylin:

; 933  :             {
; 934  :                 _VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col_trans;

  00810	f2 0f 10 46 f0	 movsd	 xmm0, QWORD PTR [rsi-16]
  00815	48 8d 76 20	 lea	 rsi, QWORD PTR [rsi+32]
  00819	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  0081d	49 ff c2	 inc	 r10
  00820	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00824	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00828	f3 0f 11 70 08	 movss	 DWORD PTR [rax+8], xmm6
  0082d	f3 0f 11 78 0c	 movss	 DWORD PTR [rax+12], xmm7
  00832	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00836	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 935  :                 _VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;

  00839	f2 0f 10 46 d8	 movsd	 xmm0, QWORD PTR [rsi-40]
  0083e	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00842	f2 0f 11 40 14	 movsd	 QWORD PTR [rax+20], xmm0
  00847	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  0084b	f3 0f 11 70 1c	 movss	 DWORD PTR [rax+28], xmm6
  00850	f3 0f 11 78 20	 movss	 DWORD PTR [rax+32], xmm7
  00855	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00859	44 89 60 24	 mov	 DWORD PTR [rax+36], r12d

; 936  :                 _VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;

  0085d	f2 0f 10 46 e0	 movsd	 xmm0, QWORD PTR [rsi-32]
  00862	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00866	f2 0f 11 40 28	 movsd	 QWORD PTR [rax+40], xmm0
  0086b	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  0086f	f3 0f 11 70 30	 movss	 DWORD PTR [rax+48], xmm6
  00874	f3 0f 11 78 34	 movss	 DWORD PTR [rax+52], xmm7
  00879	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  0087d	44 89 60 38	 mov	 DWORD PTR [rax+56], r12d

; 937  :                 _VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col_trans;

  00881	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00885	f2 0f 10 46 e8	 movsd	 xmm0, QWORD PTR [rsi-24]
  0088a	f2 0f 11 40 3c	 movsd	 QWORD PTR [rax+60], xmm0
  0088f	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00893	f3 0f 11 70 44	 movss	 DWORD PTR [rax+68], xmm6
  00898	f3 0f 11 78 48	 movss	 DWORD PTR [rax+72], xmm7
  0089d	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  008a1	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 938  :                 _VtxWritePtr += 4;

  008a4	48 83 43 48 50	 add	 QWORD PTR [rbx+72], 80	; 00000050H
  008a9	4d 3b d5	 cmp	 r10, r13
  008ac	0f 8c 5e ff ff
	ff		 jl	 $LL19@AddPolylin

; 939  :             }
; 940  :         }
; 941  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

  008b2	0f b7 45 14	 movzx	 eax, WORD PTR tv5195[rbp]
  008b6	01 43 34	 add	 DWORD PTR [rbx+52], eax

; 942  :     }

  008b9	e9 ae 05 00 00	 jmp	 $LN21@AddPolylin
$LN243@AddPolylin:

; 774  :         {
; 775  :             // [PATH 1] Texture-based lines (thick or non-thick)
; 776  :             // [PATH 2] Non texture-based lines (non-thick)
; 777  : 
; 778  :             // The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
; 779  :             // - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
; 780  :             //   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
; 781  :             // - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
; 782  :             //   allow scaling geometry while preserving one-screen-pixel AA fringe).
; 783  :             const float half_draw_size = use_texture ? ((thickness * 0.5f) + 1) : AA_SIZE;

  008be	45 0f 28 c8	 movaps	 xmm9, xmm8
  008c2	f3 44 0f 59 cc	 mulss	 xmm9, xmm4
  008c7	f3 45 0f 58 cd	 addss	 xmm9, xmm13
$LN60@AddPolylin:

; 784  : 
; 785  :             // If line is not closed, the first and last points need to be generated differently as there are no normals to blend
; 786  :             if (!closed)

  008cc	84 c0		 test	 al, al
  008ce	0f 85 c2 00 00
	00		 jne	 $LN31@AddPolylin
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  008d4	41 0f 28 c1	 movaps	 xmm0, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 790  :                 temp_points[(points_count - 1) * 2 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * half_draw_size;

  008d8	43 8d 04 36	 lea	 eax, DWORD PTR [r14+r14]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  008dc	f3 41 0f 59 43
	04		 mulss	 xmm0, DWORD PTR [r11+4]
  008e2	41 0f 28 c9	 movaps	 xmm1, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 790  :                 temp_points[(points_count - 1) * 2 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * half_draw_size;

  008e6	48 63 c8	 movsxd	 rcx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  008e9	f3 41 0f 59 0b	 mulss	 xmm1, DWORD PTR [r11]

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  008ee	f3 0f 58 47 04	 addss	 xmm0, DWORD PTR [rdi+4]
  008f3	f3 0f 58 0f	 addss	 xmm1, DWORD PTR [rdi]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 788  :                 temp_points[0] = points[0] + temp_normals[0] * half_draw_size;

  008f7	f3 0f 11 46 04	 movss	 DWORD PTR [rsi+4], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  008fc	41 0f 28 c1	 movaps	 xmm0, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 788  :                 temp_points[0] = points[0] + temp_normals[0] * half_draw_size;

  00900	f3 0f 11 0e	 movss	 DWORD PTR [rsi], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00904	41 0f 28 c9	 movaps	 xmm1, xmm9
  00908	f3 41 0f 59 03	 mulss	 xmm0, DWORD PTR [r11]
  0090d	f3 41 0f 59 4b
	04		 mulss	 xmm1, DWORD PTR [r11+4]

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  00913	f3 0f 10 17	 movss	 xmm2, DWORD PTR [rdi]
  00917	f3 0f 5c d0	 subss	 xmm2, xmm0
  0091b	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [rdi+4]
  00920	f3 0f 5c c1	 subss	 xmm0, xmm1

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00924	41 0f 28 c9	 movaps	 xmm1, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 789  :                 temp_points[1] = points[0] - temp_normals[0] * half_draw_size;

  00928	f3 0f 11 56 08	 movss	 DWORD PTR [rsi+8], xmm2
  0092d	f3 0f 11 46 0c	 movss	 DWORD PTR [rsi+12], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00932	41 0f 28 c1	 movaps	 xmm0, xmm9
  00936	f3 43 0f 59 44
	eb fc		 mulss	 xmm0, DWORD PTR [r11+r13*8-4]
  0093d	f3 43 0f 59 4c
	eb f8		 mulss	 xmm1, DWORD PTR [r11+r13*8-8]

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00944	f3 42 0f 58 44
	ef fc		 addss	 xmm0, DWORD PTR [rdi+r13*8-4]
  0094b	f3 42 0f 58 4c
	ef f8		 addss	 xmm1, DWORD PTR [rdi+r13*8-8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 790  :                 temp_points[(points_count - 1) * 2 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * half_draw_size;

  00952	f3 0f 11 44 ce
	f4		 movss	 DWORD PTR [rsi+rcx*8-12], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00958	41 0f 28 c1	 movaps	 xmm0, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 790  :                 temp_points[(points_count - 1) * 2 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * half_draw_size;

  0095c	f3 0f 11 4c ce
	f0		 movss	 DWORD PTR [rsi+rcx*8-16], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00962	41 0f 28 c9	 movaps	 xmm1, xmm9
  00966	f3 43 0f 59 44
	eb f8		 mulss	 xmm0, DWORD PTR [r11+r13*8-8]

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  0096d	f3 42 0f 10 54
	ef f8		 movss	 xmm2, DWORD PTR [rdi+r13*8-8]

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00974	f3 43 0f 59 4c
	eb fc		 mulss	 xmm1, DWORD PTR [r11+r13*8-4]

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  0097b	f3 0f 5c d0	 subss	 xmm2, xmm0
  0097f	f3 42 0f 10 44
	ef fc		 movss	 xmm0, DWORD PTR [rdi+r13*8-4]
  00986	f3 0f 5c c1	 subss	 xmm0, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 791  :                 temp_points[(points_count - 1) * 2 + 1] = points[points_count - 1] - temp_normals[points_count - 1] * half_draw_size;

  0098a	f3 0f 11 54 ce
	f8		 movss	 DWORD PTR [rsi+rcx*8-8], xmm2
  00990	f3 0f 11 44 ce
	fc		 movss	 DWORD PTR [rsi+rcx*8-4], xmm0
$LN31@AddPolylin:

; 792  :             }
; 793  : 
; 794  :             // Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
; 795  :             // This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
; 796  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 797  :             unsigned int idx1 = _VtxCurrentIdx; // Vertex index for start of line segment

  00996	44 8b 43 34	 mov	 r8d, DWORD PTR [rbx+52]

; 798  :             for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment

  0099a	4d 85 ff	 test	 r15, r15
  0099d	0f 8e a5 01 00
	00		 jle	 $LN6@AddPolylin

; 770  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

  009a3	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@358637bd
  009ac	4d 8b ca	 mov	 r9, r10
  009af	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR __real@42c80000
  009b7	41 bf 01 00 00
	00		 mov	 r15d, 1
  009bd	44 0f b6 65 00	 movzx	 r12d, BYTE PTR tv5731[rbp]
$LL7@AddPolylin:

; 799  :             {
; 800  :                 const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
; 801  :                 const unsigned int idx2 = ((i1 + 1) == points_count) ? _VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment

  009c2	49 8d 41 01	 lea	 rax, QWORD PTR [r9+1]
  009c6	45 3b fe	 cmp	 r15d, r14d
  009c9	49 8b ca	 mov	 rcx, r10
  009cc	48 89 45 20	 mov	 QWORD PTR tv5557[rbp], rax
  009d0	48 0f 45 c8	 cmovne	 rcx, rax
  009d4	75 05		 jne	 SHORT $LN63@AddPolylin
  009d6	8b 53 34	 mov	 edx, DWORD PTR [rbx+52]
  009d9	eb 0d		 jmp	 SHORT $LN64@AddPolylin
$LN63@AddPolylin:
  009db	0f b6 55 01	 movzx	 edx, BYTE PTR tv5733[rbp]
  009df	83 f2 01	 xor	 edx, 1
  009e2	83 c2 02	 add	 edx, 2
  009e5	41 03 d0	 add	 edx, r8d
$LN64@AddPolylin:

; 802  : 
; 803  :                 // Average normals
; 804  :                 float dm_x = (temp_normals[i1].x + temp_normals[i2].x) * 0.5f;

  009e8	f3 43 0f 10 14
	cb		 movss	 xmm2, DWORD PTR [r11+r9*8]
  009ee	48 8d 04 cd 00
	00 00 00	 lea	 rax, QWORD PTR [rcx*8]

; 805  :                 float dm_y = (temp_normals[i1].y + temp_normals[i2].y) * 0.5f;

  009f6	f3 42 0f 10 5c
	18 04		 movss	 xmm3, DWORD PTR [rax+r11+4]
  009fd	f3 43 0f 58 5c
	cb 04		 addss	 xmm3, DWORD PTR [r11+r9*8+4]
  00a04	f3 42 0f 58 14
	18		 addss	 xmm2, DWORD PTR [rax+r11]
  00a0a	f3 0f 59 dc	 mulss	 xmm3, xmm4
  00a0e	f3 0f 59 d4	 mulss	 xmm2, xmm4

; 806  :                 IM_FIXNORMAL2F(dm_x, dm_y);

  00a12	0f 28 cb	 movaps	 xmm1, xmm3
  00a15	f3 0f 59 cb	 mulss	 xmm1, xmm3
  00a19	0f 28 c2	 movaps	 xmm0, xmm2
  00a1c	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00a20	f3 0f 58 c8	 addss	 xmm1, xmm0
  00a24	41 0f 2f c8	 comiss	 xmm1, xmm8
  00a28	76 17		 jbe	 SHORT $LN32@AddPolylin
  00a2a	41 0f 28 c5	 movaps	 xmm0, xmm13
  00a2e	f3 0f 5e c1	 divss	 xmm0, xmm1
  00a32	0f 28 cd	 movaps	 xmm1, xmm5
  00a35	f3 0f 5d c8	 minss	 xmm1, xmm0
  00a39	f3 0f 59 d1	 mulss	 xmm2, xmm1
  00a3d	f3 0f 59 d9	 mulss	 xmm3, xmm1
$LN32@AddPolylin:

; 807  :                 dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area

  00a41	f3 41 0f 59 d1	 mulss	 xmm2, xmm9

; 808  :                 dm_y *= half_draw_size;
; 809  : 
; 810  :                 // Add temporary vertexes for the outer edges
; 811  :                 ImVec2* out_vtx = &temp_points[i2 * 2];
; 812  :                 out_vtx[0].x = points[i2].x + dm_x;
; 813  :                 out_vtx[0].y = points[i2].y + dm_y;
; 814  :                 out_vtx[1].x = points[i2].x - dm_x;
; 815  :                 out_vtx[1].y = points[i2].y - dm_y;

  00a46	44 8d 6a 01	 lea	 r13d, DWORD PTR [rdx+1]
  00a4a	48 c1 e1 04	 shl	 rcx, 4
  00a4e	45 8d 48 01	 lea	 r9d, DWORD PTR [r8+1]
  00a52	48 03 ce	 add	 rcx, rsi
  00a55	f3 41 0f 59 d9	 mulss	 xmm3, xmm9
  00a5a	0f 28 c2	 movaps	 xmm0, xmm2
  00a5d	f3 0f 58 04 38	 addss	 xmm0, DWORD PTR [rax+rdi]
  00a62	0f 28 cb	 movaps	 xmm1, xmm3
  00a65	f3 0f 11 01	 movss	 DWORD PTR [rcx], xmm0
  00a69	f3 0f 58 4c 38
	04		 addss	 xmm1, DWORD PTR [rax+rdi+4]
  00a6f	f3 0f 11 49 04	 movss	 DWORD PTR [rcx+4], xmm1
  00a74	f3 0f 10 04 38	 movss	 xmm0, DWORD PTR [rax+rdi]
  00a79	f3 0f 5c c2	 subss	 xmm0, xmm2
  00a7d	f3 0f 11 41 08	 movss	 DWORD PTR [rcx+8], xmm0
  00a82	f3 0f 10 4c 38
	04		 movss	 xmm1, DWORD PTR [rax+rdi+4]
  00a88	f3 0f 5c cb	 subss	 xmm1, xmm3
  00a8c	f3 0f 11 49 0c	 movss	 DWORD PTR [rcx+12], xmm1
  00a91	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00a95	66 89 10	 mov	 WORD PTR [rax], dx
  00a98	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00a9c	66 44 89 40 02	 mov	 WORD PTR [rax+2], r8w
  00aa1	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]

; 816  : 
; 817  :                 if (use_texture)

  00aa5	45 84 e4	 test	 r12b, r12b
  00aa8	74 26		 je	 SHORT $LN34@AddPolylin

; 818  :                 {
; 819  :                     // Add indices for two triangles
; 820  :                     _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 1); // Right tri

  00aaa	66 44 89 48 04	 mov	 WORD PTR [rax+4], r9w

; 821  :                     _IdxWritePtr[3] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[4] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Left tri

  00aaf	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00ab3	66 44 89 68 06	 mov	 WORD PTR [rax+6], r13w
  00ab8	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00abc	66 44 89 48 08	 mov	 WORD PTR [rax+8], r9w
  00ac1	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00ac5	66 89 50 0a	 mov	 WORD PTR [rax+10], dx

; 822  :                     _IdxWritePtr += 6;

  00ac9	48 83 43 50 0c	 add	 QWORD PTR [rbx+80], 12

; 823  :                 }

  00ace	eb 5d		 jmp	 SHORT $LN35@AddPolylin
$LN34@AddPolylin:

; 824  :                 else
; 825  :                 {
; 826  :                     // Add indexes for four triangles
; 827  :                     _IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2); // Right tri 1

  00ad0	41 8d 48 02	 lea	 ecx, DWORD PTR [r8+2]
  00ad4	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 828  :                     _IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0); // Right tri 2

  00ad8	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00adc	66 89 48 06	 mov	 WORD PTR [rax+6], cx
  00ae0	8d 4a 02	 lea	 ecx, DWORD PTR [rdx+2]
  00ae3	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00ae7	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  00aeb	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00aef	66 89 50 0a	 mov	 WORD PTR [rax+10], dx

; 829  :                     _IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0); // Left tri 1

  00af3	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00af7	66 44 89 68 0c	 mov	 WORD PTR [rax+12], r13w
  00afc	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00b00	66 44 89 48 0e	 mov	 WORD PTR [rax+14], r9w
  00b05	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00b09	66 44 89 40 10	 mov	 WORD PTR [rax+16], r8w
  00b0e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00b12	66 44 89 40 12	 mov	 WORD PTR [rax+18], r8w

; 830  :                     _IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1); // Left tri 2

  00b17	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00b1b	66 89 50 14	 mov	 WORD PTR [rax+20], dx
  00b1f	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00b23	66 44 89 68 16	 mov	 WORD PTR [rax+22], r13w

; 831  :                     _IdxWritePtr += 12;

  00b28	48 83 43 50 18	 add	 QWORD PTR [rbx+80], 24
$LN35@AddPolylin:

; 798  :             for (int i1 = 0; i1 < count; i1++) // i1 is the first point of the line segment

  00b2d	4c 8b 4d 20	 mov	 r9, QWORD PTR tv5557[rbp]
  00b31	41 ff c7	 inc	 r15d

; 832  :                 }
; 833  : 
; 834  :                 idx1 = idx2;

  00b34	44 8b c2	 mov	 r8d, edx
  00b37	4c 3b 4d 30	 cmp	 r9, QWORD PTR tv5196[rbp]
  00b3b	0f 8c 81 fe ff
	ff		 jl	 $LL7@AddPolylin
  00b41	44 8b 65 10	 mov	 r12d, DWORD PTR col$1$[rbp]
  00b45	4d 8b ee	 mov	 r13, r14
$LN6@AddPolylin:

; 835  :             }
; 836  : 
; 837  :             // Add vertexes for each point on the line
; 838  :             if (use_texture)

  00b48	44 38 55 00	 cmp	 BYTE PTR tv5731[rbp], r10b
  00b4c	0f 84 a1 00 00
	00		 je	 $LN36@AddPolylin

; 839  :             {
; 840  :                 // If we're using textures we only need to emit the left/right edge vertices
; 841  :                 ImVec4 tex_uvs = _Data->TexUvLines[integer_thickness];

  00b52	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00b56	48 63 55 38	 movsxd	 rdx, DWORD PTR integer_thickness$1$[rbp]
  00b5a	48 03 d2	 add	 rdx, rdx
  00b5d	48 8b 88 f8 01
	00 00		 mov	 rcx, QWORD PTR [rax+504]
  00b64	0f 10 04 d1	 movups	 xmm0, XMMWORD PTR [rcx+rdx*8]
  00b68	0f 11 45 20	 movups	 XMMWORD PTR tex_uvs$15[rbp], xmm0

; 842  :                 /*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
; 843  :                 {
; 844  :                     const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
; 845  :                     tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
; 846  :                     tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
; 847  :                     tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
; 848  :                     tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
; 849  :                 }*/
; 850  :                 ImVec2 tex_uv0(tex_uvs.x, tex_uvs.y);
; 851  :                 ImVec2 tex_uv1(tex_uvs.z, tex_uvs.w);
; 852  :                 for (int i = 0; i < points_count; i++)

  00b6c	4d 85 ed	 test	 r13, r13
  00b6f	0f 84 08 01 00
	00		 je	 $LN12@AddPolylin

; 770  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

  00b75	f3 0f 10 4d 2c	 movss	 xmm1, DWORD PTR tex_uvs$15[rbp+12]
  00b7a	f3 0f 10 55 28	 movss	 xmm2, DWORD PTR tex_uvs$15[rbp+8]
  00b7f	f3 0f 10 5d 24	 movss	 xmm3, DWORD PTR tex_uvs$15[rbp+4]
  00b84	f3 0f 10 65 20	 movss	 xmm4, DWORD PTR tex_uvs$15[rbp]
  00b89	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@AddPolylin:

; 853  :                 {
; 854  :                     _VtxWritePtr[0].pos = temp_points[i * 2 + 0]; _VtxWritePtr[0].uv = tex_uv0; _VtxWritePtr[0].col = col; // Left-side outer edge

  00b90	f2 0f 10 06	 movsd	 xmm0, QWORD PTR [rsi]
  00b94	48 8d 76 10	 lea	 rsi, QWORD PTR [rsi+16]
  00b98	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00b9c	49 ff c2	 inc	 r10
  00b9f	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00ba3	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00ba7	f3 0f 11 60 08	 movss	 DWORD PTR [rax+8], xmm4
  00bac	f3 0f 11 58 0c	 movss	 DWORD PTR [rax+12], xmm3
  00bb1	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00bb5	44 89 60 10	 mov	 DWORD PTR [rax+16], r12d

; 855  :                     _VtxWritePtr[1].pos = temp_points[i * 2 + 1]; _VtxWritePtr[1].uv = tex_uv1; _VtxWritePtr[1].col = col; // Right-side outer edge

  00bb9	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00bbd	f2 0f 10 46 f8	 movsd	 xmm0, QWORD PTR [rsi-8]
  00bc2	f2 0f 11 40 14	 movsd	 QWORD PTR [rax+20], xmm0
  00bc7	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00bcb	f3 0f 11 50 1c	 movss	 DWORD PTR [rax+28], xmm2
  00bd0	f3 0f 11 48 20	 movss	 DWORD PTR [rax+32], xmm1
  00bd5	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00bd9	44 89 60 24	 mov	 DWORD PTR [rax+36], r12d

; 856  :                     _VtxWritePtr += 2;

  00bdd	48 83 43 48 28	 add	 QWORD PTR [rbx+72], 40	; 00000028H
  00be2	4d 3b d5	 cmp	 r10, r13
  00be5	7c a9		 jl	 SHORT $LL10@AddPolylin

; 939  :             }
; 940  :         }
; 941  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

  00be7	0f b7 45 14	 movzx	 eax, WORD PTR tv5195[rbp]
  00beb	01 43 34	 add	 DWORD PTR [rbx+52], eax

; 942  :     }

  00bee	e9 79 02 00 00	 jmp	 $LN21@AddPolylin
$LN36@AddPolylin:

; 857  :                 }
; 858  :             }
; 859  :             else
; 860  :             {
; 861  :                 // If we're not using a texture, we need the center vertex as well
; 862  :                 for (int i = 0; i < points_count; i++)

  00bf3	4d 85 ed	 test	 r13, r13
  00bf6	0f 84 81 00 00
	00		 je	 $LN12@AddPolylin
  00bfc	8b 4d 18	 mov	 ecx, DWORD PTR col_trans$1$[rbp]
  00bff	90		 npad	 1
$LL13@AddPolylin:

; 863  :                 {
; 864  :                     _VtxWritePtr[0].pos = points[i];              _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;       // Center of line

  00c00	f2 0f 10 07	 movsd	 xmm0, QWORD PTR [rdi]
  00c04	48 8d 7f 08	 lea	 rdi, QWORD PTR [rdi+8]
  00c08	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00c0c	48 8d 76 10	 lea	 rsi, QWORD PTR [rsi+16]
  00c10	49 ff c2	 inc	 r10
  00c13	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00c17	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00c1b	f3 0f 11 70 08	 movss	 DWORD PTR [rax+8], xmm6
  00c20	f3 0f 11 78 0c	 movss	 DWORD PTR [rax+12], xmm7
  00c25	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00c29	44 89 60 10	 mov	 DWORD PTR [rax+16], r12d

; 865  :                     _VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col_trans; // Left-side outer edge

  00c2d	f2 0f 10 46 f0	 movsd	 xmm0, QWORD PTR [rsi-16]
  00c32	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00c36	f2 0f 11 40 14	 movsd	 QWORD PTR [rax+20], xmm0
  00c3b	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00c3f	f3 0f 11 70 1c	 movss	 DWORD PTR [rax+28], xmm6
  00c44	f3 0f 11 78 20	 movss	 DWORD PTR [rax+32], xmm7
  00c49	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00c4d	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 866  :                     _VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col_trans; // Right-side outer edge

  00c50	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00c54	f2 0f 10 46 f8	 movsd	 xmm0, QWORD PTR [rsi-8]
  00c59	f2 0f 11 40 28	 movsd	 QWORD PTR [rax+40], xmm0
  00c5e	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00c62	f3 0f 11 70 30	 movss	 DWORD PTR [rax+48], xmm6
  00c67	f3 0f 11 78 34	 movss	 DWORD PTR [rax+52], xmm7
  00c6c	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00c70	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 867  :                     _VtxWritePtr += 3;

  00c73	48 83 43 48 3c	 add	 QWORD PTR [rbx+72], 60	; 0000003cH
  00c78	4d 3b d5	 cmp	 r10, r13
  00c7b	7c 83		 jl	 SHORT $LL13@AddPolylin
$LN12@AddPolylin:

; 939  :             }
; 940  :         }
; 941  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

  00c7d	0f b7 45 14	 movzx	 eax, WORD PTR tv5195[rbp]
  00c81	01 43 34	 add	 DWORD PTR [rbx+52], eax

; 942  :     }

  00c84	e9 e3 01 00 00	 jmp	 $LN21@AddPolylin
$LN24@AddPolylin:

; 943  :     else
; 944  :     {
; 945  :         // [PATH 4] Non texture-based, Non anti-aliased lines
; 946  :         const int idx_count = count * 6;

  00c89	8d 14 40	 lea	 edx, DWORD PTR [rax+rax*2]

; 947  :         const int vtx_count = count * 4;    // FIXME-OPT: Not sharing edges
; 948  :         PrimReserve(idx_count, vtx_count);

  00c8c	48 8b cb	 mov	 rcx, rbx
  00c8f	03 d2		 add	 edx, edx
  00c91	44 8d 04 85 00
	00 00 00	 lea	 r8d, DWORD PTR [rax*4]
  00c99	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve

; 949  : 
; 950  :         for (int i1 = 0; i1 < count; i1++)

  00c9e	4d 85 ff	 test	 r15, r15
  00ca1	0f 8e c5 01 00
	00		 jle	 $LN21@AddPolylin

; 770  :             temp_normals[points_count - 1] = temp_normals[points_count - 2];

  00ca7	f3 44 0f 59 05
	00 00 00 00	 mulss	 xmm8, DWORD PTR __real@3f000000
  00cb0	45 33 d2	 xor	 r10d, r10d
  00cb3	41 8b d2	 mov	 edx, r10d
  00cb6	0f 57 ed	 xorps	 xmm5, xmm5
  00cb9	45 8d 7a 01	 lea	 r15d, QWORD PTR [r10+1]
  00cbd	0f 1f 00	 npad	 3
$LL22@AddPolylin:

; 951  :         {
; 952  :             const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
; 953  :             const ImVec2& p1 = points[i1];
; 954  :             const ImVec2& p2 = points[i2];
; 955  : 
; 956  :             float dx = p2.x - p1.x;

  00cc0	f3 0f 10 24 d7	 movss	 xmm4, DWORD PTR [rdi+rdx*8]
  00cc5	4c 8d 04 d7	 lea	 r8, QWORD PTR [rdi+rdx*8]
  00cc9	48 ff c2	 inc	 rdx
  00ccc	49 8b ca	 mov	 rcx, r10
  00ccf	45 3b fe	 cmp	 r15d, r14d
  00cd2	48 0f 45 ca	 cmovne	 rcx, rdx
  00cd6	f3 0f 10 14 cf	 movss	 xmm2, DWORD PTR [rdi+rcx*8]

; 957  :             float dy = p2.y - p1.y;

  00cdb	f3 0f 10 5c cf
	04		 movss	 xmm3, DWORD PTR [rdi+rcx*8+4]
  00ce1	f3 0f 5c d4	 subss	 xmm2, xmm4
  00ce5	f3 41 0f 5c 58
	04		 subss	 xmm3, DWORD PTR [r8+4]

; 958  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  00ceb	0f 28 c2	 movaps	 xmm0, xmm2
  00cee	0f 28 cb	 movaps	 xmm1, xmm3
  00cf1	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00cf5	f3 0f 59 cb	 mulss	 xmm1, xmm3
  00cf9	f3 0f 58 c8	 addss	 xmm1, xmm0
  00cfd	0f 2f cd	 comiss	 xmm1, xmm5
  00d00	76 0c		 jbe	 SHORT $LN41@AddPolylin
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  00d02	f3 0f 52 c1	 rsqrtss xmm0, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 958  :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  00d06	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00d0a	f3 0f 59 d8	 mulss	 xmm3, xmm0
$LN41@AddPolylin:

; 959  :             dx *= (thickness * 0.5f);
; 960  :             dy *= (thickness * 0.5f);
; 961  : 
; 962  :             _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = opaque_uv; _VtxWritePtr[0].col = col;

  00d0e	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00d12	41 ff c7	 inc	 r15d
  00d15	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  00d1a	f3 41 0f 59 d0	 mulss	 xmm2, xmm8
  00d1f	0f 28 c3	 movaps	 xmm0, xmm3
  00d22	f3 0f 58 c4	 addss	 xmm0, xmm4
  00d26	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0

; 963  :             _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = opaque_uv; _VtxWritePtr[1].col = col;

  00d2a	0f 28 c3	 movaps	 xmm0, xmm3
  00d2d	f3 41 0f 10 48
	04		 movss	 xmm1, DWORD PTR [r8+4]
  00d33	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00d37	f3 0f 5c ca	 subss	 xmm1, xmm2
  00d3b	f3 0f 11 48 04	 movss	 DWORD PTR [rax+4], xmm1
  00d40	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00d44	f3 0f 11 70 08	 movss	 DWORD PTR [rax+8], xmm6
  00d49	f3 0f 11 78 0c	 movss	 DWORD PTR [rax+12], xmm7
  00d4e	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00d52	44 89 60 10	 mov	 DWORD PTR [rax+16], r12d
  00d56	f3 0f 58 04 cf	 addss	 xmm0, DWORD PTR [rdi+rcx*8]
  00d5b	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00d5f	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0
  00d64	f3 0f 10 4c cf
	04		 movss	 xmm1, DWORD PTR [rdi+rcx*8+4]
  00d6a	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00d6e	f3 0f 5c ca	 subss	 xmm1, xmm2
  00d72	f3 0f 11 48 18	 movss	 DWORD PTR [rax+24], xmm1

; 964  :             _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = opaque_uv; _VtxWritePtr[2].col = col;

  00d77	0f 28 ca	 movaps	 xmm1, xmm2
  00d7a	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00d7e	f3 0f 11 70 1c	 movss	 DWORD PTR [rax+28], xmm6
  00d83	f3 0f 11 78 20	 movss	 DWORD PTR [rax+32], xmm7
  00d88	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00d8c	44 89 60 24	 mov	 DWORD PTR [rax+36], r12d
  00d90	f3 0f 10 04 cf	 movss	 xmm0, DWORD PTR [rdi+rcx*8]
  00d95	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00d99	f3 0f 5c c3	 subss	 xmm0, xmm3
  00d9d	f3 0f 11 40 28	 movss	 DWORD PTR [rax+40], xmm0
  00da2	f3 0f 58 4c cf
	04		 addss	 xmm1, DWORD PTR [rdi+rcx*8+4]
  00da8	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00dac	f3 0f 11 48 2c	 movss	 DWORD PTR [rax+44], xmm1
  00db1	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00db5	f3 0f 11 70 30	 movss	 DWORD PTR [rax+48], xmm6
  00dba	f3 0f 11 78 34	 movss	 DWORD PTR [rax+52], xmm7
  00dbf	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00dc3	44 89 60 38	 mov	 DWORD PTR [rax+56], r12d

; 965  :             _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = opaque_uv; _VtxWritePtr[3].col = col;

  00dc7	f3 41 0f 10 00	 movss	 xmm0, DWORD PTR [r8]
  00dcc	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00dd0	f3 0f 5c c3	 subss	 xmm0, xmm3
  00dd4	f3 0f 11 40 3c	 movss	 DWORD PTR [rax+60], xmm0
  00dd9	f3 41 0f 58 50
	04		 addss	 xmm2, DWORD PTR [r8+4]
  00ddf	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00de3	f3 0f 11 50 40	 movss	 DWORD PTR [rax+64], xmm2
  00de8	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00dec	f3 0f 11 70 44	 movss	 DWORD PTR [rax+68], xmm6
  00df1	f3 0f 11 78 48	 movss	 DWORD PTR [rax+72], xmm7
  00df6	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00dfa	44 89 60 4c	 mov	 DWORD PTR [rax+76], r12d

; 966  :             _VtxWritePtr += 4;
; 967  : 
; 968  :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);

  00dfe	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00e02	0f b7 43 34	 movzx	 eax, WORD PTR [rbx+52]
  00e06	48 83 43 48 50	 add	 QWORD PTR [rbx+72], 80	; 00000050H
  00e0b	66 89 01	 mov	 WORD PTR [rcx], ax
  00e0e	0f b7 4b 34	 movzx	 ecx, WORD PTR [rbx+52]
  00e12	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00e16	66 ff c1	 inc	 cx
  00e19	66 89 48 02	 mov	 WORD PTR [rax+2], cx
  00e1d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00e21	0f b7 4b 34	 movzx	 ecx, WORD PTR [rbx+52]
  00e25	66 83 c1 02	 add	 cx, 2
  00e29	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 969  :             _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);

  00e2d	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00e31	0f b7 43 34	 movzx	 eax, WORD PTR [rbx+52]
  00e35	66 89 41 06	 mov	 WORD PTR [rcx+6], ax
  00e39	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00e3d	0f b7 4b 34	 movzx	 ecx, WORD PTR [rbx+52]
  00e41	66 83 c1 02	 add	 cx, 2
  00e45	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  00e49	0f b7 4b 34	 movzx	 ecx, WORD PTR [rbx+52]
  00e4d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00e51	66 83 c1 03	 add	 cx, 3
  00e55	66 89 48 0a	 mov	 WORD PTR [rax+10], cx

; 970  :             _IdxWritePtr += 6;

  00e59	48 83 43 50 0c	 add	 QWORD PTR [rbx+80], 12

; 971  :             _VtxCurrentIdx += 4;

  00e5e	83 43 34 04	 add	 DWORD PTR [rbx+52], 4
  00e62	48 3b 55 30	 cmp	 rdx, QWORD PTR tv5196[rbp]
  00e66	0f 8c 54 fe ff
	ff		 jl	 $LL22@AddPolylin
$LN21@AddPolylin:

; 972  :         }
; 973  :     }
; 974  : }

  00e6c	48 8b 4d 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00e70	48 33 cd	 xor	 rcx, rbp
  00e73	e8 00 00 00 00	 call	 __security_check_cookie
  00e78	48 8b 9d 00 01
	00 00		 mov	 rbx, QWORD PTR [rbp+256]
  00e7f	48 8b b5 08 01
	00 00		 mov	 rsi, QWORD PTR [rbp+264]
  00e86	48 8b bd 10 01
	00 00		 mov	 rdi, QWORD PTR [rbp+272]
  00e8d	0f 28 b5 c0 00
	00 00		 movaps	 xmm6, XMMWORD PTR [rbp+192]
  00e94	0f 28 bd b0 00
	00 00		 movaps	 xmm7, XMMWORD PTR [rbp+176]
  00e9b	44 0f 28 85 a0
	00 00 00	 movaps	 xmm8, XMMWORD PTR [rbp+160]
  00ea3	44 0f 28 8d 90
	00 00 00	 movaps	 xmm9, XMMWORD PTR [rbp+144]
  00eab	44 0f 28 95 80
	00 00 00	 movaps	 xmm10, XMMWORD PTR [rbp+128]
  00eb3	44 0f 28 5d 70	 movaps	 xmm11, XMMWORD PTR [rbp+112]
  00eb8	44 0f 28 65 60	 movaps	 xmm12, XMMWORD PTR [rbp+96]
  00ebd	44 0f 28 6d 50	 movaps	 xmm13, XMMWORD PTR [rbp+80]
  00ec2	48 8d a5 d0 00
	00 00		 lea	 rsp, QWORD PTR [rbp+208]
  00ec9	41 5f		 pop	 r15
  00ecb	41 5e		 pop	 r14
  00ecd	41 5d		 pop	 r13
  00ecf	41 5c		 pop	 r12
  00ed1	5d		 pop	 rbp
  00ed2	c3		 ret	 0
?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ENDP	; ImDrawList::AddPolyline
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i1$1$ = 0
col_trans$1$ = 4
vtx_count$1$ = 8
__$ArrayPad$ = 16
this$ = 160
points$ = 168
points_count$ = 176
col$ = 184
?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z PROC ; ImDrawList::AddConvexPolyFilled

; 978  : {

$LN70:
  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00011	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00016	48 89 9d a0 00
	00 00		 mov	 QWORD PTR [rbp+160], rbx
  0001d	48 89 b5 a8 00
	00 00		 mov	 QWORD PTR [rbp+168], rsi
  00024	48 89 bd b0 00
	00 00		 mov	 QWORD PTR [rbp+176], rdi
  0002b	0f 29 75 60	 movaps	 XMMWORD PTR [rbp+96], xmm6
  0002f	0f 29 7d 50	 movaps	 XMMWORD PTR [rbp+80], xmm7
  00033	44 0f 29 45 40	 movaps	 XMMWORD PTR [rbp+64], xmm8
  00038	44 0f 29 4d 30	 movaps	 XMMWORD PTR [rbp+48], xmm9
  0003d	44 0f 29 55 20	 movaps	 XMMWORD PTR [rbp+32], xmm10
  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00049	48 33 c5	 xor	 rax, rbp
  0004c	48 89 45 10	 mov	 QWORD PTR __$ArrayPad$[rbp], rax
  00050	41 8b f0	 mov	 esi, r8d
  00053	45 8b e9	 mov	 r13d, r9d
  00056	48 8b fa	 mov	 rdi, rdx
  00059	48 8b d9	 mov	 rbx, rcx

; 979  :     if (points_count < 3)

  0005c	41 83 f8 03	 cmp	 r8d, 3
  00060	0f 8c d8 04 00
	00		 jl	 $LN19@AddConvexP

; 980  :         return;
; 981  : 
; 982  :     const ImVec2 uv = _Data->TexUvWhitePixel;
; 983  : 
; 984  :     if (Flags & ImDrawListFlags_AntiAliasedFill)

  00066	f6 41 30 04	 test	 BYTE PTR [rcx+48], 4
  0006a	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0006e	f3 44 0f 10 00	 movss	 xmm8, DWORD PTR [rax]
  00073	f3 44 0f 10 48
	04		 movss	 xmm9, DWORD PTR [rax+4]
  00079	0f 84 24 04 00
	00		 je	 $LN18@AddConvexP

; 985  :     {
; 986  :         // Anti-aliased Fill
; 987  :         const float AA_SIZE = _FringeScale;

  0007f	f3 44 0f 10 91
	c0 00 00 00	 movss	 xmm10, DWORD PTR [rcx+192]

; 988  :         const ImU32 col_trans = col & ~IM_COL32_A_MASK;
; 989  :         const int idx_count = (points_count - 2) * 3 + points_count * 6;

  00088	8d 14 f5 fa ff
	ff ff		 lea	 edx, DWORD PTR [rsi*8-6]
  0008f	41 8b c1	 mov	 eax, r9d
  00092	03 d6		 add	 edx, esi
  00094	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00099	89 45 04	 mov	 DWORD PTR col_trans$1$[rbp], eax

; 990  :         const int vtx_count = (points_count * 2);

  0009c	8d 04 36	 lea	 eax, DWORD PTR [rsi+rsi]

; 991  :         PrimReserve(idx_count, vtx_count);

  0009f	44 8b c0	 mov	 r8d, eax
  000a2	89 45 08	 mov	 DWORD PTR vtx_count$1$[rbp], eax
  000a5	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve

; 992  : 
; 993  :         // Add indexes for fill
; 994  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

  000aa	44 8b 73 34	 mov	 r14d, DWORD PTR [rbx+52]
  000ae	41 b8 02 00 00
	00		 mov	 r8d, 2
  000b4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@AddConvexP:

; 995  :         unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
; 996  :         for (int i = 2; i < points_count; i++)
; 997  :         {
; 998  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));

  000c0	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000c4	41 0f b7 d0	 movzx	 edx, r8w
  000c8	66 03 d2	 add	 dx, dx
  000cb	41 ff c0	 inc	 r8d
  000ce	66 41 03 d6	 add	 dx, r14w
  000d2	66 44 89 30	 mov	 WORD PTR [rax], r14w
  000d6	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000da	8d 4a fe	 lea	 ecx, DWORD PTR [rdx-2]
  000dd	66 89 48 02	 mov	 WORD PTR [rax+2], cx
  000e1	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000e5	66 89 50 04	 mov	 WORD PTR [rax+4], dx

; 999  :             _IdxWritePtr += 3;

  000e9	48 83 43 50 06	 add	 QWORD PTR [rbx+80], 6
  000ee	44 3b c6	 cmp	 r8d, esi
  000f1	7c cd		 jl	 SHORT $LL4@AddConvexP

; 1000 :         }
; 1001 : 
; 1002 :         // Compute normals
; 1003 :         ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2)); //-V630

  000f3	48 63 c6	 movsxd	 rax, esi
  000f6	48 c1 e0 03	 shl	 rax, 3
  000fa	48 8d 48 0f	 lea	 rcx, QWORD PTR [rax+15]
  000fe	48 3b c8	 cmp	 rcx, rax
  00101	77 0a		 ja	 SHORT $LN67@AddConvexP
  00103	48 b9 f0 ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846960 ; 0ffffffffffffff0H
$LN67@AddConvexP:
  0010d	48 83 e1 f0	 and	 rcx, -16
  00111	48 8b c1	 mov	 rax, rcx
  00114	e8 00 00 00 00	 call	 __chkstk

; 1004 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

  00119	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __xmm@80000000800000008000000080000000
  00121	44 8d 7e ff	 lea	 r15d, DWORD PTR [rsi-1]
  00125	48 2b e1	 sub	 rsp, rcx
  00128	45 33 d2	 xor	 r10d, r10d
  0012b	45 8b c2	 mov	 r8d, r10d
  0012e	0f 57 ed	 xorps	 xmm5, xmm5
  00131	4c 8d 4c 24 20	 lea	 r9, QWORD PTR [rsp+32]
  00136	83 fe 04	 cmp	 esi, 4
  00139	0f 8c 74 01 00
	00		 jl	 $LN66@AddConvexP
  0013f	48 63 d6	 movsxd	 rdx, esi
  00142	8d 46 fc	 lea	 eax, DWORD PTR [rsi-4]
  00145	48 ff ca	 dec	 rdx
  00148	c1 e8 02	 shr	 eax, 2
  0014b	4d 8b c1	 mov	 r8, r9
  0014e	48 c1 e2 03	 shl	 rdx, 3
  00152	41 bc 0c 00 00
	00		 mov	 r12d, 12
  00158	48 8d 4f 0c	 lea	 rcx, QWORD PTR [rdi+12]
  0015c	4c 2b c7	 sub	 r8, rdi
  0015f	4c 2b e7	 sub	 r12, rdi
  00162	ff c0		 inc	 eax
  00164	44 8b d8	 mov	 r11d, eax
  00167	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR [rax*4]
  0016e	89 45 00	 mov	 DWORD PTR i1$1$[rbp], eax
$LL47@AddConvexP:

; 1005 :         {
; 1006 :             const ImVec2& p0 = points[i0];
; 1007 :             const ImVec2& p1 = points[i1];
; 1008 :             float dx = p1.x - p0.x;

  00171	f3 0f 10 49 f4	 movss	 xmm1, DWORD PTR [rcx-12]

; 1009 :             float dy = p1.y - p0.y;

  00176	f3 0f 10 51 f8	 movss	 xmm2, DWORD PTR [rcx-8]
  0017b	f3 0f 5c 0c 3a	 subss	 xmm1, DWORD PTR [rdx+rdi]
  00180	f3 0f 5c 54 3a
	04		 subss	 xmm2, DWORD PTR [rdx+rdi+4]

; 1010 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  00186	0f 28 c1	 movaps	 xmm0, xmm1
  00189	0f 28 da	 movaps	 xmm3, xmm2
  0018c	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00190	f3 0f 59 da	 mulss	 xmm3, xmm2
  00194	f3 0f 58 d8	 addss	 xmm3, xmm0
  00198	0f 2f dd	 comiss	 xmm3, xmm5
  0019b	76 0c		 jbe	 SHORT $LN43@AddConvexP
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  0019d	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1010 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  001a1	f3 0f 59 c8	 mulss	 xmm1, xmm0
  001a5	f3 0f 59 d0	 mulss	 xmm2, xmm0
$LN43@AddConvexP:

; 1011 :             temp_normals[i0].x = dy;

  001a9	f3 42 0f 11 14
	0a		 movss	 DWORD PTR [rdx+r9], xmm2

; 1012 :             temp_normals[i0].y = -dx;

  001af	0f 57 cc	 xorps	 xmm1, xmm4
  001b2	f3 42 0f 11 4c
	0a 04		 movss	 DWORD PTR [rdx+r9+4], xmm1
  001b9	f3 0f 10 51 fc	 movss	 xmm2, DWORD PTR [rcx-4]
  001be	f3 0f 10 09	 movss	 xmm1, DWORD PTR [rcx]
  001c2	f3 0f 5c 51 f4	 subss	 xmm2, DWORD PTR [rcx-12]
  001c7	f3 0f 5c 49 f8	 subss	 xmm1, DWORD PTR [rcx-8]
  001cc	0f 28 c2	 movaps	 xmm0, xmm2
  001cf	0f 28 d9	 movaps	 xmm3, xmm1
  001d2	f3 0f 59 c2	 mulss	 xmm0, xmm2
  001d6	f3 0f 59 d9	 mulss	 xmm3, xmm1
  001da	f3 0f 58 d8	 addss	 xmm3, xmm0
  001de	0f 2f dd	 comiss	 xmm3, xmm5
  001e1	76 0c		 jbe	 SHORT $LN44@AddConvexP
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  001e3	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1010 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  001e7	f3 0f 59 d0	 mulss	 xmm2, xmm0
  001eb	f3 0f 59 c8	 mulss	 xmm1, xmm0
$LN44@AddConvexP:

; 1011 :             temp_normals[i0].x = dy;

  001ef	f3 41 0f 11 4c
	08 f4		 movss	 DWORD PTR [r8+rcx-12], xmm1

; 1012 :             temp_normals[i0].y = -dx;

  001f6	0f 57 d4	 xorps	 xmm2, xmm4
  001f9	f3 41 0f 11 54
	08 f8		 movss	 DWORD PTR [r8+rcx-8], xmm2
  00200	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [rcx+4]
  00205	f3 0f 10 51 08	 movss	 xmm2, DWORD PTR [rcx+8]
  0020a	f3 0f 5c 49 fc	 subss	 xmm1, DWORD PTR [rcx-4]
  0020f	f3 0f 5c 11	 subss	 xmm2, DWORD PTR [rcx]
  00213	0f 28 c1	 movaps	 xmm0, xmm1
  00216	0f 28 da	 movaps	 xmm3, xmm2
  00219	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0021d	f3 0f 59 da	 mulss	 xmm3, xmm2
  00221	f3 0f 58 d8	 addss	 xmm3, xmm0
  00225	0f 2f dd	 comiss	 xmm3, xmm5
  00228	76 0c		 jbe	 SHORT $LN45@AddConvexP
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  0022a	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1010 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  0022e	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00232	f3 0f 59 d0	 mulss	 xmm2, xmm0
$LN45@AddConvexP:

; 1011 :             temp_normals[i0].x = dy;

  00236	f3 41 0f 11 54
	08 fc		 movss	 DWORD PTR [r8+rcx-4], xmm2

; 1012 :             temp_normals[i0].y = -dx;

  0023d	0f 57 cc	 xorps	 xmm1, xmm4
  00240	f3 41 0f 11 0c
	08		 movss	 DWORD PTR [r8+rcx], xmm1
  00246	f3 0f 10 49 0c	 movss	 xmm1, DWORD PTR [rcx+12]
  0024b	f3 0f 10 51 10	 movss	 xmm2, DWORD PTR [rcx+16]
  00250	f3 0f 5c 49 04	 subss	 xmm1, DWORD PTR [rcx+4]
  00255	f3 0f 5c 51 08	 subss	 xmm2, DWORD PTR [rcx+8]
  0025a	0f 28 c1	 movaps	 xmm0, xmm1
  0025d	0f 28 da	 movaps	 xmm3, xmm2
  00260	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00264	f3 0f 59 da	 mulss	 xmm3, xmm2
  00268	f3 0f 58 d8	 addss	 xmm3, xmm0
  0026c	0f 2f dd	 comiss	 xmm3, xmm5
  0026f	76 0c		 jbe	 SHORT $LN46@AddConvexP
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  00271	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1010 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  00275	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00279	f3 0f 59 d0	 mulss	 xmm2, xmm0
$LN46@AddConvexP:

; 1011 :             temp_normals[i0].x = dy;

  0027d	f3 41 0f 11 54
	08 04		 movss	 DWORD PTR [r8+rcx+4], xmm2
  00284	49 8d 42 03	 lea	 rax, QWORD PTR [r10+3]

; 1012 :             temp_normals[i0].y = -dx;

  00288	0f 57 cc	 xorps	 xmm1, xmm4
  0028b	49 8d 14 0c	 lea	 rdx, QWORD PTR [r12+rcx]
  0028f	f3 41 0f 11 4c
	08 08		 movss	 DWORD PTR [r8+rcx+8], xmm1
  00296	49 83 c2 04	 add	 r10, 4
  0029a	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0029e	49 83 eb 01	 sub	 r11, 1
  002a2	0f 85 c9 fe ff
	ff		 jne	 $LL47@AddConvexP

; 1004 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

  002a8	44 8b 45 00	 mov	 r8d, DWORD PTR i1$1$[rbp]
  002ac	44 3b c6	 cmp	 r8d, esi
  002af	7c 08		 jl	 SHORT $LN59@AddConvexP
  002b1	eb 71		 jmp	 SHORT $LN65@AddConvexP
$LN66@AddConvexP:
  002b3	48 63 c6	 movsxd	 rax, esi
  002b6	48 ff c8	 dec	 rax
$LN59@AddConvexP:
  002b9	48 8d 0c c5 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*8]
  002c1	8b c6		 mov	 eax, esi
  002c3	41 2b c0	 sub	 eax, r8d
  002c6	4a 8d 14 d7	 lea	 rdx, QWORD PTR [rdi+r10*8]
  002ca	44 8b c0	 mov	 r8d, eax
$LC48@AddConvexP:

; 1005 :         {
; 1006 :             const ImVec2& p0 = points[i0];
; 1007 :             const ImVec2& p1 = points[i1];
; 1008 :             float dx = p1.x - p0.x;

  002cd	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [rdx]

; 1009 :             float dy = p1.y - p0.y;

  002d1	f3 0f 10 52 04	 movss	 xmm2, DWORD PTR [rdx+4]
  002d6	f3 0f 5c 0c 39	 subss	 xmm1, DWORD PTR [rcx+rdi]
  002db	f3 0f 5c 54 39
	04		 subss	 xmm2, DWORD PTR [rcx+rdi+4]

; 1010 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  002e1	0f 28 c1	 movaps	 xmm0, xmm1
  002e4	0f 28 da	 movaps	 xmm3, xmm2
  002e7	f3 0f 59 c1	 mulss	 xmm0, xmm1
  002eb	f3 0f 59 da	 mulss	 xmm3, xmm2
  002ef	f3 0f 58 d8	 addss	 xmm3, xmm0
  002f3	0f 2f dd	 comiss	 xmm3, xmm5
  002f6	76 0c		 jbe	 SHORT $LN20@AddConvexP
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  002f8	f3 0f 52 c3	 rsqrtss xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1010 :             IM_NORMALIZE2F_OVER_ZERO(dx, dy);

  002fc	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00300	f3 0f 59 d0	 mulss	 xmm2, xmm0
$LN20@AddConvexP:

; 1011 :             temp_normals[i0].x = dy;

  00304	f3 42 0f 11 14
	09		 movss	 DWORD PTR [rcx+r9], xmm2

; 1012 :             temp_normals[i0].y = -dx;

  0030a	0f 57 cc	 xorps	 xmm1, xmm4
  0030d	f3 42 0f 11 4c
	09 04		 movss	 DWORD PTR [rcx+r9+4], xmm1
  00314	48 8b ca	 mov	 rcx, rdx
  00317	48 2b cf	 sub	 rcx, rdi
  0031a	48 83 c2 08	 add	 rdx, 8
  0031e	49 83 e8 01	 sub	 r8, 1
  00322	75 a9		 jne	 SHORT $LC48@AddConvexP
$LN65@AddConvexP:

; 1013 :         }
; 1014 : 
; 1015 :         for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)

  00324	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  0032c	4c 8d 57 04	 lea	 r10, QWORD PTR [rdi+4]
  00330	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@358637bd
  00338	4d 8b d9	 mov	 r11, r9
  0033b	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR __real@3f800000
  00343	4c 2b df	 sub	 r11, rdi
  00346	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@42c80000
  0034e	33 ff		 xor	 edi, edi
  00350	44 8b 65 04	 mov	 r12d, DWORD PTR col_trans$1$[rbp]
  00354	f3 44 0f 59 d4	 mulss	 xmm10, xmm4
  00359	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@AddConvexP:

; 1016 :         {
; 1017 :             // Average normals
; 1018 :             const ImVec2& n0 = temp_normals[i0];
; 1019 :             const ImVec2& n1 = temp_normals[i1];
; 1020 :             float dm_x = (n0.x + n1.x) * 0.5f;

  00360	f3 43 0f 10 54
	1a fc		 movss	 xmm2, DWORD PTR [r10+r11-4]

; 1021 :             float dm_y = (n0.y + n1.y) * 0.5f;

  00367	f3 43 0f 10 1c
	1a		 movss	 xmm3, DWORD PTR [r10+r11]
  0036d	49 63 c7	 movsxd	 rax, r15d
  00370	f3 41 0f 58 14
	c1		 addss	 xmm2, DWORD PTR [r9+rax*8]
  00376	f3 41 0f 58 5c
	c1 04		 addss	 xmm3, DWORD PTR [r9+rax*8+4]
  0037d	f3 0f 59 d4	 mulss	 xmm2, xmm4
  00381	f3 0f 59 dc	 mulss	 xmm3, xmm4

; 1022 :             IM_FIXNORMAL2F(dm_x, dm_y);

  00385	0f 28 c2	 movaps	 xmm0, xmm2
  00388	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0038c	0f 28 cb	 movaps	 xmm1, xmm3
  0038f	f3 0f 59 cb	 mulss	 xmm1, xmm3
  00393	f3 0f 58 c8	 addss	 xmm1, xmm0
  00397	0f 2f cf	 comiss	 xmm1, xmm7
  0039a	76 16		 jbe	 SHORT $LN21@AddConvexP
  0039c	0f 28 c5	 movaps	 xmm0, xmm5
  0039f	f3 0f 5e c1	 divss	 xmm0, xmm1
  003a3	0f 28 ce	 movaps	 xmm1, xmm6
  003a6	f3 0f 5d c8	 minss	 xmm1, xmm0
  003aa	f3 0f 59 d1	 mulss	 xmm2, xmm1
  003ae	f3 0f 59 d9	 mulss	 xmm3, xmm1
$LN21@AddConvexP:

; 1023 :             dm_x *= AA_SIZE * 0.5f;
; 1024 :             dm_y *= AA_SIZE * 0.5f;
; 1025 : 
; 1026 :             // Add vertices
; 1027 :             _VtxWritePtr[0].pos.x = (points[i1].x - dm_x); _VtxWritePtr[0].pos.y = (points[i1].y - dm_y); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

  003b2	f3 41 0f 10 42
	fc		 movss	 xmm0, DWORD PTR [r10-4]

; 1028 :             _VtxWritePtr[1].pos.x = (points[i1].x + dm_x); _VtxWritePtr[1].pos.y = (points[i1].y + dm_y); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
; 1029 :             _VtxWritePtr += 2;
; 1030 : 
; 1031 :             // Add indexes for fringes
; 1032 :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));

  003b8	66 45 03 ff	 add	 r15w, r15w
  003bc	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  003c0	44 0f b7 c7	 movzx	 r8d, di
  003c4	f3 41 0f 59 d2	 mulss	 xmm2, xmm10
  003c9	66 45 03 c0	 add	 r8w, r8w
  003cd	43 8d 0c 3e	 lea	 ecx, DWORD PTR [r14+r15]
  003d1	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  003d6	f3 0f 5c c2	 subss	 xmm0, xmm2
  003da	43 8d 14 06	 lea	 edx, DWORD PTR [r14+r8]
  003de	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  003e2	f3 41 0f 10 0a	 movss	 xmm1, DWORD PTR [r10]
  003e7	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  003eb	f3 0f 5c cb	 subss	 xmm1, xmm3
  003ef	f3 0f 11 48 04	 movss	 DWORD PTR [rax+4], xmm1
  003f4	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  003f8	f3 44 0f 11 40
	08		 movss	 DWORD PTR [rax+8], xmm8
  003fe	f3 44 0f 11 48
	0c		 movss	 DWORD PTR [rax+12], xmm9
  00404	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00408	44 89 68 10	 mov	 DWORD PTR [rax+16], r13d
  0040c	f3 41 0f 58 52
	fc		 addss	 xmm2, DWORD PTR [r10-4]
  00412	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00416	f3 0f 11 50 14	 movss	 DWORD PTR [rax+20], xmm2
  0041b	f3 41 0f 58 1a	 addss	 xmm3, DWORD PTR [r10]
  00420	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00424	49 83 c2 08	 add	 r10, 8
  00428	f3 0f 11 58 18	 movss	 DWORD PTR [rax+24], xmm3
  0042d	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00431	f3 44 0f 11 40
	1c		 movss	 DWORD PTR [rax+28], xmm8
  00437	f3 44 0f 11 48
	20		 movss	 DWORD PTR [rax+32], xmm9
  0043d	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00441	44 89 60 24	 mov	 DWORD PTR [rax+36], r12d
  00445	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00449	48 83 43 48 28	 add	 QWORD PTR [rbx+72], 40	; 00000028H
  0044e	66 89 10	 mov	 WORD PTR [rax], dx
  00451	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00455	66 89 48 02	 mov	 WORD PTR [rax+2], cx
  00459	41 8d 4e 01	 lea	 ecx, DWORD PTR [r14+1]
  0045d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00461	66 44 03 f9	 add	 r15w, cx

; 1033 :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));

  00465	66 44 03 c1	 add	 r8w, cx
  00469	66 44 89 78 04	 mov	 WORD PTR [rax+4], r15w
  0046e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00472	66 44 89 78 06	 mov	 WORD PTR [rax+6], r15w
  00477	44 8b ff	 mov	 r15d, edi
  0047a	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0047e	ff c7		 inc	 edi
  00480	66 44 89 40 08	 mov	 WORD PTR [rax+8], r8w
  00485	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00489	66 89 50 0a	 mov	 WORD PTR [rax+10], dx

; 1034 :             _IdxWritePtr += 6;

  0048d	48 83 43 50 0c	 add	 QWORD PTR [rbx+80], 12
  00492	3b fe		 cmp	 edi, esi
  00494	0f 8c c6 fe ff
	ff		 jl	 $LL10@AddConvexP

; 1035 :         }
; 1036 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

  0049a	0f b7 45 08	 movzx	 eax, WORD PTR vtx_count$1$[rbp]

; 1037 :     }

  0049e	e9 98 00 00 00	 jmp	 $LN68@AddConvexP
$LN18@AddConvexP:

; 1038 :     else
; 1039 :     {
; 1040 :         // Non Anti-aliased Fill
; 1041 :         const int idx_count = (points_count - 2) * 3;

  004a3	8d 46 fe	 lea	 eax, DWORD PTR [rsi-2]

; 1042 :         const int vtx_count = points_count;
; 1043 :         PrimReserve(idx_count, vtx_count);

  004a6	44 8b c6	 mov	 r8d, esi
  004a9	8d 14 40	 lea	 edx, DWORD PTR [rax+rax*2]
  004ac	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve
  004b1	48 8b ce	 mov	 rcx, rsi
  004b4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL13@AddConvexP:

; 1044 :         for (int i = 0; i < vtx_count; i++)
; 1045 :         {
; 1046 :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

  004c0	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  004c4	f2 0f 10 07	 movsd	 xmm0, QWORD PTR [rdi]
  004c8	48 8d 7f 08	 lea	 rdi, QWORD PTR [rdi+8]
  004cc	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  004d0	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  004d4	f3 44 0f 11 40
	08		 movss	 DWORD PTR [rax+8], xmm8
  004da	f3 44 0f 11 48
	0c		 movss	 DWORD PTR [rax+12], xmm9
  004e0	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  004e4	44 89 68 10	 mov	 DWORD PTR [rax+16], r13d

; 1047 :             _VtxWritePtr++;

  004e8	48 83 43 48 14	 add	 QWORD PTR [rbx+72], 20
  004ed	48 83 e9 01	 sub	 rcx, 1
  004f1	75 cd		 jne	 SHORT $LL13@AddConvexP
  004f3	41 b8 02 00 00
	00		 mov	 r8d, 2
  004f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL16@AddConvexP:

; 1048 :         }
; 1049 :         for (int i = 2; i < points_count; i++)
; 1050 :         {
; 1051 :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);

  00500	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00504	0f b7 43 34	 movzx	 eax, WORD PTR [rbx+52]
  00508	66 89 01	 mov	 WORD PTR [rcx], ax
  0050b	41 8d 48 ff	 lea	 ecx, DWORD PTR [r8-1]
  0050f	66 03 4b 34	 add	 cx, WORD PTR [rbx+52]
  00513	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00517	66 89 48 02	 mov	 WORD PTR [rax+2], cx
  0051b	41 0f b7 c8	 movzx	 ecx, r8w
  0051f	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00523	41 ff c0	 inc	 r8d
  00526	66 03 4b 34	 add	 cx, WORD PTR [rbx+52]
  0052a	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 1052 :             _IdxWritePtr += 3;

  0052e	48 83 43 50 06	 add	 QWORD PTR [rbx+80], 6
  00533	44 3b c6	 cmp	 r8d, esi
  00536	7c c8		 jl	 SHORT $LL16@AddConvexP

; 1053 :         }
; 1054 :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

  00538	0f b7 c6	 movzx	 eax, si
$LN68@AddConvexP:

; 1055 :     }
; 1056 : }

  0053b	01 43 34	 add	 DWORD PTR [rbx+52], eax
$LN19@AddConvexP:
  0053e	48 8b 4d 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  00542	48 33 cd	 xor	 rcx, rbp
  00545	e8 00 00 00 00	 call	 __security_check_cookie
  0054a	48 8b 9d a0 00
	00 00		 mov	 rbx, QWORD PTR [rbp+160]
  00551	48 8b b5 a8 00
	00 00		 mov	 rsi, QWORD PTR [rbp+168]
  00558	48 8b bd b0 00
	00 00		 mov	 rdi, QWORD PTR [rbp+176]
  0055f	0f 28 75 60	 movaps	 xmm6, XMMWORD PTR [rbp+96]
  00563	0f 28 7d 50	 movaps	 xmm7, XMMWORD PTR [rbp+80]
  00567	44 0f 28 45 40	 movaps	 xmm8, XMMWORD PTR [rbp+64]
  0056c	44 0f 28 4d 30	 movaps	 xmm9, XMMWORD PTR [rbp+48]
  00571	44 0f 28 55 20	 movaps	 xmm10, XMMWORD PTR [rbp+32]
  00576	48 8d 65 70	 lea	 rsp, QWORD PTR [rbp+112]
  0057a	41 5f		 pop	 r15
  0057c	41 5e		 pop	 r14
  0057e	41 5d		 pop	 r13
  00580	41 5c		 pop	 r12
  00582	5d		 pop	 rbp
  00583	c3		 ret	 0
?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ENDP ; ImDrawList::AddConvexPolyFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
this$ = 208
center$ = 216
tv1007 = 224
radius$ = 224
a_min$ = 232
a_max$ = 240
num_segments$ = 248
?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z PROC	; ImDrawList::PathArcTo

; 1180 : {

$LN78:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 56		 push	 r14
  00006	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0000d	0f 29 bc 24 80
	00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm7
  00015	4c 8b f2	 mov	 r14, rdx
  00018	44 0f 29 4c 24
	60		 movaps	 XMMWORD PTR [rsp+96], xmm9
  0001e	0f 57 ff	 xorps	 xmm7, xmm7
  00021	44 0f 28 ca	 movaps	 xmm9, xmm2
  00025	44 0f 29 54 24
	50		 movaps	 XMMWORD PTR [rsp+80], xmm10

; 1181 :     if (radius <= 0.0f)

  0002b	41 0f 2f f9	 comiss	 xmm7, xmm9
  0002f	48 8b e9	 mov	 rbp, rcx
  00032	44 0f 28 d3	 movaps	 xmm10, xmm3
  00036	72 52		 jb	 SHORT $LN2@PathArcTo
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00038	8b 41 78	 mov	 eax, DWORD PTR [rcx+120]
  0003b	8b 49 7c	 mov	 ecx, DWORD PTR [rcx+124]
  0003e	3b c1		 cmp	 eax, ecx
  00040	75 2f		 jne	 SHORT $LN21@PathArcTo
  00042	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00046	85 c9		 test	 ecx, ecx
  00048	74 0c		 je	 SHORT $LN25@PathArcTo
  0004a	8b c1		 mov	 eax, ecx
  0004c	99		 cdq
  0004d	2b c2		 sub	 eax, edx
  0004f	d1 f8		 sar	 eax, 1
  00051	8d 3c 01	 lea	 edi, DWORD PTR [rcx+rax]
  00054	eb 05		 jmp	 SHORT $LN26@PathArcTo
$LN25@PathArcTo:
  00056	bf 08 00 00 00	 mov	 edi, 8
$LN26@PathArcTo:
  0005b	41 3b f8	 cmp	 edi, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0005e	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00062	44 0f 4f c7	 cmovg	 r8d, edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00066	41 8b d0	 mov	 edx, r8d
  00069	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  0006e	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN21@PathArcTo:
  00071	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  00078	48 63 d0	 movsxd	 rdx, eax
  0007b	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0007e	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00082	ff 45 78	 inc	 DWORD PTR [rbp+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1184 :         return;

  00085	e9 0c 03 00 00	 jmp	 $LN5@PathArcTo
$LN2@PathArcTo:

; 1185 :     }
; 1186 : 
; 1187 :     if (num_segments > 0)

  0008a	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR num_segments$[rsp]
  00091	85 c0		 test	 eax, eax
  00093	7e 1d		 jle	 SHORT $LN3@PathArcTo

; 1188 :     {
; 1189 :         _PathArcToN(center, radius, a_min, a_max, num_segments);

  00095	f3 0f 10 84 24
	f0 00 00 00	 movss	 xmm0, DWORD PTR a_max$[rsp]
  0009e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000a2	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  000a8	e8 00 00 00 00	 call	 ?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN

; 1190 :         return;

  000ad	e9 e4 02 00 00	 jmp	 $LN5@PathArcTo
$LN3@PathArcTo:

; 1191 :     }
; 1192 : 
; 1193 :     // Automatic segment count
; 1194 :     if (radius <= _Data->ArcFastRadiusCutoff)

  000b2	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  000b6	0f 29 b4 24 90
	00 00 00	 movaps	 XMMWORD PTR [rsp+144], xmm6
  000be	44 0f 29 44 24
	70		 movaps	 XMMWORD PTR [rsp+112], xmm8
  000c4	f3 0f 10 80 b0
	01 00 00	 movss	 xmm0, DWORD PTR [rax+432]
  000cc	41 0f 2f c1	 comiss	 xmm0, xmm9
  000d0	0f 82 e1 02 00
	00		 jb	 $LN4@PathArcTo

; 1195 :     {
; 1196 :         const bool a_is_reverse = a_max < a_min;
; 1197 : 
; 1198 :         // We are going to use precomputed values for mid samples.
; 1199 :         // Determine first and last sample in lookup table that belong to the arc.
; 1200 :         const float a_min_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0f);

  000d6	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@42400000
  000df	41 0f 28 ca	 movaps	 xmm1, xmm10
  000e3	48 89 b4 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rsi
  000eb	4c 89 a4 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], r12
  000f3	4c 89 ac 24 e8
	00 00 00	 mov	 QWORD PTR [rsp+232], r13
  000fb	4c 89 bc 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], r15
  00103	44 0f 29 5c 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm11
  00109	f3 44 0f 10 9c
	24 f0 00 00 00	 movss	 xmm11, DWORD PTR a_max$[rsp]
  00113	45 0f 2f d3	 comiss	 xmm10, xmm11

; 1201 :         const float a_max_sample_f = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0f);

  00117	41 0f 28 f3	 movaps	 xmm6, xmm11
  0011b	f3 41 0f 59 c8	 mulss	 xmm1, xmm8
  00120	f3 41 0f 59 f0	 mulss	 xmm6, xmm8
  00125	0f 97 c0	 seta	 al
  00128	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@40c90fdb
  00130	f3 0f 5e 35 00
	00 00 00	 divss	 xmm6, DWORD PTR __real@40c90fdb

; 1203 :         const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);

  00138	84 c0		 test	 al, al
  0013a	74 3f		 je	 SHORT $LN10@PathArcTo
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  0013c	0f 2f cf	 comiss	 xmm1, xmm7
  0013f	f3 0f 2c c1	 cvttss2si eax, xmm1
  00143	73 10		 jae	 SHORT $LN63@PathArcTo
  00145	66 0f 6e c0	 movd	 xmm0, eax
  00149	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0014c	0f 2e c1	 ucomiss xmm0, xmm1
  0014f	7a 02		 jp	 SHORT $LN72@PathArcTo
  00151	74 02		 je	 SHORT $LN63@PathArcTo
$LN72@PathArcTo:
  00153	ff c8		 dec	 eax
$LN63@PathArcTo:
  00155	66 0f 6e c0	 movd	 xmm0, eax
  00159	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1203 :         const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);

  0015c	f3 0f 2c d8	 cvttss2si ebx, xmm0

; 1204 :         const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloorSigned(a_max_sample_f);

  00160	0f 28 c6	 movaps	 xmm0, xmm6
  00163	89 9c 24 e0 00
	00 00		 mov	 DWORD PTR tv1007[rsp], ebx
  0016a	e8 00 00 00 00	 call	 ceilf
  0016f	f3 44 0f 2c e8	 cvttss2si r13d, xmm0

; 1205 :         const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);

  00174	8b c3		 mov	 eax, ebx
  00176	41 2b c5	 sub	 eax, r13d
  00179	eb 3d		 jmp	 SHORT $LN76@PathArcTo
$LN10@PathArcTo:

; 1203 :         const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);

  0017b	0f 28 c1	 movaps	 xmm0, xmm1
  0017e	e8 00 00 00 00	 call	 ceilf
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00183	0f 2f f7	 comiss	 xmm6, xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1203 :         const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);

  00186	f3 0f 2c d8	 cvttss2si ebx, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  0018a	f3 0f 2c c6	 cvttss2si eax, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1203 :         const int a_min_sample = a_is_reverse ? (int)ImFloorSigned(a_min_sample_f) : (int)ImCeil(a_min_sample_f);

  0018e	89 9c 24 e0 00
	00 00		 mov	 DWORD PTR tv1007[rsp], ebx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00195	73 10		 jae	 SHORT $LN64@PathArcTo
  00197	66 0f 6e c0	 movd	 xmm0, eax
  0019b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0019e	0f 2e c6	 ucomiss xmm0, xmm6
  001a1	7a 02		 jp	 SHORT $LN71@PathArcTo
  001a3	74 02		 je	 SHORT $LN64@PathArcTo
$LN71@PathArcTo:
  001a5	ff c8		 dec	 eax
$LN64@PathArcTo:
  001a7	66 0f 6e c0	 movd	 xmm0, eax
  001ab	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1204 :         const int a_max_sample = a_is_reverse ? (int)ImCeil(a_max_sample_f) : (int)ImFloorSigned(a_max_sample_f);

  001ae	f3 44 0f 2c e8	 cvttss2si r13d, xmm0

; 1205 :         const int a_mid_samples = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0);

  001b3	41 8b c5	 mov	 eax, r13d
  001b6	2b c3		 sub	 eax, ebx
$LN76@PathArcTo:

; 1206 : 
; 1207 :         const float a_min_segment_angle = a_min_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

  001b8	0f 57 c9	 xorps	 xmm1, xmm1
  001bb	0f 57 d2	 xorps	 xmm2, xmm2
  001be	f3 0f 2a cb	 cvtsi2ss xmm1, ebx

; 1208 :         const float a_max_segment_angle = a_max_sample * IM_PI * 2.0f / IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

  001c2	be 00 00 00 00	 mov	 esi, 0
  001c7	0f 49 f0	 cmovns	 esi, eax
  001ca	f3 41 0f 2a d5	 cvtsi2ss xmm2, r13d
  001cf	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40490fdb
  001d7	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@40490fdb
  001df	f3 0f 58 c9	 addss	 xmm1, xmm1
  001e3	f3 0f 58 d2	 addss	 xmm2, xmm2
  001e7	f3 41 0f 5e c8	 divss	 xmm1, xmm8
  001ec	f3 41 0f 5e d0	 divss	 xmm2, xmm8

; 1209 :         const bool a_emit_start = (a_min_segment_angle - a_min) != 0.0f;

  001f1	f3 41 0f 5c ca	 subss	 xmm1, xmm10
  001f6	0f 2e cf	 ucomiss xmm1, xmm7
  001f9	7a 07		 jp	 SHORT $LN70@PathArcTo
  001fb	75 05		 jne	 SHORT $LN70@PathArcTo
  001fd	45 32 e4	 xor	 r12b, r12b
  00200	eb 03		 jmp	 SHORT $LN17@PathArcTo
$LN70@PathArcTo:
  00202	41 b4 01	 mov	 r12b, 1
$LN17@PathArcTo:

; 1210 :         const bool a_emit_end = (a_max - a_max_segment_angle) != 0.0f;

  00205	41 0f 28 c3	 movaps	 xmm0, xmm11
  00209	f3 0f 5c c2	 subss	 xmm0, xmm2
  0020d	0f 2e c7	 ucomiss xmm0, xmm7
  00210	7a 07		 jp	 SHORT $LN69@PathArcTo
  00212	75 05		 jne	 SHORT $LN69@PathArcTo
  00214	45 32 ff	 xor	 r15b, r15b
  00217	eb 03		 jmp	 SHORT $LN19@PathArcTo
$LN69@PathArcTo:
  00219	41 b7 01	 mov	 r15b, 1
$LN19@PathArcTo:

; 1211 : 
; 1212 :         _Path.reserve(_Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)));

  0021c	8b 55 78	 mov	 edx, DWORD PTR [rbp+120]
  0021f	41 0f b6 c7	 movzx	 eax, r15b
  00223	ff c2		 inc	 edx
  00225	03 c6		 add	 eax, esi
  00227	41 0f b6 cc	 movzx	 ecx, r12b
  0022b	03 c8		 add	 ecx, eax
  0022d	03 d1		 add	 edx, ecx
  0022f	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]
  00233	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve

; 1213 :         if (a_emit_start)

  00238	45 84 e4	 test	 r12b, r12b
  0023b	bf 08 00 00 00	 mov	 edi, 8
  00240	4c 8b a4 24 d8
	00 00 00	 mov	 r12, QWORD PTR [rsp+216]
  00248	74 7f		 je	 SHORT $LN66@PathArcTo

; 1214 :             _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));

  0024a	41 0f 28 c2	 movaps	 xmm0, xmm10
  0024e	e8 00 00 00 00	 call	 cosf
  00253	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00258	f3 41 0f 58 06	 addss	 xmm0, DWORD PTR [r14]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0025d	f3 0f 11 44 24
	30		 movss	 DWORD PTR $T2[rsp], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1214 :             _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));

  00263	41 0f 28 c2	 movaps	 xmm0, xmm10
  00267	e8 00 00 00 00	 call	 sinf
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0026c	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  0026f	44 8b 45 7c	 mov	 r8d, DWORD PTR [rbp+124]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1214 :             _Path.push_back(ImVec2(center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius));

  00273	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00278	f3 41 0f 58 46
	04		 addss	 xmm0, DWORD PTR [r14+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0027e	f3 0f 11 44 24
	34		 movss	 DWORD PTR $T2[rsp+4], xmm0

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00284	41 3b c0	 cmp	 eax, r8d
  00287	75 2a		 jne	 SHORT $LN42@PathArcTo
  00289	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0028c	45 85 c0	 test	 r8d, r8d
  0028f	74 0d		 je	 SHORT $LN46@PathArcTo
  00291	41 8b c0	 mov	 eax, r8d
  00294	99		 cdq
  00295	2b c2		 sub	 eax, edx
  00297	d1 f8		 sar	 eax, 1
  00299	41 03 c0	 add	 eax, r8d
  0029c	eb 02		 jmp	 SHORT $LN47@PathArcTo
$LN46@PathArcTo:
  0029e	8b c7		 mov	 eax, edi
$LN47@PathArcTo:
  002a0	3b c1		 cmp	 eax, ecx
  002a2	0f 4f c8	 cmovg	 ecx, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  002a5	8b d1		 mov	 edx, ecx
  002a7	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]
  002ab	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  002b0	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN42@PathArcTo:
  002b3	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  002ba	48 63 d0	 movsxd	 rdx, eax
  002bd	48 8b 44 24 30	 mov	 rax, QWORD PTR $T2[rsp]
  002c2	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  002c6	ff 45 78	 inc	 DWORD PTR [rbp+120]
$LN66@PathArcTo:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1215 :         if (a_mid_samples > 0)

  002c9	85 f6		 test	 esi, esi
  002cb	48 8b b4 24 d0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+208]
  002d3	7e 1c		 jle	 SHORT $LN7@PathArcTo

; 1216 :             _PathArcToFastEx(center, radius, a_min_sample, a_max_sample, 0);

  002d5	44 8b 8c 24 e0
	00 00 00	 mov	 r9d, DWORD PTR tv1007[rsp]
  002dd	41 0f 28 d1	 movaps	 xmm2, xmm9
  002e1	49 8b d6	 mov	 rdx, r14
  002e4	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  002e9	48 8b cd	 mov	 rcx, rbp
  002ec	e8 00 00 00 00	 call	 ?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN7@PathArcTo:

; 1217 :         if (a_emit_end)

  002f1	4c 8b ac 24 e8
	00 00 00	 mov	 r13, QWORD PTR [rsp+232]
  002f9	45 84 ff	 test	 r15b, r15b
  002fc	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR [rsp+160]
  00304	74 7c		 je	 SHORT $LN75@PathArcTo

; 1218 :             _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));

  00306	41 0f 28 c3	 movaps	 xmm0, xmm11
  0030a	e8 00 00 00 00	 call	 cosf
  0030f	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00314	f3 41 0f 58 06	 addss	 xmm0, DWORD PTR [r14]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00319	f3 0f 11 44 24
	30		 movss	 DWORD PTR $T1[rsp], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1218 :             _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));

  0031f	41 0f 28 c3	 movaps	 xmm0, xmm11
  00323	e8 00 00 00 00	 call	 sinf
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00328	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  0032b	44 8b 45 7c	 mov	 r8d, DWORD PTR [rbp+124]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1218 :             _Path.push_back(ImVec2(center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius));

  0032f	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00334	f3 41 0f 58 46
	04		 addss	 xmm0, DWORD PTR [r14+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0033a	f3 0f 11 44 24
	34		 movss	 DWORD PTR $T1[rsp+4], xmm0

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00340	41 3b c0	 cmp	 eax, r8d
  00343	75 27		 jne	 SHORT $LN51@PathArcTo
  00345	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00348	45 85 c0	 test	 r8d, r8d
  0034b	74 0c		 je	 SHORT $LN55@PathArcTo
  0034d	41 8b c0	 mov	 eax, r8d
  00350	99		 cdq
  00351	2b c2		 sub	 eax, edx
  00353	d1 f8		 sar	 eax, 1
  00355	41 8d 3c 00	 lea	 edi, DWORD PTR [r8+rax]
$LN55@PathArcTo:
  00359	3b f9		 cmp	 edi, ecx
  0035b	0f 4f cf	 cmovg	 ecx, edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0035e	8b d1		 mov	 edx, ecx
  00360	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]
  00364	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00369	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN51@PathArcTo:
  0036c	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  00373	48 63 d0	 movsxd	 rdx, eax
  00376	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  0037b	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0037f	ff 45 78	 inc	 DWORD PTR [rbp+120]
$LN75@PathArcTo:
  00382	44 0f 28 5c 24
	40		 movaps	 xmm11, XMMWORD PTR [rsp+64]
$LN74@PathArcTo:
  00388	0f 28 b4 24 90
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+144]
  00390	44 0f 28 44 24
	70		 movaps	 xmm8, XMMWORD PTR [rsp+112]
$LN5@PathArcTo:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1227 : }

  00396	0f 28 bc 24 80
	00 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+128]
  0039e	44 0f 28 4c 24
	60		 movaps	 xmm9, XMMWORD PTR [rsp+96]
  003a4	44 0f 28 54 24
	50		 movaps	 xmm10, XMMWORD PTR [rsp+80]
  003aa	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003b1	41 5e		 pop	 r14
  003b3	5f		 pop	 rdi
  003b4	5d		 pop	 rbp
  003b5	5b		 pop	 rbx
  003b6	c3		 ret	 0
$LN4@PathArcTo:

; 1219 :     }
; 1220 :     else
; 1221 :     {
; 1222 :         const float arc_length = ImAbs(a_max - a_min);

  003b7	f3 44 0f 10 84
	24 f0 00 00 00	 movss	 xmm8, DWORD PTR a_max$[rsp]

; 1223 :         const int circle_segment_count = _CalcCircleAutoSegmentCount(radius);

  003c1	41 0f 28 c9	 movaps	 xmm1, xmm9

; 1224 :         const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));

  003c5	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@40c90fdb
  003cd	41 0f 28 f8	 movaps	 xmm7, xmm8
  003d1	0f 28 c6	 movaps	 xmm0, xmm6
  003d4	f3 41 0f 5c fa	 subss	 xmm7, xmm10
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

  003d9	0f 54 3d 00 00
	00 00		 andps	 xmm7, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1224 :         const int arc_segment_count = ImMax((int)ImCeil(circle_segment_count * arc_length / (IM_PI * 2.0f)), (int)(2.0f * IM_PI / arc_length));

  003e0	f3 0f 5e c7	 divss	 xmm0, xmm7
  003e4	f3 0f 2c d8	 cvttss2si ebx, xmm0
  003e8	e8 00 00 00 00	 call	 ?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ; ImDrawList::_CalcCircleAutoSegmentCount
  003ed	66 0f 6e c0	 movd	 xmm0, eax
  003f1	0f 5b c0	 cvtdq2ps xmm0, xmm0
  003f4	f3 0f 59 c7	 mulss	 xmm0, xmm7
  003f8	f3 0f 5e c6	 divss	 xmm0, xmm6
  003fc	e8 00 00 00 00	 call	 ceilf
  00401	f3 0f 2c c0	 cvttss2si eax, xmm0

; 1225 :         _PathArcToN(center, radius, a_min, a_max, arc_segment_count);

  00405	49 8b d6	 mov	 rdx, r14
  00408	48 8b cd	 mov	 rcx, rbp
  0040b	41 0f 28 da	 movaps	 xmm3, xmm10
  0040f	41 0f 28 d1	 movaps	 xmm2, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  00413	3b c3		 cmp	 eax, ebx
  00415	0f 4d d8	 cmovge	 ebx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1225 :         _PathArcToN(center, radius, a_min, a_max, arc_segment_count);

  00418	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  0041c	f3 44 0f 11 44
	24 20		 movss	 DWORD PTR [rsp+32], xmm8
  00423	e8 00 00 00 00	 call	 ?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::_PathArcToN
  00428	e9 5b ff ff ff	 jmp	 $LN74@PathArcTo
?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ENDP	; ImDrawList::PathArcTo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
center$ = 72
radius$ = 80
a_min_of_12$ = 88
a_max_of_12$ = 96
?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z PROC	; ImDrawList::PathArcToFast

; 1170 : {

$LN12:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	48 8b fa	 mov	 rdi, rdx

; 1171 :     if (radius <= 0.0f)

  0000c	0f 2f c2	 comiss	 xmm0, xmm2
  0000f	72 5a		 jb	 SHORT $LN2@PathArcToF
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00011	8b 41 78	 mov	 eax, DWORD PTR [rcx+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1173 :         _Path.push_back(center);

  00014	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00019	48 8d 59 78	 lea	 rbx, QWORD PTR [rcx+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0001d	8b 49 7c	 mov	 ecx, DWORD PTR [rcx+124]
  00020	3b c1		 cmp	 eax, ecx
  00022	75 2c		 jne	 SHORT $LN5@PathArcToF
  00024	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00028	85 c9		 test	 ecx, ecx
  0002a	74 0b		 je	 SHORT $LN9@PathArcToF
  0002c	8b c1		 mov	 eax, ecx
  0002e	99		 cdq
  0002f	2b c2		 sub	 eax, edx
  00031	d1 f8		 sar	 eax, 1
  00033	03 c1		 add	 eax, ecx
  00035	eb 05		 jmp	 SHORT $LN10@PathArcToF
$LN9@PathArcToF:
  00037	b8 08 00 00 00	 mov	 eax, 8
$LN10@PathArcToF:
  0003c	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0003f	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00042	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00046	41 8b d0	 mov	 edx, r8d
  00049	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  0004e	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN5@PathArcToF:
  00050	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00054	48 63 d0	 movsxd	 rdx, eax
  00057	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0005a	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0005e	ff 03		 inc	 DWORD PTR [rbx]
  00060	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1177 : }

  00065	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
$LN2@PathArcToF:

; 1174 :         return;
; 1175 :     }
; 1176 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

  0006b	8b 44 24 60	 mov	 eax, DWORD PTR a_max_of_12$[rsp]
  0006f	46 8d 0c 8d 00
	00 00 00	 lea	 r9d, DWORD PTR [r9*4]
  00077	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR [rax*4]
  0007e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00082	e8 00 00 00 00	 call	 ?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1177 : }

  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z ENDP	; ImDrawList::PathArcToFast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
draw_cmd$ = 32
this$ = 144
?AddDrawCmd@ImDrawList@@QEAAXXZ PROC			; ImDrawList::AddDrawCmd

; 451  : {

$LN17:
  00000	40 53		 push	 rbx
  00002	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 452  :     ImDrawCmd draw_cmd;
; 453  :     draw_cmd.ClipRect = _CmdHeader.ClipRect;    // Same as calling ImDrawCmd_HeaderCopy()
; 454  :     draw_cmd.TextureId = _CmdHeader.TextureId;

  00009	48 8b 81 98 00
	00 00		 mov	 rax, QWORD PTR [rcx+152]
  00010	48 8b d9	 mov	 rbx, rcx
  00013	0f 29 74 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm6
  00018	0f 10 b1 88 00
	00 00		 movups	 xmm6, XMMWORD PTR [rcx+136]
  0001f	48 89 44 24 30	 mov	 QWORD PTR draw_cmd$[rsp+16], rax

; 455  :     draw_cmd.VtxOffset = _CmdHeader.VtxOffset;

  00024	8b 81 a0 00 00
	00		 mov	 eax, DWORD PTR [rcx+160]

; 457  : 
; 458  :     IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);

  0002a	0f 28 c6	 movaps	 xmm0, xmm6
  0002d	89 44 24 38	 mov	 DWORD PTR draw_cmd$[rsp+24], eax
  00031	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00034	0f c6 c6 aa	 shufps	 xmm0, xmm6, 170		; 000000aaH
  00038	0f 2f c6	 comiss	 xmm0, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2404 :     ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed

  0003b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR draw_cmd$[rsp+48], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 456  :     draw_cmd.IdxOffset = IdxBuffer.Size;

  00044	89 44 24 3c	 mov	 DWORD PTR draw_cmd$[rsp+28], eax
  00048	0f 29 7c 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm7
  0004d	0f 57 ff	 xorps	 xmm7, xmm7

; 457  : 
; 458  :     IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);

  00050	72 13		 jb	 SHORT $LN3@AddDrawCmd
  00052	0f 28 ce	 movaps	 xmm1, xmm6
  00055	0f 28 c6	 movaps	 xmm0, xmm6
  00058	0f c6 ce ff	 shufps	 xmm1, xmm6, 255		; 000000ffH
  0005c	0f c6 c6 55	 shufps	 xmm0, xmm6, 85		; 00000055H
  00060	0f 2f c8	 comiss	 xmm1, xmm0
  00063	73 1a		 jae	 SHORT $LN4@AddDrawCmd
$LN3@AddDrawCmd:
  00065	41 b8 ca 01 00
	00		 mov	 r8d, 458		; 000001caH
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LC@MAEAJCLC@?$AAd?$AAr?$AAa?$AAw?$AA_?$AAc?$AAm?$AAd?$AA?4?$AAC?$AAl?$AAi?$AAp?$AAR?$AAe@
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@AddDrawCmd:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0007f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00081	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  00084	3b c1		 cmp	 eax, ecx
  00086	75 2c		 jne	 SHORT $LN10@AddDrawCmd
  00088	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0008c	85 c9		 test	 ecx, ecx
  0008e	74 0b		 je	 SHORT $LN14@AddDrawCmd
  00090	8b c1		 mov	 eax, ecx
  00092	99		 cdq
  00093	2b c2		 sub	 eax, edx
  00095	d1 f8		 sar	 eax, 1
  00097	03 c1		 add	 eax, ecx
  00099	eb 05		 jmp	 SHORT $LN15@AddDrawCmd
$LN14@AddDrawCmd:
  0009b	b8 08 00 00 00	 mov	 eax, 8
$LN15@AddDrawCmd:
  000a0	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000a3	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000a6	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000aa	41 8b d0	 mov	 edx, r8d
  000ad	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
  000b2	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN10@AddDrawCmd:
  000b4	0f 10 44 24 30	 movups	 xmm0, XMMWORD PTR draw_cmd$[rsp+16]
  000b9	48 98		 cdqe
  000bb	48 6b c8 38	 imul	 rcx, rax, 56		; 00000038H
  000bf	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000c3	0f 11 34 01	 movups	 XMMWORD PTR [rcx+rax], xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 460  : }

  000c7	0f 28 74 24 70	 movaps	 xmm6, XMMWORD PTR [rsp+112]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000cc	0f 11 44 01 10	 movups	 XMMWORD PTR [rcx+rax+16], xmm0
  000d1	f2 0f 10 44 24
	50		 movsd	 xmm0, QWORD PTR draw_cmd$[rsp+48]
  000d7	0f 11 7c 01 20	 movups	 XMMWORD PTR [rcx+rax+32], xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 460  : }

  000dc	0f 28 7c 24 60	 movaps	 xmm7, XMMWORD PTR [rsp+96]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000e1	f2 0f 11 44 01
	30		 movsd	 QWORD PTR [rcx+rax+48], xmm0
  000e7	ff 03		 inc	 DWORD PTR [rbx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 460  : }

  000e9	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000f0	5b		 pop	 rbx
  000f1	c3		 ret	 0
?AddDrawCmd@ImDrawList@@QEAAXXZ ENDP			; ImDrawList::AddDrawCmd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 112
?_ResetForNewFrame@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_ResetForNewFrame

; 403  : {

$LN59:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00012	33 f6		 xor	 esi, esi
  00014	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00017	85 c9		 test	 ecx, ecx
  00019	79 18		 jns	 SHORT $LN4@ResetForNe

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001b	8b c1		 mov	 eax, ecx
  0001d	99		 cdq
  0001e	2b c2		 sub	 eax, edx
  00020	8b d6		 mov	 edx, esi
  00022	d1 f8		 sar	 eax, 1
  00024	03 c1		 add	 eax, ecx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00026	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00029	85 c0		 test	 eax, eax
  0002b	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0002e	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
$LN4@ResetForNe:
  00033	89 33		 mov	 DWORD PTR [rbx], esi
  00035	8b 4b 14	 mov	 ecx, DWORD PTR [rbx+20]
  00038	85 c9		 test	 ecx, ecx
  0003a	79 19		 jns	 SHORT $LN11@ResetForNe

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0003c	8b c1		 mov	 eax, ecx
  0003e	99		 cdq
  0003f	2b c2		 sub	 eax, edx
  00041	8b d6		 mov	 edx, esi
  00043	d1 f8		 sar	 eax, 1
  00045	03 c1		 add	 eax, ecx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00047	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0004b	85 c0		 test	 eax, eax
  0004d	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00050	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QEAAXH@Z ; ImVector<unsigned short>::reserve
$LN11@ResetForNe:
  00055	89 73 10	 mov	 DWORD PTR [rbx+16], esi
  00058	8b 4b 24	 mov	 ecx, DWORD PTR [rbx+36]
  0005b	85 c9		 test	 ecx, ecx
  0005d	79 19		 jns	 SHORT $LN18@ResetForNe

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0005f	8b c1		 mov	 eax, ecx
  00061	99		 cdq
  00062	2b c2		 sub	 eax, edx
  00064	8b d6		 mov	 edx, esi
  00066	d1 f8		 sar	 eax, 1
  00068	03 c1		 add	 eax, ecx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0006a	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0006e	85 c0		 test	 eax, eax
  00070	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00073	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::reserve
$LN18@ResetForNe:
  00078	89 73 20	 mov	 DWORD PTR [rbx+32], esi
  0007b	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 412  :     Flags = _Data->InitialFlags;

  0007e	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00082	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  00085	89 4b 30	 mov	 DWORD PTR [rbx+48], ecx

; 413  :     memset(&_CmdHeader, 0, sizeof(_CmdHeader));

  00088	0f 11 83 88 00
	00 00		 movups	 XMMWORD PTR [rbx+136], xmm0
  0008f	0f 11 83 98 00
	00 00		 movups	 XMMWORD PTR [rbx+152], xmm0

; 414  :     _VtxCurrentIdx = 0;

  00096	89 73 34	 mov	 DWORD PTR [rbx+52], esi

; 415  :     _VtxWritePtr = NULL;

  00099	48 89 73 48	 mov	 QWORD PTR [rbx+72], rsi

; 416  :     _IdxWritePtr = NULL;

  0009d	48 89 73 50	 mov	 QWORD PTR [rbx+80], rsi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000a1	8b 4b 5c	 mov	 ecx, DWORD PTR [rbx+92]
  000a4	85 c9		 test	 ecx, ecx
  000a6	79 19		 jns	 SHORT $LN25@ResetForNe

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000a8	8b c1		 mov	 eax, ecx
  000aa	99		 cdq
  000ab	2b c2		 sub	 eax, edx
  000ad	8b d6		 mov	 edx, esi
  000af	d1 f8		 sar	 eax, 1
  000b1	03 c1		 add	 eax, ecx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000b3	48 8d 4b 58	 lea	 rcx, QWORD PTR [rbx+88]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000b7	85 c0		 test	 eax, eax
  000b9	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000bc	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z ; ImVector<ImVec4>::reserve
$LN25@ResetForNe:
  000c1	89 73 58	 mov	 DWORD PTR [rbx+88], esi
  000c4	8b 4b 6c	 mov	 ecx, DWORD PTR [rbx+108]
  000c7	85 c9		 test	 ecx, ecx
  000c9	79 19		 jns	 SHORT $LN32@ResetForNe

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000cb	8b c1		 mov	 eax, ecx
  000cd	99		 cdq
  000ce	2b c2		 sub	 eax, edx
  000d0	8b d6		 mov	 edx, esi
  000d2	d1 f8		 sar	 eax, 1
  000d4	03 c1		 add	 eax, ecx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000d6	48 8d 4b 68	 lea	 rcx, QWORD PTR [rbx+104]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000da	85 c0		 test	 eax, eax
  000dc	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000df	e8 00 00 00 00	 call	 ?reserve@?$ImVector@PEAX@@QEAAXH@Z ; ImVector<void *>::reserve
$LN32@ResetForNe:
  000e4	89 73 68	 mov	 DWORD PTR [rbx+104], esi
  000e7	8b 4b 7c	 mov	 ecx, DWORD PTR [rbx+124]
  000ea	85 c9		 test	 ecx, ecx
  000ec	79 19		 jns	 SHORT $LN39@ResetForNe

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000ee	8b c1		 mov	 eax, ecx
  000f0	99		 cdq
  000f1	2b c2		 sub	 eax, edx
  000f3	8b d6		 mov	 edx, esi
  000f5	d1 f8		 sar	 eax, 1
  000f7	03 c1		 add	 eax, ecx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000f9	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000fd	85 c0		 test	 eax, eax
  000ff	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00102	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
$LN39@ResetForNe:
  00107	89 73 78	 mov	 DWORD PTR [rbx+120], esi

; 2404 :     ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed

  0010a	33 c0		 xor	 eax, eax

; 2452 :     inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame

  0010c	89 b3 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], esi
  00112	0f 57 c0	 xorps	 xmm0, xmm0
  00115	c7 83 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+172], 1

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0011f	44 8b 43 04	 mov	 r8d, DWORD PTR [rbx+4]

; 2404 :     ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed

  00123	48 89 44 24 50	 mov	 QWORD PTR $T1[rsp+48], rax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00128	8b 03		 mov	 eax, DWORD PTR [rbx]
  0012a	41 3b c0	 cmp	 eax, r8d
  0012d	75 2e		 jne	 SHORT $LN52@ResetForNe
  0012f	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00132	45 85 c0	 test	 r8d, r8d
  00135	74 0d		 je	 SHORT $LN56@ResetForNe
  00137	41 8b c0	 mov	 eax, r8d
  0013a	99		 cdq
  0013b	2b c2		 sub	 eax, edx
  0013d	d1 f8		 sar	 eax, 1
  0013f	41 03 c0	 add	 eax, r8d
  00142	eb 05		 jmp	 SHORT $LN57@ResetForNe
$LN56@ResetForNe:
  00144	b8 08 00 00 00	 mov	 eax, 8
$LN57@ResetForNe:
  00149	3b c1		 cmp	 eax, ecx
  0014b	0f 4f c8	 cmovg	 ecx, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0014e	8b d1		 mov	 edx, ecx
  00150	48 8b cb	 mov	 rcx, rbx
  00153	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
  00158	8b 03		 mov	 eax, DWORD PTR [rbx]
  0015a	0f 57 c0	 xorps	 xmm0, xmm0
$LN52@ResetForNe:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 423  : }

  0015d	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00162	48 98		 cdqe
  00164	48 6b c8 38	 imul	 rcx, rax, 56		; 00000038H
  00168	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0016c	0f 11 04 01	 movups	 XMMWORD PTR [rcx+rax], xmm0
  00170	0f 11 44 01 10	 movups	 XMMWORD PTR [rcx+rax+16], xmm0
  00175	0f 11 44 01 20	 movups	 XMMWORD PTR [rcx+rax+32], xmm0
  0017a	f2 0f 10 44 24
	50		 movsd	 xmm0, QWORD PTR $T1[rsp+48]
  00180	f2 0f 11 44 01
	30		 movsd	 QWORD PTR [rcx+rax+48], xmm0
  00186	ff 03		 inc	 DWORD PTR [rbx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 422  :     _FringeScale = 1.0f;

  00188	c7 83 c0 00 00
	00 00 00 80 3f	 mov	 DWORD PTR [rbx+192], 1065353216 ; 3f800000H

; 423  : }

  00192	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00197	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0019b	5f		 pop	 rdi
  0019c	c3		 ret	 0
?_ResetForNewFrame@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_ResetForNewFrame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?_ClearFreeMemory@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_ClearFreeMemory

; 426  : {

$LN70:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0000d	33 ff		 xor	 edi, edi
  0000f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00013	48 85 c9	 test	 rcx, rcx
  00016	74 1f		 je	 SHORT $LN4@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0001f	48 89 3b	 mov	 QWORD PTR [rbx], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00022	48 85 c0	 test	 rax, rax
  00025	74 06		 je	 SHORT $LN8@ClearFreeM

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00027	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN8@ClearFreeM:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00033	48 89 7b 08	 mov	 QWORD PTR [rbx+8], rdi
$LN4@ClearFreeM:
  00037	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  0003b	48 85 c9	 test	 rcx, rcx
  0003e	74 20		 je	 SHORT $LN15@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00047	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0004b	48 85 c0	 test	 rax, rax
  0004e	74 06		 je	 SHORT $LN19@ClearFreeM

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00050	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN19@ClearFreeM:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0005c	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi
$LN15@ClearFreeM:
  00060	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  00064	48 85 c9	 test	 rcx, rcx
  00067	74 20		 je	 SHORT $LN26@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00069	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00070	48 89 7b 20	 mov	 QWORD PTR [rbx+32], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00074	48 85 c0	 test	 rax, rax
  00077	74 06		 je	 SHORT $LN30@ClearFreeM

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00079	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN30@ClearFreeM:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00085	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi
$LN26@ClearFreeM:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 430  :     Flags = ImDrawListFlags_None;

  00089	48 89 7b 30	 mov	 QWORD PTR [rbx+48], rdi

; 431  :     _VtxCurrentIdx = 0;
; 432  :     _VtxWritePtr = NULL;

  0008d	48 89 7b 48	 mov	 QWORD PTR [rbx+72], rdi

; 433  :     _IdxWritePtr = NULL;

  00091	48 89 7b 50	 mov	 QWORD PTR [rbx+80], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00095	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00099	48 85 c9	 test	 rcx, rcx
  0009c	74 20		 je	 SHORT $LN37@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0009e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000a5	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000a9	48 85 c0	 test	 rax, rax
  000ac	74 06		 je	 SHORT $LN41@ClearFreeM

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000ae	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN41@ClearFreeM:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000ba	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi
$LN37@ClearFreeM:
  000be	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000c2	48 85 c9	 test	 rcx, rcx
  000c5	74 20		 je	 SHORT $LN48@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000ce	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000d2	48 85 c0	 test	 rax, rax
  000d5	74 06		 je	 SHORT $LN52@ClearFreeM

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000d7	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN52@ClearFreeM:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000e3	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi
$LN48@ClearFreeM:
  000e7	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  000ee	48 85 c9	 test	 rcx, rcx
  000f1	74 23		 je	 SHORT $LN59@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000fa	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000fe	48 85 c0	 test	 rax, rax
  00101	74 06		 je	 SHORT $LN63@ClearFreeM

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00103	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN63@ClearFreeM:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0010f	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi
$LN59@ClearFreeM:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 437  :     _Splitter.ClearFreeMemory();

  00116	48 8d 8b a8 00
	00 00		 lea	 rcx, QWORD PTR [rbx+168]

; 438  : }

  0011d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00122	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00126	5f		 pop	 rdi

; 437  :     _Splitter.ClearFreeMemory();

  00127	e9 00 00 00 00	 jmp	 ?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ ; ImDrawListSplitter::ClearFreeMemory
?_ClearFreeMemory@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_ClearFreeMemory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_PopUnusedDrawCmd

; 465  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 466  :     if (CmdBuffer.Size == 0)

  00006	4c 63 01	 movsxd	 r8, DWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	45 85 c0	 test	 r8d, r8d
  0000f	74 3f		 je	 SHORT $LN3@PopUnusedD

; 467  :         return;
; 468  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  00011	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00015	49 6b d0 38	 imul	 rdx, r8, 56		; 00000038H

; 469  :     if (curr_cmd->ElemCount == 0 && curr_cmd->UserCallback == NULL)

  00019	83 7c 02 e8 00	 cmp	 DWORD PTR [rdx+rax-24], 0
  0001e	75 30		 jne	 SHORT $LN3@PopUnusedD
  00020	48 83 7c 02 f0
	00		 cmp	 QWORD PTR [rdx+rax-16], 0
  00026	75 28		 jne	 SHORT $LN3@PopUnusedD
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1815 :     inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

  00028	45 85 c0	 test	 r8d, r8d
  0002b	7f 1d		 jg	 SHORT $LN7@PopUnusedD
  0002d	41 b8 17 07 00
	00		 mov	 r8d, 1815		; 00000717H
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00047	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
$LN7@PopUnusedD:
  0004a	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  0004e	89 03		 mov	 DWORD PTR [rbx], eax
$LN3@PopUnusedD:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 471  : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_PopUnusedDrawCmd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ PROC	; ImDrawListSplitter::ClearFreeMemory

; 1676 : {

$LN62:
  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1677 :     for (int i = 0; i < _Channels.Size; i++)

  0000a	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  0000d	33 ed		 xor	 ebp, ebp
  0000f	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	8b dd		 mov	 ebx, ebp
  00019	85 c0		 test	 eax, eax
  0001b	0f 8e 0a 01 00
	00		 jle	 $LN3@ClearFreeM
  00021	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00026	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  0002b	44 8b f5	 mov	 r14d, ebp
  0002e	66 90		 npad	 2
$LL4@ClearFreeM:

; 1678 :     {
; 1679 :         if (i == _Current)

  00030	3b 1f		 cmp	 ebx, DWORD PTR [rdi]
  00032	75 37		 jne	 SHORT $LN5@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00034	85 db		 test	 ebx, ebx
  00036	78 04		 js	 SHORT $LN9@ClearFreeM
  00038	3b d8		 cmp	 ebx, eax
  0003a	7c 1a		 jl	 SHORT $LN10@ClearFreeM
$LN9@ClearFreeM:
  0003c	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN10@ClearFreeM:
  00056	0f 57 c0	 xorps	 xmm0, xmm0
  00059	48 63 c3	 movsxd	 rax, ebx
  0005c	48 c1 e0 05	 shl	 rax, 5
  00060	48 03 47 10	 add	 rax, QWORD PTR [rdi+16]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1680 :             memset(&_Channels[i], 0, sizeof(_Channels[i]));  // Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again

  00064	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  00067	0f 11 40 10	 movups	 XMMWORD PTR [rax+16], xmm0
$LN5@ClearFreeM:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  0006b	85 db		 test	 ebx, ebx
  0006d	78 05		 js	 SHORT $LN56@ClearFreeM
  0006f	3b 5f 08	 cmp	 ebx, DWORD PTR [rdi+8]
  00072	7c 1a		 jl	 SHORT $LN14@ClearFreeM
$LN56@ClearFreeM:
  00074	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN14@ClearFreeM:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1681 :         _Channels[i]._CmdBuffer.clear();

  0008e	48 8b 77 10	 mov	 rsi, QWORD PTR [rdi+16]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00092	4a 8b 4c 36 08	 mov	 rcx, QWORD PTR [rsi+r14+8]
  00097	48 85 c9	 test	 rcx, rcx
  0009a	74 21		 je	 SHORT $LN59@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0009c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000a3	4a 89 2c 36	 mov	 QWORD PTR [rsi+r14], rbp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000a7	48 85 c0	 test	 rax, rax
  000aa	74 06		 je	 SHORT $LN20@ClearFreeM

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000ac	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN20@ClearFreeM:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000b8	4a 89 6c 36 08	 mov	 QWORD PTR [rsi+r14+8], rbp
$LN59@ClearFreeM:

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  000bd	85 db		 test	 ebx, ebx
  000bf	78 05		 js	 SHORT $LN28@ClearFreeM
  000c1	3b 5f 08	 cmp	 ebx, DWORD PTR [rdi+8]
  000c4	7c 1a		 jl	 SHORT $LN29@ClearFreeM
$LN28@ClearFreeM:
  000c6	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN29@ClearFreeM:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1682 :         _Channels[i]._IdxBuffer.clear();

  000e0	48 8b 77 10	 mov	 rsi, QWORD PTR [rdi+16]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000e4	4a 8b 4c 36 18	 mov	 rcx, QWORD PTR [rsi+r14+24]
  000e9	48 85 c9	 test	 rcx, rcx
  000ec	74 22		 je	 SHORT $LN2@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000ee	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000f5	4a 89 6c 36 10	 mov	 QWORD PTR [rsi+r14+16], rbp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000fa	48 85 c0	 test	 rax, rax
  000fd	74 06		 je	 SHORT $LN35@ClearFreeM

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000ff	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN35@ClearFreeM:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0010b	4a 89 6c 36 18	 mov	 QWORD PTR [rsi+r14+24], rbp
$LN2@ClearFreeM:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1677 :     for (int i = 0; i < _Channels.Size; i++)

  00110	8b 47 08	 mov	 eax, DWORD PTR [rdi+8]
  00113	ff c3		 inc	 ebx
  00115	49 83 c6 20	 add	 r14, 32			; 00000020H
  00119	3b d8		 cmp	 ebx, eax
  0011b	0f 8c 0f ff ff
	ff		 jl	 $LL4@ClearFreeM
  00121	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
  00126	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
$LN3@ClearFreeM:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0012b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1684 :     _Current = 0;

  00130	89 2f		 mov	 DWORD PTR [rdi], ebp

; 1685 :     _Count = 1;

  00132	c7 47 04 01 00
	00 00		 mov	 DWORD PTR [rdi+4], 1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00139	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0013d	48 85 c9	 test	 rcx, rcx
  00140	74 20		 je	 SHORT $LN42@ClearFreeM
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00142	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00149	48 89 6f 08	 mov	 QWORD PTR [rdi+8], rbp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0014d	48 85 c0	 test	 rax, rax
  00150	74 06		 je	 SHORT $LN46@ClearFreeM

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00152	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN46@ClearFreeM:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0015e	48 89 6f 10	 mov	 QWORD PTR [rdi+16], rbp
$LN42@ClearFreeM:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1687 : }

  00162	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00167	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016b	5f		 pop	 rdi
  0016c	c3		 ret	 0
?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ ENDP	; ImDrawListSplitter::ClearFreeMemory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
??0ImFont@@QEAA@XZ PROC					; ImFont::ImFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00000	33 d2		 xor	 edx, edx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3109 :     FallbackChar = (ImWchar)-1;

  00002	c7 41 52 ff ff
	ff ff		 mov	 DWORD PTR [rcx+82], -1	; ffffffffH
  00009	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  0000e	48 89 11	 mov	 QWORD PTR [rcx], rdx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3111 :     DotChar = (ImWchar)-1;

  00011	66 89 41 56	 mov	 WORD PTR [rcx+86], ax

; 3119 :     MetricsTotalSurface = 0;
; 3120 :     memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));

  00015	33 c0		 xor	 eax, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00017	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001b	48 89 51 18	 mov	 QWORD PTR [rcx+24], rdx
  0001f	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx
  00023	48 89 51 28	 mov	 QWORD PTR [rcx+40], rdx
  00027	48 89 51 30	 mov	 QWORD PTR [rcx+48], rdx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3108 :     FallbackAdvanceX = 0.0f;

  0002b	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 3112 :     FallbackGlyph = NULL;

  0002f	48 89 51 38	 mov	 QWORD PTR [rcx+56], rdx

; 3113 :     ContainerAtlas = NULL;

  00033	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx

; 3114 :     ConfigData = NULL;

  00037	48 89 51 48	 mov	 QWORD PTR [rcx+72], rdx

; 3115 :     ConfigDataCount = 0;

  0003b	66 89 51 50	 mov	 WORD PTR [rcx+80], dx

; 3116 :     DirtyLookupTables = false;

  0003f	88 51 58	 mov	 BYTE PTR [rcx+88], dl

; 3117 :     Scale = 1.0f;

  00042	48 c7 41 5c 00
	00 80 3f	 mov	 QWORD PTR [rcx+92], 1065353216 ; 3f800000H

; 3118 :     Ascent = Descent = 0.0f;

  0004a	48 89 51 64	 mov	 QWORD PTR [rcx+100], rdx

; 3119 :     MetricsTotalSurface = 0;
; 3120 :     memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));

  0004e	66 89 41 6c	 mov	 WORD PTR [rcx+108], ax

; 3121 : }

  00052	48 8b c1	 mov	 rax, rcx
  00055	c3		 ret	 0
??0ImFont@@QEAA@XZ ENDP					; ImFont::ImFont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
??1ImFont@@QEAA@XZ PROC					; ImFont::~ImFont

; 3124 : {

$LN42:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 3125 :     ClearOutputData();

  00009	e8 00 00 00 00	 call	 ?ClearOutputData@ImFont@@QEAAXXZ ; ImFont::ClearOutputData
  0000e	90		 npad	 1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0000f	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00013	48 85 c9	 test	 rcx, rcx
  00016	74 19		 je	 SHORT $LN11@ImFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001f	48 85 c0	 test	 rax, rax
  00022	74 06		 je	 SHORT $LN9@ImFont

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00024	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN9@ImFont:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00030	90		 npad	 1
$LN11@ImFont:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00031	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00035	48 85 c9	 test	 rcx, rcx
  00038	74 19		 je	 SHORT $LN23@ImFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00041	48 85 c0	 test	 rax, rax
  00044	74 06		 je	 SHORT $LN21@ImFont

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00046	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN21@ImFont:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00052	90		 npad	 1
$LN23@ImFont:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00053	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00057	48 85 c9	 test	 rcx, rcx
  0005a	74 19		 je	 SHORT $LN39@ImFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0005c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00063	48 85 c0	 test	 rax, rax
  00066	74 06		 je	 SHORT $LN33@ImFont

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00068	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN33@ImFont:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00074	90		 npad	 1
$LN39@ImFont:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3126 : }

  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
??1ImFont@@QEAA@XZ ENDP					; ImFont::~ImFont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
c$ = 16
?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z PROC	; ImFont::FindGlyph

; 3314 :     if (c >= (size_t)IndexLookup.Size)

  00000	48 63 41 18	 movsxd	 rax, DWORD PTR [rcx+24]
  00004	44 0f b7 c2	 movzx	 r8d, dx
  00008	4c 3b c0	 cmp	 r8, rax
  0000b	73 20		 jae	 SHORT $LN5@FindGlyph

; 3315 :         return FallbackGlyph;
; 3316 :     const ImWchar i = IndexLookup.Data[c];

  0000d	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00011	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]

; 3317 :     if (i == (ImWchar)-1)

  00016	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001b	66 3b d0	 cmp	 dx, ax
  0001e	74 0d		 je	 SHORT $LN5@FindGlyph

; 3319 :     return &Glyphs.Data[i];

  00020	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00024	48 8d 14 92	 lea	 rdx, QWORD PTR [rdx+rdx*4]
  00028	48 8d 04 d0	 lea	 rax, QWORD PTR [rax+rdx*8]

; 3320 : }

  0002c	c3		 ret	 0
$LN5@FindGlyph:

; 3318 :         return FallbackGlyph;

  0002d	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]

; 3320 : }

  00031	c3		 ret	 0
?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z ENDP	; ImFont::FindGlyph
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
c$ = 16
?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z PROC ; ImFont::FindGlyphNoFallback

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  00000	48 63 41 18	 movsxd	 rax, DWORD PTR [rcx+24]
  00004	44 0f b7 c2	 movzx	 r8d, dx
  00008	4c 3b c0	 cmp	 r8, rax
  0000b	73 20		 jae	 SHORT $LN5@FindGlyphN

; 3325 :         return NULL;
; 3326 :     const ImWchar i = IndexLookup.Data[c];

  0000d	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00011	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]

; 3327 :     if (i == (ImWchar)-1)

  00016	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001b	66 3b d0	 cmp	 dx, ax
  0001e	74 0d		 je	 SHORT $LN5@FindGlyphN

; 3329 :     return &Glyphs.Data[i];

  00020	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00024	48 8d 14 92	 lea	 rdx, QWORD PTR [rdx+rdx*4]
  00028	48 8d 04 d0	 lea	 rax, QWORD PTR [rax+rdx*8]

; 3330 : }

  0002c	c3		 ret	 0
$LN5@FindGlyphN:

; 3328 :         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 3330 : }

  0002f	c3		 ret	 0
?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z ENDP ; ImFont::FindGlyphNoFallback
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 176
__$ReturnUdt$ = 184
size$ = 192
max_width$ = 200
c$1 = 208
wrap_width$ = 208
text_begin$ = 216
text_end$ = 224
remaining$dead$ = 232
?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z PROC ; ImFont::CalcTextSizeA

; 3432 : {

$LN64:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 3433 :     if (!text_end)

  0001b	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR text_end$[rsp]
  00023	48 8b f2	 mov	 rsi, rdx
  00026	48 8b 9c 24 d8
	00 00 00	 mov	 rbx, QWORD PTR text_begin$[rsp]
  0002e	4c 8b f1	 mov	 r14, rcx
  00031	0f 29 70 d8	 movaps	 XMMWORD PTR [rax-40], xmm6
  00035	0f 29 78 c8	 movaps	 XMMWORD PTR [rax-56], xmm7
  00039	0f 28 fa	 movaps	 xmm7, xmm2
  0003c	44 0f 29 40 b8	 movaps	 XMMWORD PTR [rax-72], xmm8
  00041	44 0f 29 48 a8	 movaps	 XMMWORD PTR [rax-88], xmm9
  00046	44 0f 29 50 98	 movaps	 XMMWORD PTR [rax-104], xmm10
  0004b	44 0f 29 58 88	 movaps	 XMMWORD PTR [rax-120], xmm11
  00050	44 0f 28 db	 movaps	 xmm11, xmm3
  00054	48 85 ff	 test	 rdi, rdi
  00057	75 13		 jne	 SHORT $LN6@CalcTextSi

; 3434 :         text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

  00059	48 c7 c7 ff ff
	ff ff		 mov	 rdi, -1
$LL58@CalcTextSi:
  00060	48 ff c7	 inc	 rdi
  00063	80 3c 3b 00	 cmp	 BYTE PTR [rbx+rdi], 0
  00067	75 f7		 jne	 SHORT $LL58@CalcTextSi
  00069	48 03 fb	 add	 rdi, rbx
$LN6@CalcTextSi:

; 3438 : 
; 3439 :     ImVec2 text_size = ImVec2(0, 0);
; 3440 :     float line_width = 0.0f;
; 3441 : 
; 3442 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

  0006c	f3 44 0f 10 94
	24 d0 00 00 00	 movss	 xmm10, DWORD PTR wrap_width$[rsp]
  00076	45 0f 57 c0	 xorps	 xmm8, xmm8
  0007a	45 0f 2f d0	 comiss	 xmm10, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0007e	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3437 :     const float scale = size / FontSize;

  00085	44 0f 28 cf	 movaps	 xmm9, xmm7
  00089	0f 57 f6	 xorps	 xmm6, xmm6
  0008c	f3 44 0f 5e 49
	14		 divss	 xmm9, DWORD PTR [rcx+20]

; 3438 : 
; 3439 :     ImVec2 text_size = ImVec2(0, 0);
; 3440 :     float line_width = 0.0f;
; 3441 : 
; 3442 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

  00092	41 0f 97 c7	 seta	 r15b

; 3443 :     const char* word_wrap_eol = NULL;

  00096	33 ed		 xor	 ebp, ebp

; 3444 : 
; 3445 :     const char* s = text_begin;
; 3446 :     while (s < text_end)

  00098	48 3b df	 cmp	 rbx, rdi
  0009b	0f 83 19 01 00
	00		 jae	 $LN61@CalcTextSi
$LL2@CalcTextSi:

; 3447 :     {
; 3448 :         if (word_wrap_enabled)

  000a1	45 84 ff	 test	 r15b, r15b
  000a4	74 79		 je	 SHORT $LN10@CalcTextSi

; 3449 :         {
; 3450 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 3451 :             if (!word_wrap_eol)

  000a6	48 85 ed	 test	 rbp, rbp
  000a9	75 2b		 jne	 SHORT $LN9@CalcTextSi

; 3452 :             {
; 3453 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);

  000ab	41 0f 28 c2	 movaps	 xmm0, xmm10
  000af	4c 8b cf	 mov	 r9, rdi
  000b2	f3 0f 5c c6	 subss	 xmm0, xmm6
  000b6	4c 8b c3	 mov	 r8, rbx
  000b9	41 0f 28 c9	 movaps	 xmm1, xmm9
  000bd	49 8b ce	 mov	 rcx, r14
  000c0	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  000c6	e8 00 00 00 00	 call	 ?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
  000cb	48 8b e8	 mov	 rbp, rax

; 3454 :                 if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.

  000ce	48 3b c3	 cmp	 rax, rbx
  000d1	75 03		 jne	 SHORT $LN9@CalcTextSi

; 3455 :                     word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below

  000d3	48 ff c5	 inc	 rbp
$LN9@CalcTextSi:

; 3456 :             }
; 3457 : 
; 3458 :             if (s >= word_wrap_eol)

  000d6	48 3b dd	 cmp	 rbx, rbp
  000d9	72 44		 jb	 SHORT $LN10@CalcTextSi

; 3459 :             {
; 3460 :                 if (text_size.x < line_width)

  000db	0f 2f 36	 comiss	 xmm6, DWORD PTR [rsi]
  000de	76 04		 jbe	 SHORT $LN11@CalcTextSi

; 3461 :                     text_size.x = line_width;

  000e0	f3 0f 11 36	 movss	 DWORD PTR [rsi], xmm6
$LN11@CalcTextSi:

; 3462 :                 text_size.y += line_height;

  000e4	0f 28 c7	 movaps	 xmm0, xmm7

; 3463 :                 line_width = 0.0f;

  000e7	41 0f 28 f0	 movaps	 xmm6, xmm8
  000eb	f3 0f 58 46 04	 addss	 xmm0, DWORD PTR [rsi+4]

; 3464 :                 word_wrap_eol = NULL;

  000f0	33 ed		 xor	 ebp, ebp
  000f2	f3 0f 11 46 04	 movss	 DWORD PTR [rsi+4], xmm0
$LL4@CalcTextSi:

; 3468 :                 {
; 3469 :                     const char c = *s;

  000f7	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 335  : static inline bool      ImCharIsBlankA(char c) { return c == ' ' || c == '\t'; }

  000fa	3c 20		 cmp	 al, 32			; 00000020H
  000fc	74 04		 je	 SHORT $LN34@CalcTextSi
  000fe	3c 09		 cmp	 al, 9
  00100	75 0d		 jne	 SHORT $LN56@CalcTextSi
$LN34@CalcTextSi:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3470 :                     if (ImCharIsBlankA(c)) { s++; }

  00102	48 ff c3	 inc	 rbx
  00105	48 3b df	 cmp	 rbx, rdi
  00108	72 ed		 jb	 SHORT $LL4@CalcTextSi

; 3465 : 
; 3466 :                 // Wrapping skips upcoming blanks
; 3467 :                 while (s < text_end)

  0010a	e9 ab 00 00 00	 jmp	 $LN61@CalcTextSi
$LN56@CalcTextSi:

; 3471 :                     else if (c == '\n') { s++; break; }

  0010f	3c 0a		 cmp	 al, 10
  00111	0f 85 9a 00 00
	00		 jne	 $LN47@CalcTextSi
  00117	48 ff c3	 inc	 rbx

; 3472 :                     else { break; }
; 3473 :                 }
; 3474 :                 continue;

  0011a	e9 92 00 00 00	 jmp	 $LN47@CalcTextSi
$LN10@CalcTextSi:

; 3475 :             }
; 3476 :         }
; 3477 : 
; 3478 :         // Decode and advance source
; 3479 :         const char* prev_s = s;
; 3480 :         unsigned int c = (unsigned int)*s;

  0011f	0f be 03	 movsx	 eax, BYTE PTR [rbx]
  00122	89 84 24 d0 00
	00 00		 mov	 DWORD PTR c$1[rsp], eax
  00129	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H

; 3481 :         if (c < 0x80)

  0012e	73 05		 jae	 SHORT $LN16@CalcTextSi

; 3482 :         {
; 3483 :             s += 1;

  00130	48 ff c3	 inc	 rbx

; 3484 :         }

  00133	eb 24		 jmp	 SHORT $LN18@CalcTextSi
$LN16@CalcTextSi:

; 3485 :         else
; 3486 :         {
; 3487 :             s += ImTextCharFromUtf8(&c, s, text_end);

  00135	4c 8b c7	 mov	 r8, rdi
  00138	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR c$1[rsp]
  00140	48 8b d3	 mov	 rdx, rbx
  00143	e8 00 00 00 00	 call	 ?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z ; ImTextCharFromUtf8
  00148	48 63 c8	 movsxd	 rcx, eax

; 3488 :             if (c == 0) // Malformed UTF-8?

  0014b	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR c$1[rsp]
  00152	48 03 d9	 add	 rbx, rcx
  00155	85 c0		 test	 eax, eax
  00157	74 61		 je	 SHORT $LN61@CalcTextSi
$LN18@CalcTextSi:

; 3489 :                 break;
; 3490 :         }
; 3491 : 
; 3492 :         if (c < 32)

  00159	83 f8 20	 cmp	 eax, 32			; 00000020H
  0015c	73 29		 jae	 SHORT $LN21@CalcTextSi

; 3493 :         {
; 3494 :             if (c == '\n')

  0015e	83 f8 0a	 cmp	 eax, 10
  00161	75 1f		 jne	 SHORT $LN20@CalcTextSi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  00163	f3 0f 10 06	 movss	 xmm0, DWORD PTR [rsi]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3497 :                 text_size.y += line_height;

  00167	0f 28 cf	 movaps	 xmm1, xmm7
  0016a	f3 0f 58 4e 04	 addss	 xmm1, DWORD PTR [rsi+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  0016f	f3 0f 5f c6	 maxss	 xmm0, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3498 :                 line_width = 0.0f;

  00173	41 0f 28 f0	 movaps	 xmm6, xmm8
  00177	f3 0f 11 4e 04	 movss	 DWORD PTR [rsi+4], xmm1
  0017c	f3 0f 11 06	 movss	 DWORD PTR [rsi], xmm0

; 3499 :                 continue;

  00180	eb 2f		 jmp	 SHORT $LN47@CalcTextSi
$LN20@CalcTextSi:

; 3500 :             }
; 3501 :             if (c == '\r')

  00182	83 f8 0d	 cmp	 eax, 13
  00185	74 2a		 je	 SHORT $LN47@CalcTextSi
$LN21@CalcTextSi:

; 3502 :                 continue;
; 3503 :         }
; 3504 : 
; 3505 :         const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX) * scale;

  00187	41 3b 06	 cmp	 eax, DWORD PTR [r14]
  0018a	7d 0d		 jge	 SHORT $LN28@CalcTextSi
  0018c	8b c8		 mov	 ecx, eax
  0018e	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  00192	f3 0f 10 04 88	 movss	 xmm0, DWORD PTR [rax+rcx*4]
  00197	eb 06		 jmp	 SHORT $LN29@CalcTextSi
$LN28@CalcTextSi:
  00199	f3 41 0f 10 46
	10		 movss	 xmm0, DWORD PTR [r14+16]
$LN29@CalcTextSi:
  0019f	f3 41 0f 59 c1	 mulss	 xmm0, xmm9

; 3506 :         if (line_width + char_width >= max_width)

  001a4	f3 0f 58 c6	 addss	 xmm0, xmm6
  001a8	41 0f 2f c3	 comiss	 xmm0, xmm11
  001ac	73 0c		 jae	 SHORT $LN61@CalcTextSi

; 3507 :         {
; 3508 :             s = prev_s;
; 3509 :             break;
; 3510 :         }
; 3511 : 
; 3512 :         line_width += char_width;

  001ae	0f 28 f0	 movaps	 xmm6, xmm0
$LN47@CalcTextSi:

; 3444 : 
; 3445 :     const char* s = text_begin;
; 3446 :     while (s < text_end)

  001b1	48 3b df	 cmp	 rbx, rdi
  001b4	0f 82 e7 fe ff
	ff		 jb	 $LL2@CalcTextSi
$LN61@CalcTextSi:

; 3513 :     }
; 3514 : 
; 3515 :     if (text_size.x < line_width)

  001ba	0f 2f 36	 comiss	 xmm6, DWORD PTR [rsi]
  001bd	76 04		 jbe	 SHORT $LN23@CalcTextSi

; 3516 :         text_size.x = line_width;

  001bf	f3 0f 11 36	 movss	 DWORD PTR [rsi], xmm6
$LN23@CalcTextSi:

; 3517 : 
; 3518 :     if (line_width > 0 || text_size.y == 0.0f)

  001c3	41 0f 2f f0	 comiss	 xmm6, xmm8
  001c7	77 0d		 ja	 SHORT $LN57@CalcTextSi
  001c9	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [rsi+4]
  001ce	41 0f 2e c0	 ucomiss xmm0, xmm8
  001d2	7a 0c		 jp	 SHORT $LN62@CalcTextSi
  001d4	75 0a		 jne	 SHORT $LN62@CalcTextSi
$LN57@CalcTextSi:

; 3519 :         text_size.y += line_height;

  001d6	f3 0f 58 7e 04	 addss	 xmm7, DWORD PTR [rsi+4]
  001db	f3 0f 11 7e 04	 movss	 DWORD PTR [rsi+4], xmm7
$LN62@CalcTextSi:

; 3520 : 
; 3521 :     if (remaining)
; 3522 :         *remaining = s;
; 3523 : 
; 3524 :     return text_size;
; 3525 : }

  001e0	0f 28 7c 24 70	 movaps	 xmm7, XMMWORD PTR [rsp+112]
  001e5	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  001ed	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  001f1	48 8b c6	 mov	 rax, rsi
  001f4	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  001f8	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  001fc	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00201	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  00206	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  0020b	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  00210	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  00215	49 8b e3	 mov	 rsp, r11
  00218	41 5f		 pop	 r15
  0021a	41 5e		 pop	 r14
  0021c	5f		 pop	 rdi
  0021d	c3		 ret	 0
?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z ENDP ; ImFont::CalcTextSizeA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 80
p1$ = 88
p2$ = 96
p3$ = 104
col$ = 112
thickness$ = 120
?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z PROC	; ImDrawList::AddTriangle

; 1461 : {

$LN34:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	41 54		 push	 r12
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1462 :     if ((col & IM_COL32_A_MASK) == 0)

  0000f	f7 44 24 70 00
	00 00 ff	 test	 DWORD PTR col$[rsp], -16777216 ; ff000000H
  00017	4d 8b e1	 mov	 r12, r9
  0001a	4d 8b f8	 mov	 r15, r8
  0001d	4c 8b f2	 mov	 r14, rdx
  00020	48 8b f1	 mov	 rsi, rcx
  00023	0f 84 27 01 00
	00		 je	 $LN1@AddTriangl
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00029	8b 41 78	 mov	 eax, DWORD PTR [rcx+120]
  0002c	44 8b 49 7c	 mov	 r9d, DWORD PTR [rcx+124]

; 2567 :     inline    void  PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }

  00030	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00035	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0003a	bf 08 00 00 00	 mov	 edi, 8
  0003f	41 3b c1	 cmp	 eax, r9d
  00042	75 2a		 jne	 SHORT $LN7@AddTriangl
  00044	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00047	45 85 c9	 test	 r9d, r9d
  0004a	74 0d		 je	 SHORT $LN11@AddTriangl
  0004c	41 8b c1	 mov	 eax, r9d
  0004f	99		 cdq
  00050	2b c2		 sub	 eax, edx
  00052	d1 f8		 sar	 eax, 1
  00054	41 03 c1	 add	 eax, r9d
  00057	eb 02		 jmp	 SHORT $LN12@AddTriangl
$LN11@AddTriangl:
  00059	8b c7		 mov	 eax, edi
$LN12@AddTriangl:
  0005b	3b c1		 cmp	 eax, ecx
  0005d	0f 4f c8	 cmovg	 ecx, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00060	8b d1		 mov	 edx, ecx
  00062	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  00066	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  0006b	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN7@AddTriangl:
  0006e	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00075	48 63 d0	 movsxd	 rdx, eax
  00078	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0007b	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0007f	ff 46 78	 inc	 DWORD PTR [rsi+120]
  00082	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  00085	8b 4e 7c	 mov	 ecx, DWORD PTR [rsi+124]
  00088	3b c1		 cmp	 eax, ecx
  0008a	75 2b		 jne	 SHORT $LN16@AddTriangl
  0008c	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00090	85 c9		 test	 ecx, ecx
  00092	74 0b		 je	 SHORT $LN20@AddTriangl
  00094	8b c1		 mov	 eax, ecx
  00096	99		 cdq
  00097	2b c2		 sub	 eax, edx
  00099	d1 f8		 sar	 eax, 1
  0009b	03 c1		 add	 eax, ecx
  0009d	eb 02		 jmp	 SHORT $LN21@AddTriangl
$LN20@AddTriangl:
  0009f	8b c7		 mov	 eax, edi
$LN21@AddTriangl:
  000a1	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000a4	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000a8	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000ac	41 8b d0	 mov	 edx, r8d
  000af	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  000b4	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN16@AddTriangl:
  000b7	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  000be	48 63 d0	 movsxd	 rdx, eax
  000c1	49 8b 07	 mov	 rax, QWORD PTR [r15]
  000c4	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  000c8	ff 46 78	 inc	 DWORD PTR [rsi+120]
  000cb	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  000ce	44 8b 46 7c	 mov	 r8d, DWORD PTR [rsi+124]
  000d2	41 3b c0	 cmp	 eax, r8d
  000d5	75 27		 jne	 SHORT $LN25@AddTriangl
  000d7	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000da	45 85 c0	 test	 r8d, r8d
  000dd	74 0c		 je	 SHORT $LN29@AddTriangl
  000df	41 8b c0	 mov	 eax, r8d
  000e2	99		 cdq
  000e3	2b c2		 sub	 eax, edx
  000e5	d1 f8		 sar	 eax, 1
  000e7	41 8d 3c 00	 lea	 edi, DWORD PTR [r8+rax]
$LN29@AddTriangl:
  000eb	3b f9		 cmp	 edi, ecx
  000ed	0f 4f cf	 cmovg	 ecx, edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000f0	8b d1		 mov	 edx, ecx
  000f2	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  000f6	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  000fb	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN25@AddTriangl:
  000fe	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  00105	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR thickness$[rsp]
  0010b	44 8b 4c 24 70	 mov	 r9d, DWORD PTR col$[rsp]

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00110	48 63 d0	 movsxd	 rdx, eax
  00113	49 8b 04 24	 mov	 rax, QWORD PTR [r12]

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  00117	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0011d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00125	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  00129	48 8b ce	 mov	 rcx, rsi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0012c	ff 46 78	 inc	 DWORD PTR [rsi+120]

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  0012f	44 8b 46 78	 mov	 r8d, DWORD PTR [rsi+120]
  00133	48 8b 96 80 00
	00 00		 mov	 rdx, QWORD PTR [rsi+128]
  0013a	e8 00 00 00 00	 call	 ?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
  0013f	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00144	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00149	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [rsi+120], 0
$LN1@AddTriangl:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1469 : }

  00150	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00155	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00159	41 5f		 pop	 r15
  0015b	41 5e		 pop	 r14
  0015d	41 5c		 pop	 r12
  0015f	c3		 ret	 0
?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z ENDP	; ImDrawList::AddTriangle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
p1$ = 72
p2$ = 80
p3$ = 88
col$ = 96
?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z PROC ; ImDrawList::AddTriangleFilled

; 1472 : {

$LN34:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	41 54		 push	 r12
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1473 :     if ((col & IM_COL32_A_MASK) == 0)

  0000f	f7 44 24 60 00
	00 00 ff	 test	 DWORD PTR col$[rsp], -16777216 ; ff000000H
  00017	4d 8b e1	 mov	 r12, r9
  0001a	4d 8b f8	 mov	 r15, r8
  0001d	4c 8b f2	 mov	 r14, rdx
  00020	48 8b f1	 mov	 rsi, rcx
  00023	0f 84 13 01 00
	00		 je	 $LN1@AddTriangl
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00029	8b 41 78	 mov	 eax, DWORD PTR [rcx+120]
  0002c	44 8b 49 7c	 mov	 r9d, DWORD PTR [rcx+124]

; 2567 :     inline    void  PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }

  00030	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00035	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0003a	bf 08 00 00 00	 mov	 edi, 8
  0003f	41 3b c1	 cmp	 eax, r9d
  00042	75 2a		 jne	 SHORT $LN7@AddTriangl
  00044	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00047	45 85 c9	 test	 r9d, r9d
  0004a	74 0d		 je	 SHORT $LN11@AddTriangl
  0004c	41 8b c1	 mov	 eax, r9d
  0004f	99		 cdq
  00050	2b c2		 sub	 eax, edx
  00052	d1 f8		 sar	 eax, 1
  00054	41 03 c1	 add	 eax, r9d
  00057	eb 02		 jmp	 SHORT $LN12@AddTriangl
$LN11@AddTriangl:
  00059	8b c7		 mov	 eax, edi
$LN12@AddTriangl:
  0005b	3b c1		 cmp	 eax, ecx
  0005d	0f 4f c8	 cmovg	 ecx, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00060	8b d1		 mov	 edx, ecx
  00062	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  00066	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  0006b	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN7@AddTriangl:
  0006e	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00075	48 63 d0	 movsxd	 rdx, eax
  00078	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0007b	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0007f	ff 46 78	 inc	 DWORD PTR [rsi+120]
  00082	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  00085	8b 4e 7c	 mov	 ecx, DWORD PTR [rsi+124]
  00088	3b c1		 cmp	 eax, ecx
  0008a	75 2b		 jne	 SHORT $LN16@AddTriangl
  0008c	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00090	85 c9		 test	 ecx, ecx
  00092	74 0b		 je	 SHORT $LN20@AddTriangl
  00094	8b c1		 mov	 eax, ecx
  00096	99		 cdq
  00097	2b c2		 sub	 eax, edx
  00099	d1 f8		 sar	 eax, 1
  0009b	03 c1		 add	 eax, ecx
  0009d	eb 02		 jmp	 SHORT $LN21@AddTriangl
$LN20@AddTriangl:
  0009f	8b c7		 mov	 eax, edi
$LN21@AddTriangl:
  000a1	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000a4	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000a8	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000ac	41 8b d0	 mov	 edx, r8d
  000af	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  000b4	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN16@AddTriangl:
  000b7	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  000be	48 63 d0	 movsxd	 rdx, eax
  000c1	49 8b 07	 mov	 rax, QWORD PTR [r15]
  000c4	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  000c8	ff 46 78	 inc	 DWORD PTR [rsi+120]
  000cb	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  000ce	44 8b 46 7c	 mov	 r8d, DWORD PTR [rsi+124]
  000d2	41 3b c0	 cmp	 eax, r8d
  000d5	75 27		 jne	 SHORT $LN25@AddTriangl
  000d7	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000da	45 85 c0	 test	 r8d, r8d
  000dd	74 0c		 je	 SHORT $LN29@AddTriangl
  000df	41 8b c0	 mov	 eax, r8d
  000e2	99		 cdq
  000e3	2b c2		 sub	 eax, edx
  000e5	d1 f8		 sar	 eax, 1
  000e7	41 8d 3c 00	 lea	 edi, DWORD PTR [r8+rax]
$LN29@AddTriangl:
  000eb	3b f9		 cmp	 edi, ecx
  000ed	0f 4f cf	 cmovg	 ecx, edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000f0	8b d1		 mov	 edx, ecx
  000f2	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  000f6	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  000fb	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN25@AddTriangl:
  000fe	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]

; 2569 :     inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  00105	44 8b 4c 24 60	 mov	 r9d, DWORD PTR col$[rsp]

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0010a	48 63 d0	 movsxd	 rdx, eax
  0010d	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00111	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 2569 :     inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  00115	48 8b ce	 mov	 rcx, rsi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00118	ff 46 78	 inc	 DWORD PTR [rsi+120]

; 2569 :     inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  0011b	44 8b 46 78	 mov	 r8d, DWORD PTR [rsi+120]
  0011f	48 8b 96 80 00
	00 00		 mov	 rdx, QWORD PTR [rsi+128]
  00126	e8 00 00 00 00	 call	 ?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
  0012b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00130	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00135	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [rsi+120], 0
$LN1@AddTriangl:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1480 : }

  0013c	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00141	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00145	41 5f		 pop	 r15
  00147	41 5e		 pop	 r14
  00149	41 5c		 pop	 r12
  0014b	c3		 ret	 0
?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ENDP ; ImDrawList::AddTriangleFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
center$ = 72
radius$ = 80
col$ = 88
num_segments$dead$ = 96
thickness$ = 104
?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z PROC	; ImDrawList::AddCircle

; 1483 : {

$LN15:

; 1484 :     if ((col & IM_COL32_A_MASK) == 0 || radius <= 0.0f)

  00000	41 f7 c1 00 00
	00 ff		 test	 r9d, -16777216		; ff000000H
  00007	74 76		 je	 SHORT $LN13@AddCircle
  00009	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	0f 57 db	 xorps	 xmm3, xmm3

; 1483 : {

  00016	41 8b f9	 mov	 edi, r9d

; 1484 :     if ((col & IM_COL32_A_MASK) == 0 || radius <= 0.0f)

  00019	0f 2f da	 comiss	 xmm3, xmm2
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	73 54		 jae	 SHORT $LN3@AddCircle

; 1485 :         return;
; 1486 : 
; 1487 :     if (num_segments <= 0)
; 1488 :     {
; 1489 :         // Use arc with automatic segment count
; 1490 :         _PathArcToFastEx(center, radius - 0.5f, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);
; 1491 :         _Path.Size--;
; 1492 :     }
; 1493 :     else
; 1494 :     {
; 1495 :         // Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
; 1496 :         num_segments = ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX);
; 1497 : 
; 1498 :         // Because we are filling a closed shape we remove 1 from the count of segments/points
; 1499 :         const float a_max = (IM_PI * 2.0f) * ((float)num_segments - 1.0f) / (float)num_segments;
; 1500 :         PathArcTo(center, radius - 0.5f, 0.0f, a_max, num_segments - 1);

  00021	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40c70d23
  00029	f3 0f 5c 15 00
	00 00 00	 subss	 xmm2, DWORD PTR __real@3f000000
  00031	c7 44 24 28 63
	00 00 00	 mov	 DWORD PTR [rsp+40], 99	; 00000063H
  00039	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0003f	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  00044	f3 0f 10 44 24
	68		 movss	 xmm0, DWORD PTR thickness$[rsp]
  0004a	44 8b cf	 mov	 r9d, edi
  0004d	44 8b 43 78	 mov	 r8d, DWORD PTR [rbx+120]
  00051	48 8b cb	 mov	 rcx, rbx
  00054	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0005b	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00061	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00069	e8 00 00 00 00	 call	 ?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
  0006e	c7 43 78 00 00
	00 00		 mov	 DWORD PTR [rbx+120], 0
$LN3@AddCircle:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1504 : }

  00075	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5f		 pop	 rdi
$LN13@AddCircle:
  0007f	c3		 ret	 0
?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z ENDP	; ImDrawList::AddCircle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
center$ = 72
radius$ = 80
col$ = 88
num_segments$ = 96
?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z PROC ; ImDrawList::AddCircleFilled

; 1507 : {

$LN16:

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius <= 0.0f)

  00000	41 f7 c1 00 00
	00 ff		 test	 r9d, -16777216		; ff000000H
  00007	0f 84 a8 00 00
	00		 je	 $LN13@AddCircleF
  0000d	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00012	57		 push	 rdi
  00013	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00017	0f 57 db	 xorps	 xmm3, xmm3

; 1507 : {

  0001a	41 8b f9	 mov	 edi, r9d

; 1508 :     if ((col & IM_COL32_A_MASK) == 0 || radius <= 0.0f)

  0001d	0f 2f da	 comiss	 xmm3, xmm2
  00020	48 8b d9	 mov	 rbx, rcx
  00023	0f 83 82 00 00
	00		 jae	 $LN3@AddCircleF

; 1509 :         return;
; 1510 : 
; 1511 :     if (num_segments <= 0)

  00029	8b 44 24 60	 mov	 eax, DWORD PTR num_segments$[rsp]
  0002d	85 c0		 test	 eax, eax
  0002f	7f 15		 jg	 SHORT $LN4@AddCircleF

; 1512 :     {
; 1513 :         // Use arc with automatic segment count
; 1514 :         _PathArcToFastEx(center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0);

  00031	45 33 c9	 xor	 r9d, r9d
  00034	c7 44 24 20 30
	00 00 00	 mov	 DWORD PTR [rsp+32], 48	; 00000030H
  0003c	e8 00 00 00 00	 call	 ?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx

; 1515 :         _Path.Size--;

  00041	ff 4b 78	 dec	 DWORD PTR [rbx+120]

; 1516 :     }

  00044	eb 48		 jmp	 SHORT $LN14@AddCircleF
$LN4@AddCircleF:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 426  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00046	83 f8 03	 cmp	 eax, 3
  00049	7d 07		 jge	 SHORT $LN9@AddCircleF
  0004b	b8 03 00 00 00	 mov	 eax, 3
  00050	eb 0a		 jmp	 SHORT $LN10@AddCircleF
$LN9@AddCircleF:
  00052	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00057	3b c1		 cmp	 eax, ecx
  00059	0f 4f c1	 cmovg	 eax, ecx
$LN10@AddCircleF:
  0005c	66 0f 6e c0	 movd	 xmm0, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1524 :         PathArcTo(center, radius, 0.0f, a_max, num_segments - 1);

  00060	48 8b cb	 mov	 rcx, rbx
  00063	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00066	ff c8		 dec	 eax
  00068	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0006c	0f 28 c8	 movaps	 xmm1, xmm0
  0006f	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f800000
  00077	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40c90fdb
  0007f	f3 0f 5e c8	 divss	 xmm1, xmm0
  00083	f3 0f 11 4c 24
	20		 movss	 DWORD PTR [rsp+32], xmm1
  00089	e8 00 00 00 00	 call	 ?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
$LN14@AddCircleF:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2569 :     inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  0008e	44 8b 43 78	 mov	 r8d, DWORD PTR [rbx+120]
  00092	44 8b cf	 mov	 r9d, edi
  00095	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	e8 00 00 00 00	 call	 ?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
  000a4	c7 43 78 00 00
	00 00		 mov	 DWORD PTR [rbx+120], 0
$LN3@AddCircleF:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1528 : }

  000ab	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b4	5f		 pop	 rdi
$LN13@AddCircleF:
  000b5	c3		 ret	 0
?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z ENDP ; ImDrawList::AddCircleFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
radius$ = 56
?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z PROC	; ImDrawList::_CalcCircleAutoSegmentCount

; 573  : {

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 574  :     // Automatic segment count
; 575  :     const int radius_idx = (int)(radius + 0.999999f); // ceil to never reduce accuracy

  00004	48 8b 51 38	 mov	 rdx, QWORD PTR [rcx+56]
  00008	0f 28 c1	 movaps	 xmm0, xmm1
  0000b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f7fffef
  00013	0f 28 d1	 movaps	 xmm2, xmm1
  00016	f3 0f 2c c0	 cvttss2si eax, xmm0

; 576  :     if (radius_idx < IM_ARRAYSIZE(_Data->CircleSegmentCounts))

  0001a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0001d	7d 0f		 jge	 SHORT $LN2@CalcCircle

; 577  :         return _Data->CircleSegmentCounts[radius_idx]; // Use cached value

  0001f	48 98		 cdqe
  00021	0f b6 84 10 b4
	01 00 00	 movzx	 eax, BYTE PTR [rax+rdx+436]

; 580  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
$LN2@CalcCircle:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 424  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

  0002e	f3 0f 10 4a 18	 movss	 xmm1, DWORD PTR [rdx+24]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 579  :         return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);

  00033	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 424  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

  0003b	f3 0f 5d ca	 minss	 xmm1, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 579  :         return IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, _Data->CircleSegmentMaxError);

  0003f	f3 0f 5e ca	 divss	 xmm1, xmm2
  00043	f3 0f 5c c1	 subss	 xmm0, xmm1
  00047	e8 00 00 00 00	 call	 acosf
  0004c	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40490fdb
  00054	f3 0f 5e c8	 divss	 xmm1, xmm0
  00058	0f 28 c1	 movaps	 xmm0, xmm1
  0005b	e8 00 00 00 00	 call	 ceilf
  00060	f3 0f 2c c0	 cvttss2si eax, xmm0
  00064	ff c0		 inc	 eax
  00066	99		 cdq
  00067	2b c2		 sub	 eax, edx
  00069	d1 f8		 sar	 eax, 1
  0006b	03 c0		 add	 eax, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 426  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

  0006d	83 f8 04	 cmp	 eax, 4
  00070	7d 0a		 jge	 SHORT $LN11@CalcCircle
  00072	b8 04 00 00 00	 mov	 eax, 4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 580  : }

  00077	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007b	c3		 ret	 0
$LN11@CalcCircle:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 426  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

  0007c	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00081	3b c1		 cmp	 eax, ecx
  00083	0f 4f c1	 cmovg	 eax, ecx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 580  : }

  00086	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008a	c3		 ret	 0
?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ENDP	; ImDrawList::_CalcCircleAutoSegmentCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??0ImDrawCmd@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImDrawCmd@@QEAA@XZ PROC				; ImDrawCmd::ImDrawCmd, COMDAT

; 2404 :     ImDrawCmd() { memset(this, 0, sizeof(*this)); } // Also ensure our padding fields are zeroed

  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	33 c0		 xor	 eax, eax
  00005	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00008	0f 11 41 10	 movups	 XMMWORD PTR [rcx+16], xmm0
  0000c	0f 11 41 20	 movups	 XMMWORD PTR [rcx+32], xmm0
  00010	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  00014	48 8b c1	 mov	 rax, rcx
  00017	c3		 ret	 0
??0ImDrawCmd@@QEAA@XZ ENDP				; ImDrawCmd::ImDrawCmd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?Clear@ImDrawListSplitter@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?Clear@ImDrawListSplitter@@QEAAXXZ PROC			; ImDrawListSplitter::Clear, COMDAT

; 2452 :     inline void                 Clear() { _Current = 0; _Count = 1; } // Do not clear Channels[] so our allocations are reused next frame

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [rcx], 0
  00006	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [rcx+4], 1
  0000d	c3		 ret	 0
?Clear@ImDrawListSplitter@@QEAAXXZ ENDP			; ImDrawListSplitter::Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??0ImFontAtlasCustomRect@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImFontAtlasCustomRect@@QEAA@XZ PROC			; ImFontAtlasCustomRect::ImFontAtlasCustomRect, COMDAT

; 2711 :     ImFontAtlasCustomRect() { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

  00000	33 d2		 xor	 edx, edx
  00002	c7 41 04 ff ff
	ff ff		 mov	 DWORD PTR [rcx+4], -1	; ffffffffH
  00009	89 11		 mov	 DWORD PTR [rcx], edx
  0000b	48 8b c1	 mov	 rax, rcx
  0000e	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  00012	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  00016	48 89 51 18	 mov	 QWORD PTR [rcx+24], rdx
  0001a	c3		 ret	 0
??0ImFontAtlasCustomRect@@QEAA@XZ ENDP			; ImFontAtlasCustomRect::ImFontAtlasCustomRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?IsPacked@ImFontAtlasCustomRect@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?IsPacked@ImFontAtlasCustomRect@@QEBA_NXZ PROC		; ImFontAtlasCustomRect::IsPacked, COMDAT

; 2712 :     bool IsPacked() const { return X != 0xFFFF; }

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00005	66 39 41 04	 cmp	 WORD PTR [rcx+4], ax
  00009	0f 95 c0	 setne	 al
  0000c	c3		 ret	 0
?IsPacked@ImFontAtlasCustomRect@@QEBA_NXZ ENDP		; ImFontAtlasCustomRect::IsPacked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z
_TEXT	SEGMENT
this$ = 48
index$ = 56
?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z PROC ; ImFontAtlas::GetCustomRectByIndex, COMDAT

; 2796 :     ImFontAtlasCustomRect* GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8d 59 58	 lea	 rbx, QWORD PTR [rcx+88]
  00011	85 d2		 test	 edx, edx
  00013	79 1c		 jns	 SHORT $LN3@GetCustomR
  00015	41 b8 ec 0a 00
	00		 mov	 r8d, 2796		; 00000aecH
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@HMJJDGFN@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	eb 04		 jmp	 SHORT $LN6@GetCustomR
$LN3@GetCustomR:

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00031	3b 3b		 cmp	 edi, DWORD PTR [rbx]
  00033	7c 1a		 jl	 SHORT $LN7@GetCustomR
$LN6@GetCustomR:
  00035	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN7@GetCustomR:
  0004f	48 8b c7	 mov	 rax, rdi
  00052	48 c1 e0 05	 shl	 rax, 5
  00056	48 03 43 08	 add	 rax, QWORD PTR [rbx+8]

; 2796 :     ImFontAtlasCustomRect* GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }

  0005a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z ENDP ; ImFontAtlas::GetCustomRectByIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
base$ = 8
count$ = 16
size_of_element$dead$ = 24
compare_func$ = 32
?ImQsort@@YAXPEAX_K1P6AHPEBX2@Z@Z PROC			; ImQsort

; 305  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL* compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

  00000	48 83 fa 01	 cmp	 rdx, 1
  00004	76 0d		 jbe	 SHORT $LN2@ImQsort
  00006	41 b8 10 00 00
	00		 mov	 r8d, 16
  0000c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_qsort
$LN2@ImQsort:
  00013	c3		 ret	 0
?ImQsort@@YAXPEAX_K1P6AHPEBX2@Z@Z ENDP			; ImQsort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
v$ = 8
?ImUpperPowerOfTwo@@YAHH@Z PROC				; ImUpperPowerOfTwo

; 314  : static inline int       ImUpperPowerOfTwo(int v) { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

  00000	ff c9		 dec	 ecx
  00002	8b c1		 mov	 eax, ecx
  00004	d1 f8		 sar	 eax, 1
  00006	0b c8		 or	 ecx, eax
  00008	8b c1		 mov	 eax, ecx
  0000a	c1 f8 02	 sar	 eax, 2
  0000d	0b c8		 or	 ecx, eax
  0000f	8b c1		 mov	 eax, ecx
  00011	c1 f8 04	 sar	 eax, 4
  00014	0b c8		 or	 ecx, eax
  00016	8b c1		 mov	 eax, ecx
  00018	c1 f8 08	 sar	 eax, 8
  0001b	0b c8		 or	 ecx, eax
  0001d	8b c1		 mov	 eax, ecx
  0001f	c1 f8 10	 sar	 eax, 16
  00022	0b c1		 or	 eax, ecx
  00024	ff c0		 inc	 eax
  00026	c3		 ret	 0
?ImUpperPowerOfTwo@@YAHH@Z ENDP				; ImUpperPowerOfTwo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
c$ = 8
?ImCharIsBlankA@@YA_ND@Z PROC				; ImCharIsBlankA

; 335  : static inline bool      ImCharIsBlankA(char c) { return c == ' ' || c == '\t'; }

  00000	80 f9 20	 cmp	 cl, 32			; 00000020H
  00003	74 08		 je	 SHORT $LN3@ImCharIsBl
  00005	80 f9 09	 cmp	 cl, 9
  00008	74 03		 je	 SHORT $LN3@ImCharIsBl
  0000a	32 c0		 xor	 al, al
  0000c	c3		 ret	 0
$LN3@ImCharIsBl:
  0000d	b0 01		 mov	 al, 1
  0000f	c3		 ret	 0
?ImCharIsBlankA@@YA_ND@Z ENDP				; ImCharIsBlankA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
c$ = 8
?ImCharIsBlankW@@YA_NI@Z PROC				; ImCharIsBlankW

; 336  : static inline bool      ImCharIsBlankW(unsigned int c) { return c == ' ' || c == '\t' || c == 0x3000; }

  00000	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00003	74 10		 je	 SHORT $LN3@ImCharIsBl
  00005	83 f9 09	 cmp	 ecx, 9
  00008	74 0b		 je	 SHORT $LN3@ImCharIsBl
  0000a	81 f9 00 30 00
	00		 cmp	 ecx, 12288		; 00003000H
  00010	74 03		 je	 SHORT $LN3@ImCharIsBl
  00012	32 c0		 xor	 al, al
  00014	c3		 ret	 0
$LN3@ImCharIsBl:
  00015	b0 01		 mov	 al, 1
  00017	c3		 ret	 0
?ImCharIsBlankW@@YA_NI@Z ENDP				; ImCharIsBlankW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??D@YA?AUImVec2@@AEBU0@M@Z PROC				; operator*

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00000	0f 28 c2	 movaps	 xmm0, xmm2
  00003	48 8b c1	 mov	 rax, rcx
  00006	f3 0f 59 02	 mulss	 xmm0, DWORD PTR [rdx]
  0000a	f3 0f 59 52 04	 mulss	 xmm2, DWORD PTR [rdx+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0000f	f3 0f 11 01	 movss	 DWORD PTR [rcx], xmm0
  00013	f3 0f 11 51 04	 movss	 DWORD PTR [rcx+4], xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 352  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }

  00018	c3		 ret	 0
??D@YA?AUImVec2@@AEBU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??H@YA?AUImVec2@@AEBU0@0@Z PROC				; operator+

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00000	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  00004	48 8b c1	 mov	 rax, rcx
  00007	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [rdx+4]
  0000c	f3 41 0f 58 00	 addss	 xmm0, DWORD PTR [r8]
  00011	f3 41 0f 58 48
	04		 addss	 xmm1, DWORD PTR [r8+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00017	f3 0f 11 01	 movss	 DWORD PTR [rcx], xmm0
  0001b	f3 0f 11 49 04	 movss	 DWORD PTR [rcx+4], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00020	c3		 ret	 0
??H@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??G@YA?AUImVec2@@AEBU0@0@Z PROC				; operator-

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  00000	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  00004	48 8b c1	 mov	 rax, rcx
  00007	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [rdx+4]
  0000c	f3 41 0f 5c 00	 subss	 xmm0, DWORD PTR [r8]
  00011	f3 41 0f 5c 48
	04		 subss	 xmm1, DWORD PTR [r8+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00017	f3 0f 11 01	 movss	 DWORD PTR [rcx], xmm0
  0001b	f3 0f 11 49 04	 movss	 DWORD PTR [rcx+4], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 355  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }

  00020	c3		 ret	 0
??G@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 8
lhs$ = 16
rhs$ = 24
??D@YA?AUImVec2@@AEBU0@0@Z PROC				; operator*

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  00000	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  00004	48 8b c1	 mov	 rax, rcx
  00007	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [rdx+4]
  0000c	f3 41 0f 59 00	 mulss	 xmm0, DWORD PTR [r8]
  00011	f3 41 0f 59 48
	04		 mulss	 xmm1, DWORD PTR [r8+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00017	f3 0f 11 01	 movss	 DWORD PTR [rcx], xmm0
  0001b	f3 0f 11 49 04	 movss	 DWORD PTR [rcx+4], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  00020	c3		 ret	 0
??D@YA?AUImVec2@@AEBU0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z PROC			; operator-=

; 361  : static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }

  00000	f3 0f 10 01	 movss	 xmm0, DWORD PTR [rcx]
  00004	48 8b c1	 mov	 rax, rcx
  00007	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [rdx]
  0000b	f3 0f 10 49 04	 movss	 xmm1, DWORD PTR [rcx+4]
  00010	f3 0f 11 01	 movss	 DWORD PTR [rcx], xmm0
  00014	f3 0f 5c 4a 04	 subss	 xmm1, DWORD PTR [rdx+4]
  00019	f3 0f 11 49 04	 movss	 DWORD PTR [rcx+4], xmm1
  0001e	c3		 ret	 0
??Z@YAAEAUImVec2@@AEAU0@AEBU0@@Z ENDP			; operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 8
?ImAbs@@YAHH@Z PROC					; ImAbs

; 410  : static inline int    ImAbs(int x) { return x < 0 ? -x : x; }

  00000	8b c1		 mov	 eax, ecx
  00002	99		 cdq
  00003	33 c2		 xor	 eax, edx
  00005	2b c2		 sub	 eax, edx
  00007	c3		 ret	 0
?ImAbs@@YAHH@Z ENDP					; ImAbs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 8
?ImAbs@@YAMM@Z PROC					; ImAbs
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

  00000	0f 54 05 00 00
	00 00		 andps	 xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 411  : static inline float  ImAbs(float x) { return fabsf(x); }

  00007	c3		 ret	 0
?ImAbs@@YAMM@Z ENDP					; ImAbs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
x$ = 8
?ImRsqrt@@YAMM@Z PROC					; ImRsqrt

; 416  : static inline float  ImRsqrt(float x) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(x))); }

  00000	f3 0f 52 c8	 rsqrtss xmm1, xmm0
  00004	0f 28 c1	 movaps	 xmm0, xmm1
  00007	c3		 ret	 0
?ImRsqrt@@YAMM@Z ENDP					; ImRsqrt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
__$ReturnUdt$ = 8
a$ = 16
b$ = 24
t$ = 32
?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z PROC			; ImLerp

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  00000	0f 10 0a	 movups	 xmm1, XMMWORD PTR [rdx]
  00003	48 8b c1	 mov	 rax, rcx
  00006	41 0f 10 10	 movups	 xmm2, XMMWORD PTR [r8]
  0000a	0f 28 c3	 movaps	 xmm0, xmm3
  0000d	0f 5c d1	 subps	 xmm2, xmm1
  00010	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00014	0f 59 d0	 mulps	 xmm2, xmm0
  00017	0f 58 d1	 addps	 xmm2, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 266  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

  0001a	0f 11 11	 movups	 XMMWORD PTR [rcx], xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 437  : static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }

  0001d	c3		 ret	 0
?ImLerp@@YA?AUImVec4@@AEBU1@0M@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
f$ = 8
?ImFloor@@YAMM@Z PROC					; ImFloor

; 442  : static inline float  ImFloor(float f) { return (float)(int)(f); }

  00000	f3 0f 2c c0	 cvttss2si eax, xmm0
  00004	66 0f 6e c0	 movd	 xmm0, eax
  00008	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0000b	c3		 ret	 0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
f$ = 8
?ImFloorSigned@@YAMM@Z PROC				; ImFloorSigned

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00000	0f 57 c9	 xorps	 xmm1, xmm1
  00003	0f 2f c1	 comiss	 xmm0, xmm1
  00006	f3 0f 2c c0	 cvttss2si eax, xmm0
  0000a	73 10		 jae	 SHORT $LN5@ImFloorSig
  0000c	66 0f 6e c8	 movd	 xmm1, eax
  00010	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00013	0f 2e c8	 ucomiss xmm1, xmm0
  00016	7a 02		 jp	 SHORT $LN6@ImFloorSig
  00018	74 02		 je	 SHORT $LN5@ImFloorSig
$LN6@ImFloorSig:
  0001a	ff c8		 dec	 eax
$LN5@ImFloorSig:
  0001c	66 0f 6e c0	 movd	 xmm0, eax
  00020	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00023	c3		 ret	 0
?ImFloorSigned@@YAMM@Z ENDP				; ImFloorSigned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
;	COMDAT ?Create@ImBitVector@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
sz$ = 56
?Create@ImBitVector@@QEAAXH@Z PROC			; ImBitVector::Create, COMDAT

; 562  :     void            Create(int sz) { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0000a	44 8b 41 04	 mov	 r8d, DWORD PTR [rcx+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 562  :     void            Create(int sz) { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

  0000e	8d 5a 1f	 lea	 ebx, DWORD PTR [rdx+31]
  00011	c1 fb 05	 sar	 ebx, 5
  00014	48 8b f9	 mov	 rdi, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00017	41 3b d8	 cmp	 ebx, r8d
  0001a	7e 23		 jle	 SHORT $LN4@Create

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001c	45 85 c0	 test	 r8d, r8d
  0001f	74 0d		 je	 SHORT $LN8@Create
  00021	41 8b c0	 mov	 eax, r8d
  00024	99		 cdq
  00025	2b c2		 sub	 eax, edx
  00027	d1 f8		 sar	 eax, 1
  00029	41 03 c0	 add	 eax, r8d
  0002c	eb 05		 jmp	 SHORT $LN9@Create
$LN8@Create:
  0002e	b8 08 00 00 00	 mov	 eax, 8
$LN9@Create:
  00033	3b c3		 cmp	 eax, ebx
  00035	8b d3		 mov	 edx, ebx
  00037	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0003a	e8 00 00 00 00	 call	 ?reserve@?$ImVector@I@@QEAAXH@Z ; ImVector<unsigned int>::reserve
$LN4@Create:
  0003f	89 1f		 mov	 DWORD PTR [rdi], ebx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 562  :     void            Create(int sz) { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

  00041	33 d2		 xor	 edx, edx
  00043	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00047	4c 63 c3	 movsxd	 r8, ebx
  0004a	49 c1 e0 02	 shl	 r8, 2
  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	e9 00 00 00 00	 jmp	 memset
?Create@ImBitVector@@QEAAXH@Z ENDP			; ImBitVector::Create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
;	COMDAT ?Clear@ImBitVector@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?Clear@ImBitVector@@QEAAXXZ PROC			; ImBitVector::Clear, COMDAT

; 563  :     void            Clear() { Storage.clear(); }

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN4@Clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN8@Clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN8@Clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN4@Clear:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 563  :     void            Clear() { Storage.clear(); }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?Clear@ImBitVector@@QEAAXXZ ENDP			; ImBitVector::Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
;	COMDAT ?TestBit@ImBitVector@@QEBA_NH@Z
_TEXT	SEGMENT
this$ = 48
n$ = 56
?TestBit@ImBitVector@@QEBA_NH@Z PROC			; ImBitVector::TestBit, COMDAT

; 564  :     bool            TestBit(int n) const { IM_ASSERT(n < (Storage.Size << 5)); return ImBitArrayTestBit(Storage.Data, n); }

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0000c	48 8b f9	 mov	 rdi, rcx
  0000f	c1 e0 05	 shl	 eax, 5
  00012	48 63 da	 movsxd	 rbx, edx
  00015	3b d8		 cmp	 ebx, eax
  00017	7c 1a		 jl	 SHORT $LN3@TestBit
  00019	41 b8 34 02 00
	00		 mov	 r8d, 564		; 00000234H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@MPMNJHLP@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@HCNHOFJN@?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAo?$AAr?$AAa?$AAg?$AAe?$AA?4?$AAS?$AAi@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN3@TestBit:

; 525  : inline bool     ImBitArrayTestBit(const ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); return (arr[n >> 5] & mask) != 0; }

  00033	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00037	4c 8b c3	 mov	 r8, rbx
  0003a	49 c1 f8 05	 sar	 r8, 5
  0003e	83 e3 1f	 and	 ebx, 31
  00041	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  00045	0f a3 d8	 bt	 eax, ebx

; 564  :     bool            TestBit(int n) const { IM_ASSERT(n < (Storage.Size << 5)); return ImBitArrayTestBit(Storage.Data, n); }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 525  : inline bool     ImBitArrayTestBit(const ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); return (arr[n >> 5] & mask) != 0; }

  0004d	0f 92 c0	 setb	 al

; 564  :     bool            TestBit(int n) const { IM_ASSERT(n < (Storage.Size << 5)); return ImBitArrayTestBit(Storage.Data, n); }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
?TestBit@ImBitVector@@QEBA_NH@Z ENDP			; ImBitVector::TestBit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
;	COMDAT ?SetBit@ImBitVector@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
n$ = 56
?SetBit@ImBitVector@@QEAAXH@Z PROC			; ImBitVector::SetBit, COMDAT

; 565  :     void            SetBit(int n) { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0000c	48 8b f9	 mov	 rdi, rcx
  0000f	c1 e0 05	 shl	 eax, 5
  00012	48 63 da	 movsxd	 rbx, edx
  00015	3b d8		 cmp	 ebx, eax
  00017	7c 1a		 jl	 SHORT $LN3@SetBit
  00019	41 b8 35 02 00
	00		 mov	 r8d, 565		; 00000235H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@MPMNJHLP@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@HCNHOFJN@?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAo?$AAr?$AAa?$AAg?$AAe?$AA?4?$AAS?$AAi@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN3@SetBit:
  00033	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]

; 527  : inline void     ImBitArraySetBit(ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }

  00037	48 8b c3	 mov	 rax, rbx
  0003a	48 c1 f8 05	 sar	 rax, 5
  0003e	83 e3 1f	 and	 ebx, 31
  00041	48 8d 14 81	 lea	 rdx, QWORD PTR [rcx+rax*4]
  00045	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00048	0f ab d8	 bts	 eax, ebx

; 565  :     void            SetBit(int n) { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }

  0004b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 527  : inline void     ImBitArraySetBit(ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }

  00050	89 02		 mov	 DWORD PTR [rdx], eax

; 565  :     void            SetBit(int n) { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
?SetBit@ImBitVector@@QEAAXH@Z ENDP			; ImBitVector::SetBit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
context$ = 8
allow_out_of_mem$dead$ = 16
stbrp_setup_allow_out_of_mem PROC

; 244  :     if (allow_out_of_mem)
; 245  :         // if it's ok to run out of memory, then don't bother aligning them;
; 246  :         // this gives better packing, but may fail due to OOM (even though
; 247  :         // the rectangles easily fit). @TODO a smarter approach would be to only
; 248  :         // quantize once we've hit OOM, then we could get rid of this parameter.
; 249  :         context->align = 1;
; 250  :     else {
; 251  :         // if it's not ok to run out of memory, then quantize the widths
; 252  :         // so that num_nodes is always enough nodes.
; 253  :         //
; 254  :         // I.e. num_nodes * align >= width
; 255  :         //                  align >= width / num_nodes
; 256  :         //                  align = ceil(width/num_nodes)
; 257  : 
; 258  :         context->align = (context->width + context->num_nodes - 1) / context->num_nodes;

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	ff c8		 dec	 eax
  00004	03 41 14	 add	 eax, DWORD PTR [rcx+20]
  00007	99		 cdq
  00008	f7 79 14	 idiv	 DWORD PTR [rcx+20]

; 259  :     }
; 260  : }

  0000b	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  0000e	c3		 ret	 0
stbrp_setup_allow_out_of_mem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
context$ = 96
width$ = 104
height$ = 112
nodes$ = 120
num_nodes$ = 128
stbrp_init_target PROC

; 263  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00018	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6

; 264  :     int i;
; 265  : #ifndef STBRP_LARGE_RECTS
; 266  :     STBRP_ASSERT(width <= 0xffff && height <= 0xffff);

  0001d	41 bf ff ff 00
	00		 mov	 r15d, 65535		; 0000ffffH

; 267  : #endif
; 268  : 
; 269  :     for (i = 0; i < num_nodes - 1; ++i)

  00023	66 49 0f 6e f1	 movq	 xmm6, r9
  00028	49 8b f9	 mov	 rdi, r9
  0002b	66 0f 6c f6	 punpcklqdq xmm6, xmm6
  0002f	41 8b e8	 mov	 ebp, r8d
  00032	8b f2		 mov	 esi, edx
  00034	48 8b d9	 mov	 rbx, rcx
  00037	41 3b d7	 cmp	 edx, r15d
  0003a	7f 05		 jg	 SHORT $LN9@stbrp_init

; 264  :     int i;
; 265  : #ifndef STBRP_LARGE_RECTS
; 266  :     STBRP_ASSERT(width <= 0xffff && height <= 0xffff);

  0003c	45 3b c7	 cmp	 r8d, r15d
  0003f	7e 1a		 jle	 SHORT $LN2@stbrp_init
$LN9@stbrp_init:
  00041	41 b8 0a 01 00
	00		 mov	 r8d, 266		; 0000010aH
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@NNJKMECF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA0?$AAx?$AAf?$AAf?$AAf?$AAf@
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN2@stbrp_init:

; 267  : #endif
; 268  : 
; 269  :     for (i = 0; i < num_nodes - 1; ++i)

  0005b	44 8b 9c 24 80
	00 00 00	 mov	 r11d, DWORD PTR num_nodes$[rsp]
  00063	45 33 f6	 xor	 r14d, r14d
  00066	45 8b ce	 mov	 r9d, r14d
  00069	41 8d 4b ff	 lea	 ecx, DWORD PTR [r11-1]
  0006d	85 c9		 test	 ecx, ecx
  0006f	0f 8e d4 00 00
	00		 jle	 $LN18@stbrp_init
  00075	83 f9 04	 cmp	 ecx, 4
  00078	0f 82 cb 00 00
	00		 jb	 $LN18@stbrp_init
  0007e	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR __isa_available, 2
  00085	0f 8c be 00 00
	00		 jl	 $LN18@stbrp_init
  0008b	8b c1		 mov	 eax, ecx
  0008d	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  00092	66 0f 6f 3d 00
	00 00 00	 movdqa	 xmm7, XMMWORD PTR __xmm@00000003000000020000000100000000
  0009a	25 03 00 00 80	 and	 eax, -2147483645	; ffffffff80000003H
  0009f	7d 07		 jge	 SHORT $LN24@stbrp_init
  000a1	ff c8		 dec	 eax
  000a3	83 c8 fc	 or	 eax, -4
  000a6	ff c0		 inc	 eax
$LN24@stbrp_init:
  000a8	66 0f 6f 25 00
	00 00 00	 movdqa	 xmm4, XMMWORD PTR __xmm@00000001000000010000000100000001
  000b0	48 8d 57 28	 lea	 rdx, QWORD PTR [rdi+40]
  000b4	44 8b c1	 mov	 r8d, ecx
  000b7	44 2b c0	 sub	 r8d, eax
  000ba	b8 04 00 00 00	 mov	 eax, 4
  000bf	66 0f 6e e8	 movd	 xmm5, eax
  000c3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL7@stbrp_init:

; 270  :         nodes[i].next = &nodes[i + 1];

  000d0	66 41 0f 6e c9	 movd	 xmm1, r9d
  000d5	41 8d 41 02	 lea	 eax, DWORD PTR [r9+2]
  000d9	66 0f 70 c9 00	 pshufd	 xmm1, xmm1, 0
  000de	48 8d 52 40	 lea	 rdx, QWORD PTR [rdx+64]
  000e2	f3 0f 7e df	 movq	 xmm3, xmm7
  000e6	f3 0f 7e c4	 movq	 xmm0, xmm4
  000ea	66 0f fe cb	 paddd	 xmm1, xmm3
  000ee	41 83 c1 04	 add	 r9d, 4
  000f2	66 0f fe c8	 paddd	 xmm1, xmm0
  000f6	66 0f 38 25 d1	 pmovsxdq xmm2, xmm1
  000fb	66 0f 6e c8	 movd	 xmm1, eax
  000ff	66 0f 70 c9 00	 pshufd	 xmm1, xmm1, 0
  00104	66 0f fe cb	 paddd	 xmm1, xmm3
  00108	66 0f fe c8	 paddd	 xmm1, xmm0
  0010c	66 0f f3 d5	 psllq	 xmm2, xmm5
  00110	66 0f d4 d6	 paddq	 xmm2, xmm6
  00114	66 0f d6 52 a0	 movq	 QWORD PTR [rdx-96], xmm2
  00119	66 0f 73 da 08	 psrldq	 xmm2, 8
  0011e	66 0f d6 52 b0	 movq	 QWORD PTR [rdx-80], xmm2
  00123	66 0f 38 25 d1	 pmovsxdq xmm2, xmm1
  00128	66 0f f3 d5	 psllq	 xmm2, xmm5
  0012c	66 0f d4 d6	 paddq	 xmm2, xmm6
  00130	66 0f d6 52 c0	 movq	 QWORD PTR [rdx-64], xmm2
  00135	66 0f 73 da 08	 psrldq	 xmm2, 8
  0013a	66 0f d6 52 d0	 movq	 QWORD PTR [rdx-48], xmm2
  0013f	45 3b c8	 cmp	 r9d, r8d
  00142	7c 8c		 jl	 SHORT $LL7@stbrp_init

; 267  : #endif
; 268  : 
; 269  :     for (i = 0; i < num_nodes - 1; ++i)

  00144	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
$LN18@stbrp_init:
  00149	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0014e	4d 63 d1	 movsxd	 r10, r9d
  00151	4c 63 c1	 movsxd	 r8, ecx
  00154	4d 3b d0	 cmp	 r10, r8
  00157	7d 41		 jge	 SHORT $LN6@stbrp_init
  00159	49 8b c2	 mov	 rax, r10
  0015c	41 8d 51 01	 lea	 edx, DWORD PTR [r9+1]
  00160	48 c1 e0 04	 shl	 rax, 4
  00164	4d 2b c2	 sub	 r8, r10
  00167	48 83 c0 08	 add	 rax, 8
  0016b	48 03 c7	 add	 rax, rdi
  0016e	45 03 c8	 add	 r9d, r8d
  00171	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL17@stbrp_init:

; 270  :         nodes[i].next = &nodes[i + 1];

  00180	48 63 ca	 movsxd	 rcx, edx
  00183	48 8d 40 10	 lea	 rax, QWORD PTR [rax+16]
  00187	48 c1 e1 04	 shl	 rcx, 4
  0018b	ff c2		 inc	 edx
  0018d	48 03 cf	 add	 rcx, rdi
  00190	48 89 48 f0	 mov	 QWORD PTR [rax-16], rcx
  00194	49 83 e8 01	 sub	 r8, 1
  00198	75 e6		 jne	 SHORT $LL17@stbrp_init
$LN6@stbrp_init:

; 271  :     nodes[i].next = NULL;

  0019a	49 63 c1	 movsxd	 rax, r9d

; 272  :     context->init_mode = STBRP__INIT_skyline;
; 273  :     context->heuristic = STBRP_HEURISTIC_Skyline_default;
; 274  :     context->free_head = &nodes[0];
; 275  :     context->active_head = &context->extra[0];

  0019d	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
  001a1	48 03 c0	 add	 rax, rax
  001a4	4c 89 74 c7 08	 mov	 QWORD PTR [rdi+rax*8+8], r14

; 258  :         context->align = (context->width + context->num_nodes - 1) / context->num_nodes;

  001a9	41 8d 43 ff	 lea	 eax, DWORD PTR [r11-1]

; 276  :     context->width = width;

  001ad	89 33		 mov	 DWORD PTR [rbx], esi

; 258  :         context->align = (context->width + context->num_nodes - 1) / context->num_nodes;

  001af	03 c6		 add	 eax, esi

; 277  :     context->height = height;

  001b1	89 6b 04	 mov	 DWORD PTR [rbx+4], ebp

; 258  :         context->align = (context->width + context->num_nodes - 1) / context->num_nodes;

  001b4	99		 cdq

; 286  : #ifdef STBRP_LARGE_RECTS
; 287  :     context->extra[1].y = (1 << 30);
; 288  : #else
; 289  :     context->extra[1].y = 65535;
; 290  : #endif
; 291  :     context->extra[1].next = NULL;
; 292  : }

  001b5	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  001ba	48 c7 43 0c 01
	00 00 00	 mov	 QWORD PTR [rbx+12], 1
  001c2	48 89 7b 20	 mov	 QWORD PTR [rbx+32], rdi
  001c6	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx
  001ca	44 89 5b 14	 mov	 DWORD PTR [rbx+20], r11d

; 258  :         context->align = (context->width + context->num_nodes - 1) / context->num_nodes;

  001ce	41 f7 fb	 idiv	 r11d
  001d1	89 43 08	 mov	 DWORD PTR [rbx+8], eax

; 278  :     context->num_nodes = num_nodes;
; 279  :     stbrp_setup_allow_out_of_mem(context, 0);
; 280  : 
; 281  :     // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
; 282  :     context->extra[0].x = 0;
; 283  :     context->extra[0].y = 0;
; 284  :     context->extra[0].next = &context->extra[1];

  001d4	48 8d 43 38	 lea	 rax, QWORD PTR [rbx+56]
  001d8	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax

; 285  :     context->extra[1].x = (stbrp_coord)width;

  001dc	66 89 30	 mov	 WORD PTR [rax], si

; 286  : #ifdef STBRP_LARGE_RECTS
; 287  :     context->extra[1].y = (1 << 30);
; 288  : #else
; 289  :     context->extra[1].y = 65535;
; 290  : #endif
; 291  :     context->extra[1].next = NULL;
; 292  : }

  001df	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  001e4	66 44 89 73 2a	 mov	 WORD PTR [rbx+42], r14w
  001e9	66 44 89 7b 3a	 mov	 WORD PTR [rbx+58], r15w
  001ee	4c 89 73 40	 mov	 QWORD PTR [rbx+64], r14
  001f2	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001f7	66 44 89 31	 mov	 WORD PTR [rcx], r14w
  001fb	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001ff	41 5f		 pop	 r15
  00201	41 5e		 pop	 r14
  00203	5f		 pop	 rdi
  00204	c3		 ret	 0
stbrp_init_target ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
c$dead$ = 64
first$ = 72
x0$ = 80
width$ = 88
pwaste$ = 96
?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z PROC ; stbrp__skyline_find_min_y

; 296  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 297  :     stbrp_node* node = first;
; 298  :     int x1 = x0 + width;
; 299  :     int min_y, visited_width, waste_area;
; 300  : 
; 301  :     STBRP__NOTUSED(c);
; 302  : 
; 303  :     STBRP_ASSERT(first->x <= x0);

  00013	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00016	47 8d 34 08	 lea	 r14d, DWORD PTR [r8+r9]
  0001a	45 8b f9	 mov	 r15d, r9d
  0001d	41 8b f0	 mov	 esi, r8d
  00020	48 8b da	 mov	 rbx, rdx
  00023	41 3b c0	 cmp	 eax, r8d
  00026	7e 1a		 jle	 SHORT $LN2@stbrp__sky
  00028	41 b8 2f 01 00
	00		 mov	 r8d, 303		; 0000012fH
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@KBODBKOH@?$AAf?$AAi?$AAr?$AAs?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN2@stbrp__sky:

; 304  : 
; 305  : #if 0
; 306  :     // skip in case we're past the node
; 307  :     while (node->next->x <= x0)
; 308  :         ++node;
; 309  : #else
; 310  :     STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency

  00042	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00046	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00049	3b ce		 cmp	 ecx, esi
  0004b	7f 1a		 jg	 SHORT $LN5@stbrp__sky
  0004d	41 b8 36 01 00
	00		 mov	 r8d, 310		; 00000136H
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@BDIGDJGP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN5@stbrp__sky:

; 311  : #endif
; 312  : 
; 313  :     STBRP_ASSERT(node->x <= x0);

  00067	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  0006a	3b c6		 cmp	 eax, esi
  0006c	7e 1d		 jle	 SHORT $LN8@stbrp__sky
  0006e	41 b8 39 01 00
	00		 mov	 r8d, 313		; 00000139H
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@JHJLEEND@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA0@
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00088	0f b7 03	 movzx	 eax, WORD PTR [rbx]
$LN8@stbrp__sky:

; 314  : 
; 315  :     min_y = 0;

  0008b	45 33 db	 xor	 r11d, r11d

; 316  :     waste_area = 0;
; 317  :     visited_width = 0;
; 318  :     while (node->x < x1) {

  0008e	0f b7 c0	 movzx	 eax, ax
  00091	41 8b eb	 mov	 ebp, r11d
  00094	45 8b d3	 mov	 r10d, r11d
  00097	41 3b c6	 cmp	 eax, r14d
  0009a	0f 8d 8e 00 00
	00		 jge	 $LN26@stbrp__sky
  000a0	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
$LL11@stbrp__sky:

; 319  :         if (node->y > min_y) {

  000a5	0f b7 7b 02	 movzx	 edi, WORD PTR [rbx+2]
  000a9	41 3b fb	 cmp	 edi, r11d
  000ac	7e 36		 jle	 SHORT $LN13@stbrp__sky

; 320  :             // raise min_y higher.
; 321  :             // we've accounted for all waste up to min_y,
; 322  :             // but we'll now add more waste for everything we've visted
; 323  :             waste_area += visited_width * (node->y - min_y);
; 324  :             min_y = node->y;
; 325  :             // the first time through, visited_width might be reduced
; 326  :             if (node->x < x0)

  000ae	0f b7 13	 movzx	 edx, WORD PTR [rbx]
  000b1	44 8b c7	 mov	 r8d, edi
  000b4	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  000b8	45 2b c3	 sub	 r8d, r11d
  000bb	45 0f af c2	 imul	 r8d, r10d
  000bf	44 8b df	 mov	 r11d, edi
  000c2	3b d6		 cmp	 edx, esi
  000c4	7d 0e		 jge	 SHORT $LN15@stbrp__sky

; 327  :                 visited_width += node->next->x - x0;

  000c6	44 0f b7 0b	 movzx	 r9d, WORD PTR [rbx]
  000ca	41 8b c1	 mov	 eax, r9d
  000cd	2b c6		 sub	 eax, esi
  000cf	44 03 d0	 add	 r10d, eax
  000d2	eb 40		 jmp	 SHORT $LN14@stbrp__sky
$LN15@stbrp__sky:

; 328  :             else
; 329  :                 visited_width += node->next->x - node->x;

  000d4	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  000d7	8b c1		 mov	 eax, ecx
  000d9	44 0f b7 c9	 movzx	 r9d, cx
  000dd	2b c2		 sub	 eax, edx
  000df	44 03 d0	 add	 r10d, eax

; 330  :         }

  000e2	eb 30		 jmp	 SHORT $LN14@stbrp__sky
$LN13@stbrp__sky:

; 331  :         else {
; 332  :             // add waste area
; 333  :             int under_width = node->next->x - node->x;

  000e4	4c 8b 43 08	 mov	 r8, QWORD PTR [rbx+8]

; 334  :             if (under_width + visited_width > width)
; 335  :                 under_width = width - visited_width;
; 336  :             waste_area += under_width * (min_y - node->y);

  000e8	41 8b d7	 mov	 edx, r15d
  000eb	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000ee	41 2b d2	 sub	 edx, r10d

; 337  :             visited_width += under_width;

  000f1	49 8b d8	 mov	 rbx, r8
  000f4	45 0f b7 08	 movzx	 r9d, WORD PTR [r8]
  000f8	45 8b c3	 mov	 r8d, r11d
  000fb	41 8b c9	 mov	 ecx, r9d
  000fe	2b c8		 sub	 ecx, eax
  00100	42 8d 04 11	 lea	 eax, DWORD PTR [rcx+r10]
  00104	41 3b c7	 cmp	 eax, r15d
  00107	0f 4e d1	 cmovle	 edx, ecx
  0010a	44 2b c7	 sub	 r8d, edi
  0010d	44 03 d2	 add	 r10d, edx
  00110	44 0f af c2	 imul	 r8d, edx
$LN14@stbrp__sky:

; 338  :         }
; 339  :         node = node->next;

  00114	41 03 e8	 add	 ebp, r8d
  00117	41 0f b7 c9	 movzx	 ecx, r9w
  0011b	41 3b ce	 cmp	 ecx, r14d
  0011e	7c 85		 jl	 SHORT $LL11@stbrp__sky

; 340  :     }
; 341  : 
; 342  :     *pwaste = waste_area;

  00120	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pwaste$[rsp]

; 343  :     return min_y;

  00125	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0012a	89 29		 mov	 DWORD PTR [rcx], ebp
  0012c	eb 08		 jmp	 SHORT $LN27@stbrp__sky
$LN26@stbrp__sky:

; 340  :     }
; 341  : 
; 342  :     *pwaste = waste_area;

  0012e	48 8b 44 24 60	 mov	 rax, QWORD PTR pwaste$[rsp]
  00133	44 89 18	 mov	 DWORD PTR [rax], r11d
$LN27@stbrp__sky:

; 344  : }

  00136	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0013b	41 8b c3	 mov	 eax, r11d
  0013e	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00143	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00147	41 5f		 pop	 r15
  00149	41 5e		 pop	 r14
  0014b	5e		 pop	 rsi
  0014c	c3		 ret	 0
?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z ENDP ; stbrp__skyline_find_min_y
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
best$1$ = 48
tv510 = 56
prev$2$ = 64
$T1 = 160
c$ = 168
waste$2 = 176
waste$3 = 176
width$ = 176
height$ = 184
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z PROC ; stbrp__skyline_find_best_pos

; 353  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	55		 push	 rbp
  00011	56		 push	 rsi
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 354  :     int best_waste = (1 << 30), best_x, best_y = (1 << 30);
; 355  :     stbrp__findresult fr;
; 356  :     stbrp_node** prev, * node, * tail, ** best = NULL;
; 357  : 
; 358  :     // align to multiple of c->align
; 359  :     width = (width + c->align - 1);

  0001c	44 8b 52 08	 mov	 r10d, DWORD PTR [rdx+8]
  00020	45 8d 78 ff	 lea	 r15d, DWORD PTR [r8-1]
  00024	48 8b f2	 mov	 rsi, rdx
  00027	45 03 fa	 add	 r15d, r10d

; 360  :     width -= width % c->align;

  0002a	41 8b c7	 mov	 eax, r15d
  0002d	33 db		 xor	 ebx, ebx
  0002f	99		 cdq
  00030	48 89 5c 24 38	 mov	 QWORD PTR tv510[rsp], rbx
  00035	41 f7 fa	 idiv	 r10d
  00038	41 bd 00 00 00
	40		 mov	 r13d, 1073741824	; 40000000H
  0003e	48 89 5c 24 30	 mov	 QWORD PTR best$1$[rsp], rbx
  00043	44 2b fa	 sub	 r15d, edx
  00046	48 8b e9	 mov	 rbp, rcx

; 361  :     STBRP_ASSERT(width % c->align == 0);

  00049	41 8b c7	 mov	 eax, r15d
  0004c	45 8b f5	 mov	 r14d, r13d
  0004f	99		 cdq
  00050	41 f7 fa	 idiv	 r10d
  00053	85 d2		 test	 edx, edx
  00055	74 22		 je	 SHORT $LN2@stbrp__sky
  00057	41 b8 69 01 00
	00		 mov	 r8d, 361		; 00000169H
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@LEHAODMI@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$CF?$AA?5?$AAc?$AA?9?$AA?$DO?$AAa?$AAl?$AAi?$AAg@
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00071	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR height$[rsp]
$LN2@stbrp__sky:

; 362  : 
; 363  :     // if it can't possibly fit, bail immediately
; 364  :     if (width > c->width || height > c->height) {

  00079	8b 16		 mov	 edx, DWORD PTR [rsi]
  0007b	44 3b fa	 cmp	 r15d, edx
  0007e	0f 8f 2f 02 00
	00		 jg	 $LN23@stbrp__sky
  00084	44 3b 4e 04	 cmp	 r9d, DWORD PTR [rsi+4]
  00088	0f 8f 25 02 00
	00		 jg	 $LN23@stbrp__sky

; 366  :         fr.x = fr.y = 0;
; 367  :         return fr;
; 368  :     }
; 369  : 
; 370  :     node = c->active_head;

  0008e	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00093	48 8b 7e 18	 mov	 rdi, QWORD PTR [rsi+24]
  00097	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12
  0009c	4c 8d 66 18	 lea	 r12, QWORD PTR [rsi+24]
  000a0	4c 89 64 24 40	 mov	 QWORD PTR prev$2$[rsp], r12

; 371  :     prev = &c->active_head;

  000a5	49 8b dc	 mov	 rbx, r12

; 372  :     while (node->x + width <= c->width) {

  000a8	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  000ab	41 8d 04 0f	 lea	 eax, DWORD PTR [r15+rcx]
  000af	3b c2		 cmp	 eax, edx
  000b1	0f 8f a7 00 00
	00		 jg	 $LN55@stbrp__sky
  000b7	4c 8b 64 24 30	 mov	 r12, QWORD PTR best$1$[rsp]
  000bc	8b ac 24 b8 00
	00 00		 mov	 ebp, DWORD PTR height$[rsp]
  000c3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL5@stbrp__sky:

; 373  :         int y, waste;
; 374  :         y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);

  000d0	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR waste$3[rsp]
  000d8	44 0f b7 c1	 movzx	 r8d, cx
  000dc	45 8b cf	 mov	 r9d, r15d
  000df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e4	48 8b d7	 mov	 rdx, rdi
  000e7	e8 00 00 00 00	 call	 ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z ; stbrp__skyline_find_min_y

; 375  :         if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL

  000ec	8b 56 10	 mov	 edx, DWORD PTR [rsi+16]
  000ef	8b c8		 mov	 ecx, eax
  000f1	85 d2		 test	 edx, edx
  000f3	75 07		 jne	 SHORT $LN24@stbrp__sky

; 376  :            // bottom left
; 377  :             if (y < best_y) {

  000f5	41 3b c6	 cmp	 eax, r14d
  000f8	7d 25		 jge	 SHORT $LN28@stbrp__sky

; 378  :                 best_y = y;
; 379  :                 best = prev;
; 380  :             }
; 381  :         }

  000fa	eb 1d		 jmp	 SHORT $LN67@stbrp__sky
$LN24@stbrp__sky:

; 382  :         else {
; 383  :             // best-fit
; 384  :             if (y + height <= c->height) {

  000fc	03 c5		 add	 eax, ebp
  000fe	3b 46 04	 cmp	 eax, DWORD PTR [rsi+4]
  00101	7f 1c		 jg	 SHORT $LN28@stbrp__sky

; 385  :                 // can only use it if it first vertically
; 386  :                 if (y < best_y || (y == best_y && waste < best_waste)) {

  00103	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR waste$3[rsp]
  0010a	41 3b ce	 cmp	 ecx, r14d
  0010d	7c 07		 jl	 SHORT $LN29@stbrp__sky
  0010f	75 0e		 jne	 SHORT $LN28@stbrp__sky
  00111	41 3b c5	 cmp	 eax, r13d
  00114	7d 09		 jge	 SHORT $LN28@stbrp__sky
$LN29@stbrp__sky:

; 387  :                     best_y = y;
; 388  :                     best_waste = waste;

  00116	44 8b e8	 mov	 r13d, eax
$LN67@stbrp__sky:

; 389  :                     best = prev;
; 390  :                 }
; 391  :             }
; 392  :         }
; 393  :         prev = &node->next;

  00119	4c 8b e3	 mov	 r12, rbx
  0011c	44 8b f1	 mov	 r14d, ecx
$LN28@stbrp__sky:
  0011f	48 8d 5f 08	 lea	 rbx, QWORD PTR [rdi+8]

; 394  :         node = node->next;

  00123	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  00127	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  0012a	0f b7 c8	 movzx	 ecx, ax
  0012d	41 03 c7	 add	 eax, r15d
  00130	3b 06		 cmp	 eax, DWORD PTR [rsi]
  00132	7e 9c		 jle	 SHORT $LL5@stbrp__sky

; 395  :     }
; 396  : 
; 397  :     best_x = (best == NULL) ? 0 : (*best)->x;

  00134	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR $T1[rsp]
  0013c	4d 85 e4	 test	 r12, r12
  0013f	4c 89 64 24 30	 mov	 QWORD PTR best$1$[rsp], r12
  00144	4c 8b 64 24 40	 mov	 r12, QWORD PTR prev$2$[rsp]
  00149	74 16		 je	 SHORT $LN62@stbrp__sky
  0014b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR best$1$[rsp]
  00150	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00153	44 0f b7 00	 movzx	 r8d, WORD PTR [rax]
  00157	4c 89 44 24 38	 mov	 QWORD PTR tv510[rsp], r8
  0015c	eb 0b		 jmp	 SHORT $LN38@stbrp__sky
$LN55@stbrp__sky:
  0015e	8b 56 10	 mov	 edx, DWORD PTR [rsi+16]
$LN62@stbrp__sky:
  00161	48 8b 4c 24 30	 mov	 rcx, QWORD PTR best$1$[rsp]
  00166	45 33 c0	 xor	 r8d, r8d
$LN38@stbrp__sky:

; 398  : 
; 399  :     // if doing best-fit (BF), we also have to try aligning right edge to each node position
; 400  :     //
; 401  :     // e.g, if fitting
; 402  :     //
; 403  :     //     ____________________
; 404  :     //    |____________________|
; 405  :     //
; 406  :     //            into
; 407  :     //
; 408  :     //   |                         |
; 409  :     //   |             ____________|
; 410  :     //   |____________|
; 411  :     //
; 412  :     // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
; 413  :     //
; 414  :     // This makes BF take about 2x the time
; 415  : 
; 416  :     if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {

  00169	83 fa 01	 cmp	 edx, 1
  0016c	0f 85 1a 01 00
	00		 jne	 $LN10@stbrp__sky

; 417  :         tail = c->active_head;

  00172	49 8b 2c 24	 mov	 rbp, QWORD PTR [r12]

; 418  :         node = c->active_head;

  00176	48 8b f5	 mov	 rsi, rbp

; 419  :         prev = &c->active_head;
; 420  :         // find first node that's admissible
; 421  :         while (tail->x < width)

  00179	0f b7 45 00	 movzx	 eax, WORD PTR [rbp]
  0017d	41 3b c7	 cmp	 eax, r15d
  00180	7d 0d		 jge	 SHORT $LN60@stbrp__sky
$LL7@stbrp__sky:

; 422  :             tail = tail->next;

  00182	48 8b 6d 08	 mov	 rbp, QWORD PTR [rbp+8]
  00186	0f b7 45 00	 movzx	 eax, WORD PTR [rbp]
  0018a	41 3b c7	 cmp	 eax, r15d
  0018d	7c f3		 jl	 SHORT $LL7@stbrp__sky
$LN60@stbrp__sky:
  0018f	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
$LL9@stbrp__sky:

; 423  :         while (tail) {
; 424  :             int xpos = tail->x - width;

  00193	0f b7 5d 00	 movzx	 ebx, WORD PTR [rbp]
  00197	41 2b df	 sub	 ebx, r15d

; 425  :             int y, waste;
; 426  :             STBRP_ASSERT(xpos >= 0);

  0019a	79 1a		 jns	 SHORT $LN11@stbrp__sky
  0019c	41 b8 aa 01 00
	00		 mov	 r8d, 426		; 000001aaH
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@MNLKNDNL@?$AAx?$AAp?$AAo?$AAs?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN11@stbrp__sky:

; 427  :             // find the left position that matches this
; 428  :             while (node->next->x <= xpos) {

  001b6	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  001b9	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001bc	3b c3		 cmp	 eax, ebx
  001be	7f 15		 jg	 SHORT $LN18@stbrp__sky
$LL14@stbrp__sky:

; 429  :                 prev = &node->next;

  001c0	4c 8b e7	 mov	 r12, rdi

; 430  :                 node = node->next;

  001c3	48 8b f1	 mov	 rsi, rcx
  001c6	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  001ca	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001ce	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001d1	3b c3		 cmp	 eax, ebx
  001d3	7e eb		 jle	 SHORT $LL14@stbrp__sky
$LN18@stbrp__sky:

; 431  :             }
; 432  :             STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);

  001d5	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  001d9	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
  001dd	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  001e0	3b cb		 cmp	 ecx, ebx
  001e2	7e 07		 jle	 SHORT $LN40@stbrp__sky
  001e4	0f b7 06	 movzx	 eax, WORD PTR [rsi]
  001e7	3b c3		 cmp	 eax, ebx
  001e9	7e 1a		 jle	 SHORT $LN16@stbrp__sky
$LN40@stbrp__sky:
  001eb	41 b8 b0 01 00
	00		 mov	 r8d, 432		; 000001b0H
  001f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@OJNPDLDG@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@GPDJEJHP@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AA?9?$AA?$DO?$AAx?$AA?5?$AA?$DO@
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN16@stbrp__sky:

; 433  :             y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);

  00205	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR waste$2[rsp]
  0020d	45 8b cf	 mov	 r9d, r15d
  00210	44 8b c3	 mov	 r8d, ebx
  00213	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00218	48 8b d6	 mov	 rdx, rsi
  0021b	e8 00 00 00 00	 call	 ?stbrp__skyline_find_min_y@@YAHPEAUstbrp_context@@PEAUstbrp_node@@HHPEAH@Z ; stbrp__skyline_find_min_y

; 434  :             if (y + height <= c->height) {

  00220	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00228	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR height$[rsp]
  0022f	03 c8		 add	 ecx, eax
  00231	3b 4a 04	 cmp	 ecx, DWORD PTR [rdx+4]
  00234	7f 37		 jg	 SHORT $LN64@stbrp__sky

; 435  :                 if (y <= best_y) {

  00236	41 3b c6	 cmp	 eax, r14d
  00239	7f 32		 jg	 SHORT $LN64@stbrp__sky

; 436  :                     if (y < best_y || waste < best_waste || (waste == best_waste && xpos < best_x)) {

  0023b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR waste$2[rsp]
  00242	7c 11		 jl	 SHORT $LN34@stbrp__sky
  00244	41 3b cd	 cmp	 ecx, r13d
  00247	7c 0c		 jl	 SHORT $LN34@stbrp__sky
  00249	4c 8b 44 24 38	 mov	 r8, QWORD PTR tv510[rsp]
  0024e	75 22		 jne	 SHORT $LN66@stbrp__sky
  00250	41 3b d8	 cmp	 ebx, r8d
  00253	7d 1d		 jge	 SHORT $LN66@stbrp__sky
$LN34@stbrp__sky:

; 437  :                         best_x = xpos;
; 438  :                         STBRP_ASSERT(y <= best_y);
; 439  :                         best_y = y;
; 440  :                         best_waste = waste;

  00255	44 8b e9	 mov	 r13d, ecx
  00258	44 8b c3	 mov	 r8d, ebx

; 441  :                         best = prev;

  0025b	49 8b cc	 mov	 rcx, r12
  0025e	4c 89 44 24 38	 mov	 QWORD PTR tv510[rsp], r8
  00263	48 89 4c 24 30	 mov	 QWORD PTR best$1$[rsp], rcx
  00268	44 8b f0	 mov	 r14d, eax
  0026b	eb 0a		 jmp	 SHORT $LN33@stbrp__sky
$LN64@stbrp__sky:

; 442  :                     }
; 443  :                 }
; 444  :             }
; 445  :             tail = tail->next;

  0026d	4c 8b 44 24 38	 mov	 r8, QWORD PTR tv510[rsp]
$LN66@stbrp__sky:
  00272	48 8b 4c 24 30	 mov	 rcx, QWORD PTR best$1$[rsp]
$LN33@stbrp__sky:
  00277	48 8b 6d 08	 mov	 rbp, QWORD PTR [rbp+8]
  0027b	48 85 ed	 test	 rbp, rbp
  0027e	0f 85 0f ff ff
	ff		 jne	 $LL9@stbrp__sky
  00284	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR $T1[rsp]
$LN10@stbrp__sky:

; 446  :         }
; 447  :     }
; 448  : 
; 449  :     fr.prev_link = best;
; 450  :     fr.x = best_x;
; 451  :     fr.y = best_y;
; 452  :     return fr;

  0028c	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]

; 453  : }

  00291	48 8b c5	 mov	 rax, rbp
  00294	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00299	48 89 4d 08	 mov	 QWORD PTR [rbp+8], rcx
  0029d	44 89 45 00	 mov	 DWORD PTR [rbp], r8d
  002a1	44 89 75 04	 mov	 DWORD PTR [rbp+4], r14d
  002a5	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002a9	41 5f		 pop	 r15
  002ab	41 5e		 pop	 r14
  002ad	41 5d		 pop	 r13
  002af	5e		 pop	 rsi
  002b0	5d		 pop	 rbp
  002b1	5b		 pop	 rbx
  002b2	c3		 ret	 0
$LN23@stbrp__sky:

; 365  :         fr.prev_link = NULL;

  002b3	48 89 5d 08	 mov	 QWORD PTR [rbp+8], rbx

; 453  : }

  002b7	48 8b c5	 mov	 rax, rbp
  002ba	48 89 5d 00	 mov	 QWORD PTR [rbp], rbx
  002be	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002c2	41 5f		 pop	 r15
  002c4	41 5e		 pop	 r14
  002c6	41 5d		 pop	 r13
  002c8	5e		 pop	 rsi
  002c9	5d		 pop	 rbp
  002ca	5b		 pop	 rbx
  002cb	c3		 ret	 0
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_find_best_pos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
context$ = 72
width$ = 80
height$ = 88
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z PROC ; stbrp__skyline_pack_rectangle

; 456  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f9	 mov	 rdi, rcx
  00017	41 8b e9	 mov	 ebp, r9d

; 457  :     // find best position according to heuristic
; 458  :     stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);

  0001a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  0001f	41 8b f0	 mov	 esi, r8d
  00022	48 8b da	 mov	 rbx, rdx
  00025	e8 00 00 00 00	 call	 ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ; stbrp__skyline_find_best_pos
  0002a	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0002d	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0

; 459  :     stbrp_node* node, * cur;
; 460  : 
; 461  :     // bail if:
; 462  :     //    1. it failed
; 463  :     //    2. the best node doesn't fit (we don't always check this)
; 464  :     //    3. we're out of memory
; 465  :     if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {

  00030	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00034	48 85 d2	 test	 rdx, rdx
  00037	0f 84 93 00 00
	00		 je	 $LN5@stbrp__sky
  0003d	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  00040	8d 04 29	 lea	 eax, DWORD PTR [rcx+rbp]
  00043	3b 43 04	 cmp	 eax, DWORD PTR [rbx+4]
  00046	0f 8f 84 00 00
	00		 jg	 $LN5@stbrp__sky
  0004c	4c 8b 4b 20	 mov	 r9, QWORD PTR [rbx+32]
  00050	4d 85 c9	 test	 r9, r9
  00053	74 7b		 je	 SHORT $LN5@stbrp__sky

; 467  :         return res;
; 468  :     }
; 469  : 
; 470  :     // on success, create new node
; 471  :     node = context->free_head;
; 472  :     node->x = (stbrp_coord)res.x;

  00055	0f b7 07	 movzx	 eax, WORD PTR [rdi]

; 473  :     node->y = (stbrp_coord)(res.y + height);

  00058	66 03 cd	 add	 cx, bp

; 474  : 
; 475  :     context->free_head = node->next;
; 476  : 
; 477  :     // insert the new node into the right starting point, and
; 478  :     // let 'cur' point to the remaining nodes needing to be
; 479  :     // stiched back in
; 480  : 
; 481  :     cur = *res.prev_link;
; 482  :     if (cur->x < res.x) {

  0005b	44 8b 07	 mov	 r8d, DWORD PTR [rdi]
  0005e	66 41 89 01	 mov	 WORD PTR [r9], ax
  00062	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  00066	66 41 89 49 02	 mov	 WORD PTR [r9+2], cx
  0006b	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0006f	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00072	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00075	41 3b c8	 cmp	 ecx, r8d
  00078	7d 0d		 jge	 SHORT $LN6@stbrp__sky

; 483  :         // preserve the existing one, so start testing with the next one
; 484  :         stbrp_node* next = cur->next;

  0007a	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  0007e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 485  :         cur->next = node;

  00082	4c 89 09	 mov	 QWORD PTR [rcx], r9

; 486  :         cur = next;
; 487  :     }

  00085	eb 03		 jmp	 SHORT $LN10@stbrp__sky
$LN6@stbrp__sky:

; 488  :     else {
; 489  :         *res.prev_link = node;

  00087	4c 89 0a	 mov	 QWORD PTR [rdx], r9
$LN10@stbrp__sky:

; 490  :     }
; 491  : 
; 492  :     // from here, traverse cur and free the nodes, until we get to one
; 493  :     // that shouldn't be freed
; 494  :     while (cur->next && cur->next->x <= res.x + width) {

  0008a	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0008e	48 85 d2	 test	 rdx, rdx
  00091	74 24		 je	 SHORT $LN14@stbrp__sky
  00093	45 8d 14 30	 lea	 r10d, DWORD PTR [r8+rsi]
$LL2@stbrp__sky:
  00097	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  0009a	41 3b ca	 cmp	 ecx, r10d
  0009d	7f 18		 jg	 SHORT $LN14@stbrp__sky

; 495  :         stbrp_node* next = cur->next;
; 496  :         // move the current node to the free list
; 497  :         cur->next = context->free_head;

  0009f	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000a3	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 498  :         context->free_head = cur;

  000a7	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 499  :         cur = next;

  000ab	48 8b c2	 mov	 rax, rdx
  000ae	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000b2	48 85 d2	 test	 rdx, rdx
  000b5	75 e0		 jne	 SHORT $LL2@stbrp__sky
$LN14@stbrp__sky:

; 500  :     }
; 501  : 
; 502  :     // stitch the list back in
; 503  :     node->next = cur;

  000b7	49 89 41 08	 mov	 QWORD PTR [r9+8], rax

; 504  : 
; 505  :     if (cur->x < res.x + width)

  000bb	41 8d 14 30	 lea	 edx, DWORD PTR [r8+rsi]
  000bf	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000c2	3b ca		 cmp	 ecx, edx
  000c4	7d 12		 jge	 SHORT $LN8@stbrp__sky

; 506  :         cur->x = (stbrp_coord)(res.x + width);

  000c6	66 44 03 c6	 add	 r8w, si
  000ca	66 44 89 00	 mov	 WORD PTR [rax], r8w

; 507  : 
; 508  : #ifdef _DEBUG
; 509  :     cur = context->active_head;
; 510  :     while (cur->x < context->width) {
; 511  :         STBRP_ASSERT(cur->x < cur->next->x);
; 512  :         cur = cur->next;
; 513  :     }
; 514  :     STBRP_ASSERT(cur->next == NULL);
; 515  : 
; 516  :     {
; 517  :         int count = 0;
; 518  :         cur = context->active_head;
; 519  :         while (cur) {
; 520  :             cur = cur->next;
; 521  :             ++count;
; 522  :         }
; 523  :         cur = context->free_head;
; 524  :         while (cur) {
; 525  :             cur = cur->next;
; 526  :             ++count;
; 527  :         }
; 528  :         STBRP_ASSERT(count == context->num_nodes + 2);
; 529  :     }
; 530  : #endif
; 531  : 
; 532  :     return res;

  000ce	eb 08		 jmp	 SHORT $LN8@stbrp__sky
$LN5@stbrp__sky:

; 466  :         res.prev_link = NULL;

  000d0	48 c7 47 08 00
	00 00 00	 mov	 QWORD PTR [rdi+8], 0
$LN8@stbrp__sky:

; 533  : }

  000d8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000dd	48 8b c7	 mov	 rax, rdi
  000e0	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000e5	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ea	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_pack_rectangle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
?rect_height_compare@@YAHPEBX0@Z PROC			; rect_height_compare

; 538  :     const stbrp_rect* p = (const stbrp_rect*)a;
; 539  :     const stbrp_rect* q = (const stbrp_rect*)b;
; 540  :     if (p->h > q->h)

  00000	0f b7 41 06	 movzx	 eax, WORD PTR [rcx+6]
  00004	66 3b 42 06	 cmp	 ax, WORD PTR [rdx+6]
  00008	77 15		 ja	 SHORT $LN7@rect_heigh

; 541  :         return -1;
; 542  :     if (p->h < q->h)

  0000a	73 06		 jae	 SHORT $LN3@rect_heigh

; 543  :         return  1;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 545  : }

  00011	c3		 ret	 0
$LN3@rect_heigh:

; 544  :     return (p->w > q->w) ? -1 : (p->w < q->w);

  00012	0f b7 49 04	 movzx	 ecx, WORD PTR [rcx+4]
  00016	0f b7 52 04	 movzx	 edx, WORD PTR [rdx+4]
  0001a	66 3b ca	 cmp	 cx, dx
  0001d	76 06		 jbe	 SHORT $LN5@rect_heigh
$LN7@rect_heigh:

; 545  : }

  0001f	b8 ff ff ff ff	 mov	 eax, -1
  00024	c3		 ret	 0
$LN5@rect_heigh:

; 544  :     return (p->w > q->w) ? -1 : (p->w < q->w);

  00025	33 c0		 xor	 eax, eax
  00027	66 3b ca	 cmp	 cx, dx
  0002a	0f 92 c0	 setb	 al

; 545  : }

  0002d	c3		 ret	 0
?rect_height_compare@@YAHPEBX0@Z ENDP			; rect_height_compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
a$ = 8
b$ = 16
?rect_original_order@@YAHPEBX0@Z PROC			; rect_original_order

; 550  :     const stbrp_rect* p = (const stbrp_rect*)a;
; 551  :     const stbrp_rect* q = (const stbrp_rect*)b;
; 552  :     return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);

  00000	44 8b 41 0c	 mov	 r8d, DWORD PTR [rcx+12]
  00004	8b 4a 0c	 mov	 ecx, DWORD PTR [rdx+12]
  00007	44 3b c1	 cmp	 r8d, ecx
  0000a	7d 06		 jge	 SHORT $LN3@rect_origi
  0000c	b8 ff ff ff ff	 mov	 eax, -1

; 553  : }

  00011	c3		 ret	 0
$LN3@rect_origi:

; 550  :     const stbrp_rect* p = (const stbrp_rect*)a;
; 551  :     const stbrp_rect* q = (const stbrp_rect*)b;
; 552  :     return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);

  00012	33 c0		 xor	 eax, eax
  00014	44 3b c1	 cmp	 r8d, ecx
  00017	0f 9f c0	 setg	 al

; 553  : }

  0001a	c3		 ret	 0
?rect_original_order@@YAHPEBX0@Z ENDP			; rect_original_order
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
context$ = 128
rects$ = 136
num_rects$ = 144
tv946 = 152
stbrp_pack_rects PROC

; 562  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 563  :     int i, all_rects_packed = 1;

  00011	45 33 f6	 xor	 r14d, r14d
  00014	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00019	48 8b da	 mov	 rbx, rdx
  0001c	48 8b f9	 mov	 rdi, rcx
  0001f	41 bc 01 00 00
	00		 mov	 r12d, 1
  00025	41 8b c6	 mov	 eax, r14d

; 564  : 
; 565  :     // we use the 'was_packed' field internally to allow sorting/unsorting
; 566  :     for (i = 0; i < num_rects; ++i) {

  00028	45 85 c0	 test	 r8d, r8d
  0002b	7e 12		 jle	 SHORT $LN3@stbrp_pack
  0002d	4c 8d 4a 0c	 lea	 r9, QWORD PTR [rdx+12]
$LL4@stbrp_pack:

; 567  :         rects[i].was_packed = i;

  00031	41 89 01	 mov	 DWORD PTR [r9], eax
  00034	4d 8d 49 10	 lea	 r9, QWORD PTR [r9+16]
  00038	ff c0		 inc	 eax
  0003a	41 3b c0	 cmp	 eax, r8d
  0003d	7c f2		 jl	 SHORT $LL4@stbrp_pack
$LN3@stbrp_pack:

; 568  :     }
; 569  : 
; 570  :     // sort according to heuristic
; 571  :     STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

  0003f	4d 63 f8	 movsxd	 r15, r8d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 305  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL* compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

  00042	4d 3b fc	 cmp	 r15, r12
  00045	76 19		 jbe	 SHORT $LN21@stbrp_pack
  00047	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?rect_height_compare@@YAHPEBX0@Z ; rect_height_compare
  0004e	41 b8 10 00 00
	00		 mov	 r8d, 16
  00054	49 8b d7	 mov	 rdx, r15
  00057	48 8b cb	 mov	 rcx, rbx
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort
$LN21@stbrp_pack:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h

; 573  :     for (i = 0; i < num_rects; ++i) {

  00060	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  00065	4d 85 ff	 test	 r15, r15
  00068	0f 8e 62 01 00
	00		 jle	 $LN6@stbrp_pack
  0006e	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp
  00076	48 83 c3 0a	 add	 rbx, 10
  0007a	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  0007f	4c 89 bc 24 98
	00 00 00	 mov	 QWORD PTR tv946[rsp], r15
  00087	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@stbrp_pack:

; 574  :         if (rects[i].w == 0 || rects[i].h == 0) {

  00090	0f b7 6b fa	 movzx	 ebp, WORD PTR [rbx-6]
  00094	66 85 ed	 test	 bp, bp
  00097	0f 84 ff 00 00
	00		 je	 $LN13@stbrp_pack
  0009d	0f b7 73 fc	 movzx	 esi, WORD PTR [rbx-4]
  000a1	66 85 f6	 test	 si, si
  000a4	0f 84 ed 00 00
	00		 je	 $LN58@stbrp_pack

; 458  :     stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);

  000aa	44 8b ce	 mov	 r9d, esi
  000ad	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  000b2	44 8b c5	 mov	 r8d, ebp
  000b5	48 8b d7	 mov	 rdx, rdi
  000b8	e8 00 00 00 00	 call	 ?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PEAUstbrp_context@@HH@Z ; stbrp__skyline_find_best_pos
  000bd	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000c0	0f 11 44 24 20	 movups	 XMMWORD PTR $T1[rsp], xmm0

; 459  :     stbrp_node* node, * cur;
; 460  : 
; 461  :     // bail if:
; 462  :     //    1. it failed
; 463  :     //    2. the best node doesn't fit (we don't always check this)
; 464  :     //    3. we're out of memory
; 465  :     if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {

  000c5	66 0f 73 d8 08	 psrldq	 xmm0, 8
  000ca	66 48 0f 7e c2	 movq	 rdx, xmm0
  000cf	48 85 d2	 test	 rdx, rdx
  000d2	0f 84 ad 00 00
	00		 je	 $LN27@stbrp_pack
  000d8	4c 8b 4c 24 20	 mov	 r9, QWORD PTR $T1[rsp]
  000dd	4d 8b c1	 mov	 r8, r9
  000e0	49 c1 e8 20	 shr	 r8, 32			; 00000020H
  000e4	41 8d 04 30	 lea	 eax, DWORD PTR [r8+rsi]
  000e8	3b 47 04	 cmp	 eax, DWORD PTR [rdi+4]
  000eb	0f 8f 94 00 00
	00		 jg	 $LN27@stbrp_pack
  000f1	4c 8b 57 20	 mov	 r10, QWORD PTR [rdi+32]
  000f5	4d 85 d2	 test	 r10, r10
  000f8	0f 84 87 00 00
	00		 je	 $LN27@stbrp_pack

; 466  :         res.prev_link = NULL;
; 467  :         return res;
; 468  :     }
; 469  : 
; 470  :     // on success, create new node
; 471  :     node = context->free_head;
; 472  :     node->x = (stbrp_coord)res.x;

  000fe	66 45 89 0a	 mov	 WORD PTR [r10], r9w

; 473  :     node->y = (stbrp_coord)(res.y + height);

  00102	42 8d 04 06	 lea	 eax, DWORD PTR [rsi+r8]
  00106	66 41 89 42 02	 mov	 WORD PTR [r10+2], ax

; 474  : 
; 475  :     context->free_head = node->next;

  0010b	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  0010f	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 476  : 
; 477  :     // insert the new node into the right starting point, and
; 478  :     // let 'cur' point to the remaining nodes needing to be
; 479  :     // stiched back in
; 480  : 
; 481  :     cur = *res.prev_link;

  00113	48 8b 02	 mov	 rax, QWORD PTR [rdx]

; 482  :     if (cur->x < res.x) {

  00116	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00119	41 3b c9	 cmp	 ecx, r9d
  0011c	7d 0d		 jge	 SHORT $LN28@stbrp_pack

; 483  :         // preserve the existing one, so start testing with the next one
; 484  :         stbrp_node* next = cur->next;

  0011e	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00122	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 485  :         cur->next = node;

  00126	4c 89 11	 mov	 QWORD PTR [rcx], r10

; 486  :         cur = next;
; 487  :     }

  00129	eb 03		 jmp	 SHORT $LN37@stbrp_pack
$LN28@stbrp_pack:

; 488  :     else {
; 489  :         *res.prev_link = node;

  0012b	4c 89 12	 mov	 QWORD PTR [rdx], r10
$LN37@stbrp_pack:

; 490  :     }
; 491  : 
; 492  :     // from here, traverse cur and free the nodes, until we get to one
; 493  :     // that shouldn't be freed
; 494  :     while (cur->next && cur->next->x <= res.x + width) {

  0012e	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00132	48 85 d2	 test	 rdx, rdx
  00135	74 29		 je	 SHORT $LN57@stbrp_pack
  00137	45 8d 1c 29	 lea	 r11d, DWORD PTR [r9+rbp]
  0013b	0f 1f 44 00 00	 npad	 5
$LL24@stbrp_pack:
  00140	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  00143	41 3b cb	 cmp	 ecx, r11d
  00146	7f 18		 jg	 SHORT $LN57@stbrp_pack

; 495  :         stbrp_node* next = cur->next;
; 496  :         // move the current node to the free list
; 497  :         cur->next = context->free_head;

  00148	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  0014c	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 498  :         context->free_head = cur;

  00150	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 499  :         cur = next;

  00154	48 8b c2	 mov	 rax, rdx
  00157	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0015b	48 85 d2	 test	 rdx, rdx
  0015e	75 e0		 jne	 SHORT $LL24@stbrp_pack
$LN57@stbrp_pack:

; 500  :     }
; 501  : 
; 502  :     // stitch the list back in
; 503  :     node->next = cur;

  00160	49 89 42 08	 mov	 QWORD PTR [r10+8], rax

; 504  : 
; 505  :     if (cur->x < res.x + width)

  00164	41 8d 14 29	 lea	 edx, DWORD PTR [r9+rbp]
  00168	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  0016b	3b ca		 cmp	 ecx, edx
  0016d	7d 07		 jge	 SHORT $LN23@stbrp_pack

; 506  :         cur->x = (stbrp_coord)(res.x + width);

  0016f	66 41 03 e9	 add	 bp, r9w
  00173	66 89 28	 mov	 WORD PTR [rax], bp
$LN23@stbrp_pack:

; 576  :         }
; 577  :         else {
; 578  :             stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
; 579  :             if (fr.prev_link) {
; 580  :                 rects[i].x = (stbrp_coord)fr.x;

  00176	66 44 89 4b fe	 mov	 WORD PTR [rbx-2], r9w

; 581  :                 rects[i].y = (stbrp_coord)fr.y;
; 582  :             }

  0017b	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  00180	45 33 f6	 xor	 r14d, r14d
  00183	eb 20		 jmp	 SHORT $LN5@stbrp_pack
$LN27@stbrp_pack:

; 583  :             else {
; 584  :                 rects[i].x = rects[i].y = STBRP__MAXVAL;

  00185	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  0018a	45 33 f6	 xor	 r14d, r14d
  0018d	66 89 73 fe	 mov	 WORD PTR [rbx-2], si
  00191	44 0f b7 c6	 movzx	 r8d, si
  00195	eb 0e		 jmp	 SHORT $LN5@stbrp_pack
$LN58@stbrp_pack:

; 574  :         if (rects[i].w == 0 || rects[i].h == 0) {

  00197	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
$LN13@stbrp_pack:

; 575  :             rects[i].x = rects[i].y = 0;  // empty rect needs no space

  0019c	66 44 89 73 fe	 mov	 WORD PTR [rbx-2], r14w
  001a1	45 0f b7 c6	 movzx	 r8d, r14w
$LN5@stbrp_pack:

; 573  :     for (i = 0; i < num_rects; ++i) {

  001a5	66 44 89 03	 mov	 WORD PTR [rbx], r8w
  001a9	48 83 c3 10	 add	 rbx, 16
  001ad	4c 29 a4 24 98
	00 00 00	 sub	 QWORD PTR tv946[rsp], r12
  001b5	0f 85 d5 fe ff
	ff		 jne	 $LL7@stbrp_pack
  001bb	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR rects$[rsp]
  001c3	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
  001c8	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
$LN6@stbrp_pack:
  001d0	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 305  : static inline void      ImQsort(void* base, size_t count, size_t size_of_element, int(IMGUI_CDECL* compare_func)(void const*, void const*)) { if (count > 1) qsort(base, count, size_of_element, compare_func); }

  001d5	4d 3b fc	 cmp	 r15, r12
  001d8	76 19		 jbe	 SHORT $LN33@stbrp_pack
  001da	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?rect_original_order@@YAHPEBX0@Z ; rect_original_order
  001e1	41 b8 10 00 00
	00		 mov	 r8d, 16
  001e7	49 8b d7	 mov	 rdx, r15
  001ea	48 8b cb	 mov	 rcx, rbx
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort
$LN33@stbrp_pack:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_rectpack.h

; 593  :     for (i = 0; i < num_rects; ++i) {

  001f3	4d 85 ff	 test	 r15, r15
  001f6	7e 34		 jle	 SHORT $LN56@stbrp_pack
  001f8	48 8d 43 0a	 lea	 rax, QWORD PTR [rbx+10]
  001fc	0f 1f 40 00	 npad	 4
$LL43@stbrp_pack:

; 594  :         rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);

  00200	66 39 70 fe	 cmp	 WORD PTR [rax-2], si
  00204	75 08		 jne	 SHORT $LN44@stbrp_pack
  00206	41 8b d6	 mov	 edx, r14d
  00209	66 39 30	 cmp	 WORD PTR [rax], si
  0020c	74 05		 je	 SHORT $LN45@stbrp_pack
$LN44@stbrp_pack:
  0020e	ba 01 00 00 00	 mov	 edx, 1
$LN45@stbrp_pack:

; 593  :     for (i = 0; i < num_rects; ++i) {

  00213	85 d2		 test	 edx, edx

; 594  :         rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);

  00215	89 50 02	 mov	 DWORD PTR [rax+2], edx
  00218	41 8b ce	 mov	 ecx, r14d
  0021b	41 0f 45 cc	 cmovne	 ecx, r12d
  0021f	48 83 c0 10	 add	 rax, 16
  00223	44 8b e1	 mov	 r12d, ecx
  00226	49 83 ef 01	 sub	 r15, 1
  0022a	75 d4		 jne	 SHORT $LL43@stbrp_pack
$LN56@stbrp_pack:

; 595  :         if (!rects[i].was_packed)
; 596  :             all_rects_packed = 0;
; 597  :     }
; 598  : 
; 599  :     // return the all_rects_packed status
; 600  :     return all_rects_packed;
; 601  : }

  0022c	41 8b c4	 mov	 eax, r12d
  0022f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00233	41 5f		 pop	 r15
  00235	41 5e		 pop	 r14
  00237	41 5c		 pop	 r12
  00239	5e		 pop	 rsi
  0023a	5b		 pop	 rbx
  0023b	c3		 ret	 0
stbrp_pack_rects ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 8
?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z PROC		; stbtt__buf_get8

; 1118 :     if (b->cursor >= b->size)

  00000	4c 63 41 08	 movsxd	 r8, DWORD PTR [rcx+8]
  00004	48 8b d1	 mov	 rdx, rcx
  00007	44 3b 41 0c	 cmp	 r8d, DWORD PTR [rcx+12]
  0000b	7c 03		 jl	 SHORT $LN2@stbtt__buf

; 1119 :         return 0;

  0000d	32 c0		 xor	 al, al

; 1121 : }

  0000f	c3		 ret	 0
$LN2@stbtt__buf:

; 1120 :     return b->data[b->cursor++];

  00010	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00013	41 8d 48 01	 lea	 ecx, DWORD PTR [r8+1]
  00017	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0001c	89 4a 08	 mov	 DWORD PTR [rdx+8], ecx

; 1121 : }

  0001f	c3		 ret	 0
?stbtt__buf_get8@@YAEPEAUstbtt__buf@@@Z ENDP		; stbtt__buf_get8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 8
?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z PROC		; stbtt__buf_peek8

; 1124 : {

  00000	48 8b c1	 mov	 rax, rcx

; 1125 :     if (b->cursor >= b->size)

  00003	48 63 49 08	 movsxd	 rcx, DWORD PTR [rcx+8]
  00007	3b 48 0c	 cmp	 ecx, DWORD PTR [rax+12]
  0000a	7c 03		 jl	 SHORT $LN2@stbtt__buf

; 1126 :         return 0;

  0000c	32 c0		 xor	 al, al

; 1128 : }

  0000e	c3		 ret	 0
$LN2@stbtt__buf:

; 1127 :     return b->data[b->cursor];

  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]

; 1128 : }

  00016	c3		 ret	 0
?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ENDP		; stbtt__buf_peek8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 48
o$ = 56
?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_seek

; 1131 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  0000a	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]
  0000d	8b da		 mov	 ebx, edx
  0000f	48 8b f9	 mov	 rdi, rcx
  00012	3b d0		 cmp	 edx, eax
  00014	7f 04		 jg	 SHORT $LN6@stbtt__buf
  00016	85 d2		 test	 edx, edx
  00018	79 25		 jns	 SHORT $LN12@stbtt__buf
$LN6@stbtt__buf:
  0001a	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00034	8b 47 0c	 mov	 eax, DWORD PTR [rdi+12]

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  00037	3b d8		 cmp	 ebx, eax
  00039	7f 12		 jg	 SHORT $LN8@stbtt__buf
  0003b	85 db		 test	 ebx, ebx
  0003d	78 0e		 js	 SHORT $LN8@stbtt__buf
$LN12@stbtt__buf:
  0003f	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx

; 1134 : }

  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN8@stbtt__buf:
  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	89 47 08	 mov	 DWORD PTR [rdi+8], eax
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
?stbtt__buf_seek@@YAXPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_seek
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 48
o$ = 56
?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_skip

; 1137 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1138 :     stbtt__buf_seek(b, b->cursor + o);

  0000a	8b 59 08	 mov	 ebx, DWORD PTR [rcx+8]
  0000d	48 8b f9	 mov	 rdi, rcx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00010	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]

; 1138 :     stbtt__buf_seek(b, b->cursor + o);

  00013	03 da		 add	 ebx, edx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00015	3b d8		 cmp	 ebx, eax
  00017	7f 04		 jg	 SHORT $LN8@stbtt__buf
  00019	85 db		 test	 ebx, ebx
  0001b	79 25		 jns	 SHORT $LN14@stbtt__buf
$LN8@stbtt__buf:
  0001d	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	8b 47 0c	 mov	 eax, DWORD PTR [rdi+12]

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0003a	3b d8		 cmp	 ebx, eax
  0003c	7f 12		 jg	 SHORT $LN10@stbtt__buf
  0003e	85 db		 test	 ebx, ebx
  00040	78 0e		 js	 SHORT $LN10@stbtt__buf
$LN14@stbtt__buf:
  00042	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx

; 1139 : }

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN10@stbtt__buf:
  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  00055	89 47 08	 mov	 DWORD PTR [rdi+8], eax

; 1139 : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
?stbtt__buf_skip@@YAXPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_skip
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 48
n$ = 56
?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z PROC		; stbtt__buf_get

; 1142 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b f2		 mov	 esi, edx

; 1143 :     stbtt_uint32 v = 0;

  00011	33 db		 xor	 ebx, ebx
  00013	48 8b f9	 mov	 rdi, rcx

; 1144 :     int i;
; 1145 :     STBTT_assert(n >= 1 && n <= 4);

  00016	44 8d 46 ff	 lea	 r8d, DWORD PTR [rsi-1]
  0001a	41 83 f8 03	 cmp	 r8d, 3
  0001e	76 1e		 jbe	 SHORT $LN18@stbtt__buf
  00020	41 b8 79 04 00
	00		 mov	 r8d, 1145		; 00000479H
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@OMFGMKMB@?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5@
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1146 :     for (i = 0; i < n; i++)

  0003a	85 f6		 test	 esi, esi
  0003c	7e 30		 jle	 SHORT $LN21@stbtt__buf
$LN18@stbtt__buf:

; 1118 :     if (b->cursor >= b->size)

  0003e	44 8b 47 0c	 mov	 r8d, DWORD PTR [rdi+12]
  00042	4c 8b ce	 mov	 r9, rsi
  00045	8b 47 08	 mov	 eax, DWORD PTR [rdi+8]
$LL7@stbtt__buf:
  00048	41 3b c0	 cmp	 eax, r8d
  0004b	7c 04		 jl	 SHORT $LN12@stbtt__buf

; 1119 :         return 0;

  0004d	32 c9		 xor	 cl, cl
  0004f	eb 0f		 jmp	 SHORT $LN11@stbtt__buf
$LN12@stbtt__buf:

; 1120 :     return b->data[b->cursor++];

  00051	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00054	48 63 d0	 movsxd	 rdx, eax
  00057	ff c0		 inc	 eax
  00059	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0005d	89 47 08	 mov	 DWORD PTR [rdi+8], eax
$LN11@stbtt__buf:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00060	c1 e3 08	 shl	 ebx, 8
  00063	0f b6 c9	 movzx	 ecx, cl
  00066	0b d9		 or	 ebx, ecx
  00068	49 83 e9 01	 sub	 r9, 1
  0006c	75 da		 jne	 SHORT $LL7@stbtt__buf
$LN21@stbtt__buf:

; 1148 :     return v;
; 1149 : }

  0006e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00073	8b c3		 mov	 eax, ebx
  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ENDP		; stbtt__buf_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
$T1 = 48
p$ = 56
size$ = 64
?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z PROC		; stbtt__new_buf

; 1152 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 1153 :     stbtt__buf r;
; 1154 :     STBTT_assert(size < 0x40000000);

  00018	49 81 f8 00 00
	00 40		 cmp	 r8, 1073741824		; 40000000H
  0001f	72 1a		 jb	 SHORT $LN2@stbtt__new
  00021	41 b8 82 04 00
	00		 mov	 r8d, 1154		; 00000482H
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@EPOLDKHI@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0?$AAx?$AA4?$AA0?$AA0?$AA0?$AA0?$AA0@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN2@stbtt__new:

; 1155 :     r.data = (stbtt_uint8*)p;

  0003b	48 89 33	 mov	 QWORD PTR [rbx], rsi

; 1156 :     r.size = (int)size;
; 1157 :     r.cursor = 0;
; 1158 :     return r;

  0003e	48 8b c3	 mov	 rax, rbx

; 1159 : }

  00041	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00046	89 7b 0c	 mov	 DWORD PTR [rbx+12], edi
  00049	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [rbx+8], 0
  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
?stbtt__new_buf@@YA?AUstbtt__buf@@PEBX_K@Z ENDP		; stbtt__new_buf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
$T1 = 0
$T2 = 32
b$ = 40
o$ = 48
s$ = 56
?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z PROC	; stbtt__buf_range

; 1165 : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 1155 :     r.data = (stbtt_uint8*)p;

  00004	33 c0		 xor	 eax, eax
  00006	48 89 04 24	 mov	 QWORD PTR $T1[rsp], rax

; 1156 :     r.size = (int)size;
; 1157 :     r.cursor = 0;

  0000a	48 89 44 24 08	 mov	 QWORD PTR $T1[rsp+8], rax

; 1166 :     stbtt__buf r = stbtt__new_buf(NULL, 0);

  0000f	0f 10 04 24	 movups	 xmm0, XMMWORD PTR $T1[rsp]
  00013	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0

; 1167 :     if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

  00016	45 85 c0	 test	 r8d, r8d
  00019	78 22		 js	 SHORT $LN3@stbtt__buf
  0001b	45 85 c9	 test	 r9d, r9d
  0001e	78 1d		 js	 SHORT $LN3@stbtt__buf
  00020	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]
  00023	44 3b c0	 cmp	 r8d, eax
  00026	7f 15		 jg	 SHORT $LN3@stbtt__buf
  00028	41 2b c0	 sub	 eax, r8d
  0002b	44 3b c8	 cmp	 r9d, eax
  0002e	7f 0d		 jg	 SHORT $LN3@stbtt__buf

; 1168 :     r.data = b->data + o;

  00030	49 63 c0	 movsxd	 rax, r8d
  00033	48 03 02	 add	 rax, QWORD PTR [rdx]
  00036	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1169 :     r.size = s;

  00039	44 89 49 0c	 mov	 DWORD PTR [rcx+12], r9d
$LN3@stbtt__buf:

; 1170 :     return r;
; 1171 : }

  0003d	48 8b c1	 mov	 rax, rcx
  00040	48 83 c4 18	 add	 rsp, 24
  00044	c3		 ret	 0
?stbtt__buf_range@@YA?AUstbtt__buf@@PEBU1@HH@Z ENDP	; stbtt__buf_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 80
b$ = 88
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z PROC	; stbtt__cff_get_index

; 1174 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1175 :     int count, start, offsize;
; 1176 :     start = b->cursor;

  0000d	4c 63 72 08	 movsxd	 r14, DWORD PTR [rdx+8]
  00011	48 8b fa	 mov	 rdi, rdx

; 1118 :     if (b->cursor >= b->size)

  00014	44 8b 42 0c	 mov	 r8d, DWORD PTR [rdx+12]

; 1174 : {

  00018	48 8b f1	 mov	 rsi, rcx
  0001b	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp

; 1118 :     if (b->cursor >= b->size)

  00020	45 3b f0	 cmp	 r14d, r8d
  00023	7c 09		 jl	 SHORT $LN20@stbtt__cff

; 1119 :         return 0;

  00025	33 ed		 xor	 ebp, ebp
  00027	41 8b de	 mov	 ebx, r14d
  0002a	32 c0		 xor	 al, al
  0002c	eb 24		 jmp	 SHORT $LN61@stbtt__cff
$LN20@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  0002e	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00031	41 8d 5e 01	 lea	 ebx, DWORD PTR [r14+1]
  00035	41 0f b6 2c 06	 movzx	 ebp, BYTE PTR [r14+rax]
  0003a	89 5a 08	 mov	 DWORD PTR [rdx+8], ebx
  0003d	41 3b d8	 cmp	 ebx, r8d
  00040	7c 04		 jl	 SHORT $LN60@stbtt__cff

; 1119 :         return 0;

  00042	32 c0		 xor	 al, al
  00044	eb 0c		 jmp	 SHORT $LN61@stbtt__cff
$LN60@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  00046	48 63 cb	 movsxd	 rcx, ebx
  00049	ff c3		 inc	 ebx
  0004b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004f	89 5a 08	 mov	 DWORD PTR [rdx+8], ebx
$LN61@stbtt__cff:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00052	c1 e5 08	 shl	 ebp, 8
  00055	0f b6 c0	 movzx	 eax, al
  00058	0b e8		 or	 ebp, eax

; 1177 :     count = stbtt__buf_get16(b);
; 1178 :     if (count) {

  0005a	0f 84 d2 00 00
	00		 je	 $LN63@stbtt__cff

; 1118 :     if (b->cursor >= b->size)

  00060	4c 89 7c 24 58	 mov	 QWORD PTR [rsp+88], r15
  00065	41 3b d8	 cmp	 ebx, r8d
  00068	7c 04		 jl	 SHORT $LN23@stbtt__cff

; 1119 :         return 0;

  0006a	32 c0		 xor	 al, al
  0006c	eb 0f		 jmp	 SHORT $LN22@stbtt__cff
$LN23@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  0006e	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00071	48 63 cb	 movsxd	 rcx, ebx
  00074	ff c3		 inc	 ebx
  00076	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007a	89 5a 08	 mov	 DWORD PTR [rdx+8], ebx
$LN22@stbtt__cff:

; 1179 :         offsize = stbtt__buf_get8(b);

  0007d	44 0f b6 f8	 movzx	 r15d, al

; 1180 :         STBTT_assert(offsize >= 1 && offsize <= 4);

  00081	41 83 ff 01	 cmp	 r15d, 1
  00085	72 06		 jb	 SHORT $LN7@stbtt__cff
  00087	41 83 ff 04	 cmp	 r15d, 4
  0008b	76 21		 jbe	 SHORT $LN2@stbtt__cff
$LN7@stbtt__cff:
  0008d	41 b8 9c 04 00
	00		 mov	 r8d, 1180		; 0000049cH
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a7	44 8b 47 0c	 mov	 r8d, DWORD PTR [rdi+12]
  000ab	8b 5f 08	 mov	 ebx, DWORD PTR [rdi+8]
$LN2@stbtt__cff:

; 1181 :         stbtt__buf_skip(b, offsize * count);

  000ae	41 0f af ef	 imul	 ebp, r15d

; 1138 :     stbtt__buf_seek(b, b->cursor + o);

  000b2	03 eb		 add	 ebp, ebx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  000b4	41 3b e8	 cmp	 ebp, r8d
  000b7	7f 04		 jg	 SHORT $LN32@stbtt__cff
  000b9	85 ed		 test	 ebp, ebp
  000bb	79 27		 jns	 SHORT $LN35@stbtt__cff
$LN32@stbtt__cff:
  000bd	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d7	8b 47 0c	 mov	 eax, DWORD PTR [rdi+12]

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  000da	3b e8		 cmp	 ebp, eax
  000dc	7f 04		 jg	 SHORT $LN34@stbtt__cff
  000de	85 ed		 test	 ebp, ebp
  000e0	79 02		 jns	 SHORT $LN35@stbtt__cff
$LN34@stbtt__cff:
  000e2	8b e8		 mov	 ebp, eax
$LN35@stbtt__cff:

; 1182 :         stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);

  000e4	41 8b d7	 mov	 edx, r15d

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  000e7	89 6f 08	 mov	 DWORD PTR [rdi+8], ebp

; 1182 :         stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);

  000ea	48 8b cf	 mov	 rcx, rdi
  000ed	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  000f2	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]

; 1182 :         stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);

  000f7	8d 58 ff	 lea	 ebx, DWORD PTR [rax-1]

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  000fa	8b 47 0c	 mov	 eax, DWORD PTR [rdi+12]

; 1138 :     stbtt__buf_seek(b, b->cursor + o);

  000fd	03 5f 08	 add	 ebx, DWORD PTR [rdi+8]

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00100	3b d8		 cmp	 ebx, eax
  00102	7f 04		 jg	 SHORT $LN43@stbtt__cff
  00104	85 db		 test	 ebx, ebx
  00106	79 27		 jns	 SHORT $LN46@stbtt__cff
$LN43@stbtt__cff:
  00108	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00122	8b 47 0c	 mov	 eax, DWORD PTR [rdi+12]

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  00125	3b d8		 cmp	 ebx, eax
  00127	7f 04		 jg	 SHORT $LN45@stbtt__cff
  00129	85 db		 test	 ebx, ebx
  0012b	79 02		 jns	 SHORT $LN46@stbtt__cff
$LN45@stbtt__cff:
  0012d	8b d8		 mov	 ebx, eax
$LN46@stbtt__cff:
  0012f	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx
$LN63@stbtt__cff:

; 1166 :     stbtt__buf r = stbtt__new_buf(NULL, 0);

  00132	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 1183 :     }
; 1184 :     return stbtt__buf_range(b, start, b->cursor - start);

  00137	41 2b de	 sub	 ebx, r14d

; 1155 :     r.data = (stbtt_uint8*)p;

  0013a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR $T1[rsp], 0

; 1156 :     r.size = (int)size;
; 1157 :     r.cursor = 0;

  00143	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR $T1[rsp+8], 0

; 1166 :     stbtt__buf r = stbtt__new_buf(NULL, 0);

  0014c	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T1[rsp]
  00151	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0

; 1167 :     if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

  00154	45 85 f6	 test	 r14d, r14d
  00157	78 1f		 js	 SHORT $LN71@stbtt__cff
  00159	85 db		 test	 ebx, ebx
  0015b	78 1b		 js	 SHORT $LN71@stbtt__cff
  0015d	8b 47 0c	 mov	 eax, DWORD PTR [rdi+12]
  00160	44 3b f0	 cmp	 r14d, eax
  00163	7f 13		 jg	 SHORT $LN71@stbtt__cff
  00165	41 2b c6	 sub	 eax, r14d
  00168	3b d8		 cmp	 ebx, eax
  0016a	7f 0c		 jg	 SHORT $LN71@stbtt__cff

; 1168 :     r.data = b->data + o;

  0016c	49 8b c6	 mov	 rax, r14
  0016f	48 03 07	 add	 rax, QWORD PTR [rdi]
  00172	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1169 :     r.size = s;

  00175	89 5e 0c	 mov	 DWORD PTR [rsi+12], ebx
$LN71@stbtt__cff:

; 1185 : }

  00178	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0017d	48 8b c6	 mov	 rax, rsi
  00180	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00184	41 5e		 pop	 r14
  00186	5f		 pop	 rdi
  00187	5e		 pop	 rsi
  00188	c3		 ret	 0
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ENDP	; stbtt__cff_get_index
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 48
?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z PROC		; stbtt__cff_int

; 1188 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1118 :     if (b->cursor >= b->size)

  00004	4c 63 41 08	 movsxd	 r8, DWORD PTR [rcx+8]

; 1188 : {

  00008	4c 8b c9	 mov	 r9, rcx

; 1118 :     if (b->cursor >= b->size)

  0000b	44 8b 51 0c	 mov	 r10d, DWORD PTR [rcx+12]
  0000f	45 3b c2	 cmp	 r8d, r10d
  00012	7c 04		 jl	 SHORT $LN17@stbtt__cff

; 1119 :         return 0;

  00014	32 c0		 xor	 al, al
  00016	eb 0f		 jmp	 SHORT $LN16@stbtt__cff
$LN17@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  00018	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00020	41 ff c0	 inc	 r8d
  00023	44 89 41 08	 mov	 DWORD PTR [rcx+8], r8d
$LN16@stbtt__cff:

; 1189 :     int b0 = stbtt__buf_get8(b);

  00027	0f b6 d0	 movzx	 edx, al

; 1190 :     if (b0 >= 32 && b0 <= 246)       return b0 - 139;

  0002a	8d 42 e0	 lea	 eax, DWORD PTR [rdx-32]
  0002d	3d d6 00 00 00	 cmp	 eax, 214		; 000000d6H
  00032	77 0b		 ja	 SHORT $LN5@stbtt__cff
  00034	8d 82 75 ff ff
	ff		 lea	 eax, DWORD PTR [rdx-139]

; 1197 : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
$LN5@stbtt__cff:

; 1191 :     else if (b0 >= 247 && b0 <= 250) return (b0 - 247) * 256 + stbtt__buf_get8(b) + 108;

  0003f	8d 82 09 ff ff
	ff		 lea	 eax, DWORD PTR [rdx-247]
  00045	83 f8 03	 cmp	 eax, 3
  00048	77 3d		 ja	 SHORT $LN7@stbtt__cff

; 1118 :     if (b->cursor >= b->size)

  0004a	45 3b c2	 cmp	 r8d, r10d
  0004d	7c 14		 jl	 SHORT $LN20@stbtt__cff

; 1119 :         return 0;

  0004f	32 c9		 xor	 cl, cl

; 1191 :     else if (b0 >= 247 && b0 <= 250) return (b0 - 247) * 256 + stbtt__buf_get8(b) + 108;

  00051	c1 e2 08	 shl	 edx, 8
  00054	0f b6 c1	 movzx	 eax, cl
  00057	05 6c 09 ff ff	 add	 eax, -63124		; ffffffffffff096cH
  0005c	03 c2		 add	 eax, edx

; 1197 : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
$LN20@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  00063	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00066	49 63 c8	 movsxd	 rcx, r8d

; 1191 :     else if (b0 >= 247 && b0 <= 250) return (b0 - 247) * 256 + stbtt__buf_get8(b) + 108;

  00069	c1 e2 08	 shl	 edx, 8

; 1120 :     return b->data[b->cursor++];

  0006c	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00070	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  00074	41 89 41 08	 mov	 DWORD PTR [r9+8], eax

; 1191 :     else if (b0 >= 247 && b0 <= 250) return (b0 - 247) * 256 + stbtt__buf_get8(b) + 108;

  00078	0f b6 c1	 movzx	 eax, cl
  0007b	05 6c 09 ff ff	 add	 eax, -63124		; ffffffffffff096cH
  00080	03 c2		 add	 eax, edx

; 1197 : }

  00082	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00086	c3		 ret	 0
$LN7@stbtt__cff:

; 1192 :     else if (b0 >= 251 && b0 <= 254) return -(b0 - 251) * 256 - stbtt__buf_get8(b) - 108;

  00087	8d 82 05 ff ff
	ff		 lea	 eax, DWORD PTR [rdx-251]
  0008d	83 f8 03	 cmp	 eax, 3
  00090	77 41		 ja	 SHORT $LN9@stbtt__cff

; 1118 :     if (b->cursor >= b->size)

  00092	45 3b c2	 cmp	 r8d, r10d
  00095	7c 16		 jl	 SHORT $LN23@stbtt__cff

; 1119 :         return 0;

  00097	32 c9		 xor	 cl, cl

; 1192 :     else if (b0 >= 251 && b0 <= 254) return -(b0 - 251) * 256 - stbtt__buf_get8(b) - 108;

  00099	c1 e2 08	 shl	 edx, 8
  0009c	b8 94 fa 00 00	 mov	 eax, 64148		; 0000fa94H
  000a1	0f b6 c9	 movzx	 ecx, cl
  000a4	2b c2		 sub	 eax, edx
  000a6	2b c1		 sub	 eax, ecx

; 1197 : }

  000a8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ac	c3		 ret	 0
$LN23@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  000ad	49 8b 01	 mov	 rax, QWORD PTR [r9]
  000b0	49 63 c8	 movsxd	 rcx, r8d

; 1192 :     else if (b0 >= 251 && b0 <= 254) return -(b0 - 251) * 256 - stbtt__buf_get8(b) - 108;

  000b3	c1 e2 08	 shl	 edx, 8

; 1120 :     return b->data[b->cursor++];

  000b6	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  000ba	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  000be	41 89 41 08	 mov	 DWORD PTR [r9+8], eax

; 1192 :     else if (b0 >= 251 && b0 <= 254) return -(b0 - 251) * 256 - stbtt__buf_get8(b) - 108;

  000c2	b8 94 fa 00 00	 mov	 eax, 64148		; 0000fa94H
  000c7	2b c2		 sub	 eax, edx
  000c9	0f b6 c9	 movzx	 ecx, cl
  000cc	2b c1		 sub	 eax, ecx

; 1197 : }

  000ce	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d2	c3		 ret	 0
$LN9@stbtt__cff:

; 1193 :     else if (b0 == 28)               return stbtt__buf_get16(b);

  000d3	83 fa 1c	 cmp	 edx, 28
  000d6	75 5a		 jne	 SHORT $LN11@stbtt__cff

; 1118 :     if (b->cursor >= b->size)

  000d8	45 3b c2	 cmp	 r8d, r10d
  000db	7c 11		 jl	 SHORT $LN36@stbtt__cff

; 1119 :         return 0;

  000dd	33 c0		 xor	 eax, eax
  000df	32 d2		 xor	 dl, dl

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  000e1	c1 e0 08	 shl	 eax, 8
  000e4	0f b6 ca	 movzx	 ecx, dl
  000e7	0b c1		 or	 eax, ecx

; 1197 : }

  000e9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ed	c3		 ret	 0
$LN36@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  000ee	49 8b 01	 mov	 rax, QWORD PTR [r9]
  000f1	49 63 c8	 movsxd	 rcx, r8d
  000f4	41 ff c0	 inc	 r8d
  000f7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fb	45 89 41 08	 mov	 DWORD PTR [r9+8], r8d
  000ff	45 3b c2	 cmp	 r8d, r10d
  00102	7c 0f		 jl	 SHORT $LN41@stbtt__cff

; 1119 :         return 0;

  00104	32 d2		 xor	 dl, dl

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00106	c1 e0 08	 shl	 eax, 8
  00109	0f b6 ca	 movzx	 ecx, dl
  0010c	0b c1		 or	 eax, ecx

; 1197 : }

  0010e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00112	c3		 ret	 0
$LN41@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  00113	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  00116	49 63 d0	 movsxd	 rdx, r8d

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00119	c1 e0 08	 shl	 eax, 8

; 1120 :     return b->data[b->cursor++];

  0011c	0f b6 14 0a	 movzx	 edx, BYTE PTR [rdx+rcx]
  00120	41 8d 48 01	 lea	 ecx, DWORD PTR [r8+1]
  00124	41 89 49 08	 mov	 DWORD PTR [r9+8], ecx

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00128	0f b6 ca	 movzx	 ecx, dl
  0012b	0b c1		 or	 eax, ecx

; 1197 : }

  0012d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00131	c3		 ret	 0
$LN11@stbtt__cff:

; 1194 :     else if (b0 == 29)               return stbtt__buf_get32(b);

  00132	83 fa 1d	 cmp	 edx, 29
  00135	75 0e		 jne	 SHORT $LN4@stbtt__cff
  00137	ba 04 00 00 00	 mov	 edx, 4

; 1197 : }

  0013c	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1194 :     else if (b0 == 29)               return stbtt__buf_get32(b);

  00140	e9 00 00 00 00	 jmp	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
$LN4@stbtt__cff:

; 1195 :     STBTT_assert(0);

  00145	41 b8 ab 04 00
	00		 mov	 r8d, 1195		; 000004abH
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1196 :     return 0;

  0015f	33 c0		 xor	 eax, eax

; 1197 : }

  00161	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00165	c3		 ret	 0
?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ENDP		; stbtt__cff_int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 48
?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z PROC	; stbtt__cff_skip_operand

; 1199 : static void stbtt__cff_skip_operand(stbtt__buf* b) {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1125 :     if (b->cursor >= b->size)

  00006	48 63 41 08	 movsxd	 rax, DWORD PTR [rcx+8]

; 1199 : static void stbtt__cff_skip_operand(stbtt__buf* b) {

  0000a	48 8b f9	 mov	 rdi, rcx

; 1125 :     if (b->cursor >= b->size)

  0000d	3b 41 0c	 cmp	 eax, DWORD PTR [rcx+12]
  00010	0f 8d b6 00 00
	00		 jge	 $LN35@stbtt__cff

; 1126 :         return 0;
; 1127 :     return b->data[b->cursor];

  00016	48 8b d0	 mov	 rdx, rax
  00019	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001c	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]

; 1200 :     int v, b0 = stbtt__buf_peek8(b);
; 1201 :     STBTT_assert(b0 >= 28);

  00020	80 f9 1c	 cmp	 cl, 28
  00023	0f 82 a3 00 00
	00		 jb	 $LN35@stbtt__cff

; 1202 :     if (b0 == 30) {

  00029	80 f9 1e	 cmp	 cl, 30
  0002c	0f 85 b4 00 00
	00		 jne	 $LN7@stbtt__cff

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00032	44 8b 47 0c	 mov	 r8d, DWORD PTR [rdi+12]

; 1138 :     stbtt__buf_seek(b, b->cursor + o);

  00036	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0003b	8b 5f 08	 mov	 ebx, DWORD PTR [rdi+8]
  0003e	ff c3		 inc	 ebx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00040	41 3b d8	 cmp	 ebx, r8d
  00043	7f 07		 jg	 SHORT $LN23@stbtt__cff
  00045	41 8b d0	 mov	 edx, r8d
  00048	85 db		 test	 ebx, ebx
  0004a	79 2a		 jns	 SHORT $LN38@stbtt__cff
$LN23@stbtt__cff:
  0004c	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00066	44 8b 47 0c	 mov	 r8d, DWORD PTR [rdi+12]
  0006a	41 8b d0	 mov	 edx, r8d

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0006d	41 3b d8	 cmp	 ebx, r8d
  00070	7f 4c		 jg	 SHORT $LN25@stbtt__cff
  00072	85 db		 test	 ebx, ebx
  00074	78 48		 js	 SHORT $LN25@stbtt__cff
$LN38@stbtt__cff:
  00076	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx

; 1203 :         stbtt__buf_skip(b, 1);
; 1204 :         while (b->cursor < b->size) {

  00079	3b da		 cmp	 ebx, edx
  0007b	7d 36		 jge	 SHORT $LN36@stbtt__cff
  0007d	0f 1f 00	 npad	 3
$LL5@stbtt__cff:

; 1118 :     if (b->cursor >= b->size)

  00080	3b da		 cmp	 ebx, edx
  00082	7c 04		 jl	 SHORT $LN28@stbtt__cff

; 1119 :         return 0;

  00084	32 c0		 xor	 al, al
  00086	eb 0f		 jmp	 SHORT $LN27@stbtt__cff
$LN28@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  00088	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0008b	48 63 cb	 movsxd	 rcx, ebx
  0008e	ff c3		 inc	 ebx
  00090	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00094	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx
$LN27@stbtt__cff:

; 1205 :             v = stbtt__buf_get8(b);

  00097	0f b6 c8	 movzx	 ecx, al

; 1206 :             if ((v & 0xF) == 0xF || (v >> 4) == 0xF)

  0009a	8b c1		 mov	 eax, ecx
  0009c	83 e0 0f	 and	 eax, 15
  0009f	3c 0f		 cmp	 al, 15
  000a1	74 10		 je	 SHORT $LN36@stbtt__cff
  000a3	83 e1 f0	 and	 ecx, -16		; fffffff0H
  000a6	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  000ac	74 05		 je	 SHORT $LN36@stbtt__cff

; 1203 :         stbtt__buf_skip(b, 1);
; 1204 :         while (b->cursor < b->size) {

  000ae	41 3b d8	 cmp	 ebx, r8d
  000b1	7c cd		 jl	 SHORT $LL5@stbtt__cff
$LN36@stbtt__cff:
  000b3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1212 :     }
; 1213 : }

  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
$LN25@stbtt__cff:
  000be	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  000c3	89 57 08	 mov	 DWORD PTR [rdi+8], edx

; 1212 :     }
; 1213 : }

  000c6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0
$LN35@stbtt__cff:

; 1200 :     int v, b0 = stbtt__buf_peek8(b);
; 1201 :     STBTT_assert(b0 >= 28);

  000cc	41 b8 b1 04 00
	00		 mov	 r8d, 1201		; 000004b1H
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KDMJFGHG@?$AAb?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA8@
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN7@stbtt__cff:

; 1207 :                 break;
; 1208 :         }
; 1209 :     }
; 1210 :     else {
; 1211 :         stbtt__cff_int(b);

  000e6	48 8b cf	 mov	 rcx, rdi

; 1212 :     }
; 1213 : }

  000e9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ed	5f		 pop	 rdi

; 1207 :                 break;
; 1208 :         }
; 1209 :     }
; 1210 :     else {
; 1211 :         stbtt__cff_int(b);

  000ee	e9 00 00 00 00	 jmp	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
?stbtt__cff_skip_operand@@YAXPEAUstbtt__buf@@@Z ENDP	; stbtt__cff_skip_operand
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
$T3 = 80
b$ = 88
key$ = 96
?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z PROC	; stbtt__dict_get

; 1216 : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00013	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]

; 1216 : {

  00016	45 8b f0	 mov	 r14d, r8d
  00019	48 8b fa	 mov	 rdi, rdx
  0001c	48 8b f1	 mov	 rsi, rcx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  0001f	85 c0		 test	 eax, eax
  00021	79 1d		 jns	 SHORT $LN10@stbtt__dic
  00023	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003d	8b 47 0c	 mov	 eax, DWORD PTR [rdi+12]
$LN10@stbtt__dic:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  00040	45 33 ff	 xor	 r15d, r15d
  00043	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00048	85 c0		 test	 eax, eax
  0004a	41 8b ef	 mov	 ebp, r15d
  0004d	0f 48 e8	 cmovs	 ebp, eax
  00050	89 6f 08	 mov	 DWORD PTR [rdi+8], ebp

; 1217 :     stbtt__buf_seek(b, 0);
; 1218 :     while (b->cursor < b->size) {

  00053	3b e8		 cmp	 ebp, eax
  00055	0f 8d 5c 01 00
	00		 jge	 $LN70@stbtt__dic

; 1120 :     return b->data[b->cursor++];

  0005b	8b dd		 mov	 ebx, ebp
  0005d	0f 1f 00	 npad	 3
$LL2@stbtt__dic:

; 1219 :         int start = b->cursor, end, op;
; 1220 :         while (stbtt__buf_peek8(b) >= 28)

  00060	48 8b cf	 mov	 rcx, rdi
  00063	e8 00 00 00 00	 call	 ?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_peek8
  00068	3c 1c		 cmp	 al, 28
  0006a	0f 82 ec 00 00
	00		 jb	 $LN5@stbtt__dic
$LL4@stbtt__dic:

; 1125 :     if (b->cursor >= b->size)

  00070	44 8b 4f 0c	 mov	 r9d, DWORD PTR [rdi+12]
  00074	41 3b d9	 cmp	 ebx, r9d
  00077	0f 8d aa 00 00
	00		 jge	 $LN85@stbtt__dic

; 1126 :         return 0;
; 1127 :     return b->data[b->cursor];

  0007d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00080	48 63 cb	 movsxd	 rcx, ebx
  00083	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]

; 1201 :     STBTT_assert(b0 >= 28);

  00087	80 fa 1c	 cmp	 dl, 28
  0008a	0f 82 97 00 00
	00		 jb	 $LN85@stbtt__dic

; 1202 :     if (b0 == 30) {

  00090	80 fa 1e	 cmp	 dl, 30
  00093	0f 85 a8 00 00
	00		 jne	 $LN24@stbtt__dic

; 1138 :     stbtt__buf_seek(b, b->cursor + o);

  00099	ff c3		 inc	 ebx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  0009b	41 3b d9	 cmp	 ebx, r9d
  0009e	7f 07		 jg	 SHORT $LN40@stbtt__dic
  000a0	45 8b d9	 mov	 r11d, r9d
  000a3	85 db		 test	 ebx, ebx
  000a5	79 2a		 jns	 SHORT $LN92@stbtt__dic
$LN40@stbtt__dic:
  000a7	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c1	44 8b 5f 0c	 mov	 r11d, DWORD PTR [rdi+12]
  000c5	45 8b cb	 mov	 r9d, r11d

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  000c8	41 3b db	 cmp	 ebx, r11d
  000cb	7f 52		 jg	 SHORT $LN42@stbtt__dic
  000cd	85 db		 test	 ebx, ebx
  000cf	78 4e		 js	 SHORT $LN42@stbtt__dic
$LN92@stbtt__dic:
  000d1	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx

; 1204 :         while (b->cursor < b->size) {

  000d4	41 3b d9	 cmp	 ebx, r9d
  000d7	7d 73		 jge	 SHORT $LN25@stbtt__dic

; 1118 :     if (b->cursor >= b->size)

  000d9	45 8b c1	 mov	 r8d, r9d
  000dc	8b c3		 mov	 eax, ebx
  000de	66 90		 npad	 2
$LL22@stbtt__dic:
  000e0	41 3b c1	 cmp	 eax, r9d
  000e3	7c 04		 jl	 SHORT $LN45@stbtt__dic

; 1119 :         return 0;

  000e5	32 c9		 xor	 cl, cl
  000e7	eb 12		 jmp	 SHORT $LN93@stbtt__dic
$LN45@stbtt__dic:

; 1120 :     return b->data[b->cursor++];

  000e9	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000ec	45 8b c3	 mov	 r8d, r11d
  000ef	48 63 d0	 movsxd	 rdx, eax
  000f2	ff c0		 inc	 eax
  000f4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000f8	89 47 08	 mov	 DWORD PTR [rdi+8], eax
$LN93@stbtt__dic:

; 1205 :             v = stbtt__buf_get8(b);

  000fb	0f b6 d1	 movzx	 edx, cl
  000fe	44 8b d0	 mov	 r10d, eax

; 1206 :             if ((v & 0xF) == 0xF || (v >> 4) == 0xF)

  00101	8b ca		 mov	 ecx, edx
  00103	8b d8		 mov	 ebx, eax
  00105	83 e1 0f	 and	 ecx, 15
  00108	80 f9 0f	 cmp	 cl, 15
  0010b	74 3f		 je	 SHORT $LN25@stbtt__dic
  0010d	83 e2 f0	 and	 edx, -16		; fffffff0H
  00110	81 fa f0 00 00
	00		 cmp	 edx, 240		; 000000f0H
  00116	74 34		 je	 SHORT $LN25@stbtt__dic

; 1203 :         stbtt__buf_skip(b, 1);
; 1204 :         while (b->cursor < b->size) {

  00118	41 3b c0	 cmp	 eax, r8d
  0011b	7c c3		 jl	 SHORT $LL22@stbtt__dic
  0011d	eb 2d		 jmp	 SHORT $LN25@stbtt__dic
$LN42@stbtt__dic:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0011f	41 8b d9	 mov	 ebx, r9d
  00122	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx

; 1209 :     }

  00125	eb 25		 jmp	 SHORT $LN25@stbtt__dic
$LN85@stbtt__dic:

; 1170 :     return r;
; 1171 : }
; 1172 : 
; 1173 : static stbtt__buf stbtt__cff_get_index(stbtt__buf* b)
; 1174 : {
; 1175 :     int count, start, offsize;
; 1176 :     start = b->cursor;
; 1177 :     count = stbtt__buf_get16(b);
; 1178 :     if (count) {
; 1179 :         offsize = stbtt__buf_get8(b);
; 1180 :         STBTT_assert(offsize >= 1 && offsize <= 4);
; 1181 :         stbtt__buf_skip(b, offsize * count);
; 1182 :         stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
; 1183 :     }
; 1184 :     return stbtt__buf_range(b, start, b->cursor - start);
; 1185 : }
; 1186 : 
; 1187 : static stbtt_uint32 stbtt__cff_int(stbtt__buf* b)
; 1188 : {
; 1189 :     int b0 = stbtt__buf_get8(b);
; 1190 :     if (b0 >= 32 && b0 <= 246)       return b0 - 139;
; 1191 :     else if (b0 >= 247 && b0 <= 250) return (b0 - 247) * 256 + stbtt__buf_get8(b) + 108;
; 1192 :     else if (b0 >= 251 && b0 <= 254) return -(b0 - 251) * 256 - stbtt__buf_get8(b) - 108;
; 1193 :     else if (b0 == 28)               return stbtt__buf_get16(b);
; 1194 :     else if (b0 == 29)               return stbtt__buf_get32(b);
; 1195 :     STBTT_assert(0);
; 1196 :     return 0;
; 1197 : }
; 1198 : 
; 1199 : static void stbtt__cff_skip_operand(stbtt__buf* b) {
; 1200 :     int v, b0 = stbtt__buf_peek8(b);
; 1201 :     STBTT_assert(b0 >= 28);

  00127	41 b8 b1 04 00
	00		 mov	 r8d, 1201		; 000004b1H
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KDMJFGHG@?$AAb?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA2?$AA8@
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN24@stbtt__dic:

; 1210 :     else {
; 1211 :         stbtt__cff_int(b);

  00141	48 8b cf	 mov	 rcx, rdi
  00144	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  00149	8b 5f 08	 mov	 ebx, DWORD PTR [rdi+8]
$LN25@stbtt__dic:

; 1219 :         int start = b->cursor, end, op;
; 1220 :         while (stbtt__buf_peek8(b) >= 28)

  0014c	48 8b cf	 mov	 rcx, rdi
  0014f	e8 00 00 00 00	 call	 ?stbtt__buf_peek8@@YAEPEAUstbtt__buf@@@Z ; stbtt__buf_peek8
  00154	3c 1c		 cmp	 al, 28
  00156	0f 83 14 ff ff
	ff		 jae	 $LL4@stbtt__dic
$LN5@stbtt__dic:

; 1118 :     if (b->cursor >= b->size)

  0015c	44 8b 47 0c	 mov	 r8d, DWORD PTR [rdi+12]

; 1221 :             stbtt__cff_skip_operand(b);
; 1222 :         end = b->cursor;

  00160	44 8b cb	 mov	 r9d, ebx

; 1118 :     if (b->cursor >= b->size)

  00163	41 3b d8	 cmp	 ebx, r8d
  00166	7c 04		 jl	 SHORT $LN48@stbtt__dic

; 1119 :         return 0;

  00168	32 c0		 xor	 al, al
  0016a	eb 0f		 jmp	 SHORT $LN94@stbtt__dic
$LN48@stbtt__dic:

; 1120 :     return b->data[b->cursor++];

  0016c	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0016f	48 63 cb	 movsxd	 rcx, ebx
  00172	ff c3		 inc	 ebx
  00174	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00178	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx
$LN94@stbtt__dic:

; 1223 :         op = stbtt__buf_get8(b);

  0017b	0f b6 c0	 movzx	 eax, al
  0017e	8b d3		 mov	 edx, ebx

; 1224 :         if (op == 12)  op = stbtt__buf_get8(b) | 0x100;

  00180	83 f8 0c	 cmp	 eax, 12
  00183	75 22		 jne	 SHORT $LN6@stbtt__dic

; 1118 :     if (b->cursor >= b->size)

  00185	41 3b d8	 cmp	 ebx, r8d
  00188	7c 04		 jl	 SHORT $LN51@stbtt__dic

; 1119 :         return 0;

  0018a	32 c0		 xor	 al, al
  0018c	eb 12		 jmp	 SHORT $LN50@stbtt__dic
$LN51@stbtt__dic:

; 1120 :     return b->data[b->cursor++];

  0018e	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00191	8d 5a 01	 lea	 ebx, DWORD PTR [rdx+1]
  00194	48 63 ca	 movsxd	 rcx, edx
  00197	8b d3		 mov	 edx, ebx
  00199	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0019d	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx
$LN50@stbtt__dic:

; 1224 :         if (op == 12)  op = stbtt__buf_get8(b) | 0x100;

  001a0	0f b6 c0	 movzx	 eax, al
  001a3	0f ba e8 08	 bts	 eax, 8
$LN6@stbtt__dic:

; 1225 :         if (op == key) return stbtt__buf_range(b, start, end - start);

  001a7	41 3b c6	 cmp	 eax, r14d
  001aa	74 49		 je	 SHORT $LN77@stbtt__dic

; 1217 :     stbtt__buf_seek(b, 0);
; 1218 :     while (b->cursor < b->size) {

  001ac	8b ea		 mov	 ebp, edx
  001ae	41 3b d0	 cmp	 edx, r8d
  001b1	0f 8c a9 fe ff
	ff		 jl	 $LL2@stbtt__dic
$LN70@stbtt__dic:

; 1155 :     r.data = (stbtt_uint8*)p;

  001b7	4c 89 7c 24 20	 mov	 QWORD PTR $T1[rsp], r15

; 1156 :     r.size = (int)size;
; 1157 :     r.cursor = 0;

  001bc	4c 89 7c 24 28	 mov	 QWORD PTR $T1[rsp+8], r15

; 1166 :     stbtt__buf r = stbtt__new_buf(NULL, 0);

  001c1	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T1[rsp]
  001c6	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0

; 1167 :     if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

  001c9	44 39 7f 0c	 cmp	 DWORD PTR [rdi+12], r15d
  001cd	7c 0a		 jl	 SHORT $LN86@stbtt__dic

; 1168 :     r.data = b->data + o;

  001cf	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 1169 :     r.size = s;

  001d2	44 89 7e 0c	 mov	 DWORD PTR [rsi+12], r15d
$LN95@stbtt__dic:

; 1226 :     }
; 1227 :     return stbtt__buf_range(b, 0, 0);
; 1228 : }

  001d6	48 89 06	 mov	 QWORD PTR [rsi], rax
$LN86@stbtt__dic:
  001d9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001de	48 8b c6	 mov	 rax, rsi
  001e1	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001e6	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001eb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ef	41 5f		 pop	 r15
  001f1	41 5e		 pop	 r14
  001f3	5f		 pop	 rdi
  001f4	c3		 ret	 0
$LN77@stbtt__dic:

; 1155 :     r.data = (stbtt_uint8*)p;

  001f5	4c 89 7c 24 20	 mov	 QWORD PTR $T2[rsp], r15

; 1225 :         if (op == key) return stbtt__buf_range(b, start, end - start);

  001fa	44 2b cd	 sub	 r9d, ebp

; 1157 :     r.cursor = 0;

  001fd	4c 89 7c 24 28	 mov	 QWORD PTR $T2[rsp+8], r15

; 1166 :     stbtt__buf r = stbtt__new_buf(NULL, 0);

  00202	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T2[rsp]
  00207	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0

; 1167 :     if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

  0020a	85 ed		 test	 ebp, ebp
  0020c	78 cb		 js	 SHORT $LN86@stbtt__dic
  0020e	45 85 c9	 test	 r9d, r9d
  00211	78 c6		 js	 SHORT $LN86@stbtt__dic
  00213	8b 47 0c	 mov	 eax, DWORD PTR [rdi+12]
  00216	3b e8		 cmp	 ebp, eax
  00218	7f bf		 jg	 SHORT $LN86@stbtt__dic
  0021a	2b c5		 sub	 eax, ebp
  0021c	44 3b c8	 cmp	 r9d, eax
  0021f	7f b8		 jg	 SHORT $LN86@stbtt__dic

; 1168 :     r.data = b->data + o;

  00221	48 63 c5	 movsxd	 rax, ebp
  00224	48 03 07	 add	 rax, QWORD PTR [rdi]

; 1169 :     r.size = s;

  00227	44 89 4e 0c	 mov	 DWORD PTR [rsi+12], r9d
  0022b	eb a9		 jmp	 SHORT $LN95@stbtt__dic
?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ENDP	; stbtt__dict_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
$T1 = 32
operands$ = 32
b$ = 64
key$ = 72
outcount$ = 80
out$ = 88
?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z PROC	; stbtt__dict_get_ints

; 1231 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 63 d8	 movsxd	 rbx, r8d
  00012	49 8b f1	 mov	 rsi, r9

; 1232 :     int i;
; 1233 :     stbtt__buf operands = stbtt__dict_get(b, key);

  00015	44 8b c2	 mov	 r8d, edx
  00018	48 8b d1	 mov	 rdx, rcx
  0001b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00020	e8 00 00 00 00	 call	 ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get

; 1234 :     for (i = 0; i < outcount && operands.cursor < operands.size; i++)

  00025	48 8b fb	 mov	 rdi, rbx
  00028	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0002b	0f 11 44 24 20	 movups	 XMMWORD PTR operands$[rsp], xmm0
  00030	85 db		 test	 ebx, ebx
  00032	7e 21		 jle	 SHORT $LN10@stbtt__dic
  00034	33 db		 xor	 ebx, ebx
$LL4@stbtt__dic:
  00036	8b 44 24 2c	 mov	 eax, DWORD PTR operands$[rsp+12]
  0003a	39 44 24 28	 cmp	 DWORD PTR operands$[rsp+8], eax
  0003e	7d 15		 jge	 SHORT $LN10@stbtt__dic

; 1235 :         out[i] = stbtt__cff_int(&operands);

  00040	48 8d 4c 24 20	 lea	 rcx, QWORD PTR operands$[rsp]
  00045	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  0004a	89 04 9e	 mov	 DWORD PTR [rsi+rbx*4], eax
  0004d	48 ff c3	 inc	 rbx
  00050	48 3b df	 cmp	 rbx, rdi
  00053	7c e1		 jl	 SHORT $LL4@stbtt__dic
$LN10@stbtt__dic:

; 1236 : }

  00055	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
?stbtt__dict_get_ints@@YAXPEAUstbtt__buf@@HHPEAI@Z ENDP	; stbtt__dict_get_ints
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
b$ = 48
?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z PROC	; stbtt__cff_index_count

; 1239 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00006	44 8b 41 0c	 mov	 r8d, DWORD PTR [rcx+12]

; 1239 : {

  0000a	48 8b d9	 mov	 rbx, rcx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  0000d	45 85 c0	 test	 r8d, r8d
  00010	79 1e		 jns	 SHORT $LN4@stbtt__cff
  00012	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002c	44 8b 43 0c	 mov	 r8d, DWORD PTR [rbx+12]
$LN4@stbtt__cff:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  00030	33 c0		 xor	 eax, eax
  00032	45 85 c0	 test	 r8d, r8d
  00035	44 8b c8	 mov	 r9d, eax
  00038	45 0f 48 c8	 cmovs	 r9d, r8d
  0003c	44 89 4b 08	 mov	 DWORD PTR [rbx+8], r9d

; 1118 :     if (b->cursor >= b->size)

  00040	45 3b c8	 cmp	 r9d, r8d
  00043	7d 16		 jge	 SHORT $LN32@stbtt__cff

; 1120 :     return b->data[b->cursor++];

  00045	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00048	49 63 c9	 movsxd	 rcx, r9d
  0004b	41 ff c1	 inc	 r9d
  0004e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00052	44 89 4b 08	 mov	 DWORD PTR [rbx+8], r9d
  00056	45 3b c8	 cmp	 r9d, r8d
  00059	7c 10		 jl	 SHORT $LN28@stbtt__cff
$LN32@stbtt__cff:

; 1119 :         return 0;

  0005b	32 d2		 xor	 dl, dl

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  0005d	c1 e0 08	 shl	 eax, 8
  00060	0f b6 ca	 movzx	 ecx, dl
  00063	0b c1		 or	 eax, ecx

; 1240 :     stbtt__buf_seek(b, 0);
; 1241 :     return stbtt__buf_get16(b);
; 1242 : }

  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN28@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  0006b	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0006e	49 63 d1	 movsxd	 rdx, r9d

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00071	c1 e0 08	 shl	 eax, 8

; 1120 :     return b->data[b->cursor++];

  00074	0f b6 14 0a	 movzx	 edx, BYTE PTR [rdx+rcx]
  00078	41 8d 49 01	 lea	 ecx, DWORD PTR [r9+1]
  0007c	89 4b 08	 mov	 DWORD PTR [rbx+8], ecx

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  0007f	0f b6 ca	 movzx	 ecx, dl
  00082	0b c1		 or	 eax, ecx

; 1240 :     stbtt__buf_seek(b, 0);
; 1241 :     return stbtt__buf_get16(b);
; 1242 : }

  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5b		 pop	 rbx
  00089	c3		 ret	 0
?stbtt__cff_index_count@@YAHPEAUstbtt__buf@@@Z ENDP	; stbtt__cff_index_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 96
b$ = 104
i$ = 112
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z PROC	; stbtt__cff_index_get

; 1245 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  0001c	48 63 6a 0c	 movsxd	 rbp, DWORD PTR [rdx+12]

; 1245 : {

  00020	45 8b e0	 mov	 r12d, r8d
  00023	4c 8b f2	 mov	 r14, rdx
  00026	48 8b f9	 mov	 rdi, rcx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00029	85 ed		 test	 ebp, ebp
  0002b	79 1a		 jns	 SHORT $LN14@stbtt__cff
  0002d	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN14@stbtt__cff:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  00047	33 f6		 xor	 esi, esi
  00049	85 ed		 test	 ebp, ebp
  0004b	0f 48 f5	 cmovs	 esi, ebp
  0004e	48 63 ce	 movsxd	 rcx, esi

; 1118 :     if (b->cursor >= b->size)

  00051	48 3b cd	 cmp	 rcx, rbp
  00054	7c 07		 jl	 SHORT $LN33@stbtt__cff

; 1119 :         return 0;

  00056	45 33 ff	 xor	 r15d, r15d
  00059	32 c0		 xor	 al, al
  0005b	eb 1e		 jmp	 SHORT $LN63@stbtt__cff
$LN33@stbtt__cff:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  0005d	49 8b 06	 mov	 rax, QWORD PTR [r14]

; 1120 :     return b->data[b->cursor++];

  00060	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]
  00064	ff c6		 inc	 esi

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00066	44 0f b6 3c 01	 movzx	 r15d, BYTE PTR [rcx+rax]

; 1118 :     if (b->cursor >= b->size)

  0006b	4c 3b c5	 cmp	 r8, rbp
  0006e	7c 04		 jl	 SHORT $LN62@stbtt__cff

; 1119 :         return 0;

  00070	32 c0		 xor	 al, al
  00072	eb 07		 jmp	 SHORT $LN63@stbtt__cff
$LN62@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  00074	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00079	ff c6		 inc	 esi
$LN63@stbtt__cff:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  0007b	41 c1 e7 08	 shl	 r15d, 8
  0007f	0f b6 c0	 movzx	 eax, al
  00082	44 0b f8	 or	 r15d, eax

; 1118 :     if (b->cursor >= b->size)

  00085	3b f5		 cmp	 esi, ebp
  00087	7c 04		 jl	 SHORT $LN36@stbtt__cff

; 1119 :         return 0;

  00089	32 c0		 xor	 al, al
  0008b	eb 0c		 jmp	 SHORT $LN35@stbtt__cff
$LN36@stbtt__cff:

; 1120 :     return b->data[b->cursor++];

  0008d	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00090	48 63 ce	 movsxd	 rcx, esi
  00093	ff c6		 inc	 esi
  00095	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
$LN35@stbtt__cff:

; 1246 :     int count, offsize, start, end;
; 1247 :     stbtt__buf_seek(&b, 0);
; 1248 :     count = stbtt__buf_get16(&b);
; 1249 :     offsize = stbtt__buf_get8(&b);

  00099	44 0f b6 e8	 movzx	 r13d, al

; 1250 :     STBTT_assert(i >= 0 && i < count);

  0009d	45 85 e4	 test	 r12d, r12d
  000a0	78 05		 js	 SHORT $LN9@stbtt__cff
  000a2	45 3b e7	 cmp	 r12d, r15d
  000a5	7c 1a		 jl	 SHORT $LN2@stbtt__cff
$LN9@stbtt__cff:
  000a7	41 b8 e2 04 00
	00		 mov	 r8d, 1250		; 000004e2H
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@PFMEGAIA@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAc@
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN2@stbtt__cff:

; 1251 :     STBTT_assert(offsize >= 1 && offsize <= 4);

  000c1	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  000c5	83 f8 03	 cmp	 eax, 3
  000c8	76 1a		 jbe	 SHORT $LN5@stbtt__cff
  000ca	41 b8 e3 04 00
	00		 mov	 r8d, 1251		; 000004e3H
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@IJDIOPHB@?$AAo?$AAf?$AAf?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$CG?$AA?$CG@
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN5@stbtt__cff:

; 1252 :     stbtt__buf_skip(&b, i * offsize);

  000e4	41 8b dd	 mov	 ebx, r13d
  000e7	41 0f af dc	 imul	 ebx, r12d

; 1138 :     stbtt__buf_seek(b, b->cursor + o);

  000eb	03 de		 add	 ebx, esi

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  000ed	3b dd		 cmp	 ebx, ebp
  000ef	7f 04		 jg	 SHORT $LN45@stbtt__cff
  000f1	85 db		 test	 ebx, ebx
  000f3	79 24		 jns	 SHORT $LN48@stbtt__cff
$LN45@stbtt__cff:
  000f5	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  000fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0010f	3b dd		 cmp	 ebx, ebp
  00111	7f 04		 jg	 SHORT $LN47@stbtt__cff
  00113	85 db		 test	 ebx, ebx
  00115	79 02		 jns	 SHORT $LN48@stbtt__cff
$LN47@stbtt__cff:
  00117	8b dd		 mov	 ebx, ebp
$LN48@stbtt__cff:

; 1253 :     start = stbtt__buf_get(&b, offsize);

  00119	41 8b d5	 mov	 edx, r13d

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0011c	41 89 5e 08	 mov	 DWORD PTR [r14+8], ebx

; 1253 :     start = stbtt__buf_get(&b, offsize);

  00120	49 8b ce	 mov	 rcx, r14
  00123	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get

; 1254 :     end = stbtt__buf_get(&b, offsize);

  00128	41 8b d5	 mov	 edx, r13d
  0012b	49 8b ce	 mov	 rcx, r14
  0012e	8b d8		 mov	 ebx, eax
  00130	e8 00 00 00 00	 call	 ?stbtt__buf_get@@YAIPEAUstbtt__buf@@H@Z ; stbtt__buf_get
  00135	8b d0		 mov	 edx, eax

; 1255 :     return stbtt__buf_range(&b, 2 + (count + 1) * offsize + start, end - start);

  00137	41 8d 4f 01	 lea	 ecx, DWORD PTR [r15+1]

; 1155 :     r.data = (stbtt_uint8*)p;

  0013b	33 c0		 xor	 eax, eax

; 1255 :     return stbtt__buf_range(&b, 2 + (count + 1) * offsize + start, end - start);

  0013d	41 0f af cd	 imul	 ecx, r13d

; 1155 :     r.data = (stbtt_uint8*)p;

  00141	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax

; 1255 :     return stbtt__buf_range(&b, 2 + (count + 1) * offsize + start, end - start);

  00146	44 8d 43 02	 lea	 r8d, DWORD PTR [rbx+2]

; 1157 :     r.cursor = 0;

  0014a	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp+8], rax

; 1255 :     return stbtt__buf_range(&b, 2 + (count + 1) * offsize + start, end - start);

  0014f	2b d3		 sub	 edx, ebx

; 1166 :     stbtt__buf r = stbtt__new_buf(NULL, 0);

  00151	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR $T1[rsp]

; 1255 :     return stbtt__buf_range(&b, 2 + (count + 1) * offsize + start, end - start);

  00156	44 03 c1	 add	 r8d, ecx

; 1166 :     stbtt__buf r = stbtt__new_buf(NULL, 0);

  00159	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0

; 1167 :     if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

  0015c	78 20		 js	 SHORT $LN69@stbtt__cff
  0015e	85 d2		 test	 edx, edx
  00160	78 1c		 js	 SHORT $LN69@stbtt__cff
  00162	41 8b 46 0c	 mov	 eax, DWORD PTR [r14+12]
  00166	44 3b c0	 cmp	 r8d, eax
  00169	7f 13		 jg	 SHORT $LN69@stbtt__cff
  0016b	41 2b c0	 sub	 eax, r8d
  0016e	3b d0		 cmp	 edx, eax
  00170	7f 0c		 jg	 SHORT $LN69@stbtt__cff

; 1168 :     r.data = b->data + o;

  00172	49 63 c0	 movsxd	 rax, r8d
  00175	49 03 06	 add	 rax, QWORD PTR [r14]
  00178	48 89 07	 mov	 QWORD PTR [rdi], rax

; 1169 :     r.size = s;

  0017b	89 57 0c	 mov	 DWORD PTR [rdi+12], edx
$LN69@stbtt__cff:

; 1256 : }

  0017e	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00183	48 8b c7	 mov	 rax, rdi
  00186	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0018b	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00190	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00194	41 5f		 pop	 r15
  00196	41 5e		 pop	 r14
  00198	41 5d		 pop	 r13
  0019a	41 5c		 pop	 r12
  0019c	5f		 pop	 rdi
  0019d	c3		 ret	 0
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ENDP	; stbtt__cff_index_get
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttUSHORT@@YAGPEAE@Z PROC				; ttUSHORT

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00008	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0000c	0f af c2	 imul	 eax, edx
  0000f	66 03 c1	 add	 ax, cx
  00012	c3		 ret	 0
?ttUSHORT@@YAGPEAE@Z ENDP				; ttUSHORT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttSHORT@@YAFPEAE@Z PROC				; ttSHORT

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00008	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0000c	0f bf d2	 movsx	 edx, dx
  0000f	0f af c2	 imul	 eax, edx
  00012	66 03 c1	 add	 ax, cx
  00015	c3		 ret	 0
?ttSHORT@@YAFPEAE@Z ENDP				; ttSHORT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttULONG@@YAIPEAE@Z PROC				; ttULONG

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  00000	0f b6 51 01	 movzx	 edx, BYTE PTR [rcx+1]
  00004	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00007	c1 e0 08	 shl	 eax, 8
  0000a	03 c2		 add	 eax, edx
  0000c	0f b6 51 02	 movzx	 edx, BYTE PTR [rcx+2]
  00010	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  00014	c1 e0 08	 shl	 eax, 8
  00017	03 c2		 add	 eax, edx
  00019	c1 e0 08	 shl	 eax, 8
  0001c	03 c1		 add	 eax, ecx
  0001e	c3		 ret	 0
?ttULONG@@YAIPEAE@Z ENDP				; ttULONG
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 8
?ttLONG@@YAHPEAE@Z PROC					; ttLONG

; 1273 : static stbtt_int32 ttLONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  00000	0f b6 51 01	 movzx	 edx, BYTE PTR [rcx+1]
  00004	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00007	c1 e0 08	 shl	 eax, 8
  0000a	03 c2		 add	 eax, edx
  0000c	0f b6 51 02	 movzx	 edx, BYTE PTR [rcx+2]
  00010	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  00014	c1 e0 08	 shl	 eax, 8
  00017	03 c2		 add	 eax, edx
  00019	c1 e0 08	 shl	 eax, 8
  0001c	03 c1		 add	 eax, ecx
  0001e	c3		 ret	 0
?ttLONG@@YAHPEAE@Z ENDP					; ttLONG
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
font$ = 8
?stbtt__isfont@@YAHPEAE@Z PROC				; stbtt__isfont

; 1280 :     // check the version number
; 1281 :     if (stbtt_tag4(font, '1', 0, 0, 0))  return 1; // TrueType 1

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	3c 31		 cmp	 al, 49			; 00000031H
  00005	75 12		 jne	 SHORT $LN2@stbtt__isf
  00007	80 79 01 00	 cmp	 BYTE PTR [rcx+1], 0
  0000b	75 67		 jne	 SHORT $LN6@stbtt__isf
  0000d	80 79 02 00	 cmp	 BYTE PTR [rcx+2], 0
  00011	75 61		 jne	 SHORT $LN6@stbtt__isf
  00013	80 79 03 00	 cmp	 BYTE PTR [rcx+3], 0
  00017	eb 53		 jmp	 SHORT $LN9@stbtt__isf
$LN2@stbtt__isf:

; 1282 :     if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!

  00019	3c 74		 cmp	 al, 116			; 00000074H
  0001b	75 12		 jne	 SHORT $LN3@stbtt__isf
  0001d	80 79 01 79	 cmp	 BYTE PTR [rcx+1], 121	; 00000079H
  00021	75 0c		 jne	 SHORT $LN3@stbtt__isf
  00023	80 79 02 70	 cmp	 BYTE PTR [rcx+2], 112	; 00000070H
  00027	75 06		 jne	 SHORT $LN3@stbtt__isf
  00029	80 79 03 31	 cmp	 BYTE PTR [rcx+3], 49	; 00000031H
  0002d	74 3f		 je	 SHORT $LN8@stbtt__isf
$LN3@stbtt__isf:

; 1283 :     if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF

  0002f	3c 4f		 cmp	 al, 79			; 0000004fH
  00031	75 11		 jne	 SHORT $LN4@stbtt__isf
  00033	80 79 01 54	 cmp	 BYTE PTR [rcx+1], 84	; 00000054H
  00037	75 3b		 jne	 SHORT $LN6@stbtt__isf
  00039	80 79 02 54	 cmp	 BYTE PTR [rcx+2], 84	; 00000054H
  0003d	75 35		 jne	 SHORT $LN6@stbtt__isf
  0003f	38 41 03	 cmp	 BYTE PTR [rcx+3], al
  00042	eb 28		 jmp	 SHORT $LN9@stbtt__isf
$LN4@stbtt__isf:

; 1284 :     if (stbtt_tag4(font, 0, 1, 0, 0)) return 1; // OpenType 1.0

  00044	84 c0		 test	 al, al
  00046	75 10		 jne	 SHORT $LN5@stbtt__isf
  00048	80 79 01 01	 cmp	 BYTE PTR [rcx+1], 1
  0004c	75 26		 jne	 SHORT $LN6@stbtt__isf
  0004e	38 41 02	 cmp	 BYTE PTR [rcx+2], al
  00051	75 21		 jne	 SHORT $LN6@stbtt__isf
  00053	38 41 03	 cmp	 BYTE PTR [rcx+3], al
  00056	eb 14		 jmp	 SHORT $LN9@stbtt__isf
$LN5@stbtt__isf:

; 1285 :     if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts

  00058	3c 74		 cmp	 al, 116			; 00000074H
  0005a	75 18		 jne	 SHORT $LN6@stbtt__isf
  0005c	80 79 01 72	 cmp	 BYTE PTR [rcx+1], 114	; 00000072H
  00060	75 12		 jne	 SHORT $LN6@stbtt__isf
  00062	80 79 02 75	 cmp	 BYTE PTR [rcx+2], 117	; 00000075H
  00066	75 0c		 jne	 SHORT $LN6@stbtt__isf
  00068	80 79 03 65	 cmp	 BYTE PTR [rcx+3], 101	; 00000065H
$LN9@stbtt__isf:
  0006c	75 06		 jne	 SHORT $LN6@stbtt__isf
$LN8@stbtt__isf:
  0006e	b8 01 00 00 00	 mov	 eax, 1

; 1287 : }

  00073	c3		 ret	 0
$LN6@stbtt__isf:

; 1286 :     return 0;

  00074	33 c0		 xor	 eax, eax

; 1287 : }

  00076	c3		 ret	 0
?stbtt__isfont@@YAHPEAE@Z ENDP				; stbtt__isfont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
data$ = 8
fontstart$ = 16
tag$ = 24
?stbtt__find_table@@YAIPEAEIPEBD@Z PROC			; stbtt__find_table

; 1291 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 1292 :     stbtt_int32 num_tables = ttUSHORT(data + fontstart + 4);

  0000a	8b c2		 mov	 eax, edx

; 1293 :     stbtt_uint32 tabledir = fontstart + 12;

  0000c	8d 7a 0c	 lea	 edi, DWORD PTR [rdx+12]

; 1294 :     stbtt_int32 i;
; 1295 :     for (i = 0; i < num_tables; ++i) {

  0000f	33 d2		 xor	 edx, edx
  00011	4c 8b d9	 mov	 r11, rcx
  00014	44 0f b6 54 08
	04		 movzx	 r10d, BYTE PTR [rax+rcx+4]
  0001a	0f b6 44 08 05	 movzx	 eax, BYTE PTR [rax+rcx+5]
  0001f	41 c1 e2 08	 shl	 r10d, 8
  00023	44 03 d0	 add	 r10d, eax
  00026	74 4f		 je	 SHORT $LN16@stbtt__fin
  00028	41 0f be 18	 movsx	 ebx, BYTE PTR [r8]
  0002c	0f 1f 40 00	 npad	 4
$LL4@stbtt__fin:

; 1296 :         stbtt_uint32 loc = tabledir + 16 * i;

  00030	8b c2		 mov	 eax, edx
  00032	c1 e0 04	 shl	 eax, 4
  00035	03 c7		 add	 eax, edi

; 1297 :         if (stbtt_tag(data + loc + 0, tag))

  00037	44 8b c8	 mov	 r9d, eax
  0003a	42 0f b6 04 18	 movzx	 eax, BYTE PTR [rax+r11]
  0003f	3b c3		 cmp	 eax, ebx
  00041	75 2d		 jne	 SHORT $LN2@stbtt__fin
  00043	43 0f b6 4c 19
	01		 movzx	 ecx, BYTE PTR [r9+r11+1]
  00049	41 0f be 40 01	 movsx	 eax, BYTE PTR [r8+1]
  0004e	3b c8		 cmp	 ecx, eax
  00050	75 1e		 jne	 SHORT $LN2@stbtt__fin
  00052	43 0f b6 4c 19
	02		 movzx	 ecx, BYTE PTR [r9+r11+2]
  00058	41 0f be 40 02	 movsx	 eax, BYTE PTR [r8+2]
  0005d	3b c8		 cmp	 ecx, eax
  0005f	75 0f		 jne	 SHORT $LN2@stbtt__fin
  00061	43 0f b6 4c 19
	03		 movzx	 ecx, BYTE PTR [r9+r11+3]
  00067	41 0f be 40 03	 movsx	 eax, BYTE PTR [r8+3]
  0006c	3b c8		 cmp	 ecx, eax
  0006e	74 14		 je	 SHORT $LN12@stbtt__fin
$LN2@stbtt__fin:

; 1294 :     stbtt_int32 i;
; 1295 :     for (i = 0; i < num_tables; ++i) {

  00070	ff c2		 inc	 edx
  00072	41 3b d2	 cmp	 edx, r10d
  00075	7c b9		 jl	 SHORT $LL4@stbtt__fin
$LN16@stbtt__fin:

; 1298 :             return ttULONG(data + loc + 8);
; 1299 :     }
; 1300 :     return 0;

  00077	33 c0		 xor	 eax, eax

; 1301 : }

  00079	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0007e	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  00083	c3		 ret	 0
$LN12@stbtt__fin:

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  00084	43 0f b6 4c 19
	09		 movzx	 ecx, BYTE PTR [r9+r11+9]
  0008a	43 0f b6 44 19
	08		 movzx	 eax, BYTE PTR [r9+r11+8]

; 1301 : }

  00090	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00095	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  0009a	c1 e0 08	 shl	 eax, 8
  0009d	03 c1		 add	 eax, ecx
  0009f	43 0f b6 4c 19
	0a		 movzx	 ecx, BYTE PTR [r9+r11+10]
  000a5	c1 e0 08	 shl	 eax, 8
  000a8	03 c1		 add	 eax, ecx
  000aa	43 0f b6 4c 19
	0b		 movzx	 ecx, BYTE PTR [r9+r11+11]
  000b0	c1 e0 08	 shl	 eax, 8
  000b3	03 c1		 add	 eax, ecx

; 1301 : }

  000b5	c3		 ret	 0
?stbtt__find_table@@YAIPEAEIPEBD@Z ENDP			; stbtt__find_table
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
font_collection$ = 8
index$ = 16
?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z PROC	; stbtt_GetFontOffsetForIndex_internal

; 1281 :     if (stbtt_tag4(font, '1', 0, 0, 0))  return 1; // TrueType 1

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 1304 : {

  00003	4c 8b c1	 mov	 r8, rcx

; 1281 :     if (stbtt_tag4(font, '1', 0, 0, 0))  return 1; // TrueType 1

  00006	3c 31		 cmp	 al, 49			; 00000031H
  00008	75 1a		 jne	 SHORT $LN9@stbtt_GetF
  0000a	80 79 01 00	 cmp	 BYTE PTR [rcx+1], 0
  0000e	0f 85 27 01 00
	00		 jne	 $LN4@stbtt_GetF
  00014	80 79 02 00	 cmp	 BYTE PTR [rcx+2], 0
  00018	0f 85 1d 01 00
	00		 jne	 $LN4@stbtt_GetF
  0001e	80 79 03 00	 cmp	 BYTE PTR [rcx+3], 0
  00022	eb 6b		 jmp	 SHORT $LN26@stbtt_GetF
$LN9@stbtt_GetF:

; 1282 :     if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!

  00024	3c 74		 cmp	 al, 116			; 00000074H
  00026	75 12		 jne	 SHORT $LN10@stbtt_GetF
  00028	80 79 01 79	 cmp	 BYTE PTR [rcx+1], 121	; 00000079H
  0002c	75 0c		 jne	 SHORT $LN10@stbtt_GetF
  0002e	80 79 02 70	 cmp	 BYTE PTR [rcx+2], 112	; 00000070H
  00032	75 06		 jne	 SHORT $LN10@stbtt_GetF
  00034	80 79 03 31	 cmp	 BYTE PTR [rcx+3], 49	; 00000031H
  00038	74 5b		 je	 SHORT $LN23@stbtt_GetF
$LN10@stbtt_GetF:

; 1283 :     if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF

  0003a	3c 4f		 cmp	 al, 79			; 0000004fH
  0003c	75 19		 jne	 SHORT $LN11@stbtt_GetF
  0003e	80 79 01 54	 cmp	 BYTE PTR [rcx+1], 84	; 00000054H
  00042	0f 85 f3 00 00
	00		 jne	 $LN4@stbtt_GetF
  00048	80 79 02 54	 cmp	 BYTE PTR [rcx+2], 84	; 00000054H
  0004c	0f 85 e9 00 00
	00		 jne	 $LN4@stbtt_GetF
  00052	38 41 03	 cmp	 BYTE PTR [rcx+3], al
  00055	eb 38		 jmp	 SHORT $LN26@stbtt_GetF
$LN11@stbtt_GetF:

; 1284 :     if (stbtt_tag4(font, 0, 1, 0, 0)) return 1; // OpenType 1.0

  00057	84 c0		 test	 al, al
  00059	75 18		 jne	 SHORT $LN12@stbtt_GetF
  0005b	80 79 01 01	 cmp	 BYTE PTR [rcx+1], 1
  0005f	0f 85 d6 00 00
	00		 jne	 $LN4@stbtt_GetF
  00065	38 41 02	 cmp	 BYTE PTR [rcx+2], al
  00068	0f 85 cd 00 00
	00		 jne	 $LN4@stbtt_GetF
  0006e	38 41 03	 cmp	 BYTE PTR [rcx+3], al
  00071	eb 1c		 jmp	 SHORT $LN26@stbtt_GetF
$LN12@stbtt_GetF:

; 1285 :     if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts

  00073	3c 74		 cmp	 al, 116			; 00000074H
  00075	0f 85 c0 00 00
	00		 jne	 $LN4@stbtt_GetF
  0007b	80 79 01 72	 cmp	 BYTE PTR [rcx+1], 114	; 00000072H
  0007f	75 19		 jne	 SHORT $LN24@stbtt_GetF
  00081	80 79 02 75	 cmp	 BYTE PTR [rcx+2], 117	; 00000075H
  00085	0f 85 b0 00 00
	00		 jne	 $LN4@stbtt_GetF
  0008b	80 79 03 65	 cmp	 BYTE PTR [rcx+3], 101	; 00000065H
$LN26@stbtt_GetF:

; 1305 :     // if it's just a font, there's only one valid index
; 1306 :     if (stbtt__isfont(font_collection))
; 1307 :         return index == 0 ? 0 : -1;

  0008f	0f 85 a6 00 00
	00		 jne	 $LN4@stbtt_GetF
$LN23@stbtt_GetF:
  00095	f7 da		 neg	 edx
  00097	1b c0		 sbb	 eax, eax

; 1320 : }

  00099	c3		 ret	 0
$LN24@stbtt_GetF:

; 1308 : 
; 1309 :     // check if it's a TTC
; 1310 :     if (stbtt_tag(font_collection, "ttcf")) {

  0009a	80 79 01 74	 cmp	 BYTE PTR [rcx+1], 116	; 00000074H
  0009e	0f 85 97 00 00
	00		 jne	 $LN4@stbtt_GetF
  000a4	80 79 02 63	 cmp	 BYTE PTR [rcx+2], 99	; 00000063H
  000a8	0f 85 8d 00 00
	00		 jne	 $LN4@stbtt_GetF
  000ae	80 79 03 66	 cmp	 BYTE PTR [rcx+3], 102	; 00000066H
  000b2	0f 85 83 00 00
	00		 jne	 $LN4@stbtt_GetF

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  000b8	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  000bc	41 0f b6 40 06	 movzx	 eax, BYTE PTR [r8+6]
  000c1	c1 e0 08	 shl	 eax, 8
  000c4	c1 e1 10	 shl	 ecx, 16
  000c7	03 c8		 add	 ecx, eax
  000c9	41 0f b6 40 04	 movzx	 eax, BYTE PTR [r8+4]
  000ce	c1 e0 18	 shl	 eax, 24
  000d1	03 c8		 add	 ecx, eax
  000d3	41 0f b6 40 07	 movzx	 eax, BYTE PTR [r8+7]
  000d8	05 00 00 ff ff	 add	 eax, -65536		; ffff0000H
  000dd	03 c8		 add	 ecx, eax

; 1311 :         // version 1?
; 1312 :         if (ttULONG(font_collection + 4) == 0x00010000 || ttULONG(font_collection + 4) == 0x00020000) {

  000df	f7 c1 ff ff fe
	ff		 test	 ecx, -65537		; fffeffffH
  000e5	75 54		 jne	 SHORT $LN4@stbtt_GetF

; 1273 : static stbtt_int32 ttLONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  000e7	41 0f b6 40 09	 movzx	 eax, BYTE PTR [r8+9]
  000ec	41 0f b6 48 08	 movzx	 ecx, BYTE PTR [r8+8]
  000f1	c1 e1 08	 shl	 ecx, 8
  000f4	03 c8		 add	 ecx, eax
  000f6	41 0f b6 40 0a	 movzx	 eax, BYTE PTR [r8+10]
  000fb	c1 e1 08	 shl	 ecx, 8
  000fe	03 c8		 add	 ecx, eax
  00100	41 0f b6 40 0b	 movzx	 eax, BYTE PTR [r8+11]
  00105	c1 e1 08	 shl	 ecx, 8
  00108	03 c8		 add	 ecx, eax

; 1313 :             stbtt_int32 n = ttLONG(font_collection + 8);
; 1314 :             if (index >= n)

  0010a	3b d1		 cmp	 edx, ecx
  0010c	7d 2d		 jge	 SHORT $LN4@stbtt_GetF

; 1315 :                 return -1;
; 1316 :             return ttULONG(font_collection + 12 + index * 4);

  0010e	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [rdx*4]
  00115	48 63 d0	 movsxd	 rdx, eax
  00118	49 03 d0	 add	 rdx, r8

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  0011b	0f b6 4a 0d	 movzx	 ecx, BYTE PTR [rdx+13]
  0011f	0f b6 42 0c	 movzx	 eax, BYTE PTR [rdx+12]
  00123	c1 e0 08	 shl	 eax, 8
  00126	03 c1		 add	 eax, ecx
  00128	0f b6 4a 0e	 movzx	 ecx, BYTE PTR [rdx+14]
  0012c	c1 e0 08	 shl	 eax, 8
  0012f	03 c1		 add	 eax, ecx
  00131	0f b6 4a 0f	 movzx	 ecx, BYTE PTR [rdx+15]
  00135	c1 e0 08	 shl	 eax, 8
  00138	03 c1		 add	 eax, ecx

; 1320 : }

  0013a	c3		 ret	 0
$LN4@stbtt_GetF:

; 1317 :         }
; 1318 :     }
; 1319 :     return -1;

  0013b	b8 ff ff ff ff	 mov	 eax, -1

; 1320 : }

  00140	c3		 ret	 0
?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ENDP	; stbtt_GetFontOffsetForIndex_internal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
operands$1 = 32
$T2 = 32
operands$3 = 32
$T4 = 32
pdict$ = 32
$T5 = 48
subrsoff$ = 96
$T6 = 96
cff$ = 104
fontdict$ = 112
private_loc$ = 120
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z PROC		; stbtt__get_subrs

; 1339 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1340 :     stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };

  00012	45 33 f6	 xor	 r14d, r14d
  00015	49 8b c0	 mov	 rax, r8
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	44 89 74 24 60	 mov	 DWORD PTR subrsoff$[rsp], r14d
  00020	48 8b f9	 mov	 rdi, rcx
  00023	4c 89 74 24 78	 mov	 QWORD PTR private_loc$[rsp], r14

; 1233 :     stbtt__buf operands = stbtt__dict_get(b, key);

  00028	48 8b d0	 mov	 rdx, rax
  0002b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T2[rsp]
  00030	45 8d 46 12	 lea	 r8d, QWORD PTR [r14+18]
  00034	e8 00 00 00 00	 call	 ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
  00039	41 8b de	 mov	 ebx, r14d
  0003c	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0003f	0f 11 44 24 20	 movups	 XMMWORD PTR operands$3[rsp], xmm0
$LL9@stbtt__get:

; 1234 :     for (i = 0; i < outcount && operands.cursor < operands.size; i++)

  00044	8b 44 24 2c	 mov	 eax, DWORD PTR operands$3[rsp+12]
  00048	39 44 24 28	 cmp	 DWORD PTR operands$3[rsp+8], eax
  0004c	7d 17		 jge	 SHORT $LN8@stbtt__get

; 1235 :         out[i] = stbtt__cff_int(&operands);

  0004e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR operands$3[rsp]
  00053	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  00058	89 44 9c 78	 mov	 DWORD PTR private_loc$[rsp+rbx*4], eax
  0005c	48 ff c3	 inc	 rbx
  0005f	48 83 fb 02	 cmp	 rbx, 2
  00063	7c df		 jl	 SHORT $LL9@stbtt__get
$LN8@stbtt__get:

; 1341 :     stbtt__buf pdict;
; 1342 :     stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
; 1343 :     if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);

  00065	48 63 74 24 7c	 movsxd	 rsi, DWORD PTR private_loc$[rsp+4]
  0006a	85 f6		 test	 esi, esi
  0006c	0f 84 d9 00 00
	00		 je	 $LN14@stbtt__get
  00072	8b 4c 24 78	 mov	 ecx, DWORD PTR private_loc$[rsp]
  00076	85 c9		 test	 ecx, ecx
  00078	0f 84 cd 00 00
	00		 je	 $LN14@stbtt__get

; 1166 :     stbtt__buf r = stbtt__new_buf(NULL, 0);

  0007e	4c 89 74 24 20	 mov	 QWORD PTR $T4[rsp], r14
  00083	4c 89 74 24 28	 mov	 QWORD PTR $T4[rsp+8], r14

; 1167 :     if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

  00088	85 f6		 test	 esi, esi
  0008a	78 21		 js	 SHORT $LN19@stbtt__get
  0008c	85 c9		 test	 ecx, ecx
  0008e	78 1d		 js	 SHORT $LN19@stbtt__get
  00090	8b 45 0c	 mov	 eax, DWORD PTR [rbp+12]
  00093	3b f0		 cmp	 esi, eax
  00095	7f 16		 jg	 SHORT $LN19@stbtt__get
  00097	2b c6		 sub	 eax, esi
  00099	3b c8		 cmp	 ecx, eax
  0009b	7f 10		 jg	 SHORT $LN19@stbtt__get

; 1168 :     r.data = b->data + o;

  0009d	48 8b c6	 mov	 rax, rsi

; 1169 :     r.size = s;

  000a0	89 4c 24 2c	 mov	 DWORD PTR $T4[rsp+12], ecx
  000a4	48 03 45 00	 add	 rax, QWORD PTR [rbp]
  000a8	48 89 44 24 20	 mov	 QWORD PTR $T4[rsp], rax
$LN19@stbtt__get:

; 1344 :     pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);

  000ad	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR $T4[rsp]

; 1233 :     stbtt__buf operands = stbtt__dict_get(b, key);

  000b2	48 8d 54 24 20	 lea	 rdx, QWORD PTR pdict$[rsp]
  000b7	41 b8 13 00 00
	00		 mov	 r8d, 19

; 1344 :     pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);

  000bd	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR pdict$[rsp], xmm0

; 1233 :     stbtt__buf operands = stbtt__dict_get(b, key);

  000c3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T5[rsp]
  000c8	e8 00 00 00 00	 call	 ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
  000cd	49 8b de	 mov	 rbx, r14
  000d0	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000d3	0f 11 44 24 20	 movups	 XMMWORD PTR operands$1[rsp], xmm0
  000d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL30@stbtt__get:

; 1234 :     for (i = 0; i < outcount && operands.cursor < operands.size; i++)

  000e0	8b 44 24 2c	 mov	 eax, DWORD PTR operands$1[rsp+12]
  000e4	39 44 24 28	 cmp	 DWORD PTR operands$1[rsp+8], eax
  000e8	7d 17		 jge	 SHORT $LN29@stbtt__get

; 1235 :         out[i] = stbtt__cff_int(&operands);

  000ea	48 8d 4c 24 20	 lea	 rcx, QWORD PTR operands$1[rsp]
  000ef	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  000f4	89 44 9c 60	 mov	 DWORD PTR subrsoff$[rsp+rbx*4], eax
  000f8	48 ff c3	 inc	 rbx
  000fb	48 83 fb 01	 cmp	 rbx, 1
  000ff	7c df		 jl	 SHORT $LL30@stbtt__get
$LN29@stbtt__get:

; 1345 :     stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
; 1346 :     if (!subrsoff) return stbtt__new_buf(NULL, 0);

  00101	8b 44 24 60	 mov	 eax, DWORD PTR subrsoff$[rsp]
  00105	85 c0		 test	 eax, eax
  00107	74 42		 je	 SHORT $LN14@stbtt__get

; 1347 :     stbtt__buf_seek(&cff, private_loc[1] + subrsoff);

  00109	8d 1c 06	 lea	 ebx, DWORD PTR [rsi+rax]

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  0010c	8b 75 0c	 mov	 esi, DWORD PTR [rbp+12]
  0010f	3b de		 cmp	 ebx, esi
  00111	7f 04		 jg	 SHORT $LN43@stbtt__get
  00113	85 db		 test	 ebx, ebx
  00115	79 24		 jns	 SHORT $LN46@stbtt__get
$LN43@stbtt__get:
  00117	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  00131	3b de		 cmp	 ebx, esi
  00133	7f 04		 jg	 SHORT $LN45@stbtt__get
  00135	85 db		 test	 ebx, ebx
  00137	79 02		 jns	 SHORT $LN46@stbtt__get
$LN45@stbtt__get:
  00139	8b de		 mov	 ebx, esi
$LN46@stbtt__get:

; 1348 :     return stbtt__cff_get_index(&cff);

  0013b	48 8b d5	 mov	 rdx, rbp

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0013e	89 5d 08	 mov	 DWORD PTR [rbp+8], ebx

; 1348 :     return stbtt__cff_get_index(&cff);

  00141	48 8b cf	 mov	 rcx, rdi
  00144	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
  00149	eb 07		 jmp	 SHORT $LN57@stbtt__get
$LN14@stbtt__get:

; 1349 : }

  0014b	4c 89 77 08	 mov	 QWORD PTR [rdi+8], r14
  0014f	4c 89 37	 mov	 QWORD PTR [rdi], r14
$LN57@stbtt__get:
  00152	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00157	48 8b c7	 mov	 rax, rdi
  0015a	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0015f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00163	41 5e		 pop	 r14
  00165	5f		 pop	 rdi
  00166	5e		 pop	 rsi
  00167	c3		 ret	 0
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ENDP		; stbtt__get_subrs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
fdselectoff$1 = 32
b$2 = 48
$T3 = 64
$T4 = 64
$T5 = 64
topdict$6 = 64
$T7 = 64
$T8 = 64
$T9 = 64
$T10 = 64
$T11 = 80
operands$12 = 80
$T13 = 80
operands$14 = 80
$T15 = 80
operands$16 = 80
$T17 = 80
operands$18 = 80
$T19 = 80
$T20 = 80
$T21 = 80
$T22 = 80
$T23 = 80
$T24 = 80
$T25 = 96
$T26 = 96
$T27 = 96
tv1245 = 192
cstype$28 = 192
info$ = 192
tv1246 = 200
charstrings$29 = 200
data$ = 200
fontstart$ = 208
fdarrayoff$30 = 216
?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z PROC ; stbtt_InitFont_internal

; 1352 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 8b ec	 mov	 rbp, rsp
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00018	4c 8b e2	 mov	 r12, rdx

; 1353 :     stbtt_uint32 cmap, t;
; 1354 :     stbtt_int32 i, numTables;
; 1355 : 
; 1356 :     info->data = data;

  0001b	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 1357 :     info->fontstart = fontstart;

  0001f	44 89 41 10	 mov	 DWORD PTR [rcx+16], r8d

; 1155 :     r.data = (stbtt_uint8*)p;

  00023	33 db		 xor	 ebx, ebx

; 1352 : {

  00025	45 8b e8	 mov	 r13d, r8d

; 1155 :     r.data = (stbtt_uint8*)p;

  00028	48 89 5d c8	 mov	 QWORD PTR $T10[rbp-120], rbx

; 1352 : {

  0002c	48 8b f1	 mov	 rsi, rcx

; 1157 :     r.cursor = 0;

  0002f	48 89 5d d0	 mov	 QWORD PTR $T10[rbp-112], rbx

; 1358 :     info->cff = stbtt__new_buf(NULL, 0);

  00033	0f 10 45 c8	 movups	 xmm0, XMMWORD PTR $T10[rbp-120]

; 1359 : 
; 1360 :     cmap = stbtt__find_table(data, fontstart, "cmap");       // required

  00037	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04EICJPCEA@cmap@
  0003e	41 8b d5	 mov	 edx, r13d
  00041	0f 11 41 40	 movups	 XMMWORD PTR [rcx+64], xmm0
  00045	49 8b cc	 mov	 rcx, r12
  00048	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table

; 1361 :     info->loca = stbtt__find_table(data, fontstart, "loca"); // required

  0004d	41 8b d5	 mov	 edx, r13d
  00050	44 8b f0	 mov	 r14d, eax
  00053	49 8b cc	 mov	 rcx, r12
  00056	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04DACNFKGE@loca@
  0005d	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table

; 1362 :     info->head = stbtt__find_table(data, fontstart, "head"); // required

  00062	41 8b d5	 mov	 edx, r13d
  00065	89 46 18	 mov	 DWORD PTR [rsi+24], eax
  00068	49 8b cc	 mov	 rcx, r12
  0006b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04NEODDMOL@head@
  00072	44 8b f8	 mov	 r15d, eax
  00075	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table

; 1363 :     info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required

  0007a	41 8b d5	 mov	 edx, r13d
  0007d	89 46 1c	 mov	 DWORD PTR [rsi+28], eax
  00080	49 8b cc	 mov	 rcx, r12
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04LLIHEPK@glyf@
  0008a	8b f8		 mov	 edi, eax
  0008c	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table

; 1364 :     info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required

  00091	41 8b d5	 mov	 edx, r13d
  00094	89 45 50	 mov	 DWORD PTR tv1246[rbp-120], eax
  00097	49 8b cc	 mov	 rcx, r12
  0009a	89 46 20	 mov	 DWORD PTR [rsi+32], eax
  0009d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04FMPHLIKP@hhea@
  000a4	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table

; 1365 :     info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required

  000a9	8b 55 58	 mov	 edx, DWORD PTR fontstart$[rbp-120]
  000ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04ONMNCIMC@hmtx@
  000b3	49 8b cc	 mov	 rcx, r12
  000b6	89 46 24	 mov	 DWORD PTR [rsi+36], eax
  000b9	44 8b e8	 mov	 r13d, eax
  000bc	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table

; 1366 :     info->kern = stbtt__find_table(data, fontstart, "kern"); // not required

  000c1	8b 55 58	 mov	 edx, DWORD PTR fontstart$[rbp-120]
  000c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04HHMMLDJI@kern@
  000cb	49 8b cc	 mov	 rcx, r12
  000ce	89 45 48	 mov	 DWORD PTR tv1245[rbp-120], eax
  000d1	89 46 28	 mov	 DWORD PTR [rsi+40], eax
  000d4	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table

; 1367 :     info->gpos = stbtt__find_table(data, fontstart, "GPOS"); // not required

  000d9	8b 55 58	 mov	 edx, DWORD PTR fontstart$[rbp-120]
  000dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04PCFDEHHD@GPOS@
  000e3	49 8b cc	 mov	 rcx, r12
  000e6	89 46 2c	 mov	 DWORD PTR [rsi+44], eax
  000e9	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table
  000ee	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1368 : 
; 1369 :     if (!cmap || !info->head || !info->hhea || !info->hmtx)

  000f1	45 85 f6	 test	 r14d, r14d
  000f4	74 1c		 je	 SHORT $LN10@stbtt_Init
  000f6	85 ff		 test	 edi, edi
  000f8	74 18		 je	 SHORT $LN10@stbtt_Init
  000fa	45 85 ed	 test	 r13d, r13d
  000fd	74 13		 je	 SHORT $LN10@stbtt_Init
  000ff	39 5d 48	 cmp	 DWORD PTR tv1245[rbp-120], ebx
  00102	74 0e		 je	 SHORT $LN10@stbtt_Init

; 1371 :     if (info->glyf) {

  00104	39 5d 50	 cmp	 DWORD PTR tv1246[rbp-120], ebx
  00107	74 1c		 je	 SHORT $LN11@stbtt_Init

; 1372 :         // required for truetype
; 1373 :         if (!info->loca) return 0;

  00109	45 85 ff	 test	 r15d, r15d
  0010c	0f 85 6d 03 00
	00		 jne	 $LN12@stbtt_Init
$LN10@stbtt_Init:

; 1370 :         return 0;

  00112	33 c0		 xor	 eax, eax
$LN1@stbtt_Init:

; 1461 : }

  00114	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00118	41 5f		 pop	 r15
  0011a	41 5e		 pop	 r14
  0011c	41 5d		 pop	 r13
  0011e	41 5c		 pop	 r12
  00120	5f		 pop	 rdi
  00121	5e		 pop	 rsi
  00122	5b		 pop	 rbx
  00123	5d		 pop	 rbp
  00124	c3		 ret	 0
$LN11@stbtt_Init:

; 1374 :     }
; 1375 :     else {
; 1376 :         // initialization for CFF / Type2 fonts (OTF)
; 1377 :         stbtt__buf b, topdict, topdictidx;
; 1378 :         stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
; 1379 :         stbtt_uint32 cff;
; 1380 : 
; 1381 :         cff = stbtt__find_table(data, fontstart, "CFF ");

  00125	8b 55 58	 mov	 edx, DWORD PTR fontstart$[rbp-120]
  00128	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04HJGCPIEK@CFF?5@
  0012f	49 8b cc	 mov	 rcx, r12
  00132	c7 45 48 02 00
	00 00		 mov	 DWORD PTR cstype$28[rbp-120], 2
  00139	89 5d 50	 mov	 DWORD PTR charstrings$29[rbp-120], ebx
  0013c	89 5d 60	 mov	 DWORD PTR fdarrayoff$30[rbp-120], ebx
  0013f	89 5d a8	 mov	 DWORD PTR fdselectoff$1[rbp-120], ebx
  00142	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table

; 1382 :         if (!cff) return 0;

  00147	85 c0		 test	 eax, eax
  00149	74 c7		 je	 SHORT $LN10@stbtt_Init

; 1155 :     r.data = (stbtt_uint8*)p;

  0014b	48 89 5d c8	 mov	 QWORD PTR $T9[rbp-120], rbx

; 1157 :     r.cursor = 0;

  0014f	48 89 5d d0	 mov	 QWORD PTR $T9[rbp-112], rbx

; 1383 : 
; 1384 :         info->fontdicts = stbtt__new_buf(NULL, 0);

  00153	0f 10 45 c8	 movups	 xmm0, XMMWORD PTR $T9[rbp-120]

; 1157 :     r.cursor = 0;

  00157	48 89 5d d0	 mov	 QWORD PTR $T8[rbp-112], rbx
  0015b	48 89 5d c8	 mov	 QWORD PTR $T8[rbp-120], rbx

; 1383 : 
; 1384 :         info->fontdicts = stbtt__new_buf(NULL, 0);

  0015f	0f 11 86 80 00
	00 00		 movups	 XMMWORD PTR [rsi+128], xmm0

; 1386 : 
; 1387 :         // @TODO this should use size from table (not 512MB)
; 1388 :         info->cff = stbtt__new_buf(data + cff, 512 * 1024 * 1024);

  00166	8b c0		 mov	 eax, eax
  00168	0f 10 45 c8	 movups	 xmm0, XMMWORD PTR $T8[rbp-120]
  0016c	49 03 c4	 add	 rax, r12

; 1156 :     r.size = (int)size;

  0016f	c7 45 d4 00 00
	00 20		 mov	 DWORD PTR $T7[rbp-108], 536870912 ; 20000000H
  00176	48 89 45 c8	 mov	 QWORD PTR $T7[rbp-120], rax

; 1385 :         info->fdselect = stbtt__new_buf(NULL, 0);

  0017a	0f 11 86 90 00
	00 00		 movups	 XMMWORD PTR [rsi+144], xmm0

; 1157 :     r.cursor = 0;

  00181	89 5d d0	 mov	 DWORD PTR $T7[rbp-112], ebx

; 1386 : 
; 1387 :         // @TODO this should use size from table (not 512MB)
; 1388 :         info->cff = stbtt__new_buf(data + cff, 512 * 1024 * 1024);

  00184	0f 28 45 c8	 movaps	 xmm0, XMMWORD PTR $T7[rbp-120]
  00188	0f 11 46 40	 movups	 XMMWORD PTR [rsi+64], xmm0

; 1389 :         b = info->cff;

  0018c	66 0f 7f 45 b8	 movdqa	 XMMWORD PTR b$2[rbp-120], xmm0

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00191	66 0f 73 d8 08	 psrldq	 xmm0, 8
  00196	66 48 0f 7e c0	 movq	 rax, xmm0
  0019b	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0019f	83 f8 02	 cmp	 eax, 2
  001a2	7d 1a		 jge	 SHORT $LN157@stbtt_Init
  001a4	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  001aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  001b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN157@stbtt_Init:

; 1118 :     if (b->cursor >= b->size)

  001be	8b 7d c4	 mov	 edi, DWORD PTR b$2[rbp-108]
  001c1	83 ff 02	 cmp	 edi, 2
  001c4	7f 04		 jg	 SHORT $LN63@stbtt_Init

; 1119 :         return 0;

  001c6	32 c0		 xor	 al, al
  001c8	eb 08		 jmp	 SHORT $LN62@stbtt_Init
$LN63@stbtt_Init:

; 1120 :     return b->data[b->cursor++];

  001ca	48 8b 45 b8	 mov	 rax, QWORD PTR b$2[rbp-120]
  001ce	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
$LN62@stbtt_Init:

; 1390 : 
; 1391 :         // read the header
; 1392 :         stbtt__buf_skip(&b, 2);
; 1393 :         stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

  001d2	0f b6 c0	 movzx	 eax, al

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  001d5	3b c7		 cmp	 eax, edi
  001d7	7e 1f		 jle	 SHORT $LN158@stbtt_Init
  001d9	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  001f3	89 7d c0	 mov	 DWORD PTR b$2[rbp-112], edi
  001f6	eb 03		 jmp	 SHORT $LN73@stbtt_Init
$LN158@stbtt_Init:
  001f8	89 45 c0	 mov	 DWORD PTR b$2[rbp-112], eax
$LN73@stbtt_Init:

; 1394 : 
; 1395 :         // @TODO the name INDEX could list multiple fonts,
; 1396 :         // but we just use the first one.
; 1397 :         stbtt__cff_get_index(&b);  // name INDEX

  001fb	48 8d 55 b8	 lea	 rdx, QWORD PTR b$2[rbp-120]
  001ff	48 8d 4d d8	 lea	 rcx, QWORD PTR $T24[rbp-120]
  00203	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1398 :         topdictidx = stbtt__cff_get_index(&b);

  00208	48 8d 55 b8	 lea	 rdx, QWORD PTR b$2[rbp-120]
  0020c	48 8d 4d d8	 lea	 rcx, QWORD PTR $T23[rbp-120]
  00210	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1399 :         topdict = stbtt__cff_index_get(topdictidx, 0);

  00215	45 33 c0	 xor	 r8d, r8d
  00218	48 8d 55 d8	 lea	 rdx, QWORD PTR $T20[rbp-120]
  0021c	48 8d 4d c8	 lea	 rcx, QWORD PTR $T5[rbp-120]
  00220	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00223	0f 29 45 d8	 movaps	 XMMWORD PTR $T20[rbp-120], xmm0
  00227	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get

; 1400 :         stbtt__cff_get_index(&b);  // string INDEX

  0022c	48 8d 55 b8	 lea	 rdx, QWORD PTR b$2[rbp-120]
  00230	48 8d 4d d8	 lea	 rcx, QWORD PTR $T22[rbp-120]
  00234	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00237	0f 29 45 c8	 movaps	 XMMWORD PTR topdict$6[rbp-120], xmm0
  0023b	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1401 :         info->gsubrs = stbtt__cff_get_index(&b);

  00240	48 8d 55 b8	 lea	 rdx, QWORD PTR b$2[rbp-120]
  00244	48 8d 4d d8	 lea	 rcx, QWORD PTR $T21[rbp-120]
  00248	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1233 :     stbtt__buf operands = stbtt__dict_get(b, key);

  0024d	41 b8 11 00 00
	00		 mov	 r8d, 17
  00253	48 8d 55 c8	 lea	 rdx, QWORD PTR topdict$6[rbp-120]
  00257	48 8d 4d d8	 lea	 rcx, QWORD PTR $T17[rbp-120]

; 1401 :         info->gsubrs = stbtt__cff_get_index(&b);

  0025b	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0025e	0f 11 46 60	 movups	 XMMWORD PTR [rsi+96], xmm0

; 1233 :     stbtt__buf operands = stbtt__dict_get(b, key);

  00262	e8 00 00 00 00	 call	 ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
  00267	48 8b fb	 mov	 rdi, rbx
  0026a	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0026d	0f 11 45 d8	 movups	 XMMWORD PTR operands$18[rbp-120], xmm0
$LL77@stbtt_Init:

; 1234 :     for (i = 0; i < outcount && operands.cursor < operands.size; i++)

  00271	8b 45 e4	 mov	 eax, DWORD PTR operands$18[rbp-108]
  00274	39 45 e0	 cmp	 DWORD PTR operands$18[rbp-112], eax
  00277	7d 16		 jge	 SHORT $LN76@stbtt_Init

; 1235 :         out[i] = stbtt__cff_int(&operands);

  00279	48 8d 4d d8	 lea	 rcx, QWORD PTR operands$18[rbp-120]
  0027d	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  00282	89 44 bd 50	 mov	 DWORD PTR charstrings$29[rbp+rdi*4-120], eax
  00286	48 ff c7	 inc	 rdi
  00289	48 83 ff 01	 cmp	 rdi, 1
  0028d	7c e2		 jl	 SHORT $LL77@stbtt_Init
$LN76@stbtt_Init:

; 1233 :     stbtt__buf operands = stbtt__dict_get(b, key);

  0028f	41 b8 06 01 00
	00		 mov	 r8d, 262		; 00000106H
  00295	48 8d 55 c8	 lea	 rdx, QWORD PTR topdict$6[rbp-120]
  00299	48 8d 4d d8	 lea	 rcx, QWORD PTR $T15[rbp-120]
  0029d	e8 00 00 00 00	 call	 ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
  002a2	48 8b fb	 mov	 rdi, rbx
  002a5	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  002a8	0f 11 45 d8	 movups	 XMMWORD PTR operands$16[rbp-120], xmm0
  002ac	0f 1f 40 00	 npad	 4
$LL82@stbtt_Init:

; 1234 :     for (i = 0; i < outcount && operands.cursor < operands.size; i++)

  002b0	8b 45 e4	 mov	 eax, DWORD PTR operands$16[rbp-108]
  002b3	39 45 e0	 cmp	 DWORD PTR operands$16[rbp-112], eax
  002b6	7d 16		 jge	 SHORT $LN81@stbtt_Init

; 1235 :         out[i] = stbtt__cff_int(&operands);

  002b8	48 8d 4d d8	 lea	 rcx, QWORD PTR operands$16[rbp-120]
  002bc	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  002c1	89 44 bd 48	 mov	 DWORD PTR cstype$28[rbp+rdi*4-120], eax
  002c5	48 ff c7	 inc	 rdi
  002c8	48 83 ff 01	 cmp	 rdi, 1
  002cc	7c e2		 jl	 SHORT $LL82@stbtt_Init
$LN81@stbtt_Init:

; 1233 :     stbtt__buf operands = stbtt__dict_get(b, key);

  002ce	41 b8 24 01 00
	00		 mov	 r8d, 292		; 00000124H
  002d4	48 8d 55 c8	 lea	 rdx, QWORD PTR topdict$6[rbp-120]
  002d8	48 8d 4d d8	 lea	 rcx, QWORD PTR $T13[rbp-120]
  002dc	e8 00 00 00 00	 call	 ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
  002e1	48 8b fb	 mov	 rdi, rbx
  002e4	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  002e7	0f 11 45 d8	 movups	 XMMWORD PTR operands$14[rbp-120], xmm0
  002eb	0f 1f 44 00 00	 npad	 5
$LL87@stbtt_Init:

; 1234 :     for (i = 0; i < outcount && operands.cursor < operands.size; i++)

  002f0	8b 45 e4	 mov	 eax, DWORD PTR operands$14[rbp-108]
  002f3	39 45 e0	 cmp	 DWORD PTR operands$14[rbp-112], eax
  002f6	7d 16		 jge	 SHORT $LN86@stbtt_Init

; 1235 :         out[i] = stbtt__cff_int(&operands);

  002f8	48 8d 4d d8	 lea	 rcx, QWORD PTR operands$14[rbp-120]
  002fc	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  00301	89 44 bd 60	 mov	 DWORD PTR fdarrayoff$30[rbp+rdi*4-120], eax
  00305	48 ff c7	 inc	 rdi
  00308	48 83 ff 01	 cmp	 rdi, 1
  0030c	7c e2		 jl	 SHORT $LL87@stbtt_Init
$LN86@stbtt_Init:

; 1233 :     stbtt__buf operands = stbtt__dict_get(b, key);

  0030e	41 b8 25 01 00
	00		 mov	 r8d, 293		; 00000125H
  00314	48 8d 55 c8	 lea	 rdx, QWORD PTR topdict$6[rbp-120]
  00318	48 8d 4d d8	 lea	 rcx, QWORD PTR $T11[rbp-120]
  0031c	e8 00 00 00 00	 call	 ?stbtt__dict_get@@YA?AUstbtt__buf@@PEAU1@H@Z ; stbtt__dict_get
  00321	48 8b fb	 mov	 rdi, rbx
  00324	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00327	0f 11 45 d8	 movups	 XMMWORD PTR operands$12[rbp-120], xmm0
  0032b	0f 1f 44 00 00	 npad	 5
$LL92@stbtt_Init:

; 1234 :     for (i = 0; i < outcount && operands.cursor < operands.size; i++)

  00330	8b 45 e4	 mov	 eax, DWORD PTR operands$12[rbp-108]
  00333	39 45 e0	 cmp	 DWORD PTR operands$12[rbp-112], eax
  00336	7d 16		 jge	 SHORT $LN91@stbtt_Init

; 1235 :         out[i] = stbtt__cff_int(&operands);

  00338	48 8d 4d d8	 lea	 rcx, QWORD PTR operands$12[rbp-120]
  0033c	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  00341	89 44 bd a8	 mov	 DWORD PTR fdselectoff$1[rbp+rdi*4-120], eax
  00345	48 ff c7	 inc	 rdi
  00348	48 83 ff 01	 cmp	 rdi, 1
  0034c	7c e2		 jl	 SHORT $LL92@stbtt_Init
$LN91@stbtt_Init:

; 1402 : 
; 1403 :         stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
; 1404 :         stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
; 1405 :         stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
; 1406 :         stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
; 1407 :         info->subrs = stbtt__get_subrs(b, topdict);

  0034e	0f 28 45 c8	 movaps	 xmm0, XMMWORD PTR topdict$6[rbp-120]
  00352	4c 8d 45 d8	 lea	 r8, QWORD PTR $T19[rbp-120]
  00356	0f 28 4d b8	 movaps	 xmm1, XMMWORD PTR b$2[rbp-120]
  0035a	48 8d 55 c8	 lea	 rdx, QWORD PTR $T3[rbp-120]
  0035e	48 8d 4d e8	 lea	 rcx, QWORD PTR $T27[rbp-120]
  00362	66 0f 7f 45 d8	 movdqa	 XMMWORD PTR $T19[rbp-120], xmm0
  00367	66 0f 7f 4d c8	 movdqa	 XMMWORD PTR $T3[rbp-120], xmm1
  0036c	e8 00 00 00 00	 call	 ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs

; 1408 : 
; 1409 :         // we only support Type 2 charstrings
; 1410 :         if (cstype != 2) return 0;

  00371	83 7d 48 02	 cmp	 DWORD PTR cstype$28[rbp-120], 2
  00375	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00378	0f 11 46 70	 movups	 XMMWORD PTR [rsi+112], xmm0
  0037c	0f 85 90 fd ff
	ff		 jne	 $LN10@stbtt_Init

; 1411 :         if (charstrings == 0) return 0;

  00382	8b 7d 50	 mov	 edi, DWORD PTR charstrings$29[rbp-120]
  00385	85 ff		 test	 edi, edi
  00387	0f 84 85 fd ff
	ff		 je	 $LN10@stbtt_Init

; 1412 : 
; 1413 :         if (fdarrayoff) {

  0038d	44 8b 7d 60	 mov	 r15d, DWORD PTR fdarrayoff$30[rbp-120]
  00391	45 85 ff	 test	 r15d, r15d
  00394	0f 84 9a 00 00
	00		 je	 $LN160@stbtt_Init

; 1414 :             // looks like a CID font
; 1415 :             if (!fdselectoff) return 0;

  0039a	4c 63 6d a8	 movsxd	 r13, DWORD PTR fdselectoff$1[rbp-120]
  0039e	45 85 ed	 test	 r13d, r13d
  003a1	0f 84 6b fd ff
	ff		 je	 $LN10@stbtt_Init

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  003a7	8b 45 c4	 mov	 eax, DWORD PTR b$2[rbp-108]
  003aa	44 3b f8	 cmp	 r15d, eax
  003ad	7f 05		 jg	 SHORT $LN99@stbtt_Init
  003af	45 85 ff	 test	 r15d, r15d
  003b2	79 1d		 jns	 SHORT $LN95@stbtt_Init
$LN99@stbtt_Init:
  003b4	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  003ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  003c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  003c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003ce	8b 45 c4	 mov	 eax, DWORD PTR b$2[rbp-108]
$LN95@stbtt_Init:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  003d1	44 3b f8	 cmp	 r15d, eax
  003d4	7f 09		 jg	 SHORT $LN101@stbtt_Init
  003d6	44 89 7d c0	 mov	 DWORD PTR b$2[rbp-112], r15d
  003da	45 85 ff	 test	 r15d, r15d
  003dd	79 03		 jns	 SHORT $LN102@stbtt_Init
$LN101@stbtt_Init:
  003df	89 45 c0	 mov	 DWORD PTR b$2[rbp-112], eax
$LN102@stbtt_Init:

; 1416 :             stbtt__buf_seek(&b, fdarrayoff);
; 1417 :             info->fontdicts = stbtt__cff_get_index(&b);

  003e2	48 8d 55 b8	 lea	 rdx, QWORD PTR b$2[rbp-120]
  003e6	48 8d 4d e8	 lea	 rcx, QWORD PTR $T26[rbp-120]
  003ea	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index

; 1418 :             info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size - fdselectoff);

  003ef	44 8b 7d c4	 mov	 r15d, DWORD PTR b$2[rbp-108]
  003f3	41 8b cf	 mov	 ecx, r15d
  003f6	41 2b cd	 sub	 ecx, r13d

; 1166 :     stbtt__buf r = stbtt__new_buf(NULL, 0);

  003f9	48 89 5d c8	 mov	 QWORD PTR $T4[rbp-120], rbx
  003fd	48 89 5d d0	 mov	 QWORD PTR $T4[rbp-112], rbx

; 1416 :             stbtt__buf_seek(&b, fdarrayoff);
; 1417 :             info->fontdicts = stbtt__cff_get_index(&b);

  00401	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00404	0f 11 86 80 00
	00 00		 movups	 XMMWORD PTR [rsi+128], xmm0

; 1167 :     if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

  0040b	45 85 ed	 test	 r13d, r13d
  0040e	78 17		 js	 SHORT $LN105@stbtt_Init
  00410	85 c9		 test	 ecx, ecx
  00412	78 13		 js	 SHORT $LN105@stbtt_Init
  00414	45 3b ef	 cmp	 r13d, r15d
  00417	7f 0e		 jg	 SHORT $LN105@stbtt_Init

; 1168 :     r.data = b->data + o;

  00419	49 8b c5	 mov	 rax, r13

; 1169 :     r.size = s;

  0041c	89 4d d4	 mov	 DWORD PTR $T4[rbp-108], ecx
  0041f	48 03 45 b8	 add	 rax, QWORD PTR b$2[rbp-120]
  00423	48 89 45 c8	 mov	 QWORD PTR $T4[rbp-120], rax
$LN105@stbtt_Init:

; 1418 :             info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size - fdselectoff);

  00427	0f 10 45 c8	 movups	 xmm0, XMMWORD PTR $T4[rbp-120]
  0042b	0f 11 86 90 00
	00 00		 movups	 XMMWORD PTR [rsi+144], xmm0
  00432	eb 04		 jmp	 SHORT $LN17@stbtt_Init
$LN160@stbtt_Init:

; 1412 : 
; 1413 :         if (fdarrayoff) {

  00434	44 8b 7d c4	 mov	 r15d, DWORD PTR b$2[rbp-108]
$LN17@stbtt_Init:

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00438	41 3b ff	 cmp	 edi, r15d
  0043b	7f 04		 jg	 SHORT $LN118@stbtt_Init
  0043d	85 ff		 test	 edi, edi
  0043f	79 1a		 jns	 SHORT $LN114@stbtt_Init
$LN118@stbtt_Init:
  00441	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00447	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0044e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN114@stbtt_Init:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0045b	41 3b ff	 cmp	 edi, r15d
  0045e	7f 07		 jg	 SHORT $LN120@stbtt_Init
  00460	89 7d c0	 mov	 DWORD PTR b$2[rbp-112], edi
  00463	85 ff		 test	 edi, edi
  00465	79 04		 jns	 SHORT $LN121@stbtt_Init
$LN120@stbtt_Init:
  00467	44 89 7d c0	 mov	 DWORD PTR b$2[rbp-112], r15d
$LN121@stbtt_Init:

; 1419 :         }
; 1420 : 
; 1421 :         stbtt__buf_seek(&b, charstrings);
; 1422 :         info->charstrings = stbtt__cff_get_index(&b);

  0046b	48 8d 55 b8	 lea	 rdx, QWORD PTR b$2[rbp-120]
  0046f	48 8d 4d e8	 lea	 rcx, QWORD PTR $T25[rbp-120]
  00473	e8 00 00 00 00	 call	 ?stbtt__cff_get_index@@YA?AUstbtt__buf@@PEAU1@@Z ; stbtt__cff_get_index
  00478	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0047b	0f 11 46 50	 movups	 XMMWORD PTR [rsi+80], xmm0
$LN12@stbtt_Init:

; 1423 :     }
; 1424 : 
; 1425 :     t = stbtt__find_table(data, fontstart, "maxp");

  0047f	8b 55 58	 mov	 edx, DWORD PTR fontstart$[rbp-120]
  00482	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04KODIGLGG@maxp@
  00489	49 8b cc	 mov	 rcx, r12
  0048c	e8 00 00 00 00	 call	 ?stbtt__find_table@@YAIPEAEIPEBD@Z ; stbtt__find_table

; 1426 :     if (t)

  00491	85 c0		 test	 eax, eax
  00493	74 15		 je	 SHORT $LN19@stbtt_Init

; 1427 :         info->numGlyphs = ttUSHORT(data + t + 4);

  00495	8b c0		 mov	 eax, eax
  00497	42 0f b6 4c 20
	04		 movzx	 ecx, BYTE PTR [rax+r12+4]
  0049d	42 0f b6 44 20
	05		 movzx	 eax, BYTE PTR [rax+r12+5]
  004a3	c1 e1 08	 shl	 ecx, 8
  004a6	03 c8		 add	 ecx, eax
  004a8	eb 05		 jmp	 SHORT $LN20@stbtt_Init
$LN19@stbtt_Init:

; 1428 :     else
; 1429 :         info->numGlyphs = 0xffff;

  004aa	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
$LN20@stbtt_Init:

; 1430 : 
; 1431 :     // find a cmap encoding table we understand *now* to avoid searching
; 1432 :     // later. (todo: could make this installable)
; 1433 :     // the same regardless of glyph.
; 1434 :     numTables = ttUSHORT(data + cmap + 2);

  004af	89 4e 14	 mov	 DWORD PTR [rsi+20], ecx
  004b2	43 0f b6 4c 26
	02		 movzx	 ecx, BYTE PTR [r14+r12+2]
  004b8	47 0f b6 4c 26
	03		 movzx	 r9d, BYTE PTR [r14+r12+3]
  004be	c1 e1 08	 shl	 ecx, 8

; 1435 :     info->index_map = 0;

  004c1	89 5e 34	 mov	 DWORD PTR [rsi+52], ebx
  004c4	44 03 c9	 add	 r9d, ecx

; 1436 :     for (i = 0; i < numTables; ++i) {

  004c7	0f 84 45 fc ff
	ff		 je	 $LN10@stbtt_Init
  004cd	0f 1f 00	 npad	 3
$LL4@stbtt_Init:

; 1437 :         stbtt_uint32 encoding_record = cmap + 4 + 8 * i;

  004d0	41 8d 46 04	 lea	 eax, DWORD PTR [r14+4]
  004d4	8d 04 d8	 lea	 eax, DWORD PTR [rax+rbx*8]

; 1438 :         // find an encoding we understand:
; 1439 :         switch (ttUSHORT(data + encoding_record)) {

  004d7	46 0f b6 04 20	 movzx	 r8d, BYTE PTR [rax+r12]
  004dc	8b c8		 mov	 ecx, eax
  004de	42 0f b6 44 20
	01		 movzx	 eax, BYTE PTR [rax+r12+1]
  004e4	41 c1 e0 08	 shl	 r8d, 8
  004e8	44 03 c0	 add	 r8d, eax
  004eb	74 21		 je	 SHORT $LN24@stbtt_Init
  004ed	41 83 f8 03	 cmp	 r8d, 3
  004f1	75 4c		 jne	 SHORT $LN2@stbtt_Init

; 1440 :         case STBTT_PLATFORM_ID_MICROSOFT:
; 1441 :             switch (ttUSHORT(data + encoding_record + 2)) {

  004f3	42 0f b6 54 21
	02		 movzx	 edx, BYTE PTR [rcx+r12+2]
  004f9	42 0f b6 44 21
	03		 movzx	 eax, BYTE PTR [rcx+r12+3]
  004ff	c1 e2 08	 shl	 edx, 8
  00502	03 d0		 add	 edx, eax
  00504	83 ea 01	 sub	 edx, 1
  00507	74 05		 je	 SHORT $LN24@stbtt_Init
  00509	83 fa 09	 cmp	 edx, 9
  0050c	75 31		 jne	 SHORT $LN2@stbtt_Init
$LN24@stbtt_Init:

; 1436 :     for (i = 0; i < numTables; ++i) {

  0050e	42 0f b6 44 21
	05		 movzx	 eax, BYTE PTR [rcx+r12+5]
  00514	46 0f b6 44 21
	04		 movzx	 r8d, BYTE PTR [rcx+r12+4]
  0051a	42 0f b6 54 21
	07		 movzx	 edx, BYTE PTR [rcx+r12+7]
  00520	41 c1 e0 08	 shl	 r8d, 8
  00524	44 03 c0	 add	 r8d, eax
  00527	42 0f b6 44 21
	06		 movzx	 eax, BYTE PTR [rcx+r12+6]
  0052d	41 c1 e0 08	 shl	 r8d, 8
  00531	41 03 c0	 add	 eax, r8d
  00534	c1 e0 08	 shl	 eax, 8
  00537	41 03 c6	 add	 eax, r14d
  0053a	03 d0		 add	 edx, eax
  0053c	89 56 34	 mov	 DWORD PTR [rsi+52], edx
$LN2@stbtt_Init:
  0053f	ff c3		 inc	 ebx
  00541	41 3b d9	 cmp	 ebx, r9d
  00544	7c 8a		 jl	 SHORT $LL4@stbtt_Init

; 1442 :             case STBTT_MS_EID_UNICODE_BMP:
; 1443 :             case STBTT_MS_EID_UNICODE_FULL:
; 1444 :                 // MS/Unicode
; 1445 :                 info->index_map = cmap + ttULONG(data + encoding_record + 4);
; 1446 :                 break;
; 1447 :             }
; 1448 :             break;
; 1449 :         case STBTT_PLATFORM_ID_UNICODE:
; 1450 :             // Mac/iOS has these
; 1451 :             // all the encodingIDs are unicode, so we don't bother to check it
; 1452 :             info->index_map = cmap + ttULONG(data + encoding_record + 4);
; 1453 :             break;
; 1454 :         }
; 1455 :     }
; 1456 :     if (info->index_map == 0)

  00546	83 7e 34 00	 cmp	 DWORD PTR [rsi+52], 0
  0054a	0f 84 c2 fb ff
	ff		 je	 $LN10@stbtt_Init

; 1457 :         return 0;
; 1458 : 
; 1459 :     info->indexToLocFormat = ttUSHORT(data + info->head + 50);

  00550	48 63 46 1c	 movsxd	 rax, DWORD PTR [rsi+28]
  00554	42 0f b6 4c 20
	32		 movzx	 ecx, BYTE PTR [rax+r12+50]
  0055a	42 0f b6 44 20
	33		 movzx	 eax, BYTE PTR [rax+r12+51]
  00560	c1 e1 08	 shl	 ecx, 8
  00563	03 c8		 add	 ecx, eax

; 1460 :     return 1;

  00565	b8 01 00 00 00	 mov	 eax, 1
  0056a	89 4e 38	 mov	 DWORD PTR [rsi+56], ecx
  0056d	e9 a2 fb ff ff	 jmp	 $LN1@stbtt_Init
?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ENDP ; stbtt_InitFont_internal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 80
unicode_codepoint$ = 88
stbtt_FindGlyphIndex PROC

; 1464 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1466 :     stbtt_uint32 index_map = info->index_map;

  00016	44 8b 71 34	 mov	 r14d, DWORD PTR [rcx+52]

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0001a	41 bd 00 01 00
	00		 mov	 r13d, 256		; 00000100H

; 1465 :     stbtt_uint8* data = info->data;

  00020	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]

; 1467 : 
; 1468 :     stbtt_uint16 format = ttUSHORT(data + index_map + 0);

  00024	41 8b f6	 mov	 esi, r14d
  00027	48 63 da	 movsxd	 rbx, edx

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0002a	45 0f b6 1c 3e	 movzx	 r11d, BYTE PTR [r14+rdi]
  0002f	41 0f b6 44 3e
	01		 movzx	 eax, BYTE PTR [r14+rdi+1]
  00035	45 0f af dd	 imul	 r11d, r13d
  00039	66 44 03 d8	 add	 r11w, ax

; 1469 :     if (format == 0) { // apple byte encoding

  0003d	75 23		 jne	 SHORT $LN15@stbtt_Find

; 1470 :         stbtt_int32 bytes = ttUSHORT(data + index_map + 2);

  0003f	41 0f b6 4c 3e
	02		 movzx	 ecx, BYTE PTR [r14+rdi+2]
  00045	41 0f b6 44 3e
	03		 movzx	 eax, BYTE PTR [r14+rdi+3]
  0004b	c1 e1 08	 shl	 ecx, 8
  0004e	83 c0 fa	 add	 eax, -6
  00051	03 c8		 add	 ecx, eax

; 1471 :         if (unicode_codepoint < bytes - 6)

  00053	3b d9		 cmp	 ebx, ecx
  00055	7d 78		 jge	 SHORT $LN11@stbtt_Find

; 1472 :             return ttBYTE(data + index_map + 6 + unicode_codepoint);

  00057	49 8d 04 1e	 lea	 rax, QWORD PTR [r14+rbx]
  0005b	0f b6 44 38 06	 movzx	 eax, BYTE PTR [rax+rdi+6]
  00060	eb 6f		 jmp	 SHORT $LN1@stbtt_Find
$LN15@stbtt_Find:

; 1473 :         return 0;
; 1474 :     }
; 1475 :     else if (format == 6) {

  00062	66 41 83 fb 06	 cmp	 r11w, 6
  00067	75 45		 jne	 SHORT $LN18@stbtt_Find

; 1476 :         stbtt_uint32 first = ttUSHORT(data + index_map + 6);

  00069	41 0f b6 54 3e
	06		 movzx	 edx, BYTE PTR [r14+rdi+6]
  0006f	41 0f b6 44 3e
	07		 movzx	 eax, BYTE PTR [r14+rdi+7]
  00075	c1 e2 08	 shl	 edx, 8
  00078	03 d0		 add	 edx, eax

; 1478 :         if ((stbtt_uint32)unicode_codepoint >= first && (stbtt_uint32)unicode_codepoint < first + count)

  0007a	3b da		 cmp	 ebx, edx
  0007c	72 51		 jb	 SHORT $LN11@stbtt_Find

; 1477 :         stbtt_uint32 count = ttUSHORT(data + index_map + 8);

  0007e	41 0f b6 44 3e
	08		 movzx	 eax, BYTE PTR [r14+rdi+8]
  00084	41 0f b6 4c 3e
	09		 movzx	 ecx, BYTE PTR [r14+rdi+9]
  0008a	c1 e0 08	 shl	 eax, 8

; 1478 :         if ((stbtt_uint32)unicode_codepoint >= first && (stbtt_uint32)unicode_codepoint < first + count)

  0008d	03 c2		 add	 eax, edx
  0008f	03 c8		 add	 ecx, eax
  00091	3b d9		 cmp	 ebx, ecx
  00093	73 3a		 jae	 SHORT $LN11@stbtt_Find

; 1479 :             return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first) * 2);

  00095	2b da		 sub	 ebx, edx
  00097	8d 04 1b	 lea	 eax, DWORD PTR [rbx+rbx]
  0009a	48 03 c6	 add	 rax, rsi
  0009d	0f b6 54 38 0a	 movzx	 edx, BYTE PTR [rax+rdi+10]
  000a2	0f b6 44 38 0b	 movzx	 eax, BYTE PTR [rax+rdi+11]
  000a7	c1 e2 08	 shl	 edx, 8
  000aa	03 c2		 add	 eax, edx
  000ac	eb 23		 jmp	 SHORT $LN1@stbtt_Find
$LN18@stbtt_Find:

; 1480 :         return 0;
; 1481 :     }
; 1482 :     else if (format == 2) {

  000ae	66 41 83 fb 02	 cmp	 r11w, 2
  000b3	75 33		 jne	 SHORT $LN21@stbtt_Find

; 1483 :         STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean

  000b5	41 b8 cb 05 00
	00		 mov	 r8d, 1483		; 000005cbH
$LN90@stbtt_Find:

; 1558 : }

  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN11@stbtt_Find:
  000cf	33 c0		 xor	 eax, eax
$LN1@stbtt_Find:
  000d1	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000d6	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  000db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000df	41 5e		 pop	 r14
  000e1	41 5d		 pop	 r13
  000e3	41 5c		 pop	 r12
  000e5	5f		 pop	 rdi
  000e6	5e		 pop	 rsi
  000e7	c3		 ret	 0
$LN21@stbtt_Find:

; 1484 :         return 0;
; 1485 :     }
; 1486 :     else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges

  000e8	66 41 83 fb 04	 cmp	 r11w, 4
  000ed	0f 85 cd 01 00
	00		 jne	 $LN23@stbtt_Find

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000f3	41 0f b6 44 3e
	07		 movzx	 eax, BYTE PTR [r14+rdi+7]

; 1495 : 
; 1496 :         if (unicode_codepoint > 0xffff)

  000f9	bd ff ff 00 00	 mov	 ebp, 65535		; 0000ffffH

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000fe	41 0f b6 54 3e
	08		 movzx	 edx, BYTE PTR [r14+rdi+8]
  00104	45 0f b6 64 3e
	06		 movzx	 r12d, BYTE PTR [r14+rdi+6]
  0010a	45 0f b6 54 3e
	09		 movzx	 r10d, BYTE PTR [r14+rdi+9]
  00110	45 0f b6 44 3e
	0c		 movzx	 r8d, BYTE PTR [r14+rdi+12]
  00116	45 0f b6 5c 3e
	0b		 movzx	 r11d, BYTE PTR [r14+rdi+11]
  0011c	41 0f af d5	 imul	 edx, r13d
  00120	45 0f af e5	 imul	 r12d, r13d
  00124	45 0f af c5	 imul	 r8d, r13d
  00128	66 44 03 d2	 add	 r10w, dx
  0012c	41 0f b6 54 3e
	0a		 movzx	 edx, BYTE PTR [r14+rdi+10]
  00132	66 44 03 e0	 add	 r12w, ax
  00136	41 0f af d5	 imul	 edx, r13d
  0013a	41 0f b6 44 3e
	0d		 movzx	 eax, BYTE PTR [r14+rdi+13]

; 1489 :         stbtt_uint16 entrySelector = ttUSHORT(data + index_map + 10);
; 1490 :         stbtt_uint16 rangeShift = ttUSHORT(data + index_map + 12) >> 1;
; 1491 : 
; 1492 :         // do a binary search of the segments
; 1493 :         stbtt_uint32 endCount = index_map + 14;

  00140	41 83 c6 0e	 add	 r14d, 14

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00144	66 44 03 c0	 add	 r8w, ax

; 1487 :         stbtt_uint16 segcount = ttUSHORT(data + index_map + 6) >> 1;

  00148	66 41 d1 ec	 shr	 r12w, 1

; 1488 :         stbtt_uint16 searchRange = ttUSHORT(data + index_map + 8) >> 1;

  0014c	66 41 d1 ea	 shr	 r10w, 1

; 1494 :         stbtt_uint32 search = endCount;

  00150	45 8b ce	 mov	 r9d, r14d
  00153	66 41 d1 e8	 shr	 r8w, 1

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00157	66 44 03 da	 add	 r11w, dx

; 1495 : 
; 1496 :         if (unicode_codepoint > 0xffff)

  0015b	3b dd		 cmp	 ebx, ebp
  0015d	0f 8f 6c ff ff
	ff		 jg	 $LN11@stbtt_Find

; 1497 :             return 0;
; 1498 : 
; 1499 :         // they lie from endCount .. endCount + segCount
; 1500 :         // but searchRange is the nearest power of two, so...
; 1501 :         if (unicode_codepoint >= ttUSHORT(data + search + rangeShift * 2))

  00163	41 0f b7 c0	 movzx	 eax, r8w
  00167	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15
  0016c	49 8d 0c 46	 lea	 rcx, QWORD PTR [r14+rax*2]
  00170	0f b6 14 39	 movzx	 edx, BYTE PTR [rcx+rdi]
  00174	0f b6 44 39 01	 movzx	 eax, BYTE PTR [rcx+rdi+1]
  00179	c1 e2 08	 shl	 edx, 8
  0017c	03 d0		 add	 edx, eax
  0017e	3b da		 cmp	 ebx, edx
  00180	7c 08		 jl	 SHORT $LN26@stbtt_Find

; 1502 :             search += rangeShift * 2;

  00182	41 0f b7 c0	 movzx	 eax, r8w
  00186	45 8d 0c 46	 lea	 r9d, DWORD PTR [r14+rax*2]
$LN26@stbtt_Find:

; 1503 : 
; 1504 :         // now decrement to bias correctly to find smallest
; 1505 :         search -= 2;

  0018a	41 83 c1 fe	 add	 r9d, -2			; fffffffeH

; 1506 :         while (entrySelector) {

  0018e	66 45 85 db	 test	 r11w, r11w
  00192	74 3e		 je	 SHORT $LN6@stbtt_Find
  00194	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL5@stbtt_Find:

; 1507 :             stbtt_uint16 end;
; 1508 :             searchRange >>= 1;

  001a0	66 41 d1 ea	 shr	 r10w, 1
  001a4	41 0f b7 d2	 movzx	 edx, r10w

; 1509 :             end = ttUSHORT(data + search + searchRange * 2);

  001a8	41 8b c9	 mov	 ecx, r9d
  001ab	48 03 cf	 add	 rcx, rdi

; 1510 :             if (unicode_codepoint > end)

  001ae	44 0f b6 04 51	 movzx	 r8d, BYTE PTR [rcx+rdx*2]
  001b3	0f b6 44 51 01	 movzx	 eax, BYTE PTR [rcx+rdx*2+1]
  001b8	41 c1 e0 08	 shl	 r8d, 8
  001bc	44 03 c0	 add	 r8d, eax
  001bf	41 3b d8	 cmp	 ebx, r8d
  001c2	7e 08		 jle	 SHORT $LN27@stbtt_Find

; 1511 :                 search += searchRange * 2;

  001c4	41 0f b7 c2	 movzx	 eax, r10w
  001c8	45 8d 0c 41	 lea	 r9d, DWORD PTR [r9+rax*2]
$LN27@stbtt_Find:

; 1512 :             --entrySelector;

  001cc	66 44 03 dd	 add	 r11w, bp
  001d0	75 ce		 jne	 SHORT $LL5@stbtt_Find
$LN6@stbtt_Find:

; 1513 :         }
; 1514 :         search += 2;
; 1515 : 
; 1516 :         {
; 1517 :             stbtt_uint16 offset, start;
; 1518 :             stbtt_uint16 item = (stbtt_uint16)((search - endCount) >> 1);
; 1519 : 
; 1520 :             STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2 * item));

  001d2	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]
  001d7	45 2b ce	 sub	 r9d, r14d
  001da	41 83 c1 02	 add	 r9d, 2
  001de	41 d1 e9	 shr	 r9d, 1
  001e1	41 0f b7 e9	 movzx	 ebp, r9w
  001e5	48 03 ed	 add	 rbp, rbp
  001e8	49 8d 04 2e	 lea	 rax, QWORD PTR [r14+rbp]
  001ec	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  001f0	0f b6 44 38 01	 movzx	 eax, BYTE PTR [rax+rdi+1]
  001f5	c1 e1 08	 shl	 ecx, 8
  001f8	03 c8		 add	 ecx, eax
  001fa	3b d9		 cmp	 ebx, ecx
  001fc	7e 1a		 jle	 SHORT $LN7@stbtt_Find
  001fe	41 b8 f0 05 00
	00		 mov	 r8d, 1520		; 000005f0H
  00204	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HE@BLOLDBDN@?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAc?$AAo?$AAd?$AAe?$AAp?$AAo?$AAi@
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN7@stbtt_Find:

; 1521 :             start = ttUSHORT(data + index_map + 14 + segcount * 2 + 2 + 2 * item);

  00218	45 0f b7 d4	 movzx	 r10d, r12w
  0021c	43 8d 0c 12	 lea	 ecx, DWORD PTR [r10+r10]
  00220	48 03 cd	 add	 rcx, rbp
  00223	48 03 ce	 add	 rcx, rsi

; 1522 :             if (unicode_codepoint < start)

  00226	44 0f b6 44 39
	10		 movzx	 r8d, BYTE PTR [rcx+rdi+16]
  0022c	0f b6 44 39 11	 movzx	 eax, BYTE PTR [rcx+rdi+17]
  00231	41 c1 e0 08	 shl	 r8d, 8
  00235	44 03 c0	 add	 r8d, eax
  00238	41 3b d8	 cmp	 ebx, r8d
  0023b	0f 8c 8e fe ff
	ff		 jl	 $LN11@stbtt_Find

; 1523 :                 return 0;
; 1524 : 
; 1525 :             offset = ttUSHORT(data + index_map + 14 + segcount * 6 + 2 + 2 * item);

  00241	43 8d 04 52	 lea	 eax, DWORD PTR [r10+r10*2]
  00245	03 c0		 add	 eax, eax
  00247	44 8b d8	 mov	 r11d, eax
  0024a	48 8d 14 28	 lea	 rdx, QWORD PTR [rax+rbp]
  0024e	48 03 d6	 add	 rdx, rsi

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00251	44 0f b6 4c 3a
	10		 movzx	 r9d, BYTE PTR [rdx+rdi+16]
  00257	0f b6 44 3a 11	 movzx	 eax, BYTE PTR [rdx+rdi+17]
  0025c	45 0f af cd	 imul	 r9d, r13d
  00260	66 44 03 c8	 add	 r9w, ax

; 1526 :             if (offset == 0)

  00264	75 2e		 jne	 SHORT $LN29@stbtt_Find

; 1527 :                 return (stbtt_uint16)(unicode_codepoint + ttSHORT(data + index_map + 14 + segcount * 4 + 2 + 2 * item));

  00266	42 8d 0c 95 00
	00 00 00	 lea	 ecx, DWORD PTR [r10*4]
  0026e	48 03 cd	 add	 rcx, rbp
  00271	48 03 ce	 add	 rcx, rsi

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00274	0f b6 54 39 10	 movzx	 edx, BYTE PTR [rcx+rdi+16]
  00279	44 0f b6 44 39
	11		 movzx	 r8d, BYTE PTR [rcx+rdi+17]
  0027f	41 0f af d5	 imul	 edx, r13d

; 1527 :                 return (stbtt_uint16)(unicode_codepoint + ttSHORT(data + index_map + 14 + segcount * 4 + 2 + 2 * item));

  00283	66 44 03 c2	 add	 r8w, dx
  00287	66 44 03 c3	 add	 r8w, bx
  0028b	41 0f b7 c0	 movzx	 eax, r8w
  0028f	e9 3d fe ff ff	 jmp	 $LN1@stbtt_Find
$LN29@stbtt_Find:

; 1528 : 
; 1529 :             return ttUSHORT(data + offset + (unicode_codepoint - start) * 2 + index_map + 14 + segcount * 6 + 2 + 2 * item);

  00294	41 2b d8	 sub	 ebx, r8d
  00297	41 0f b7 c9	 movzx	 ecx, r9w
  0029b	8d 04 1b	 lea	 eax, DWORD PTR [rbx+rbx]
  0029e	48 98		 cdqe
  002a0	49 03 c3	 add	 rax, r11
  002a3	48 03 c8	 add	 rcx, rax
  002a6	48 03 cd	 add	 rcx, rbp
  002a9	48 03 ce	 add	 rcx, rsi
  002ac	0f b6 44 39 11	 movzx	 eax, BYTE PTR [rcx+rdi+17]
  002b1	0f b6 4c 39 10	 movzx	 ecx, BYTE PTR [rcx+rdi+16]
  002b6	c1 e1 08	 shl	 ecx, 8
  002b9	03 c1		 add	 eax, ecx
  002bb	e9 11 fe ff ff	 jmp	 $LN1@stbtt_Find
$LN23@stbtt_Find:

; 1530 :         }
; 1531 :     }
; 1532 :     else if (format == 12 || format == 13) {

  002c0	41 8d 43 f4	 lea	 eax, DWORD PTR [r11-12]
  002c4	66 83 f8 01	 cmp	 ax, 1
  002c8	76 0b		 jbe	 SHORT $LN31@stbtt_Find

; 1551 :             }
; 1552 :         }
; 1553 :         return 0; // not found
; 1554 :     }
; 1555 :     // @TODO
; 1556 :     STBTT_assert(0);

  002ca	41 b8 14 06 00
	00		 mov	 r8d, 1556		; 00000614H

; 1557 :     return 0;

  002d0	e9 e6 fd ff ff	 jmp	 $LN90@stbtt_Find
$LN31@stbtt_Find:

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  002d5	41 0f b6 44 3e
	0d		 movzx	 eax, BYTE PTR [r14+rdi+13]

; 1533 :         stbtt_uint32 ngroups = ttULONG(data + index_map + 12);
; 1534 :         stbtt_int32 low, high;
; 1535 :         low = 0; high = (stbtt_int32)ngroups;

  002db	33 d2		 xor	 edx, edx

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  002dd	45 0f b6 54 3e
	0c		 movzx	 r10d, BYTE PTR [r14+rdi+12]
  002e3	41 c1 e2 08	 shl	 r10d, 8
  002e7	44 03 d0	 add	 r10d, eax
  002ea	41 0f b6 44 3e
	0e		 movzx	 eax, BYTE PTR [r14+rdi+14]
  002f0	41 c1 e2 08	 shl	 r10d, 8
  002f4	44 03 d0	 add	 r10d, eax
  002f7	41 0f b6 44 3e
	0f		 movzx	 eax, BYTE PTR [r14+rdi+15]
  002fd	41 c1 e2 08	 shl	 r10d, 8
  00301	44 03 d0	 add	 r10d, eax

; 1536 :         // Binary search the right group.
; 1537 :         while (low < high) {

  00304	45 85 d2	 test	 r10d, r10d
  00307	0f 8e c2 fd ff
	ff		 jle	 $LN11@stbtt_Find
  0030d	0f 1f 00	 npad	 3
$LL10@stbtt_Find:

; 1538 :             stbtt_int32 mid = low + ((high - low) >> 1); // rounds down, so low <= mid < high

  00310	41 8b c2	 mov	 eax, r10d
  00313	2b c2		 sub	 eax, edx
  00315	d1 f8		 sar	 eax, 1
  00317	03 c2		 add	 eax, edx

; 1539 :             stbtt_uint32 start_char = ttULONG(data + index_map + 16 + mid * 12);

  00319	8d 0c 40	 lea	 ecx, DWORD PTR [rax+rax*2]
  0031c	c1 e1 02	 shl	 ecx, 2
  0031f	4c 63 f1	 movsxd	 r14, ecx
  00322	4d 8d 04 36	 lea	 r8, QWORD PTR [r14+rsi]
  00326	4c 03 c7	 add	 r8, rdi

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  00329	45 0f b6 48 11	 movzx	 r9d, BYTE PTR [r8+17]
  0032e	41 0f b6 48 12	 movzx	 ecx, BYTE PTR [r8+18]
  00333	c1 e1 08	 shl	 ecx, 8
  00336	41 c1 e1 10	 shl	 r9d, 16
  0033a	44 03 c9	 add	 r9d, ecx
  0033d	41 0f b6 48 10	 movzx	 ecx, BYTE PTR [r8+16]
  00342	c1 e1 18	 shl	 ecx, 24
  00345	44 03 c9	 add	 r9d, ecx
  00348	41 0f b6 48 13	 movzx	 ecx, BYTE PTR [r8+19]
  0034d	44 03 c9	 add	 r9d, ecx

; 1540 :             stbtt_uint32 end_char = ttULONG(data + index_map + 16 + mid * 12 + 4);
; 1541 :             if ((stbtt_uint32)unicode_codepoint < start_char)

  00350	41 3b d9	 cmp	 ebx, r9d
  00353	73 05		 jae	 SHORT $LN32@stbtt_Find

; 1542 :                 high = mid;

  00355	44 8b d0	 mov	 r10d, eax
  00358	eb 2a		 jmp	 SHORT $LN37@stbtt_Find
$LN32@stbtt_Find:

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  0035a	41 0f b6 50 15	 movzx	 edx, BYTE PTR [r8+21]
  0035f	41 0f b6 48 16	 movzx	 ecx, BYTE PTR [r8+22]
  00364	c1 e1 08	 shl	 ecx, 8
  00367	c1 e2 10	 shl	 edx, 16
  0036a	03 d1		 add	 edx, ecx
  0036c	41 0f b6 48 14	 movzx	 ecx, BYTE PTR [r8+20]
  00371	c1 e1 18	 shl	 ecx, 24
  00374	03 d1		 add	 edx, ecx
  00376	41 0f b6 48 17	 movzx	 ecx, BYTE PTR [r8+23]
  0037b	03 d1		 add	 edx, ecx

; 1543 :             else if ((stbtt_uint32)unicode_codepoint > end_char)

  0037d	3b da		 cmp	 ebx, edx
  0037f	76 0d		 jbe	 SHORT $LN34@stbtt_Find

; 1544 :                 low = mid + 1;

  00381	8d 50 01	 lea	 edx, DWORD PTR [rax+1]
$LN37@stbtt_Find:

; 1536 :         // Binary search the right group.
; 1537 :         while (low < high) {

  00384	41 3b d2	 cmp	 edx, r10d
  00387	7c 87		 jl	 SHORT $LL10@stbtt_Find

; 1530 :         }
; 1531 :     }
; 1532 :     else if (format == 12 || format == 13) {

  00389	e9 41 fd ff ff	 jmp	 $LN11@stbtt_Find
$LN34@stbtt_Find:

; 1545 :             else {
; 1546 :                 stbtt_uint32 start_glyph = ttULONG(data + index_map + 16 + mid * 12 + 8);

  0038e	49 8d 0c 36	 lea	 rcx, QWORD PTR [r14+rsi]
  00392	48 03 cf	 add	 rcx, rdi

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  00395	0f b6 51 19	 movzx	 edx, BYTE PTR [rcx+25]
  00399	0f b6 41 1a	 movzx	 eax, BYTE PTR [rcx+26]
  0039d	c1 e0 08	 shl	 eax, 8
  003a0	c1 e2 10	 shl	 edx, 16
  003a3	03 d0		 add	 edx, eax
  003a5	0f b6 41 18	 movzx	 eax, BYTE PTR [rcx+24]
  003a9	c1 e0 18	 shl	 eax, 24
  003ac	03 d0		 add	 edx, eax
  003ae	0f b6 41 1b	 movzx	 eax, BYTE PTR [rcx+27]
  003b2	03 d0		 add	 edx, eax

; 1547 :                 if (format == 12)

  003b4	66 41 83 fb 0c	 cmp	 r11w, 12
  003b9	75 0b		 jne	 SHORT $LN36@stbtt_Find

; 1548 :                     return start_glyph + unicode_codepoint - start_char;

  003bb	41 2b d1	 sub	 edx, r9d
  003be	8d 04 13	 lea	 eax, DWORD PTR [rbx+rdx]
  003c1	e9 0b fd ff ff	 jmp	 $LN1@stbtt_Find
$LN36@stbtt_Find:

; 1549 :                 else // format == 13
; 1550 :                     return start_glyph;

  003c6	8b c2		 mov	 eax, edx
  003c8	e9 04 fd ff ff	 jmp	 $LN1@stbtt_Find
stbtt_FindGlyphIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
v$ = 8
type$ = 16
x$ = 24
y$ = 32
cx$ = 40
cy$ = 48
?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z PROC	; stbtt_setvertex

; 1567 :     v->type = type;
; 1568 :     v->x = (stbtt_int16)x;
; 1569 :     v->y = (stbtt_int16)y;
; 1570 :     v->cx = (stbtt_int16)cx;

  00000	0f b7 44 24 28	 movzx	 eax, WORD PTR cx$[rsp]
  00005	66 89 41 04	 mov	 WORD PTR [rcx+4], ax

; 1571 :     v->cy = (stbtt_int16)cy;

  00009	0f b7 44 24 30	 movzx	 eax, WORD PTR cy$[rsp]
  0000e	66 89 41 06	 mov	 WORD PTR [rcx+6], ax
  00012	88 51 0c	 mov	 BYTE PTR [rcx+12], dl
  00015	66 44 89 01	 mov	 WORD PTR [rcx], r8w
  00019	66 44 89 49 02	 mov	 WORD PTR [rcx+2], r9w

; 1572 : }

  0001e	c3		 ret	 0
?stbtt_setvertex@@YAXPEAUstbtt_vertex@@EHHHH@Z ENDP	; stbtt_setvertex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 48
glyph_index$ = 56
?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z PROC	; stbtt__GetGlyfOffset

; 1575 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1576 :     int g1, g2;
; 1577 : 
; 1578 :     STBTT_assert(!info->cff.size);

  0000a	83 79 4c 00	 cmp	 DWORD PTR [rcx+76], 0
  0000e	8b fa		 mov	 edi, edx
  00010	48 8b d9	 mov	 rbx, rcx
  00013	74 1a		 je	 SHORT $LN2@stbtt__Get
  00015	41 b8 2a 06 00
	00		 mov	 r8d, 1578		; 0000062aH
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@MDABGEPC@?$AA?$CB?$AAi?$AAn?$AAf?$AAo?$AA?9?$AA?$DO?$AAc?$AAf?$AAf?$AA?4?$AAs?$AAi?$AAz?$AAe@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN2@stbtt__Get:

; 1579 : 
; 1580 :     if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range

  0002f	3b 7b 14	 cmp	 edi, DWORD PTR [rbx+20]
  00032	0f 8d da 00 00
	00		 jge	 $LN19@stbtt__Get

; 1581 :     if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

  00038	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  0003b	83 f8 02	 cmp	 eax, 2
  0003e	0f 8d ce 00 00
	00		 jge	 $LN19@stbtt__Get

; 1582 : 
; 1583 :     if (info->indexToLocFormat == 0) {

  00044	48 63 53 18	 movsxd	 rdx, DWORD PTR [rbx+24]
  00048	4c 8b 43 08	 mov	 r8, QWORD PTR [rbx+8]
  0004c	85 c0		 test	 eax, eax
  0004e	75 4b		 jne	 SHORT $LN7@stbtt__Get

; 1584 :         g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;

  00050	8d 04 3f	 lea	 eax, DWORD PTR [rdi+rdi]
  00053	48 63 c8	 movsxd	 rcx, eax
  00056	49 03 c8	 add	 rcx, r8
  00059	44 8b 43 20	 mov	 r8d, DWORD PTR [rbx+32]
  0005d	48 03 d1	 add	 rdx, rcx
  00060	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00064	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00067	c1 e1 08	 shl	 ecx, 8

; 1584 :         g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;

  0006a	03 c8		 add	 ecx, eax

; 1585 :         g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;

  0006c	0f b6 42 03	 movzx	 eax, BYTE PTR [rdx+3]
  00070	45 8d 14 48	 lea	 r10d, DWORD PTR [r8+rcx*2]
  00074	0f b6 4a 02	 movzx	 ecx, BYTE PTR [rdx+2]

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00078	c1 e1 08	 shl	 ecx, 8

; 1585 :         g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;

  0007b	03 c8		 add	 ecx, eax

; 1590 :     }
; 1591 : 
; 1592 :     return g1 == g2 ? -1 : g1; // if length is 0, return -1

  0007d	b8 ff ff ff ff	 mov	 eax, -1
  00082	45 8d 0c 48	 lea	 r9d, DWORD PTR [r8+rcx*2]
  00086	45 3b d1	 cmp	 r10d, r9d
  00089	44 0f 44 d0	 cmove	 r10d, eax
  0008d	41 8b c2	 mov	 eax, r10d

; 1593 : }

  00090	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
$LN7@stbtt__Get:

; 1586 :     }
; 1587 :     else {
; 1588 :         g1 = info->glyf + ttULONG(info->data + info->loca + glyph_index * 4);

  0009b	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [rdi*4]
  000a2	4c 63 c8	 movsxd	 r9, eax
  000a5	4d 03 c8	 add	 r9, r8
  000a8	4c 03 ca	 add	 r9, rdx

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  000ab	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  000b0	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  000b4	45 0f b6 51 03	 movzx	 r10d, BYTE PTR [r9+3]
  000b9	41 0f b6 51 04	 movzx	 edx, BYTE PTR [r9+4]
  000be	c1 e1 08	 shl	 ecx, 8

; 1586 :     }
; 1587 :     else {
; 1588 :         g1 = info->glyf + ttULONG(info->data + info->loca + glyph_index * 4);

  000c1	03 c8		 add	 ecx, eax

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  000c3	c1 e2 08	 shl	 edx, 8
  000c6	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]

; 1586 :     }
; 1587 :     else {
; 1588 :         g1 = info->glyf + ttULONG(info->data + info->loca + glyph_index * 4);

  000cb	c1 e1 08	 shl	 ecx, 8
  000ce	03 c1		 add	 eax, ecx

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  000d0	41 0f b6 49 06	 movzx	 ecx, BYTE PTR [r9+6]

; 1586 :     }
; 1587 :     else {
; 1588 :         g1 = info->glyf + ttULONG(info->data + info->loca + glyph_index * 4);

  000d5	c1 e0 08	 shl	 eax, 8
  000d8	03 43 20	 add	 eax, DWORD PTR [rbx+32]
  000db	44 03 d0	 add	 r10d, eax

; 1272 : static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

  000de	41 0f b6 41 05	 movzx	 eax, BYTE PTR [r9+5]
  000e3	45 0f b6 49 07	 movzx	 r9d, BYTE PTR [r9+7]

; 1589 :         g2 = info->glyf + ttULONG(info->data + info->loca + glyph_index * 4 + 4);

  000e8	03 d0		 add	 edx, eax
  000ea	c1 e2 08	 shl	 edx, 8

; 1590 :     }
; 1591 : 
; 1592 :     return g1 == g2 ? -1 : g1; // if length is 0, return -1

  000ed	b8 ff ff ff ff	 mov	 eax, -1
  000f2	03 ca		 add	 ecx, edx
  000f4	c1 e1 08	 shl	 ecx, 8
  000f7	03 4b 20	 add	 ecx, DWORD PTR [rbx+32]
  000fa	44 03 c9	 add	 r9d, ecx
  000fd	45 3b d1	 cmp	 r10d, r9d
  00100	44 0f 44 d0	 cmove	 r10d, eax
  00104	41 8b c2	 mov	 eax, r10d

; 1593 : }

  00107	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00110	5f		 pop	 rdi
  00111	c3		 ret	 0
$LN19@stbtt__Get:
  00112	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00117	b8 ff ff ff ff	 mov	 eax, -1
  0011c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00120	5f		 pop	 rdi
  00121	c3		 ret	 0
?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ENDP	; stbtt__GetGlyfOffset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
c$1 = 32
info$ = 112
glyph_index$ = 120
x0$ = 128
y0$ = 136
x1$ = 144
y1$ = 152
stbtt_GetGlyphBox PROC

; 1598 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1599 :     if (info->cff.size) {

  00015	83 79 4c 00	 cmp	 DWORD PTR [rcx+76], 0
  00019	49 8b f9	 mov	 rdi, r9
  0001c	4d 8b f0	 mov	 r14, r8
  0001f	48 8b f1	 mov	 rsi, rcx
  00022	0f 84 83 00 00
	00		 je	 $LN2@stbtt_GetG

; 2281 :     stbtt__csctx c = STBTT__CSCTX_INIT(1);

  00028	33 db		 xor	 ebx, ebx
  0002a	48 c7 40 b8 01
	00 00 00	 mov	 QWORD PTR [rax-72], 1
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	48 89 58 e0	 mov	 QWORD PTR [rax-32], rbx
  00039	0f 57 c9	 xorps	 xmm1, xmm1
  0003c	89 58 e8	 mov	 DWORD PTR [rax-24], ebx

; 2282 :     int r = stbtt__run_charstring(info, glyph_index, &c);

  0003f	4c 8d 40 b8	 lea	 r8, QWORD PTR [rax-72]
  00043	0f 11 40 c0	 movups	 XMMWORD PTR [rax-64], xmm0
  00047	f3 0f 7f 48 d0	 movdqu	 XMMWORD PTR [rax-48], xmm1
  0004c	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
  00051	8b c8		 mov	 ecx, eax

; 2283 :     if (x0)  *x0 = r ? c.min_x : 0;

  00053	4d 85 f6	 test	 r14, r14
  00056	74 0c		 je	 SHORT $LN11@stbtt_GetG
  00058	85 c9		 test	 ecx, ecx
  0005a	8b c3		 mov	 eax, ebx
  0005c	0f 45 44 24 38	 cmovne	 eax, DWORD PTR c$1[rsp+24]
  00061	41 89 06	 mov	 DWORD PTR [r14], eax
$LN11@stbtt_GetG:

; 2284 :     if (y0)  *y0 = r ? c.min_y : 0;

  00064	48 85 ff	 test	 rdi, rdi
  00067	74 0b		 je	 SHORT $LN12@stbtt_GetG
  00069	85 c9		 test	 ecx, ecx
  0006b	8b c3		 mov	 eax, ebx
  0006d	0f 45 44 24 40	 cmovne	 eax, DWORD PTR c$1[rsp+32]
  00072	89 07		 mov	 DWORD PTR [rdi], eax
$LN12@stbtt_GetG:

; 2285 :     if (x1)  *x1 = r ? c.max_x : 0;

  00074	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR x1$[rsp]
  0007c	48 85 d2	 test	 rdx, rdx
  0007f	74 0b		 je	 SHORT $LN13@stbtt_GetG
  00081	85 c9		 test	 ecx, ecx
  00083	8b c3		 mov	 eax, ebx
  00085	0f 45 44 24 3c	 cmovne	 eax, DWORD PTR c$1[rsp+28]
  0008a	89 02		 mov	 DWORD PTR [rdx], eax
$LN13@stbtt_GetG:

; 2286 :     if (y1)  *y1 = r ? c.max_y : 0;

  0008c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR y1$[rsp]
  00094	48 85 c0	 test	 rax, rax
  00097	0f 84 c2 00 00
	00		 je	 $LN8@stbtt_GetG
  0009d	85 c9		 test	 ecx, ecx
  0009f	0f 45 5c 24 44	 cmovne	 ebx, DWORD PTR c$1[rsp+36]
  000a4	89 18		 mov	 DWORD PTR [rax], ebx

; 1600 :         stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
; 1601 :     }

  000a6	e9 b4 00 00 00	 jmp	 $LN8@stbtt_GetG
$LN2@stbtt_GetG:

; 1602 :     else {
; 1603 :         int g = stbtt__GetGlyfOffset(info, glyph_index);

  000ab	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1604 :         if (g < 0) return 0;

  000b0	85 c0		 test	 eax, eax
  000b2	79 07		 jns	 SHORT $LN4@stbtt_GetG
  000b4	33 c0		 xor	 eax, eax
  000b6	e9 a9 00 00 00	 jmp	 $LN1@stbtt_GetG
$LN4@stbtt_GetG:

; 1605 : 
; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  000bb	4c 63 d0	 movsxd	 r10, eax
  000be	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
  000c3	4d 85 f6	 test	 r14, r14
  000c6	74 1d		 je	 SHORT $LN24@stbtt_GetG
  000c8	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000cc	0f bf cb	 movsx	 ecx, bx
  000cf	43 0f b6 44 10
	03		 movzx	 eax, BYTE PTR [r8+r10+3]
  000d5	43 0f b6 54 10
	02		 movzx	 edx, BYTE PTR [r8+r10+2]
  000db	0f af d1	 imul	 edx, ecx
  000de	66 03 c2	 add	 ax, dx

; 1605 : 
; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  000e1	98		 cwde
  000e2	41 89 06	 mov	 DWORD PTR [r14], eax
$LN24@stbtt_GetG:

; 1607 :         if (y0) *y0 = ttSHORT(info->data + g + 4);

  000e5	48 85 ff	 test	 rdi, rdi
  000e8	74 1c		 je	 SHORT $LN27@stbtt_GetG
  000ea	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000ee	0f bf cb	 movsx	 ecx, bx
  000f1	43 0f b6 44 10
	05		 movzx	 eax, BYTE PTR [r8+r10+5]
  000f7	43 0f b6 54 10
	04		 movzx	 edx, BYTE PTR [r8+r10+4]
  000fd	0f af d1	 imul	 edx, ecx
  00100	66 03 c2	 add	 ax, dx

; 1607 :         if (y0) *y0 = ttSHORT(info->data + g + 4);

  00103	98		 cwde
  00104	89 07		 mov	 DWORD PTR [rdi], eax
$LN27@stbtt_GetG:

; 1608 :         if (x1) *x1 = ttSHORT(info->data + g + 6);

  00106	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR x1$[rsp]
  0010e	4d 85 c9	 test	 r9, r9
  00111	74 1d		 je	 SHORT $LN28@stbtt_GetG
  00113	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00117	0f bf cb	 movsx	 ecx, bx
  0011a	43 0f b6 44 10
	07		 movzx	 eax, BYTE PTR [r8+r10+7]
  00120	43 0f b6 54 10
	06		 movzx	 edx, BYTE PTR [r8+r10+6]
  00126	0f af d1	 imul	 edx, ecx
  00129	66 03 c2	 add	 ax, dx

; 1608 :         if (x1) *x1 = ttSHORT(info->data + g + 6);

  0012c	98		 cwde
  0012d	41 89 01	 mov	 DWORD PTR [r9], eax
$LN28@stbtt_GetG:

; 1609 :         if (y1) *y1 = ttSHORT(info->data + g + 8);

  00130	4c 8b 9c 24 98
	00 00 00	 mov	 r11, QWORD PTR y1$[rsp]
  00138	4d 85 db	 test	 r11, r11
  0013b	74 22		 je	 SHORT $LN8@stbtt_GetG
  0013d	4c 8b 4e 08	 mov	 r9, QWORD PTR [rsi+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00141	0f bf d3	 movsx	 edx, bx
  00144	43 0f b6 4c 11
	09		 movzx	 ecx, BYTE PTR [r9+r10+9]
  0014a	47 0f b6 44 11
	08		 movzx	 r8d, BYTE PTR [r9+r10+8]
  00150	44 0f af c2	 imul	 r8d, edx
  00154	66 44 03 c1	 add	 r8w, cx

; 1609 :         if (y1) *y1 = ttSHORT(info->data + g + 8);

  00158	41 0f bf c8	 movsx	 ecx, r8w
  0015c	41 89 0b	 mov	 DWORD PTR [r11], ecx
$LN8@stbtt_GetG:

; 1610 :     }
; 1611 :     return 1;

  0015f	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbtt_GetG:

; 1612 : }

  00164	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00169	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  0016e	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]
  00176	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0017a	41 5e		 pop	 r14
  0017c	c3		 ret	 0
stbtt_GetGlyphBox ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
vertices$ = 16
num_vertices$ = 24
was_off$ = 32
start_off$ = 40
sx$ = 48
sy$ = 56
scx$ = 64
scy$ = 72
cx$ = 80
cy$ = 88
?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z PROC ; stbtt__close_shape

; 1633 : {

  00000	48 83 ec 08	 sub	 rsp, 8
  00004	4c 63 d2	 movsxd	 r10, edx
  00007	4c 8b d9	 mov	 r11, rcx

; 1634 :     if (start_off) {

  0000a	45 85 c9	 test	 r9d, r9d
  0000d	0f 84 84 00 00
	00		 je	 $LN2@stbtt__clo

; 1635 :         if (was_off)

  00013	44 8b 4c 24 48	 mov	 r9d, DWORD PTR scy$[rsp]
  00018	48 89 1c 24	 mov	 QWORD PTR [rsp], rbx
  0001c	8b 5c 24 40	 mov	 ebx, DWORD PTR scx$[rsp]
  00020	45 85 c0	 test	 r8d, r8d
  00023	74 37		 je	 SHORT $LN4@stbtt__clo

; 1636 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + scx) >> 1, (cy + scy) >> 1, cx, cy);

  00025	8b 54 24 50	 mov	 edx, DWORD PTR cx$[rsp]
  00029	4d 6b c2 0e	 imul	 r8, r10, 14
  0002d	8d 04 13	 lea	 eax, DWORD PTR [rbx+rdx]
  00030	41 ff c2	 inc	 r10d
  00033	d1 f8		 sar	 eax, 1

; 1568 :     v->x = (stbtt_int16)x;

  00035	66 41 89 04 08	 mov	 WORD PTR [r8+rcx], ax
  0003a	41 c6 44 08 0c
	03		 mov	 BYTE PTR [r8+rcx+12], 3

; 1636 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + scx) >> 1, (cy + scy) >> 1, cx, cy);

  00040	8b 4c 24 58	 mov	 ecx, DWORD PTR cy$[rsp]

; 1570 :     v->cx = (stbtt_int16)cx;

  00044	66 43 89 54 18
	04		 mov	 WORD PTR [r8+r11+4], dx

; 1571 :     v->cy = (stbtt_int16)cy;

  0004a	66 43 89 4c 18
	06		 mov	 WORD PTR [r8+r11+6], cx

; 1636 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + scx) >> 1, (cy + scy) >> 1, cx, cy);

  00050	41 8d 04 09	 lea	 eax, DWORD PTR [r9+rcx]
  00054	d1 f8		 sar	 eax, 1

; 1569 :     v->y = (stbtt_int16)y;

  00056	66 43 89 44 18
	02		 mov	 WORD PTR [r8+r11+2], ax
$LN4@stbtt__clo:

; 1637 :         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx, sy, scx, scy);

  0005c	49 63 c2	 movsxd	 rax, r10d
  0005f	48 6b c8 0e	 imul	 rcx, rax, 14

; 1568 :     v->x = (stbtt_int16)x;

  00063	0f b7 44 24 30	 movzx	 eax, WORD PTR sx$[rsp]
  00068	66 42 89 04 19	 mov	 WORD PTR [rcx+r11], ax

; 1569 :     v->y = (stbtt_int16)y;

  0006d	0f b7 44 24 38	 movzx	 eax, WORD PTR sy$[rsp]
  00072	66 42 89 44 19
	02		 mov	 WORD PTR [rcx+r11+2], ax

; 1646 : }

  00078	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]

; 1570 :     v->cx = (stbtt_int16)cx;

  0007c	66 42 89 5c 19
	04		 mov	 WORD PTR [rcx+r11+4], bx

; 1641 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx, sy, cx, cy);
; 1642 :         else
; 1643 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, sx, sy, 0, 0);
; 1644 :     }
; 1645 :     return num_vertices;

  00082	48 8b 1c 24	 mov	 rbx, QWORD PTR [rsp]

; 1567 :     v->type = type;

  00086	42 c6 44 19 0c
	03		 mov	 BYTE PTR [rcx+r11+12], 3

; 1571 :     v->cy = (stbtt_int16)cy;

  0008c	66 46 89 4c 19
	06		 mov	 WORD PTR [rcx+r11+6], r9w

; 1646 : }

  00092	48 83 c4 08	 add	 rsp, 8
  00096	c3		 ret	 0
$LN2@stbtt__clo:

; 1638 :     }
; 1639 :     else {
; 1640 :         if (was_off)

  00097	0f b7 44 24 30	 movzx	 eax, WORD PTR sx$[rsp]
  0009c	49 6b ca 0e	 imul	 rcx, r10, 14
  000a0	66 42 89 04 19	 mov	 WORD PTR [rcx+r11], ax
  000a5	0f b7 44 24 38	 movzx	 eax, WORD PTR sy$[rsp]
  000aa	66 42 89 44 19
	02		 mov	 WORD PTR [rcx+r11+2], ax
  000b0	45 85 c0	 test	 r8d, r8d
  000b3	74 25		 je	 SHORT $LN5@stbtt__clo

; 1570 :     v->cx = (stbtt_int16)cx;

  000b5	0f b7 44 24 50	 movzx	 eax, WORD PTR cx$[rsp]
  000ba	66 42 89 44 19
	04		 mov	 WORD PTR [rcx+r11+4], ax

; 1571 :     v->cy = (stbtt_int16)cy;

  000c0	0f b7 44 24 58	 movzx	 eax, WORD PTR cy$[rsp]
  000c5	66 42 89 44 19
	06		 mov	 WORD PTR [rcx+r11+6], ax

; 1646 : }

  000cb	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]

; 1567 :     v->type = type;

  000cf	42 c6 44 19 0c
	03		 mov	 BYTE PTR [rcx+r11+12], 3

; 1646 : }

  000d5	48 83 c4 08	 add	 rsp, 8
  000d9	c3		 ret	 0
$LN5@stbtt__clo:

; 1570 :     v->cx = (stbtt_int16)cx;

  000da	33 c0		 xor	 eax, eax
  000dc	42 c6 44 19 0c
	02		 mov	 BYTE PTR [rcx+r11+12], 2
  000e2	42 89 44 19 04	 mov	 DWORD PTR [rcx+r11+4], eax

; 1646 : }

  000e7	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  000eb	48 83 c4 08	 add	 rsp, 8
  000ef	c3		 ret	 0
?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ENDP ; stbtt__close_shape
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
tv4471 = 80
scy$1$ = 84
scx$1$ = 88
next_move$1$ = 92
cx$1$ = 96
i$1$ = 100
tv3747 = 104
endPtsOfContours$1$ = 112
mtx$1 = 120
flags$4$ = 352
comp_verts$2 = 352
info$ = 352
glyph_index$ = 360
pvertices$ = 368
tv4472 = 376
?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeTT

; 1649 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 55		 push	 r13
  00012	41 56		 push	 r14
  00014	41 57		 push	 r15
  00016	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H

; 1650 :     stbtt_int16 numberOfContours;
; 1651 :     stbtt_uint8* endPtsOfContours;
; 1652 :     stbtt_uint8* data = info->data;

  0001d	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]

; 1653 :     stbtt_vertex* vertices = 0;

  00021	45 33 e4	 xor	 r12d, r12d
  00024	0f 29 70 b8	 movaps	 XMMWORD PTR [rax-72], xmm6
  00028	4c 8b e9	 mov	 r13, rcx
  0002b	0f 29 78 a8	 movaps	 XMMWORD PTR [rax-88], xmm7
  0002f	41 8b fc	 mov	 edi, r12d
  00032	44 0f 29 40 98	 movaps	 XMMWORD PTR [rax-104], xmm8

; 1654 :     int num_vertices = 0;

  00037	45 8b fc	 mov	 r15d, r12d
  0003a	44 0f 29 48 88	 movaps	 XMMWORD PTR [rax-120], xmm9
  0003f	44 0f 29 90 78
	ff ff ff	 movaps	 XMMWORD PTR [rax-136], xmm10
  00047	44 0f 29 98 68
	ff ff ff	 movaps	 XMMWORD PTR [rax-152], xmm11
  0004f	44 0f 29 a0 58
	ff ff ff	 movaps	 XMMWORD PTR [rax-168], xmm12
  00057	44 0f 29 a8 48
	ff ff ff	 movaps	 XMMWORD PTR [rax-184], xmm13
  0005f	44 0f 29 b0 38
	ff ff ff	 movaps	 XMMWORD PTR [rax-200], xmm14

; 1655 :     int g = stbtt__GetGlyfOffset(info, glyph_index);

  00067	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1656 : 
; 1657 :     *pvertices = NULL;

  0006c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR pvertices$[rsp]
  00074	4c 89 21	 mov	 QWORD PTR [rcx], r12

; 1658 : 
; 1659 :     if (g < 0) return 0;

  00077	85 c0		 test	 eax, eax
  00079	0f 88 15 0c 00
	00		 js	 $LN159@stbtt__Get

; 1660 : 
; 1661 :     numberOfContours = ttSHORT(data + g);

  0007f	4c 63 d0	 movsxd	 r10, eax

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00082	41 bb 00 01 00
	00		 mov	 r11d, 256		; 00000100H
  00088	41 0f bf c3	 movsx	 eax, r11w
  0008c	41 0f b6 14 1a	 movzx	 edx, BYTE PTR [r10+rbx]
  00091	0f af d0	 imul	 edx, eax
  00094	41 0f b6 44 1a
	01		 movzx	 eax, BYTE PTR [r10+rbx+1]
  0009a	66 03 d0	 add	 dx, ax

; 1662 : 
; 1663 :     if (numberOfContours > 0) {

  0009d	66 85 d2	 test	 dx, dx
  000a0	0f 8e f5 03 00
	00		 jle	 $LN26@stbtt__Get

; 1664 :         stbtt_uint8 flags = 0, flagcount;
; 1665 :         stbtt_int32 ins, i, j = 0, m, n, next_move, was_off = 0, off, start_off = 0;
; 1666 :         stbtt_int32 x, y, cx, cy, sx, sy, scx, scy;
; 1667 :         stbtt_uint8* points;
; 1668 :         endPtsOfContours = (data + g + 10);
; 1669 :         ins = ttUSHORT(data + g + 10 + numberOfContours * 2);

  000a6	0f bf c2	 movsx	 eax, dx
  000a9	4c 8d 4b 0a	 lea	 r9, QWORD PTR [rbx+10]
  000ad	4d 03 ca	 add	 r9, r10
  000b0	40 32 ed	 xor	 bpl, bpl
  000b3	41 8b f4	 mov	 esi, r12d
  000b6	4c 89 4c 24 70	 mov	 QWORD PTR endPtsOfContours$1$[rsp], r9
  000bb	45 8b f4	 mov	 r14d, r12d
  000be	44 8d 04 00	 lea	 r8d, DWORD PTR [rax+rax]
  000c2	4d 63 f8	 movsxd	 r15, r8d
  000c5	4b 8d 0c 17	 lea	 rcx, QWORD PTR [r15+r10]

; 1670 :         points = data + g + 10 + numberOfContours * 2 + 2 + ins;

  000c9	0f b6 44 19 0a	 movzx	 eax, BYTE PTR [rcx+rbx+10]
  000ce	0f b6 54 19 0b	 movzx	 edx, BYTE PTR [rcx+rbx+11]
  000d3	48 83 c3 0c	 add	 rbx, 12

; 1671 : 
; 1672 :         n = 1 + ttUSHORT(endPtsOfContours + numberOfContours * 2 - 2);

  000d7	43 0f b6 4c 0f
	fe		 movzx	 ecx, BYTE PTR [r15+r9-2]
  000dd	48 c1 e0 08	 shl	 rax, 8
  000e1	49 03 c7	 add	 rax, r15
  000e4	c1 e1 08	 shl	 ecx, 8
  000e7	48 03 d0	 add	 rdx, rax
  000ea	43 0f b6 44 0f
	ff		 movzx	 eax, BYTE PTR [r15+r9-1]
  000f0	49 03 d2	 add	 rdx, r10
  000f3	03 c8		 add	 ecx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  000f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1670 :         points = data + g + 10 + numberOfContours * 2 + 2 + ins;

  000fc	48 03 da	 add	 rbx, rdx

; 1673 : 
; 1674 :         m = n + 2 * numberOfContours;  // a loose bound on how many vertices we might need

  000ff	41 8d 50 01	 lea	 edx, DWORD PTR [r8+1]
  00103	03 d1		 add	 edx, ecx
  00105	44 8d 61 01	 lea	 r12d, DWORD PTR [rcx+1]
  00109	44 89 64 24 68	 mov	 DWORD PTR tv3747[rsp], r12d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0010e	48 85 c0	 test	 rax, rax
  00111	74 06		 je	 SHORT $LN83@stbtt__Get

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00113	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN83@stbtt__Get:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1675 :         vertices = (stbtt_vertex*)STBTT_malloc(m * sizeof(vertices[0]), info->userdata);

  00119	48 63 c2	 movsxd	 rax, edx
  0011c	48 6b c8 0e	 imul	 rcx, rax, 14
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00126	48 8b f8	 mov	 rdi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1676 :         if (vertices == 0)

  00129	48 85 c0	 test	 rax, rax
  0012c	0f 84 62 0b 00
	00		 je	 $LN159@stbtt__Get

; 1677 :             return 0;
; 1678 : 
; 1679 :         next_move = 0;

  00132	45 33 ed	 xor	 r13d, r13d

; 1680 :         flagcount = 0;
; 1681 : 
; 1682 :         // in first pass, we load uninterpreted data into the allocated array
; 1683 :         // above, shifted to the end of the array so we won't overwrite it when
; 1684 :         // we create our final data starting from the front
; 1685 : 
; 1686 :         off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated
; 1687 : 
; 1688 :         // first load flags
; 1689 : 
; 1690 :         for (i = 0; i < n; ++i) {

  00135	45 8b dc	 mov	 r11d, r12d
  00138	32 d2		 xor	 dl, dl
  0013a	44 89 6c 24 5c	 mov	 DWORD PTR next_move$1$[rsp], r13d
  0013f	45 85 e4	 test	 r12d, r12d
  00142	0f 84 fe 02 00
	00		 je	 $LN9@stbtt__Get
  00148	49 6b cf 0e	 imul	 rcx, r15, 14
  0014c	4c 8d 40 0c	 lea	 r8, QWORD PTR [rax+12]
  00150	45 8b cb	 mov	 r9d, r11d
  00153	4c 03 c1	 add	 r8, rcx
$LL4@stbtt__Get:

; 1691 :             if (flagcount == 0) {

  00156	84 d2		 test	 dl, dl
  00158	75 20		 jne	 SHORT $LN29@stbtt__Get

; 1692 :                 flags = *points++;

  0015a	0f b6 2b	 movzx	 ebp, BYTE PTR [rbx]

; 1693 :                 if (flags & 8)

  0015d	40 0f b6 cd	 movzx	 ecx, bpl
  00161	80 e1 08	 and	 cl, 8
  00164	74 04		 je	 SHORT $LN31@stbtt__Get

; 1694 :                     flagcount = *points++;

  00166	0f b6 53 01	 movzx	 edx, BYTE PTR [rbx+1]
$LN31@stbtt__Get:

; 1695 :             }

  0016a	84 c9		 test	 cl, cl
  0016c	49 8b c5	 mov	 rax, r13
  0016f	0f 95 c0	 setne	 al
  00172	48 ff c0	 inc	 rax
  00175	48 03 d8	 add	 rbx, rax
  00178	eb 03		 jmp	 SHORT $LN30@stbtt__Get
$LN29@stbtt__Get:

; 1696 :             else
; 1697 :                 --flagcount;

  0017a	80 c2 ff	 add	 dl, 255			; 000000ffH
$LN30@stbtt__Get:

; 1698 :             vertices[off + i].type = flags;

  0017d	41 88 28	 mov	 BYTE PTR [r8], bpl
  00180	49 83 c0 0e	 add	 r8, 14
  00184	49 83 e9 01	 sub	 r9, 1
  00188	75 cc		 jne	 SHORT $LL4@stbtt__Get
  0018a	4d 6b cf 0e	 imul	 r9, r15, 14
  0018e	4d 8b d3	 mov	 r10, r11

; 1571 :     v->cy = (stbtt_int16)cy;

  00191	45 8b c5	 mov	 r8d, r13d
  00194	4c 03 cf	 add	 r9, rdi
  00197	bd 00 01 00 00	 mov	 ebp, 256		; 00000100H
  0019c	0f 1f 40 00	 npad	 4
$LL7@stbtt__Get:

; 1699 :         }
; 1700 : 
; 1701 :         // now load x coordinates
; 1702 :         x = 0;
; 1703 :         for (i = 0; i < n; ++i) {
; 1704 :             flags = vertices[off + i].type;
; 1705 :             if (flags & 2) {

  001a0	41 0f b6 51 0c	 movzx	 edx, BYTE PTR [r9+12]
  001a5	80 e2 10	 and	 dl, 16
  001a8	41 f6 41 0c 02	 test	 BYTE PTR [r9+12], 2
  001ad	74 14		 je	 SHORT $LN32@stbtt__Get

; 1706 :                 stbtt_int16 dx = *points++;

  001af	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  001b2	48 ff c3	 inc	 rbx

; 1707 :                 x += (flags & 16) ? dx : -dx; // ???

  001b5	8b c1		 mov	 eax, ecx
  001b7	f7 d8		 neg	 eax
  001b9	84 d2		 test	 dl, dl
  001bb	0f 44 c8	 cmove	 ecx, eax
  001be	44 03 c1	 add	 r8d, ecx

; 1708 :             }

  001c1	eb 1c		 jmp	 SHORT $LN34@stbtt__Get
$LN32@stbtt__Get:

; 1709 :             else {
; 1710 :                 if (!(flags & 16)) {

  001c3	84 d2		 test	 dl, dl
  001c5	75 18		 jne	 SHORT $LN34@stbtt__Get

; 1711 :                     x = x + (stbtt_int16)(points[0] * 256 + points[1]);

  001c7	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  001cb	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  001ce	0f bf cd	 movsx	 ecx, bp
  001d1	0f af d1	 imul	 edx, ecx
  001d4	66 03 c2	 add	 ax, dx
  001d7	98		 cwde
  001d8	44 03 c0	 add	 r8d, eax

; 1712 :                     points += 2;

  001db	48 83 c3 02	 add	 rbx, 2
$LN34@stbtt__Get:

; 1713 :                 }
; 1714 :             }
; 1715 :             vertices[off + i].x = (stbtt_int16)x;

  001df	66 45 89 01	 mov	 WORD PTR [r9], r8w
  001e3	49 83 c1 0e	 add	 r9, 14
  001e7	49 83 ea 01	 sub	 r10, 1
  001eb	75 b3		 jne	 SHORT $LL7@stbtt__Get
  001ed	49 6b c7 0e	 imul	 rax, r15, 14
  001f1	4c 8d 4f 02	 lea	 r9, QWORD PTR [rdi+2]
  001f5	4d 8b d3	 mov	 r10, r11
  001f8	4c 03 c8	 add	 r9, rax

; 1571 :     v->cy = (stbtt_int16)cy;

  001fb	45 8b c5	 mov	 r8d, r13d
  001fe	66 90		 npad	 2
$LL10@stbtt__Get:

; 1716 :         }
; 1717 : 
; 1718 :         // now load y coordinates
; 1719 :         y = 0;
; 1720 :         for (i = 0; i < n; ++i) {
; 1721 :             flags = vertices[off + i].type;
; 1722 :             if (flags & 4) {

  00200	41 0f b6 51 0a	 movzx	 edx, BYTE PTR [r9+10]
  00205	80 e2 20	 and	 dl, 32			; 00000020H
  00208	41 f6 41 0a 04	 test	 BYTE PTR [r9+10], 4
  0020d	74 14		 je	 SHORT $LN35@stbtt__Get

; 1723 :                 stbtt_int16 dy = *points++;

  0020f	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00212	48 ff c3	 inc	 rbx

; 1724 :                 y += (flags & 32) ? dy : -dy; // ???

  00215	8b c1		 mov	 eax, ecx
  00217	f7 d8		 neg	 eax
  00219	84 d2		 test	 dl, dl
  0021b	0f 44 c8	 cmove	 ecx, eax
  0021e	44 03 c1	 add	 r8d, ecx

; 1725 :             }

  00221	eb 1c		 jmp	 SHORT $LN37@stbtt__Get
$LN35@stbtt__Get:

; 1726 :             else {
; 1727 :                 if (!(flags & 32)) {

  00223	84 d2		 test	 dl, dl
  00225	75 18		 jne	 SHORT $LN37@stbtt__Get

; 1728 :                     y = y + (stbtt_int16)(points[0] * 256 + points[1]);

  00227	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  0022b	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  0022e	0f bf cd	 movsx	 ecx, bp
  00231	0f af d1	 imul	 edx, ecx
  00234	66 03 c2	 add	 ax, dx
  00237	98		 cwde
  00238	44 03 c0	 add	 r8d, eax

; 1729 :                     points += 2;

  0023b	48 83 c3 02	 add	 rbx, 2
$LN37@stbtt__Get:

; 1730 :                 }
; 1731 :             }
; 1732 :             vertices[off + i].y = (stbtt_int16)y;

  0023f	66 45 89 01	 mov	 WORD PTR [r9], r8w
  00243	49 83 c1 0e	 add	 r9, 14
  00247	49 83 ea 01	 sub	 r10, 1
  0024b	75 b3		 jne	 SHORT $LL10@stbtt__Get
  0024d	49 6b df 0e	 imul	 rbx, r15, 14
  00251	49 8b ed	 mov	 rbp, r13

; 1571 :     v->cy = (stbtt_int16)cy;

  00254	44 89 6c 24 54	 mov	 DWORD PTR scy$1$[rsp], r13d
  00259	48 03 df	 add	 rbx, rdi
  0025c	44 89 6c 24 58	 mov	 DWORD PTR scx$1$[rsp], r13d
  00261	33 c0		 xor	 eax, eax
  00263	41 8b d5	 mov	 edx, r13d
  00266	44 8b c0	 mov	 r8d, eax
  00269	89 44 24 60	 mov	 DWORD PTR cx$1$[rsp], eax
  0026d	44 8b d0	 mov	 r10d, eax
  00270	89 44 24 64	 mov	 DWORD PTR i$1$[rsp], eax
  00274	44 8b d8	 mov	 r11d, eax
  00277	44 8b c8	 mov	 r9d, eax
  0027a	66 0f 1f 44 00
	00		 npad	 6
$LL13@stbtt__Get:

; 1739 :             flags = vertices[off + i].type;
; 1740 :             x = (stbtt_int16)vertices[off + i].x;

  00280	0f bf 0b	 movsx	 ecx, WORD PTR [rbx]
  00283	44 8b f9	 mov	 r15d, ecx
  00286	0f b6 43 0c	 movzx	 eax, BYTE PTR [rbx+12]
  0028a	66 89 8c 24 78
	01 00 00	 mov	 WORD PTR tv4472[rsp], cx

; 1741 :             y = (stbtt_int16)vertices[off + i].y;

  00292	0f bf 4b 02	 movsx	 ecx, WORD PTR [rbx+2]
  00296	44 8b e1	 mov	 r12d, ecx
  00299	66 89 4c 24 50	 mov	 WORD PTR tv4471[rsp], cx
  0029e	88 84 24 60 01
	00 00		 mov	 BYTE PTR flags$4$[rsp], al

; 1742 : 
; 1743 :             if (next_move == i) {

  002a5	44 39 4c 24 5c	 cmp	 DWORD PTR next_move$1$[rsp], r9d
  002aa	0f 85 d9 00 00
	00		 jne	 $LN38@stbtt__Get

; 1744 :                 if (i != 0)

  002b0	48 85 ed	 test	 rbp, rbp
  002b3	74 46		 je	 SHORT $LN40@stbtt__Get

; 1745 :                     num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);

  002b5	8b 44 24 54	 mov	 eax, DWORD PTR scy$1$[rsp]
  002b9	45 8b ce	 mov	 r9d, r14d
  002bc	44 89 6c 24 48	 mov	 DWORD PTR [rsp+72], r13d
  002c1	48 8b cf	 mov	 rcx, rdi
  002c4	44 89 44 24 40	 mov	 DWORD PTR [rsp+64], r8d
  002c9	44 8b c6	 mov	 r8d, esi
  002cc	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  002d0	8b 44 24 58	 mov	 eax, DWORD PTR scx$1$[rsp]
  002d4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002d8	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  002dd	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  002e2	e8 00 00 00 00	 call	 ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
  002e7	44 8b 44 24 60	 mov	 r8d, DWORD PTR cx$1$[rsp]
  002ec	8b d0		 mov	 edx, eax
  002ee	0f b6 84 24 60
	01 00 00	 movzx	 eax, BYTE PTR flags$4$[rsp]
  002f6	44 8b 4c 24 64	 mov	 r9d, DWORD PTR i$1$[rsp]
$LN40@stbtt__Get:

; 1746 : 
; 1747 :                 // now start the new one
; 1748 :                 start_off = !(flags & 1);

  002fb	44 0f b6 f0	 movzx	 r14d, al
  002ff	41 f7 d6	 not	 r14d
  00302	41 83 e6 01	 and	 r14d, 1

; 1749 :                 if (start_off) {

  00306	74 34		 je	 SHORT $LN41@stbtt__Get

; 1750 :                     // if we start off with an off-curve point, then when we need to find a point on the curve
; 1751 :                     // where we can start, and we need to save some state for when we wraparound.
; 1752 :                     scx = x;
; 1753 :                     scy = y;
; 1754 :                     if (!(vertices[off + i + 1].type & 1)) {

  00308	f6 43 1a 01	 test	 BYTE PTR [rbx+26], 1
  0030c	44 0f bf 5b 0e	 movsx	 r11d, WORD PTR [rbx+14]
  00311	44 0f bf 53 10	 movsx	 r10d, WORD PTR [rbx+16]
  00316	44 89 7c 24 58	 mov	 DWORD PTR scx$1$[rsp], r15d
  0031b	44 89 64 24 54	 mov	 DWORD PTR scy$1$[rsp], r12d
  00320	75 0e		 jne	 SHORT $LN43@stbtt__Get

; 1755 :                         // next point is also a curve point, so interpolate an on-point curve
; 1756 :                         sx = (x + (stbtt_int32)vertices[off + i + 1].x) >> 1;

  00322	45 03 df	 add	 r11d, r15d

; 1757 :                         sy = (y + (stbtt_int32)vertices[off + i + 1].y) >> 1;

  00325	45 03 d4	 add	 r10d, r12d
  00328	41 d1 fb	 sar	 r11d, 1
  0032b	41 d1 fa	 sar	 r10d, 1

; 1758 :                     }

  0032e	eb 12		 jmp	 SHORT $LN42@stbtt__Get
$LN43@stbtt__Get:

; 1759 :                     else {
; 1760 :                         // otherwise just use the next point as our start point
; 1761 :                         sx = (stbtt_int32)vertices[off + i + 1].x;
; 1762 :                         sy = (stbtt_int32)vertices[off + i + 1].y;
; 1763 :                         ++i; // we're using point i+1 as the starting point, so skip it

  00330	41 ff c1	 inc	 r9d
  00333	48 ff c5	 inc	 rbp
  00336	48 83 c3 0e	 add	 rbx, 14

; 1764 :                     }
; 1765 :                 }

  0033a	eb 06		 jmp	 SHORT $LN42@stbtt__Get
$LN41@stbtt__Get:

; 1766 :                 else {
; 1767 :                     sx = x;

  0033c	45 8b df	 mov	 r11d, r15d

; 1768 :                     sy = y;

  0033f	45 8b d4	 mov	 r10d, r12d
$LN42@stbtt__Get:

; 1772 :                 next_move = 1 + ttUSHORT(endPtsOfContours + j * 2);

  00342	4c 8b 7c 24 70	 mov	 r15, QWORD PTR endPtsOfContours$1$[rsp]
  00347	48 63 c2	 movsxd	 rax, edx
  0034a	ff c2		 inc	 edx
  0034c	48 6b c8 0e	 imul	 rcx, rax, 14

; 1570 :     v->cx = (stbtt_int16)cx;

  00350	33 c0		 xor	 eax, eax

; 1769 :                 }
; 1770 :                 stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove, sx, sy, 0, 0);

  00352	48 03 cf	 add	 rcx, rdi

; 1771 :                 was_off = 0;

  00355	8b f0		 mov	 esi, eax

; 1570 :     v->cx = (stbtt_int16)cx;

  00357	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0035a	c6 41 0c 01	 mov	 BYTE PTR [rcx+12], 1
  0035e	66 44 89 19	 mov	 WORD PTR [rcx], r11w
  00362	66 44 89 51 02	 mov	 WORD PTR [rcx+2], r10w

; 1772 :                 next_move = 1 + ttUSHORT(endPtsOfContours + j * 2);

  00367	41 0f b6 4f 01	 movzx	 ecx, BYTE PTR [r15+1]
  0036c	41 0f b6 07	 movzx	 eax, BYTE PTR [r15]
  00370	ff c1		 inc	 ecx
  00372	c1 e0 08	 shl	 eax, 8
  00375	03 c1		 add	 eax, ecx

; 1773 :                 ++j;

  00377	49 83 c7 02	 add	 r15, 2
  0037b	89 44 24 5c	 mov	 DWORD PTR next_move$1$[rsp], eax
  0037f	4c 89 7c 24 70	 mov	 QWORD PTR endPtsOfContours$1$[rsp], r15

; 1774 :             }

  00384	e9 97 00 00 00	 jmp	 $LN11@stbtt__Get
$LN38@stbtt__Get:

; 1775 :             else {
; 1776 :                 if (!(flags & 1)) { // if it's a curve

  00389	a8 01		 test	 al, 1
  0038b	75 43		 jne	 SHORT $LN45@stbtt__Get

; 1777 :                     if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint

  0038d	85 f6		 test	 esi, esi
  0038f	74 2d		 je	 SHORT $LN213@stbtt__Get

; 1778 :                         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);

  00391	48 63 c2	 movsxd	 rax, edx
  00394	ff c2		 inc	 edx
  00396	48 6b c8 0e	 imul	 rcx, rax, 14
  0039a	43 8d 04 38	 lea	 eax, DWORD PTR [r8+r15]
  0039e	48 03 cf	 add	 rcx, rdi
  003a1	d1 f8		 sar	 eax, 1

; 1568 :     v->x = (stbtt_int16)x;

  003a3	66 89 01	 mov	 WORD PTR [rcx], ax

; 1778 :                         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);

  003a6	43 8d 04 2c	 lea	 eax, DWORD PTR [r12+r13]
  003aa	d1 f8		 sar	 eax, 1

; 1569 :     v->y = (stbtt_int16)y;

  003ac	66 89 41 02	 mov	 WORD PTR [rcx+2], ax
  003b0	c6 41 0c 03	 mov	 BYTE PTR [rcx+12], 3

; 1570 :     v->cx = (stbtt_int16)cx;

  003b4	66 44 89 41 04	 mov	 WORD PTR [rcx+4], r8w

; 1571 :     v->cy = (stbtt_int16)cy;

  003b9	66 44 89 69 06	 mov	 WORD PTR [rcx+6], r13w
$LN213@stbtt__Get:

; 1779 :                     cx = x;

  003be	45 8b c7	 mov	 r8d, r15d
  003c1	44 89 7c 24 60	 mov	 DWORD PTR cx$1$[rsp], r15d

; 1780 :                     cy = y;

  003c6	45 8b ec	 mov	 r13d, r12d

; 1781 :                     was_off = 1;

  003c9	be 01 00 00 00	 mov	 esi, 1

; 1782 :                 }

  003ce	eb 50		 jmp	 SHORT $LN11@stbtt__Get
$LN45@stbtt__Get:

; 1783 :                 else {
; 1784 :                     if (was_off)

  003d0	48 63 c2	 movsxd	 rax, edx
  003d3	48 6b c8 0e	 imul	 rcx, rax, 14
  003d7	ff c2		 inc	 edx
  003d9	85 f6		 test	 esi, esi
  003db	74 0a		 je	 SHORT $LN48@stbtt__Get

; 1571 :     v->cy = (stbtt_int16)cy;

  003dd	45 0f b7 fd	 movzx	 r15d, r13w
  003e1	45 0f b7 e0	 movzx	 r12d, r8w

; 1785 :                         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x, y, cx, cy);

  003e5	eb 08		 jmp	 SHORT $LN49@stbtt__Get
$LN48@stbtt__Get:

; 1571 :     v->cy = (stbtt_int16)cy;

  003e7	33 c0		 xor	 eax, eax
  003e9	44 8b f8	 mov	 r15d, eax
  003ec	44 8b e0	 mov	 r12d, eax
$LN49@stbtt__Get:

; 1786 :                     else
; 1787 :                         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x, y, 0, 0);
; 1788 :                     was_off = 0;

  003ef	85 f6		 test	 esi, esi
  003f1	0f 95 c0	 setne	 al
  003f4	04 02		 add	 al, 2
  003f6	88 44 39 0c	 mov	 BYTE PTR [rcx+rdi+12], al
  003fa	0f b7 84 24 78
	01 00 00	 movzx	 eax, WORD PTR tv4472[rsp]
  00402	66 89 04 39	 mov	 WORD PTR [rcx+rdi], ax
  00406	0f b7 44 24 50	 movzx	 eax, WORD PTR tv4471[rsp]
  0040b	66 89 44 39 02	 mov	 WORD PTR [rcx+rdi+2], ax
  00410	33 c0		 xor	 eax, eax
  00412	66 44 89 64 39
	04		 mov	 WORD PTR [rcx+rdi+4], r12w
  00418	8b f0		 mov	 esi, eax
  0041a	66 44 89 7c 39
	06		 mov	 WORD PTR [rcx+rdi+6], r15w
$LN11@stbtt__Get:

; 1738 :         for (i = 0; i < n; ++i) {

  00420	8b 4c 24 68	 mov	 ecx, DWORD PTR tv3747[rsp]
  00424	41 ff c1	 inc	 r9d
  00427	48 ff c5	 inc	 rbp
  0042a	44 89 4c 24 64	 mov	 DWORD PTR i$1$[rsp], r9d
  0042f	48 83 c3 0e	 add	 rbx, 14
  00433	48 3b e9	 cmp	 rbp, rcx
  00436	0f 8c 44 fe ff
	ff		 jl	 $LL13@stbtt__Get
  0043c	8b 44 24 54	 mov	 eax, DWORD PTR scy$1$[rsp]
  00440	8b 4c 24 58	 mov	 ecx, DWORD PTR scx$1$[rsp]
  00444	eb 15		 jmp	 SHORT $LN12@stbtt__Get
$LN9@stbtt__Get:

; 1733 :         }
; 1734 : 
; 1735 :         // now convert them to our format
; 1736 :         num_vertices = 0;
; 1737 :         sx = sy = cx = cy = scx = scy = 0;

  00446	45 33 c9	 xor	 r9d, r9d
  00449	41 8b d5	 mov	 edx, r13d
  0044c	45 8b c1	 mov	 r8d, r9d
  0044f	45 8b d1	 mov	 r10d, r9d
  00452	45 8b d9	 mov	 r11d, r9d
  00455	41 8b c5	 mov	 eax, r13d
  00458	41 8b cd	 mov	 ecx, r13d
$LN12@stbtt__Get:

; 1789 :                 }
; 1790 :             }
; 1791 :         }
; 1792 :         num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);

  0045b	44 89 6c 24 48	 mov	 DWORD PTR [rsp+72], r13d
  00460	45 8b ce	 mov	 r9d, r14d
  00463	44 89 44 24 40	 mov	 DWORD PTR [rsp+64], r8d
  00468	44 8b c6	 mov	 r8d, esi
  0046b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0046f	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00473	48 8b cf	 mov	 rcx, rdi
  00476	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  0047b	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  00480	e8 00 00 00 00	 call	 ?stbtt__close_shape@@YAHPEAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
  00485	44 8b f8	 mov	 r15d, eax

; 1878 :     }
; 1879 :     else {
; 1880 :         // numberOfCounters == 0, do nothing
; 1881 :     }
; 1882 : 
; 1883 :     *pvertices = vertices;

  00488	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR pvertices$[rsp]
  00490	48 89 38	 mov	 QWORD PTR [rax], rdi

; 1884 :     return num_vertices;

  00493	41 8b c7	 mov	 eax, r15d
  00496	e9 fb 07 00 00	 jmp	 $LN1@stbtt__Get
$LN26@stbtt__Get:

; 1793 :     }
; 1794 :     else if (numberOfContours == -1) {

  0049b	66 83 fa ff	 cmp	 dx, -1
  0049f	0f 85 3c 08 00
	00		 jne	 $LN50@stbtt__Get

; 1795 :         // Compound shapes.
; 1796 :         int more = 1;
; 1797 :         stbtt_uint8* comp = data + g + 10;
; 1798 :         num_vertices = 0;
; 1799 :         vertices = 0;

  004a5	f3 44 0f 10 35
	00 00 00 00	 movss	 xmm14, DWORD PTR __real@38800000
  004ae	48 83 c3 0a	 add	 rbx, 10
  004b2	49 03 da	 add	 rbx, r10
  004b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL14@stbtt__Get:

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  004c0	0f b6 6b 01	 movzx	 ebp, BYTE PTR [rbx+1]
  004c4	45 0f 57 e4	 xorps	 xmm12, xmm12
  004c8	0f b6 73 02	 movzx	 esi, BYTE PTR [rbx+2]
  004cc	45 0f 57 ed	 xorps	 xmm13, xmm13
  004d0	44 0f b6 73 03	 movzx	 r14d, BYTE PTR [rbx+3]

; 1801 :             stbtt_uint16 flags, gidx;
; 1802 :             int comp_num_verts = 0, i;
; 1803 :             stbtt_vertex* comp_verts = 0, * tmp = 0;
; 1804 :             float mtx[6] = { 1,0,0,1,0,0 }, m, n;
; 1805 : 
; 1806 :             flags = ttSHORT(comp); comp += 2;
; 1807 :             gidx = ttSHORT(comp); comp += 2;

  004d5	48 83 c3 04	 add	 rbx, 4
  004d9	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f80000000000000000000003f800000
  004e0	4c 89 a4 24 60
	01 00 00	 mov	 QWORD PTR comp_verts$2[rsp], r12
  004e8	0f 11 44 24 78	 movups	 XMMWORD PTR mtx$1[rsp], xmm0

; 1808 : 
; 1809 :             if (flags & 2) { // XY values

  004ed	40 f6 c5 02	 test	 bpl, 2
  004f1	74 5b		 je	 SHORT $LN18@stbtt__Get

; 1810 :                 if (flags & 1) { // shorts

  004f3	4c 8d 53 01	 lea	 r10, QWORD PTR [rbx+1]
  004f7	40 f6 c5 01	 test	 bpl, 1
  004fb	74 32		 je	 SHORT $LN54@stbtt__Get

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  004fd	0f b6 53 02	 movzx	 edx, BYTE PTR [rbx+2]
  00501	4c 8d 43 03	 lea	 r8, QWORD PTR [rbx+3]
  00505	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]

; 1811 :                     mtx[4] = ttSHORT(comp); comp += 2;
; 1812 :                     mtx[5] = ttSHORT(comp); comp += 2;

  00508	48 83 c3 04	 add	 rbx, 4

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0050c	41 0f bf c3	 movsx	 eax, r11w
  00510	0f af d0	 imul	 edx, eax
  00513	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00517	66 03 d0	 add	 dx, ax
  0051a	41 0f bf c3	 movsx	 eax, r11w
  0051e	0f af c8	 imul	 ecx, eax
  00521	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00525	44 0f bf c2	 movsx	 r8d, dx
  00529	66 03 c1	 add	 ax, cx
  0052c	98		 cwde

; 1813 :                 }

  0052d	eb 0b		 jmp	 SHORT $LN55@stbtt__Get
$LN54@stbtt__Get:

; 1814 :                 else {
; 1815 :                     mtx[4] = ttCHAR(comp); comp += 1;

  0052f	0f be 03	 movsx	 eax, BYTE PTR [rbx]

; 1816 :                     mtx[5] = ttCHAR(comp); comp += 1;

  00532	49 8d 5a 01	 lea	 rbx, QWORD PTR [r10+1]
  00536	45 0f be 02	 movsx	 r8d, BYTE PTR [r10]
$LN55@stbtt__Get:

; 1817 :                 }
; 1818 :             }

  0053a	66 45 0f 6e e8	 movd	 xmm13, r8d
  0053f	66 44 0f 6e e0	 movd	 xmm12, eax
  00544	45 0f 5b ed	 cvtdq2ps xmm13, xmm13
  00548	45 0f 5b e4	 cvtdq2ps xmm12, xmm12
  0054c	eb 20		 jmp	 SHORT $LN17@stbtt__Get
$LN18@stbtt__Get:

; 1819 :             else {
; 1820 :                 // @TODO handle matching point
; 1821 :                 STBTT_assert(0);

  0054e	41 b8 1d 07 00
	00		 mov	 r8d, 1821		; 0000071dH
  00554	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0055b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  00562	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00568	41 bb 00 01 00
	00		 mov	 r11d, 256		; 00000100H
$LN17@stbtt__Get:

; 1822 :             }
; 1823 :             if (flags & (1 << 3)) { // WE_HAVE_A_SCALE

  0056e	40 f6 c5 08	 test	 bpl, 8
  00572	74 32		 je	 SHORT $LN56@stbtt__Get

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00574	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  00578	45 0f 57 c9	 xorps	 xmm9, xmm9
  0057c	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  0057f	45 0f 57 c0	 xorps	 xmm8, xmm8
  00583	41 0f bf cb	 movsx	 ecx, r11w
  00587	0f af d1	 imul	 edx, ecx
  0058a	66 03 c2	 add	 ax, dx
  0058d	98		 cwde

; 1824 :                 mtx[0] = mtx[3] = ttSHORT(comp) / 16384.0f; comp += 2;

  0058e	48 83 c3 02	 add	 rbx, 2
  00592	66 0f 6e f0	 movd	 xmm6, eax
  00596	0f 5b f6	 cvtdq2ps xmm6, xmm6
  00599	f3 41 0f 59 f6	 mulss	 xmm6, xmm14
  0059e	0f 28 fe	 movaps	 xmm7, xmm6

; 1825 :                 mtx[1] = mtx[2] = 0;
; 1826 :             }

  005a1	e9 02 01 00 00	 jmp	 $LN60@stbtt__Get
$LN56@stbtt__Get:

; 1827 :             else if (flags & (1 << 6)) { // WE_HAVE_AN_X_AND_YSCALE

  005a6	40 f6 c5 40	 test	 bpl, 64			; 00000040H
  005aa	74 4e		 je	 SHORT $LN58@stbtt__Get

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  005ac	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  005b0	45 0f 57 c9	 xorps	 xmm9, xmm9
  005b4	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  005b7	45 0f 57 c0	 xorps	 xmm8, xmm8
  005bb	41 0f bf cb	 movsx	 ecx, r11w
  005bf	0f af d1	 imul	 edx, ecx
  005c2	41 0f bf cb	 movsx	 ecx, r11w
  005c6	66 03 c2	 add	 ax, dx
  005c9	0f b6 53 02	 movzx	 edx, BYTE PTR [rbx+2]
  005cd	98		 cwde
  005ce	0f af d1	 imul	 edx, ecx
  005d1	66 0f 6e f8	 movd	 xmm7, eax
  005d5	0f b6 43 03	 movzx	 eax, BYTE PTR [rbx+3]
  005d9	66 03 c2	 add	 ax, dx
  005dc	98		 cwde

; 1828 :                 mtx[0] = ttSHORT(comp) / 16384.0f; comp += 2;
; 1829 :                 mtx[1] = mtx[2] = 0;
; 1830 :                 mtx[3] = ttSHORT(comp) / 16384.0f; comp += 2;

  005dd	48 83 c3 04	 add	 rbx, 4
  005e1	0f 5b ff	 cvtdq2ps xmm7, xmm7
  005e4	66 0f 6e f0	 movd	 xmm6, eax
  005e8	0f 5b f6	 cvtdq2ps xmm6, xmm6
  005eb	f3 41 0f 59 fe	 mulss	 xmm7, xmm14
  005f0	f3 41 0f 59 f6	 mulss	 xmm6, xmm14

; 1831 :             }

  005f5	e9 ae 00 00 00	 jmp	 $LN60@stbtt__Get
$LN58@stbtt__Get:

; 1832 :             else if (flags & (1 << 7)) { // WE_HAVE_A_TWO_BY_TWO

  005fa	40 84 ed	 test	 bpl, bpl
  005fd	0f 89 85 00 00
	00		 jns	 $LN222@stbtt__Get

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00603	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  00607	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  0060a	41 0f bf cb	 movsx	 ecx, r11w
  0060e	0f af d1	 imul	 edx, ecx
  00611	41 0f bf cb	 movsx	 ecx, r11w
  00615	66 03 c2	 add	 ax, dx
  00618	0f b6 53 02	 movzx	 edx, BYTE PTR [rbx+2]
  0061c	98		 cwde
  0061d	0f af d1	 imul	 edx, ecx
  00620	41 0f bf cb	 movsx	 ecx, r11w
  00624	66 0f 6e f8	 movd	 xmm7, eax
  00628	0f b6 43 03	 movzx	 eax, BYTE PTR [rbx+3]
  0062c	66 03 c2	 add	 ax, dx
  0062f	0f b6 53 04	 movzx	 edx, BYTE PTR [rbx+4]
  00633	98		 cwde
  00634	0f af d1	 imul	 edx, ecx
  00637	41 0f bf cb	 movsx	 ecx, r11w

; 1833 :                 mtx[0] = ttSHORT(comp) / 16384.0f; comp += 2;

  0063b	0f 5b ff	 cvtdq2ps xmm7, xmm7
  0063e	66 44 0f 6e c0	 movd	 xmm8, eax

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00643	0f b6 43 05	 movzx	 eax, BYTE PTR [rbx+5]
  00647	66 03 c2	 add	 ax, dx

; 1833 :                 mtx[0] = ttSHORT(comp) / 16384.0f; comp += 2;

  0064a	f3 41 0f 59 fe	 mulss	 xmm7, xmm14

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0064f	0f b6 53 06	 movzx	 edx, BYTE PTR [rbx+6]
  00653	98		 cwde
  00654	0f af d1	 imul	 edx, ecx

; 1834 :                 mtx[1] = ttSHORT(comp) / 16384.0f; comp += 2;

  00657	45 0f 5b c0	 cvtdq2ps xmm8, xmm8
  0065b	66 44 0f 6e c8	 movd	 xmm9, eax

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00660	0f b6 43 07	 movzx	 eax, BYTE PTR [rbx+7]
  00664	66 03 c2	 add	 ax, dx

; 1834 :                 mtx[1] = ttSHORT(comp) / 16384.0f; comp += 2;

  00667	f3 45 0f 59 c6	 mulss	 xmm8, xmm14

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0066c	98		 cwde

; 1835 :                 mtx[2] = ttSHORT(comp) / 16384.0f; comp += 2;
; 1836 :                 mtx[3] = ttSHORT(comp) / 16384.0f; comp += 2;

  0066d	48 83 c3 08	 add	 rbx, 8
  00671	45 0f 5b c9	 cvtdq2ps xmm9, xmm9
  00675	66 0f 6e f0	 movd	 xmm6, eax
  00679	0f 5b f6	 cvtdq2ps xmm6, xmm6
  0067c	f3 45 0f 59 ce	 mulss	 xmm9, xmm14
  00681	f3 41 0f 59 f6	 mulss	 xmm6, xmm14
  00686	eb 20		 jmp	 SHORT $LN60@stbtt__Get
$LN222@stbtt__Get:

; 1832 :             else if (flags & (1 << 7)) { // WE_HAVE_A_TWO_BY_TWO

  00688	f3 0f 10 b4 24
	84 00 00 00	 movss	 xmm6, DWORD PTR mtx$1[rsp+12]
  00691	f3 44 0f 10 8c
	24 80 00 00 00	 movss	 xmm9, DWORD PTR mtx$1[rsp+8]
  0069b	f3 44 0f 10 44
	24 7c		 movss	 xmm8, DWORD PTR mtx$1[rsp+4]
  006a2	f3 0f 10 7c 24
	78		 movss	 xmm7, DWORD PTR mtx$1[rsp]
$LN60@stbtt__Get:

; 1837 :             }
; 1838 : 
; 1839 :             // Find transformation scales.
; 1840 :             m = (float)STBTT_sqrt(mtx[0] * mtx[0] + mtx[1] * mtx[1]);

  006a8	0f 28 c7	 movaps	 xmm0, xmm7
  006ab	41 0f 28 c8	 movaps	 xmm1, xmm8
  006af	f3 0f 59 c7	 mulss	 xmm0, xmm7
  006b3	f3 41 0f 59 c8	 mulss	 xmm1, xmm8
  006b8	f3 0f 58 c8	 addss	 xmm1, xmm0
  006bc	0f 57 c0	 xorps	 xmm0, xmm0
  006bf	0f 2e c1	 ucomiss xmm0, xmm1
  006c2	77 0b		 ja	 SHORT $LN220@stbtt__Get
  006c4	45 0f 57 db	 xorps	 xmm11, xmm11
  006c8	f3 44 0f 51 d9	 sqrtss	 xmm11, xmm1
  006cd	eb 0c		 jmp	 SHORT $LN221@stbtt__Get
$LN220@stbtt__Get:
  006cf	0f 28 c1	 movaps	 xmm0, xmm1
  006d2	e8 00 00 00 00	 call	 sqrtf
  006d7	44 0f 28 d8	 movaps	 xmm11, xmm0
$LN221@stbtt__Get:

; 1841 :             n = (float)STBTT_sqrt(mtx[2] * mtx[2] + mtx[3] * mtx[3]);

  006db	41 0f 28 c9	 movaps	 xmm1, xmm9
  006df	0f 28 c6	 movaps	 xmm0, xmm6
  006e2	f3 41 0f 59 c9	 mulss	 xmm1, xmm9
  006e7	f3 0f 59 c6	 mulss	 xmm0, xmm6
  006eb	f3 0f 58 c1	 addss	 xmm0, xmm1
  006ef	0f 57 c9	 xorps	 xmm1, xmm1
  006f2	0f 2e c8	 ucomiss xmm1, xmm0
  006f5	77 0b		 ja	 SHORT $LN218@stbtt__Get
  006f7	45 0f 57 d2	 xorps	 xmm10, xmm10
  006fb	f3 44 0f 51 d0	 sqrtss	 xmm10, xmm0
  00700	eb 09		 jmp	 SHORT $LN219@stbtt__Get
$LN218@stbtt__Get:
  00702	e8 00 00 00 00	 call	 sqrtf
  00707	44 0f 28 d0	 movaps	 xmm10, xmm0
$LN219@stbtt__Get:

; 1842 : 
; 1843 :             // Get indexed glyph.
; 1844 :             comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

  0070b	8b d6		 mov	 edx, esi

; 2292 :     if (!info->cff.size)

  0070d	4c 8d 84 24 60
	01 00 00	 lea	 r8, QWORD PTR comp_verts$2[rsp]

; 1842 : 
; 1843 :             // Get indexed glyph.
; 1844 :             comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

  00715	c1 e2 08	 shl	 edx, 8

; 2292 :     if (!info->cff.size)

  00718	49 8b cd	 mov	 rcx, r13

; 1842 : 
; 1843 :             // Get indexed glyph.
; 1844 :             comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

  0071b	41 03 d6	 add	 edx, r14d

; 2292 :     if (!info->cff.size)

  0071e	41 83 7d 4c 00	 cmp	 DWORD PTR [r13+76], 0
  00723	75 07		 jne	 SHORT $LN122@stbtt__Get

; 2293 :         return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);

  00725	e8 00 00 00 00	 call	 ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeTT
  0072a	eb 05		 jmp	 SHORT $LN223@stbtt__Get
$LN122@stbtt__Get:

; 2294 :     else
; 2295 :         return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);

  0072c	e8 00 00 00 00	 call	 ?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeT2
$LN223@stbtt__Get:

; 1845 :             if (comp_num_verts > 0) {

  00731	44 8b d0	 mov	 r10d, eax
  00734	85 c0		 test	 eax, eax
  00736	0f 8e fe 04 00
	00		 jle	 $LN61@stbtt__Get

; 1846 :                 // Transform vertices.
; 1847 :                 for (i = 0; i < comp_num_verts; ++i) {

  0073c	48 63 f0	 movsxd	 rsi, eax
  0073f	4d 8b cc	 mov	 r9, r12
  00742	48 83 fe 04	 cmp	 rsi, 4
  00746	0f 8c 5c 03 00
	00		 jl	 $LC199@stbtt__Get

; 1571 :     v->cy = (stbtt_int16)cy;

  0074c	48 8d 56 fc	 lea	 rdx, QWORD PTR [rsi-4]
  00750	4d 8b c4	 mov	 r8, r12
  00753	48 c1 ea 02	 shr	 rdx, 2
  00757	48 ff c2	 inc	 rdx
  0075a	4c 8d 0c 95 00
	00 00 00	 lea	 r9, QWORD PTR [rdx*4]

; 1852 :                     v->y = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));

$LL200@stbtt__Get:

; 1849 :                     stbtt_vertex_type x, y;
; 1850 :                     x = v->x; y = v->y;
; 1851 :                     v->x = (stbtt_vertex_type)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));

  00762	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR comp_verts$2[rsp]
  0076a	0f 57 db	 xorps	 xmm3, xmm3
  0076d	0f 57 d2	 xorps	 xmm2, xmm2
  00770	42 0f bf 44 01
	02		 movsx	 eax, WORD PTR [rcx+r8+2]
  00776	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  0077a	42 0f bf 04 01	 movsx	 eax, WORD PTR [rcx+r8]
  0077f	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  00783	0f 28 c2	 movaps	 xmm0, xmm2

; 1852 :                     v->y = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));

  00786	f3 0f 59 d6	 mulss	 xmm2, xmm6
  0078a	0f 28 cb	 movaps	 xmm1, xmm3
  0078d	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00792	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00796	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  0079b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0079f	f3 0f 58 da	 addss	 xmm3, xmm2
  007a3	0f 57 d2	 xorps	 xmm2, xmm2
  007a6	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  007ab	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  007b0	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  007b5	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  007ba	f3 0f 2c c1	 cvttss2si eax, xmm1
  007be	66 42 89 04 01	 mov	 WORD PTR [rcx+r8], ax
  007c3	f3 0f 2c c3	 cvttss2si eax, xmm3
  007c7	0f 57 db	 xorps	 xmm3, xmm3
  007ca	66 42 89 44 01
	02		 mov	 WORD PTR [rcx+r8+2], ax

; 1853 :                     x = v->cx; y = v->cy;
; 1854 :                     v->cx = (stbtt_vertex_type)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));

  007d0	42 0f bf 44 01
	06		 movsx	 eax, WORD PTR [rcx+r8+6]
  007d6	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  007da	42 0f bf 44 01
	04		 movsx	 eax, WORD PTR [rcx+r8+4]
  007e0	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  007e4	0f 28 c2	 movaps	 xmm0, xmm2

; 1855 :                     v->cy = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));

  007e7	f3 0f 59 d6	 mulss	 xmm2, xmm6
  007eb	0f 28 cb	 movaps	 xmm1, xmm3
  007ee	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  007f3	f3 0f 59 cf	 mulss	 xmm1, xmm7
  007f7	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  007fc	f3 0f 58 c8	 addss	 xmm1, xmm0
  00800	f3 0f 58 da	 addss	 xmm3, xmm2
  00804	0f 57 d2	 xorps	 xmm2, xmm2
  00807	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  0080c	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  00811	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  00816	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  0081b	f3 0f 2c c1	 cvttss2si eax, xmm1
  0081f	66 42 89 44 01
	04		 mov	 WORD PTR [rcx+r8+4], ax
  00825	f3 0f 2c c3	 cvttss2si eax, xmm3
  00829	0f 57 db	 xorps	 xmm3, xmm3
  0082c	66 42 89 44 01
	06		 mov	 WORD PTR [rcx+r8+6], ax
  00832	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR comp_verts$2[rsp]
  0083a	42 0f bf 44 01
	10		 movsx	 eax, WORD PTR [rcx+r8+16]
  00840	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  00844	42 0f bf 44 01
	0e		 movsx	 eax, WORD PTR [rcx+r8+14]
  0084a	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  0084e	0f 28 c2	 movaps	 xmm0, xmm2
  00851	f3 0f 59 d6	 mulss	 xmm2, xmm6
  00855	0f 28 cb	 movaps	 xmm1, xmm3
  00858	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  0085d	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00861	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  00866	f3 0f 58 c8	 addss	 xmm1, xmm0
  0086a	f3 0f 58 da	 addss	 xmm3, xmm2
  0086e	0f 57 d2	 xorps	 xmm2, xmm2
  00871	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  00876	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  0087b	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  00880	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  00885	f3 0f 2c c1	 cvttss2si eax, xmm1
  00889	66 42 89 44 01
	0e		 mov	 WORD PTR [rcx+r8+14], ax
  0088f	f3 0f 2c c3	 cvttss2si eax, xmm3
  00893	0f 57 db	 xorps	 xmm3, xmm3
  00896	66 42 89 44 01
	10		 mov	 WORD PTR [rcx+r8+16], ax
  0089c	42 0f bf 44 01
	14		 movsx	 eax, WORD PTR [rcx+r8+20]
  008a2	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  008a6	42 0f bf 44 01
	12		 movsx	 eax, WORD PTR [rcx+r8+18]
  008ac	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  008b0	0f 28 c2	 movaps	 xmm0, xmm2
  008b3	0f 28 cb	 movaps	 xmm1, xmm3
  008b6	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  008bb	f3 0f 59 cf	 mulss	 xmm1, xmm7
  008bf	f3 0f 58 c8	 addss	 xmm1, xmm0
  008c3	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  008c8	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  008cd	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  008d2	f3 0f 2c c1	 cvttss2si eax, xmm1
  008d6	f3 0f 59 d6	 mulss	 xmm2, xmm6
  008da	66 42 89 44 01
	12		 mov	 WORD PTR [rcx+r8+18], ax
  008e0	f3 0f 58 da	 addss	 xmm3, xmm2
  008e4	0f 57 d2	 xorps	 xmm2, xmm2
  008e7	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  008ec	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  008f1	f3 0f 2c c3	 cvttss2si eax, xmm3
  008f5	0f 57 db	 xorps	 xmm3, xmm3
  008f8	66 42 89 44 01
	14		 mov	 WORD PTR [rcx+r8+20], ax
  008fe	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR comp_verts$2[rsp]
  00906	42 0f bf 44 01
	1e		 movsx	 eax, WORD PTR [rcx+r8+30]
  0090c	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  00910	42 0f bf 44 01
	1c		 movsx	 eax, WORD PTR [rcx+r8+28]
  00916	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  0091a	0f 28 c2	 movaps	 xmm0, xmm2
  0091d	f3 0f 59 d6	 mulss	 xmm2, xmm6
  00921	0f 28 cb	 movaps	 xmm1, xmm3
  00924	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00929	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  0092e	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00932	f3 0f 58 da	 addss	 xmm3, xmm2
  00936	0f 57 d2	 xorps	 xmm2, xmm2
  00939	f3 0f 58 c8	 addss	 xmm1, xmm0
  0093d	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  00942	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  00947	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  0094c	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  00951	f3 0f 2c c1	 cvttss2si eax, xmm1
  00955	66 42 89 44 01
	1c		 mov	 WORD PTR [rcx+r8+28], ax
  0095b	f3 0f 2c c3	 cvttss2si eax, xmm3
  0095f	0f 57 db	 xorps	 xmm3, xmm3
  00962	66 42 89 44 01
	1e		 mov	 WORD PTR [rcx+r8+30], ax
  00968	42 0f bf 44 01
	22		 movsx	 eax, WORD PTR [rcx+r8+34]
  0096e	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  00972	42 0f bf 44 01
	20		 movsx	 eax, WORD PTR [rcx+r8+32]
  00978	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  0097c	0f 28 c2	 movaps	 xmm0, xmm2
  0097f	f3 0f 59 d6	 mulss	 xmm2, xmm6
  00983	0f 28 cb	 movaps	 xmm1, xmm3
  00986	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  0098b	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  00990	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00994	f3 0f 58 da	 addss	 xmm3, xmm2
  00998	0f 57 d2	 xorps	 xmm2, xmm2
  0099b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0099f	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  009a4	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  009a9	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  009ae	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  009b3	f3 0f 2c c1	 cvttss2si eax, xmm1
  009b7	66 42 89 44 01
	20		 mov	 WORD PTR [rcx+r8+32], ax
  009bd	f3 0f 2c c3	 cvttss2si eax, xmm3
  009c1	0f 57 db	 xorps	 xmm3, xmm3
  009c4	66 42 89 44 01
	22		 mov	 WORD PTR [rcx+r8+34], ax
  009ca	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR comp_verts$2[rsp]
  009d2	42 0f bf 44 01
	2c		 movsx	 eax, WORD PTR [rcx+r8+44]
  009d8	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  009dc	42 0f bf 44 01
	2a		 movsx	 eax, WORD PTR [rcx+r8+42]
  009e2	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  009e6	0f 28 c2	 movaps	 xmm0, xmm2
  009e9	f3 0f 59 d6	 mulss	 xmm2, xmm6
  009ed	0f 28 cb	 movaps	 xmm1, xmm3
  009f0	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  009f5	f3 0f 59 cf	 mulss	 xmm1, xmm7
  009f9	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  009fe	f3 0f 58 c8	 addss	 xmm1, xmm0
  00a02	f3 0f 58 da	 addss	 xmm3, xmm2
  00a06	0f 57 d2	 xorps	 xmm2, xmm2
  00a09	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  00a0e	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  00a13	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  00a18	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  00a1d	f3 0f 2c c1	 cvttss2si eax, xmm1
  00a21	66 42 89 44 01
	2a		 mov	 WORD PTR [rcx+r8+42], ax
  00a27	f3 0f 2c c3	 cvttss2si eax, xmm3
  00a2b	66 42 89 44 01
	2c		 mov	 WORD PTR [rcx+r8+44], ax
  00a31	42 0f bf 44 01
	30		 movsx	 eax, WORD PTR [rcx+r8+48]
  00a37	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  00a3b	42 0f bf 44 01
	2e		 movsx	 eax, WORD PTR [rcx+r8+46]

; 1853 :                     x = v->cx; y = v->cy;
; 1854 :                     v->cx = (stbtt_vertex_type)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));

  00a41	0f 57 db	 xorps	 xmm3, xmm3
  00a44	0f 28 c2	 movaps	 xmm0, xmm2
  00a47	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  00a4b	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00a50	0f 28 cb	 movaps	 xmm1, xmm3

; 1855 :                     v->cy = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));

  00a53	f3 0f 59 d6	 mulss	 xmm2, xmm6
  00a57	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00a5b	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  00a60	f3 0f 58 c8	 addss	 xmm1, xmm0
  00a64	f3 0f 58 da	 addss	 xmm3, xmm2
  00a68	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  00a6d	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  00a72	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  00a77	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  00a7c	f3 0f 2c c1	 cvttss2si eax, xmm1
  00a80	66 42 89 44 01
	2e		 mov	 WORD PTR [rcx+r8+46], ax
  00a86	f3 0f 2c c3	 cvttss2si eax, xmm3
  00a8a	66 42 89 44 01
	30		 mov	 WORD PTR [rcx+r8+48], ax
  00a90	49 83 c0 38	 add	 r8, 56			; 00000038H
  00a94	48 83 ea 01	 sub	 rdx, 1
  00a98	0f 85 c4 fc ff
	ff		 jne	 $LL200@stbtt__Get

; 1846 :                 // Transform vertices.
; 1847 :                 for (i = 0; i < comp_num_verts; ++i) {

  00a9e	4c 3b ce	 cmp	 r9, rsi
  00aa1	7c 0e		 jl	 SHORT $LN212@stbtt__Get
  00aa3	e9 e3 00 00 00	 jmp	 $LN198@stbtt__Get
$LC199@stbtt__Get:
  00aa8	45 85 d2	 test	 r10d, r10d
  00aab	0f 8e da 00 00
	00		 jle	 $LN198@stbtt__Get
$LN212@stbtt__Get:
  00ab1	49 6b d1 0e	 imul	 rdx, r9, 14
  00ab5	4c 8b c6	 mov	 r8, rsi
  00ab8	4d 2b c1	 sub	 r8, r9
$LC211@stbtt__Get:

; 1848 :                     stbtt_vertex* v = &comp_verts[i];

  00abb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR comp_verts$2[rsp]
  00ac3	0f 57 db	 xorps	 xmm3, xmm3
  00ac6	0f 57 d2	 xorps	 xmm2, xmm2

; 1849 :                     stbtt_vertex_type x, y;
; 1850 :                     x = v->x; y = v->y;
; 1851 :                     v->x = (stbtt_vertex_type)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));

  00ac9	0f bf 44 11 02	 movsx	 eax, WORD PTR [rcx+rdx+2]
  00ace	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  00ad2	0f bf 04 11	 movsx	 eax, WORD PTR [rcx+rdx]
  00ad6	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  00ada	0f 28 c2	 movaps	 xmm0, xmm2

; 1852 :                     v->y = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));

  00add	f3 0f 59 d6	 mulss	 xmm2, xmm6
  00ae1	0f 28 cb	 movaps	 xmm1, xmm3
  00ae4	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00ae9	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  00aee	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00af2	f3 0f 58 da	 addss	 xmm3, xmm2
  00af6	0f 57 d2	 xorps	 xmm2, xmm2
  00af9	f3 0f 58 c8	 addss	 xmm1, xmm0
  00afd	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  00b02	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  00b07	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  00b0c	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  00b11	f3 0f 2c c1	 cvttss2si eax, xmm1
  00b15	66 89 04 11	 mov	 WORD PTR [rcx+rdx], ax
  00b19	f3 0f 2c c3	 cvttss2si eax, xmm3
  00b1d	0f 57 db	 xorps	 xmm3, xmm3
  00b20	66 89 44 11 02	 mov	 WORD PTR [rcx+rdx+2], ax

; 1853 :                     x = v->cx; y = v->cy;
; 1854 :                     v->cx = (stbtt_vertex_type)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));

  00b25	0f bf 44 11 06	 movsx	 eax, WORD PTR [rcx+rdx+6]
  00b2a	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  00b2e	0f bf 44 11 04	 movsx	 eax, WORD PTR [rcx+rdx+4]
  00b33	f3 0f 2a d8	 cvtsi2ss xmm3, eax
  00b37	0f 28 c2	 movaps	 xmm0, xmm2

; 1855 :                     v->cy = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));

  00b3a	f3 0f 59 d6	 mulss	 xmm2, xmm6
  00b3e	0f 28 cb	 movaps	 xmm1, xmm3
  00b41	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00b46	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00b4a	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  00b4f	f3 0f 58 c8	 addss	 xmm1, xmm0
  00b53	f3 0f 58 da	 addss	 xmm3, xmm2
  00b57	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  00b5c	f3 41 0f 58 dd	 addss	 xmm3, xmm13
  00b61	f3 41 0f 59 cb	 mulss	 xmm1, xmm11
  00b66	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  00b6b	f3 0f 2c c1	 cvttss2si eax, xmm1
  00b6f	66 89 44 11 04	 mov	 WORD PTR [rcx+rdx+4], ax
  00b74	f3 0f 2c c3	 cvttss2si eax, xmm3
  00b78	66 89 44 11 06	 mov	 WORD PTR [rcx+rdx+6], ax
  00b7d	48 83 c2 0e	 add	 rdx, 14
  00b81	49 83 e8 01	 sub	 r8, 1
  00b85	0f 85 30 ff ff
	ff		 jne	 $LC211@stbtt__Get
$LN198@stbtt__Get:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00b8b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00b92	48 85 c0	 test	 rax, rax
  00b95	74 06		 je	 SHORT $LN141@stbtt__Get

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00b97	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN141@stbtt__Get:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1858 :                 tmp = (stbtt_vertex*)STBTT_malloc((num_vertices + comp_num_verts) * sizeof(stbtt_vertex), info->userdata);

  00b9d	47 8d 24 3a	 lea	 r12d, DWORD PTR [r10+r15]
  00ba1	49 63 c4	 movsxd	 rax, r12d
  00ba4	48 6b c8 0e	 imul	 rcx, rax, 14
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00ba8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00bae	4c 8b f0	 mov	 r14, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1859 :                 if (!tmp) {

  00bb1	48 85 c0	 test	 rax, rax
  00bb4	0f 84 95 00 00
	00		 je	 $LN185@stbtt__Get

; 1863 :                 }
; 1864 :                 if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices * sizeof(stbtt_vertex)); //-V595

  00bba	45 85 ff	 test	 r15d, r15d
  00bbd	7e 12		 jle	 SHORT $LN65@stbtt__Get
  00bbf	49 63 cf	 movsxd	 rcx, r15d
  00bc2	48 8b d7	 mov	 rdx, rdi
  00bc5	4c 6b c1 0e	 imul	 r8, rcx, 14
  00bc9	48 8b c8	 mov	 rcx, rax
  00bcc	e8 00 00 00 00	 call	 memcpy
$LN65@stbtt__Get:

; 1865 :                 STBTT_memcpy(tmp + num_vertices, comp_verts, comp_num_verts * sizeof(stbtt_vertex));

  00bd1	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR comp_verts$2[rsp]
  00bd9	49 63 c7	 movsxd	 rax, r15d
  00bdc	48 6b c8 0e	 imul	 rcx, rax, 14
  00be0	4c 6b c6 0e	 imul	 r8, rsi, 14
  00be4	49 03 ce	 add	 rcx, r14
  00be7	e8 00 00 00 00	 call	 memcpy

; 1866 :                 if (vertices) STBTT_free(vertices, info->userdata);

  00bec	48 85 ff	 test	 rdi, rdi
  00bef	74 1b		 je	 SHORT $LN167@stbtt__Get
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00bf1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00bf8	48 85 c0	 test	 rax, rax
  00bfb	74 06		 je	 SHORT $LN165@stbtt__Get

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00bfd	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN165@stbtt__Get:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00c03	48 8b cf	 mov	 rcx, rdi
  00c06	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN167@stbtt__Get:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1868 :                 STBTT_free(comp_verts, info->userdata);

  00c0c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR comp_verts$2[rsp]
  00c14	49 8b fe	 mov	 rdi, r14
  00c17	48 85 c9	 test	 rcx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00c1a	74 12		 je	 SHORT $LN173@stbtt__Get

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00c1c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00c23	48 85 c0	 test	 rax, rax
  00c26	74 06		 je	 SHORT $LN173@stbtt__Get

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00c28	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN173@stbtt__Get:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00c2e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1869 :                 num_vertices += comp_num_verts;

  00c34	45 8b fc	 mov	 r15d, r12d
  00c37	45 33 e4	 xor	 r12d, r12d
$LN61@stbtt__Get:

; 1870 :             }
; 1871 :             // More components ?
; 1872 :             more = flags & (1 << 5);

  00c3a	40 f6 c5 20	 test	 bpl, 32			; 00000020H
  00c3e	0f 84 bc 00 00
	00		 je	 $LN67@stbtt__Get

; 1800 :         while (more) {

  00c44	41 bb 00 01 00
	00		 mov	 r11d, 256		; 00000100H
  00c4a	e9 71 f8 ff ff	 jmp	 $LL14@stbtt__Get
$LN185@stbtt__Get:

; 1860 :                     if (vertices) STBTT_free(vertices, info->userdata);

  00c4f	48 85 ff	 test	 rdi, rdi
  00c52	74 1b		 je	 SHORT $LN151@stbtt__Get
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00c54	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00c5b	48 85 c0	 test	 rax, rax
  00c5e	74 06		 je	 SHORT $LN149@stbtt__Get

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00c60	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN149@stbtt__Get:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00c66	48 8b cf	 mov	 rcx, rdi
  00c69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN151@stbtt__Get:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1861 :                     if (comp_verts) STBTT_free(comp_verts, info->userdata);

  00c6f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR comp_verts$2[rsp]
  00c77	48 85 c9	 test	 rcx, rcx
  00c7a	74 18		 je	 SHORT $LN159@stbtt__Get
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00c7c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00c83	48 85 c0	 test	 rax, rax
  00c86	74 06		 je	 SHORT $LN157@stbtt__Get

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00c88	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN157@stbtt__Get:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00c8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN159@stbtt__Get:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1862 :                     return 0;

  00c94	33 c0		 xor	 eax, eax
$LN1@stbtt__Get:

; 1885 : }

  00c96	4c 8d 9c 24 20
	01 00 00	 lea	 r11, QWORD PTR [rsp+288]
  00c9e	49 8b 5b 48	 mov	 rbx, QWORD PTR [r11+72]
  00ca2	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00ca7	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  00cac	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  00cb1	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  00cb6	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  00cbb	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  00cc0	45 0f 28 63 90	 movaps	 xmm12, XMMWORD PTR [r11-112]
  00cc5	45 0f 28 6b 80	 movaps	 xmm13, XMMWORD PTR [r11-128]
  00cca	45 0f 28 b3 70
	ff ff ff	 movaps	 xmm14, XMMWORD PTR [r11-144]
  00cd2	49 8b e3	 mov	 rsp, r11
  00cd5	41 5f		 pop	 r15
  00cd7	41 5e		 pop	 r14
  00cd9	41 5d		 pop	 r13
  00cdb	41 5c		 pop	 r12
  00cdd	5f		 pop	 rdi
  00cde	5e		 pop	 rsi
  00cdf	5d		 pop	 rbp
  00ce0	c3		 ret	 0
$LN50@stbtt__Get:

; 1873 :         }
; 1874 :     }
; 1875 :     else if (numberOfContours < 0) {

  00ce1	66 85 d2	 test	 dx, dx
  00ce4	79 1a		 jns	 SHORT $LN67@stbtt__Get

; 1876 :         // @TODO other compound variations?
; 1877 :         STBTT_assert(0);

  00ce6	41 b8 55 07 00
	00		 mov	 r8d, 1877		; 00000755H
  00cec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00cf3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  00cfa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN67@stbtt__Get:

; 1878 :     }
; 1879 :     else {
; 1880 :         // numberOfCounters == 0, do nothing
; 1881 :     }
; 1882 : 
; 1883 :     *pvertices = vertices;

  00d00	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR pvertices$[rsp]
  00d08	48 89 38	 mov	 QWORD PTR [rax], rdi

; 1884 :     return num_vertices;

  00d0b	41 8b c7	 mov	 eax, r15d
  00d0e	eb 86		 jmp	 SHORT $LN1@stbtt__Get
?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeTT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
c$ = 8
x$ = 16
y$ = 24
?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z PROC	; stbtt__track_vertex

; 1903 :     if (x > c->max_x || !c->started) c->max_x = x;

  00000	3b 51 1c	 cmp	 edx, DWORD PTR [rcx+28]
  00003	7f 06		 jg	 SHORT $LN14@stbtt__tra
  00005	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00009	75 03		 jne	 SHORT $LN2@stbtt__tra
$LN14@stbtt__tra:
  0000b	89 51 1c	 mov	 DWORD PTR [rcx+28], edx
$LN2@stbtt__tra:

; 1904 :     if (y > c->max_y || !c->started) c->max_y = y;

  0000e	44 3b 41 24	 cmp	 r8d, DWORD PTR [rcx+36]
  00012	7f 06		 jg	 SHORT $LN15@stbtt__tra
  00014	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00018	75 04		 jne	 SHORT $LN4@stbtt__tra
$LN15@stbtt__tra:
  0001a	44 89 41 24	 mov	 DWORD PTR [rcx+36], r8d
$LN4@stbtt__tra:

; 1905 :     if (x < c->min_x || !c->started) c->min_x = x;

  0001e	3b 51 18	 cmp	 edx, DWORD PTR [rcx+24]
  00021	7c 06		 jl	 SHORT $LN16@stbtt__tra
  00023	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00027	75 03		 jne	 SHORT $LN6@stbtt__tra
$LN16@stbtt__tra:
  00029	89 51 18	 mov	 DWORD PTR [rcx+24], edx
$LN6@stbtt__tra:

; 1906 :     if (y < c->min_y || !c->started) c->min_y = y;

  0002c	44 3b 41 20	 cmp	 r8d, DWORD PTR [rcx+32]
  00030	7c 06		 jl	 SHORT $LN9@stbtt__tra
  00032	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00036	75 04		 jne	 SHORT $LN18@stbtt__tra
$LN9@stbtt__tra:
  00038	44 89 41 20	 mov	 DWORD PTR [rcx+32], r8d
$LN18@stbtt__tra:

; 1907 :     c->started = 1;
; 1908 : }

  0003c	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [rcx+4], 1
  00043	c3		 ret	 0
?stbtt__track_vertex@@YAXPEAUstbtt__csctx@@HH@Z ENDP	; stbtt__track_vertex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
c$ = 16
type$ = 24
x$ = 32
y$ = 40
cx$ = 48
cy$ = 56
cx1$ = 64
cy1$ = 72
?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z PROC	; stbtt__csctx_v

; 1911 : {

  00000	40 56		 push	 rsi

; 1912 :     if (c->bounds) {

  00002	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00005	45 8b d8	 mov	 r11d, r8d
  00008	0f b6 f2	 movzx	 esi, dl
  0000b	4c 8b d1	 mov	 r10, rcx
  0000e	0f 84 d6 00 00
	00		 je	 $LN2@stbtt__csc

; 1903 :     if (x > c->max_x || !c->started) c->max_x = x;

  00014	44 8b 41 1c	 mov	 r8d, DWORD PTR [rcx+28]
  00018	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  0001d	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  00022	45 3b d8	 cmp	 r11d, r8d
  00025	7f 06		 jg	 SHORT $LN41@stbtt__csc
  00027	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  0002b	75 07		 jne	 SHORT $LN7@stbtt__csc
$LN41@stbtt__csc:
  0002d	44 89 59 1c	 mov	 DWORD PTR [rcx+28], r11d
  00031	45 8b c3	 mov	 r8d, r11d
$LN7@stbtt__csc:

; 1904 :     if (y > c->max_y || !c->started) c->max_y = y;

  00034	8b 59 24	 mov	 ebx, DWORD PTR [rcx+36]
  00037	44 3b cb	 cmp	 r9d, ebx
  0003a	7f 06		 jg	 SHORT $LN42@stbtt__csc
  0003c	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00040	75 07		 jne	 SHORT $LN9@stbtt__csc
$LN42@stbtt__csc:
  00042	44 89 49 24	 mov	 DWORD PTR [rcx+36], r9d
  00046	41 8b d9	 mov	 ebx, r9d
$LN9@stbtt__csc:

; 1905 :     if (x < c->min_x || !c->started) c->min_x = x;

  00049	8b 79 18	 mov	 edi, DWORD PTR [rcx+24]
  0004c	44 3b df	 cmp	 r11d, edi
  0004f	7c 06		 jl	 SHORT $LN43@stbtt__csc
  00051	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00055	75 07		 jne	 SHORT $LN11@stbtt__csc
$LN43@stbtt__csc:
  00057	44 89 59 18	 mov	 DWORD PTR [rcx+24], r11d
  0005b	41 8b fb	 mov	 edi, r11d
$LN11@stbtt__csc:

; 1906 :     if (y < c->min_y || !c->started) c->min_y = y;

  0005e	8b 51 20	 mov	 edx, DWORD PTR [rcx+32]
  00061	44 3b ca	 cmp	 r9d, edx
  00064	7c 06		 jl	 SHORT $LN14@stbtt__csc
  00066	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  0006a	75 07		 jne	 SHORT $LN13@stbtt__csc
$LN14@stbtt__csc:
  0006c	44 89 49 20	 mov	 DWORD PTR [rcx+32], r9d
  00070	41 8b d1	 mov	 edx, r9d
$LN13@stbtt__csc:

; 1907 :     c->started = 1;

  00073	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [rcx+4], 1

; 1913 :         stbtt__track_vertex(c, x, y);
; 1914 :         if (type == STBTT_vcubic) {

  0007a	40 80 fe 04	 cmp	 sil, 4
  0007e	75 5a		 jne	 SHORT $LN33@stbtt__csc

; 1903 :     if (x > c->max_x || !c->started) c->max_x = x;

  00080	8b 44 24 30	 mov	 eax, DWORD PTR cx$[rsp]
  00084	41 3b c0	 cmp	 eax, r8d
  00087	7e 06		 jle	 SHORT $LN17@stbtt__csc
  00089	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
  0008c	44 8b c0	 mov	 r8d, eax
$LN17@stbtt__csc:

; 1904 :     if (y > c->max_y || !c->started) c->max_y = y;

  0008f	8b 4c 24 38	 mov	 ecx, DWORD PTR cy$[rsp]
  00093	3b cb		 cmp	 ecx, ebx
  00095	7e 06		 jle	 SHORT $LN19@stbtt__csc
  00097	41 89 4a 24	 mov	 DWORD PTR [r10+36], ecx
  0009b	8b d9		 mov	 ebx, ecx
$LN19@stbtt__csc:

; 1905 :     if (x < c->min_x || !c->started) c->min_x = x;

  0009d	3b c7		 cmp	 eax, edi
  0009f	7d 06		 jge	 SHORT $LN21@stbtt__csc
  000a1	41 89 42 18	 mov	 DWORD PTR [r10+24], eax
  000a5	8b f8		 mov	 edi, eax
$LN21@stbtt__csc:

; 1906 :     if (y < c->min_y || !c->started) c->min_y = y;

  000a7	3b ca		 cmp	 ecx, edx
  000a9	7d 06		 jge	 SHORT $LN23@stbtt__csc
  000ab	41 89 4a 20	 mov	 DWORD PTR [r10+32], ecx
  000af	8b d1		 mov	 edx, ecx
$LN23@stbtt__csc:

; 1903 :     if (x > c->max_x || !c->started) c->max_x = x;

  000b1	8b 4c 24 40	 mov	 ecx, DWORD PTR cx1$[rsp]
  000b5	41 3b c8	 cmp	 ecx, r8d
  000b8	7e 04		 jle	 SHORT $LN27@stbtt__csc
  000ba	41 89 4a 1c	 mov	 DWORD PTR [r10+28], ecx
$LN27@stbtt__csc:

; 1904 :     if (y > c->max_y || !c->started) c->max_y = y;

  000be	8b 44 24 48	 mov	 eax, DWORD PTR cy1$[rsp]
  000c2	3b c3		 cmp	 eax, ebx
  000c4	7e 04		 jle	 SHORT $LN29@stbtt__csc
  000c6	41 89 42 24	 mov	 DWORD PTR [r10+36], eax
$LN29@stbtt__csc:

; 1905 :     if (x < c->min_x || !c->started) c->min_x = x;

  000ca	3b cf		 cmp	 ecx, edi
  000cc	7d 04		 jge	 SHORT $LN31@stbtt__csc
  000ce	41 89 4a 18	 mov	 DWORD PTR [r10+24], ecx
$LN31@stbtt__csc:

; 1906 :     if (y < c->min_y || !c->started) c->min_y = y;

  000d2	3b c2		 cmp	 eax, edx
  000d4	7d 04		 jge	 SHORT $LN33@stbtt__csc
  000d6	41 89 42 20	 mov	 DWORD PTR [r10+32], eax
$LN33@stbtt__csc:

; 1923 :     }
; 1924 :     c->num_vertices++;

  000da	41 ff 42 30	 inc	 DWORD PTR [r10+48]
  000de	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  000e3	48 8b 5c 24 10	 mov	 rbx, QWORD PTR [rsp+16]

; 1925 : }

  000e8	5e		 pop	 rsi
  000e9	c3		 ret	 0
$LN2@stbtt__csc:

; 1915 :             stbtt__track_vertex(c, cx, cy);
; 1916 :             stbtt__track_vertex(c, cx1, cy1);
; 1917 :         }
; 1918 :     }
; 1919 :     else {
; 1920 :         stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

  000ea	4c 63 41 30	 movsxd	 r8, DWORD PTR [rcx+48]

; 1570 :     v->cx = (stbtt_int16)cx;

  000ee	0f b7 44 24 30	 movzx	 eax, WORD PTR cx$[rsp]

; 1915 :             stbtt__track_vertex(c, cx, cy);
; 1916 :             stbtt__track_vertex(c, cx1, cy1);
; 1917 :         }
; 1918 :     }
; 1919 :     else {
; 1920 :         stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

  000f3	49 6b d0 0e	 imul	 rdx, r8, 14
  000f7	48 03 51 28	 add	 rdx, QWORD PTR [rcx+40]

; 1570 :     v->cx = (stbtt_int16)cx;

  000fb	66 89 42 04	 mov	 WORD PTR [rdx+4], ax

; 1571 :     v->cy = (stbtt_int16)cy;

  000ff	0f b7 44 24 38	 movzx	 eax, WORD PTR cy$[rsp]
  00104	66 89 42 06	 mov	 WORD PTR [rdx+6], ax

; 1921 :         c->pvertices[c->num_vertices].cx1 = (stbtt_int16)cx1;

  00108	0f b7 44 24 40	 movzx	 eax, WORD PTR cx1$[rsp]

; 1567 :     v->type = type;

  0010d	40 88 72 0c	 mov	 BYTE PTR [rdx+12], sil

; 1568 :     v->x = (stbtt_int16)x;

  00111	66 44 89 1a	 mov	 WORD PTR [rdx], r11w

; 1569 :     v->y = (stbtt_int16)y;

  00115	66 44 89 4a 02	 mov	 WORD PTR [rdx+2], r9w

; 1921 :         c->pvertices[c->num_vertices].cx1 = (stbtt_int16)cx1;

  0011a	66 89 42 08	 mov	 WORD PTR [rdx+8], ax

; 1922 :         c->pvertices[c->num_vertices].cy1 = (stbtt_int16)cy1;

  0011e	0f b7 44 24 48	 movzx	 eax, WORD PTR cy1$[rsp]
  00123	66 89 42 0a	 mov	 WORD PTR [rdx+10], ax

; 1923 :     }
; 1924 :     c->num_vertices++;

  00127	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  0012b	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1925 : }

  0012e	5e		 pop	 rsi
  0012f	c3		 ret	 0
?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ENDP	; stbtt__csctx_v
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
ctx$ = 8
?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z PROC	; stbtt__csctx_close_shape

; 1929 :     if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)

  00000	f3 0f 10 49 08	 movss	 xmm1, DWORD PTR [rcx+8]
  00005	48 8b d1	 mov	 rdx, rcx
  00008	0f 2e 49 10	 ucomiss xmm1, DWORD PTR [rcx+16]
  0000c	7a 13		 jp	 SHORT $LN50@stbtt__csc
  0000e	75 11		 jne	 SHORT $LN50@stbtt__csc
  00010	f3 0f 10 41 0c	 movss	 xmm0, DWORD PTR [rcx+12]
  00015	0f 2e 41 14	 ucomiss xmm0, DWORD PTR [rcx+20]
  00019	7a 06		 jp	 SHORT $LN50@stbtt__csc
  0001b	0f 84 8e 00 00
	00		 je	 $LN2@stbtt__csc
$LN50@stbtt__csc:

; 1912 :     if (c->bounds) {

  00021	83 39 00	 cmp	 DWORD PTR [rcx], 0

; 1930 :         stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);

  00024	f3 44 0f 2c 41
	0c		 cvttss2si r8d, DWORD PTR [rcx+12]
  0002a	f3 44 0f 2c c9	 cvttss2si r9d, xmm1

; 1912 :     if (c->bounds) {

  0002f	74 53		 je	 SHORT $LN6@stbtt__csc

; 1903 :     if (x > c->max_x || !c->started) c->max_x = x;

  00031	44 3b 49 1c	 cmp	 r9d, DWORD PTR [rcx+28]
  00035	7f 06		 jg	 SHORT $LN47@stbtt__csc
  00037	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  0003b	75 04		 jne	 SHORT $LN11@stbtt__csc
$LN47@stbtt__csc:
  0003d	44 89 49 1c	 mov	 DWORD PTR [rcx+28], r9d
$LN11@stbtt__csc:

; 1904 :     if (y > c->max_y || !c->started) c->max_y = y;

  00041	44 3b 41 24	 cmp	 r8d, DWORD PTR [rcx+36]
  00045	7f 06		 jg	 SHORT $LN48@stbtt__csc
  00047	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  0004b	75 04		 jne	 SHORT $LN13@stbtt__csc
$LN48@stbtt__csc:
  0004d	44 89 41 24	 mov	 DWORD PTR [rcx+36], r8d
$LN13@stbtt__csc:

; 1905 :     if (x < c->min_x || !c->started) c->min_x = x;

  00051	44 3b 49 18	 cmp	 r9d, DWORD PTR [rcx+24]
  00055	7c 06		 jl	 SHORT $LN49@stbtt__csc
  00057	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  0005b	75 04		 jne	 SHORT $LN15@stbtt__csc
$LN49@stbtt__csc:
  0005d	44 89 49 18	 mov	 DWORD PTR [rcx+24], r9d
$LN15@stbtt__csc:

; 1906 :     if (y < c->min_y || !c->started) c->min_y = y;

  00061	44 3b 41 20	 cmp	 r8d, DWORD PTR [rcx+32]
  00065	7c 06		 jl	 SHORT $LN18@stbtt__csc
  00067	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  0006b	75 04		 jne	 SHORT $LN17@stbtt__csc
$LN18@stbtt__csc:
  0006d	44 89 41 20	 mov	 DWORD PTR [rcx+32], r8d
$LN17@stbtt__csc:

; 1918 :     }

  00071	44 8b 51 30	 mov	 r10d, DWORD PTR [rcx+48]

; 1907 :     c->started = 1;

  00075	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [rcx+4], 1

; 1924 :     c->num_vertices++;

  0007c	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  00080	89 42 30	 mov	 DWORD PTR [rdx+48], eax

; 1931 : }

  00083	c3		 ret	 0
$LN6@stbtt__csc:

; 1920 :         stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

  00084	48 8b 42 28	 mov	 rax, QWORD PTR [rdx+40]
  00088	4c 63 51 30	 movsxd	 r10, DWORD PTR [rcx+48]
  0008c	49 6b ca 0e	 imul	 rcx, r10, 14

; 1569 :     v->y = (stbtt_int16)y;

  00090	66 44 89 44 01
	02		 mov	 WORD PTR [rcx+rax+2], r8w

; 1570 :     v->cx = (stbtt_int16)cx;

  00096	45 33 c0	 xor	 r8d, r8d
  00099	4c 89 44 01 04	 mov	 QWORD PTR [rcx+rax+4], r8
  0009e	c6 44 01 0c 02	 mov	 BYTE PTR [rcx+rax+12], 2
  000a3	66 44 89 0c 01	 mov	 WORD PTR [rcx+rax], r9w

; 1924 :     c->num_vertices++;

  000a8	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  000ac	89 42 30	 mov	 DWORD PTR [rdx+48], eax
$LN2@stbtt__csc:

; 1931 : }

  000af	c3		 ret	 0
?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ENDP	; stbtt__csctx_close_shape
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
ctx$ = 48
dx$ = 56
dy$ = 64
?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rmove_to

; 1934 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	0f 28 d9	 movaps	 xmm3, xmm1
  00007	4c 8b d9	 mov	 r11, rcx

; 1935 :     stbtt__csctx_close_shape(ctx);

  0000a	e8 00 00 00 00	 call	 ?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape

; 1912 :     if (c->bounds) {

  0000f	41 83 3b 00	 cmp	 DWORD PTR [r11], 0

; 1936 :     ctx->first_x = ctx->x = ctx->x + dx;

  00013	f3 41 0f 58 5b
	10		 addss	 xmm3, DWORD PTR [r11+16]

; 1937 :     ctx->first_y = ctx->y = ctx->y + dy;

  00019	f3 41 0f 58 53
	14		 addss	 xmm2, DWORD PTR [r11+20]
  0001f	f3 41 0f 11 5b
	10		 movss	 DWORD PTR [r11+16], xmm3
  00025	f3 41 0f 11 5b
	08		 movss	 DWORD PTR [r11+8], xmm3
  0002b	f3 41 0f 11 53
	14		 movss	 DWORD PTR [r11+20], xmm2
  00031	f3 41 0f 11 53
	0c		 movss	 DWORD PTR [r11+12], xmm2

; 1938 :     stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

  00037	f3 44 0f 2c c2	 cvttss2si r8d, xmm2
  0003c	f3 44 0f 2c cb	 cvttss2si r9d, xmm3

; 1912 :     if (c->bounds) {

  00041	74 55		 je	 SHORT $LN4@stbtt__csc

; 1903 :     if (x > c->max_x || !c->started) c->max_x = x;

  00043	45 3b 4b 1c	 cmp	 r9d, DWORD PTR [r11+28]
  00047	7f 07		 jg	 SHORT $LN43@stbtt__csc
  00049	41 83 7b 04 00	 cmp	 DWORD PTR [r11+4], 0
  0004e	75 04		 jne	 SHORT $LN9@stbtt__csc
$LN43@stbtt__csc:
  00050	45 89 4b 1c	 mov	 DWORD PTR [r11+28], r9d
$LN9@stbtt__csc:

; 1904 :     if (y > c->max_y || !c->started) c->max_y = y;

  00054	45 3b 43 24	 cmp	 r8d, DWORD PTR [r11+36]
  00058	7f 07		 jg	 SHORT $LN44@stbtt__csc
  0005a	41 83 7b 04 00	 cmp	 DWORD PTR [r11+4], 0
  0005f	75 04		 jne	 SHORT $LN11@stbtt__csc
$LN44@stbtt__csc:
  00061	45 89 43 24	 mov	 DWORD PTR [r11+36], r8d
$LN11@stbtt__csc:

; 1905 :     if (x < c->min_x || !c->started) c->min_x = x;

  00065	45 3b 4b 18	 cmp	 r9d, DWORD PTR [r11+24]
  00069	7c 07		 jl	 SHORT $LN45@stbtt__csc
  0006b	41 83 7b 04 00	 cmp	 DWORD PTR [r11+4], 0
  00070	75 04		 jne	 SHORT $LN13@stbtt__csc
$LN45@stbtt__csc:
  00072	45 89 4b 18	 mov	 DWORD PTR [r11+24], r9d
$LN13@stbtt__csc:

; 1906 :     if (y < c->min_y || !c->started) c->min_y = y;

  00076	45 3b 43 20	 cmp	 r8d, DWORD PTR [r11+32]
  0007a	7c 07		 jl	 SHORT $LN16@stbtt__csc
  0007c	41 83 7b 04 00	 cmp	 DWORD PTR [r11+4], 0
  00081	75 04		 jne	 SHORT $LN15@stbtt__csc
$LN16@stbtt__csc:
  00083	45 89 43 20	 mov	 DWORD PTR [r11+32], r8d
$LN15@stbtt__csc:

; 1924 :     c->num_vertices++;

  00087	41 ff 43 30	 inc	 DWORD PTR [r11+48]

; 1907 :     c->started = 1;

  0008b	41 c7 43 04 01
	00 00 00	 mov	 DWORD PTR [r11+4], 1

; 1939 : }

  00093	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00097	c3		 ret	 0
$LN4@stbtt__csc:

; 1920 :         stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

  00098	49 8b 43 28	 mov	 rax, QWORD PTR [r11+40]
  0009c	49 63 53 30	 movsxd	 rdx, DWORD PTR [r11+48]
  000a0	48 6b ca 0e	 imul	 rcx, rdx, 14

; 1569 :     v->y = (stbtt_int16)y;

  000a4	66 44 89 44 01
	02		 mov	 WORD PTR [rcx+rax+2], r8w

; 1570 :     v->cx = (stbtt_int16)cx;

  000aa	45 33 c0	 xor	 r8d, r8d
  000ad	4c 89 44 01 04	 mov	 QWORD PTR [rcx+rax+4], r8
  000b2	c6 44 01 0c 01	 mov	 BYTE PTR [rcx+rax+12], 1
  000b7	66 44 89 0c 01	 mov	 WORD PTR [rcx+rax], r9w

; 1924 :     c->num_vertices++;

  000bc	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  000bf	41 89 43 30	 mov	 DWORD PTR [r11+48], eax

; 1939 : }

  000c3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c7	c3		 ret	 0
?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rmove_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
ctx$ = 8
dx$ = 16
dy$ = 24
?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rline_to

; 1912 :     if (c->bounds) {

  00000	83 39 00	 cmp	 DWORD PTR [rcx], 0

; 1942 : {

  00003	4c 8b c1	 mov	 r8, rcx

; 1943 :     ctx->x += dx;

  00006	f3 0f 58 49 10	 addss	 xmm1, DWORD PTR [rcx+16]

; 1944 :     ctx->y += dy;

  0000b	f3 0f 58 51 14	 addss	 xmm2, DWORD PTR [rcx+20]
  00010	f3 0f 11 49 10	 movss	 DWORD PTR [rcx+16], xmm1
  00015	f3 0f 11 51 14	 movss	 DWORD PTR [rcx+20], xmm2

; 1945 :     stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

  0001a	f3 44 0f 2c ca	 cvttss2si r9d, xmm2
  0001f	f3 44 0f 2c d1	 cvttss2si r10d, xmm1

; 1912 :     if (c->bounds) {

  00024	74 4b		 je	 SHORT $LN4@stbtt__csc

; 1903 :     if (x > c->max_x || !c->started) c->max_x = x;

  00026	44 3b 51 1c	 cmp	 r10d, DWORD PTR [rcx+28]
  0002a	7f 06		 jg	 SHORT $LN43@stbtt__csc
  0002c	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00030	75 04		 jne	 SHORT $LN9@stbtt__csc
$LN43@stbtt__csc:
  00032	44 89 51 1c	 mov	 DWORD PTR [rcx+28], r10d
$LN9@stbtt__csc:

; 1904 :     if (y > c->max_y || !c->started) c->max_y = y;

  00036	44 3b 49 24	 cmp	 r9d, DWORD PTR [rcx+36]
  0003a	7f 06		 jg	 SHORT $LN44@stbtt__csc
  0003c	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00040	75 04		 jne	 SHORT $LN11@stbtt__csc
$LN44@stbtt__csc:
  00042	44 89 49 24	 mov	 DWORD PTR [rcx+36], r9d
$LN11@stbtt__csc:

; 1905 :     if (x < c->min_x || !c->started) c->min_x = x;

  00046	44 3b 51 18	 cmp	 r10d, DWORD PTR [rcx+24]
  0004a	7c 06		 jl	 SHORT $LN45@stbtt__csc
  0004c	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00050	75 04		 jne	 SHORT $LN13@stbtt__csc
$LN45@stbtt__csc:
  00052	44 89 51 18	 mov	 DWORD PTR [rcx+24], r10d
$LN13@stbtt__csc:

; 1906 :     if (y < c->min_y || !c->started) c->min_y = y;

  00056	44 3b 49 20	 cmp	 r9d, DWORD PTR [rcx+32]
  0005a	7c 06		 jl	 SHORT $LN16@stbtt__csc
  0005c	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00060	75 04		 jne	 SHORT $LN15@stbtt__csc
$LN16@stbtt__csc:
  00062	44 89 49 20	 mov	 DWORD PTR [rcx+32], r9d
$LN15@stbtt__csc:

; 1924 :     c->num_vertices++;

  00066	ff 41 30	 inc	 DWORD PTR [rcx+48]

; 1907 :     c->started = 1;

  00069	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [rcx+4], 1

; 1946 : }

  00070	c3		 ret	 0
$LN4@stbtt__csc:

; 1920 :         stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

  00071	49 8b 40 28	 mov	 rax, QWORD PTR [r8+40]
  00075	48 63 51 30	 movsxd	 rdx, DWORD PTR [rcx+48]
  00079	48 6b ca 0e	 imul	 rcx, rdx, 14

; 1569 :     v->y = (stbtt_int16)y;

  0007d	66 44 89 4c 01
	02		 mov	 WORD PTR [rcx+rax+2], r9w

; 1570 :     v->cx = (stbtt_int16)cx;

  00083	45 33 c9	 xor	 r9d, r9d
  00086	4c 89 4c 01 04	 mov	 QWORD PTR [rcx+rax+4], r9
  0008b	c6 44 01 0c 02	 mov	 BYTE PTR [rcx+rax+12], 2
  00090	66 44 89 14 01	 mov	 WORD PTR [rcx+rax], r10w

; 1924 :     c->num_vertices++;

  00095	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  00098	41 89 40 30	 mov	 DWORD PTR [r8+48], eax

; 1946 : }

  0009c	c3		 ret	 0
?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rline_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
ctx$ = 96
dx1$ = 104
dy1$ = 112
dx2$ = 120
dy2$ = 128
dx3$ = 136
dy3$ = 144
?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z PROC ; stbtt__csctx_rccurve_to

; 1949 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	0f 28 e9	 movaps	 xmm5, xmm1
  00007	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6

; 1950 :     float cx1 = ctx->x + dx1;

  0000c	f3 0f 58 69 10	 addss	 xmm5, DWORD PTR [rcx+16]
  00011	0f 28 f2	 movaps	 xmm6, xmm2
  00014	4c 8b d9	 mov	 r11, rcx

; 1951 :     float cy1 = ctx->y + dy1;

  00017	f3 0f 58 71 14	 addss	 xmm6, DWORD PTR [rcx+20]

; 1952 :     float cx2 = cx1 + dx2;

  0001c	0f 28 e5	 movaps	 xmm4, xmm5
  0001f	f3 0f 58 e3	 addss	 xmm4, xmm3

; 1953 :     float cy2 = cy1 + dy2;
; 1954 :     ctx->x = cx2 + dx3;
; 1955 :     ctx->y = cy2 + dy3;
; 1956 :     stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);

  00023	f3 0f 2c d6	 cvttss2si edx, xmm6
  00027	0f 28 d6	 movaps	 xmm2, xmm6
  0002a	0f 28 cc	 movaps	 xmm1, xmm4
  0002d	f3 0f 58 94 24
	80 00 00 00	 addss	 xmm2, DWORD PTR dy2$[rsp]
  00036	f3 0f 58 8c 24
	88 00 00 00	 addss	 xmm1, DWORD PTR dx3$[rsp]
  0003f	f3 44 0f 2c d5	 cvttss2si r10d, xmm5
  00044	f3 0f 11 49 10	 movss	 DWORD PTR [rcx+16], xmm1
  00049	0f 28 c2	 movaps	 xmm0, xmm2
  0004c	f3 0f 58 84 24
	90 00 00 00	 addss	 xmm0, DWORD PTR dy3$[rsp]
  00055	f3 0f 2c c2	 cvttss2si eax, xmm2
  00059	f3 0f 11 41 14	 movss	 DWORD PTR [rcx+20], xmm0
  0005e	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00062	f3 0f 2c cc	 cvttss2si ecx, xmm4
  00066	f3 44 0f 2c c8	 cvttss2si r9d, xmm0
  0006b	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0006f	49 8b cb	 mov	 rcx, r11
  00072	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00076	b2 04		 mov	 dl, 4
  00078	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  0007d	f3 44 0f 2c c1	 cvttss2si r8d, xmm1
  00082	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v

; 1957 : }

  00087	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  0008c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00090	c3		 ret	 0
?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ENDP ; stbtt__csctx_rccurve_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
idx$ = 72
n$ = 80
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z PROC		; stbtt__get_subr

; 1960 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00014	8b 6a 0c	 mov	 ebp, DWORD PTR [rdx+12]

; 1960 : {

  00017	41 8b f0	 mov	 esi, r8d
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	48 8b d9	 mov	 rbx, rcx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00020	85 ed		 test	 ebp, ebp
  00022	79 1a		 jns	 SHORT $LN11@stbtt__get
  00024	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN11@stbtt__get:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0003e	45 33 c9	 xor	 r9d, r9d
  00041	85 ed		 test	 ebp, ebp
  00043	41 8b c1	 mov	 eax, r9d
  00046	0f 48 c5	 cmovs	 eax, ebp
  00049	89 47 08	 mov	 DWORD PTR [rdi+8], eax

; 1118 :     if (b->cursor >= b->size)

  0004c	3b c5		 cmp	 eax, ebp
  0004e	7c 07		 jl	 SHORT $LN30@stbtt__get

; 1119 :         return 0;

  00050	41 8b d1	 mov	 edx, r9d
  00053	32 c9		 xor	 cl, cl
  00055	eb 29		 jmp	 SHORT $LN42@stbtt__get
$LN30@stbtt__get:

; 1120 :     return b->data[b->cursor++];

  00057	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]
  0005b	48 63 c8	 movsxd	 rcx, eax

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  0005e	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 1120 :     return b->data[b->cursor++];

  00061	44 89 47 08	 mov	 DWORD PTR [rdi+8], r8d

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00065	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]

; 1118 :     if (b->cursor >= b->size)

  00069	44 3b c5	 cmp	 r8d, ebp
  0006c	7c 04		 jl	 SHORT $LN41@stbtt__get

; 1119 :         return 0;

  0006e	32 c9		 xor	 cl, cl
  00070	eb 0e		 jmp	 SHORT $LN42@stbtt__get
$LN41@stbtt__get:

; 1120 :     return b->data[b->cursor++];

  00072	49 63 c8	 movsxd	 rcx, r8d
  00075	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00079	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  0007d	89 47 08	 mov	 DWORD PTR [rdi+8], eax
$LN42@stbtt__get:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00080	c1 e2 08	 shl	 edx, 8
  00083	0f b6 c1	 movzx	 eax, cl
  00086	0b d0		 or	 edx, eax

; 1961 :     int count = stbtt__cff_index_count(&idx);
; 1962 :     int bias = 107;

  00088	b8 6b 00 00 00	 mov	 eax, 107		; 0000006bH

; 1963 :     if (count >= 33900)

  0008d	81 fa 6c 84 00
	00		 cmp	 edx, 33900		; 0000846cH
  00093	72 07		 jb	 SHORT $LN2@stbtt__get

; 1964 :         bias = 32768;

  00095	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  0009a	eb 0e		 jmp	 SHORT $LN4@stbtt__get
$LN2@stbtt__get:

; 1965 :     else if (count >= 1240)

  0009c	81 fa d8 04 00
	00		 cmp	 edx, 1240		; 000004d8H
  000a2	b9 6b 04 00 00	 mov	 ecx, 1131		; 0000046bH
  000a7	0f 43 c1	 cmovae	 eax, ecx
$LN4@stbtt__get:

; 1966 :         bias = 1131;
; 1967 :     n += bias;

  000aa	03 f0		 add	 esi, eax

; 1968 :     if (n < 0 || n >= count)

  000ac	78 1f		 js	 SHORT $LN35@stbtt__get
  000ae	3b f2		 cmp	 esi, edx
  000b0	7d 1b		 jge	 SHORT $LN35@stbtt__get

; 1969 :         return stbtt__new_buf(NULL, 0);
; 1970 :     return stbtt__cff_index_get(idx, n);

  000b2	0f 28 07	 movaps	 xmm0, XMMWORD PTR [rdi]
  000b5	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  000ba	44 8b c6	 mov	 r8d, esi
  000bd	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T1[rsp], xmm0
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  000cb	eb 07		 jmp	 SHORT $LN46@stbtt__get
$LN35@stbtt__get:

; 1155 :     r.data = (stbtt_uint8*)p;

  000cd	4c 89 0b	 mov	 QWORD PTR [rbx], r9

; 1156 :     r.size = (int)size;
; 1157 :     r.cursor = 0;

  000d0	4c 89 4b 08	 mov	 QWORD PTR [rbx+8], r9
$LN46@stbtt__get:

; 1971 : }

  000d4	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000d9	48 8b c3	 mov	 rax, rbx
  000dc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000e6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ENDP		; stbtt__get_subr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
fdselect$ = 32
$T3 = 48
$T4 = 64
$T5 = 112
info$ = 120
glyph_index$ = 128
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z PROC ; stbtt__cid_get_glyph_subrs

; 1974 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1975 :     stbtt__buf fdselect = info->fdselect;

  00018	0f 10 82 90 00
	00 00		 movups	 xmm0, XMMWORD PTR [rdx+144]
  0001f	41 8b f8	 mov	 edi, r8d
  00022	4c 8b f2	 mov	 r14, rdx
  00025	4c 8b f9	 mov	 r15, rcx

; 1976 :     int nranges, start, end, v, fmt, fdselector = -1, i;

  00028	bd ff ff ff ff	 mov	 ebp, -1
  0002d	0f 11 44 24 20	 movups	 XMMWORD PTR fdselect$[rsp], xmm0

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00032	66 0f 73 d8 08	 psrldq	 xmm0, 8
  00037	66 48 0f 7e c0	 movq	 rax, xmm0
  0003c	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00040	85 c0		 test	 eax, eax
  00042	79 1a		 jns	 SHORT $LN12@stbtt__cid
  00044	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN12@stbtt__cid:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0005e	8b 5c 24 2c	 mov	 ebx, DWORD PTR fdselect$[rsp+12]
  00062	48 8b 74 24 20	 mov	 rsi, QWORD PTR fdselect$[rsp]
  00067	85 db		 test	 ebx, ebx
  00069	0f 88 ee 00 00
	00		 js	 $LN18@stbtt__cid
  0006f	45 33 c0	 xor	 r8d, r8d
  00072	41 8b c8	 mov	 ecx, r8d

; 1118 :     if (b->cursor >= b->size)

  00075	85 db		 test	 ebx, ebx
  00077	0f 8e e2 00 00
	00		 jle	 $LN113@stbtt__cid

; 1120 :     return b->data[b->cursor++];

  0007d	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00080	41 8d 48 01	 lea	 ecx, QWORD PTR [r8+1]

; 1977 : 
; 1978 :     stbtt__buf_seek(&fdselect, 0);
; 1979 :     fmt = stbtt__buf_get8(&fdselect);
; 1980 :     if (fmt == 0) {

  00084	84 c0		 test	 al, al
  00086	0f 84 d3 00 00
	00		 je	 $LN113@stbtt__cid

; 1984 :     }
; 1985 :     else if (fmt == 3) {

  0008c	3c 03		 cmp	 al, 3
  0008e	0f 85 09 01 00
	00		 jne	 $LN3@stbtt__cid

; 1118 :     if (b->cursor >= b->size)

  00094	3b cb		 cmp	 ecx, ebx
  00096	7c 04		 jl	 SHORT $LN48@stbtt__cid

; 1119 :         return 0;

  00098	32 c0		 xor	 al, al
  0009a	eb 09		 jmp	 SHORT $LN47@stbtt__cid
$LN48@stbtt__cid:

; 1120 :     return b->data[b->cursor++];

  0009c	48 63 c1	 movsxd	 rax, ecx
  0009f	ff c1		 inc	 ecx
  000a1	0f b6 04 30	 movzx	 eax, BYTE PTR [rax+rsi]
$LN47@stbtt__cid:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  000a5	44 0f b6 d8	 movzx	 r11d, al

; 1118 :     if (b->cursor >= b->size)

  000a9	3b cb		 cmp	 ecx, ebx
  000ab	7c 04		 jl	 SHORT $LN95@stbtt__cid

; 1119 :         return 0;

  000ad	32 c0		 xor	 al, al
  000af	eb 09		 jmp	 SHORT $LN96@stbtt__cid
$LN95@stbtt__cid:

; 1120 :     return b->data[b->cursor++];

  000b1	48 63 c1	 movsxd	 rax, ecx
  000b4	ff c1		 inc	 ecx
  000b6	0f b6 04 30	 movzx	 eax, BYTE PTR [rax+rsi]
$LN96@stbtt__cid:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  000ba	41 c1 e3 08	 shl	 r11d, 8
  000be	0f b6 c0	 movzx	 eax, al
  000c1	44 0b d8	 or	 r11d, eax

; 1118 :     if (b->cursor >= b->size)

  000c4	3b cb		 cmp	 ecx, ebx
  000c6	7c 04		 jl	 SHORT $LN61@stbtt__cid

; 1119 :         return 0;

  000c8	32 c0		 xor	 al, al
  000ca	eb 09		 jmp	 SHORT $LN60@stbtt__cid
$LN61@stbtt__cid:

; 1120 :     return b->data[b->cursor++];

  000cc	48 63 c1	 movsxd	 rax, ecx
  000cf	ff c1		 inc	 ecx
  000d1	0f b6 04 30	 movzx	 eax, BYTE PTR [rax+rsi]
$LN60@stbtt__cid:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  000d5	44 0f b6 c8	 movzx	 r9d, al

; 1118 :     if (b->cursor >= b->size)

  000d9	3b cb		 cmp	 ecx, ebx
  000db	7c 04		 jl	 SHORT $LN98@stbtt__cid

; 1119 :         return 0;

  000dd	32 c0		 xor	 al, al
  000df	eb 09		 jmp	 SHORT $LN99@stbtt__cid
$LN98@stbtt__cid:

; 1120 :     return b->data[b->cursor++];

  000e1	48 63 c1	 movsxd	 rax, ecx
  000e4	ff c1		 inc	 ecx
  000e6	0f b6 04 30	 movzx	 eax, BYTE PTR [rax+rsi]
$LN99@stbtt__cid:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  000ea	41 c1 e1 08	 shl	 r9d, 8
  000ee	0f b6 c0	 movzx	 eax, al
  000f1	44 0b c8	 or	 r9d, eax

; 1986 :         nranges = stbtt__buf_get16(&fdselect);
; 1987 :         start = stbtt__buf_get16(&fdselect);
; 1988 :         for (i = 0; i < nranges; i++) {

  000f4	45 85 db	 test	 r11d, r11d
  000f7	0f 84 a0 00 00
	00		 je	 $LN3@stbtt__cid
  000fd	0f 1f 00	 npad	 3
$LL4@stbtt__cid:

; 1118 :     if (b->cursor >= b->size)

  00100	3b cb		 cmp	 ecx, ebx
  00102	7c 04		 jl	 SHORT $LN64@stbtt__cid

; 1119 :         return 0;

  00104	32 c0		 xor	 al, al
  00106	eb 09		 jmp	 SHORT $LN63@stbtt__cid
$LN64@stbtt__cid:

; 1120 :     return b->data[b->cursor++];

  00108	48 63 c1	 movsxd	 rax, ecx
  0010b	ff c1		 inc	 ecx
  0010d	0f b6 04 30	 movzx	 eax, BYTE PTR [rax+rsi]
$LN63@stbtt__cid:

; 1989 :             v = stbtt__buf_get8(&fdselect);

  00111	44 0f b6 d0	 movzx	 r10d, al

; 1118 :     if (b->cursor >= b->size)

  00115	3b cb		 cmp	 ecx, ebx
  00117	7c 04		 jl	 SHORT $LN77@stbtt__cid

; 1119 :         return 0;

  00119	32 c0		 xor	 al, al
  0011b	eb 09		 jmp	 SHORT $LN76@stbtt__cid
$LN77@stbtt__cid:

; 1120 :     return b->data[b->cursor++];

  0011d	48 63 c1	 movsxd	 rax, ecx
  00120	ff c1		 inc	 ecx
  00122	0f b6 04 30	 movzx	 eax, BYTE PTR [rax+rsi]
$LN76@stbtt__cid:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00126	0f b6 d0	 movzx	 edx, al

; 1118 :     if (b->cursor >= b->size)

  00129	3b cb		 cmp	 ecx, ebx
  0012b	7c 04		 jl	 SHORT $LN101@stbtt__cid

; 1119 :         return 0;

  0012d	32 c0		 xor	 al, al
  0012f	eb 09		 jmp	 SHORT $LN102@stbtt__cid
$LN101@stbtt__cid:

; 1120 :     return b->data[b->cursor++];

  00131	48 63 c1	 movsxd	 rax, ecx
  00134	ff c1		 inc	 ecx
  00136	0f b6 04 30	 movzx	 eax, BYTE PTR [rax+rsi]
$LN102@stbtt__cid:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  0013a	c1 e2 08	 shl	 edx, 8
  0013d	0f b6 c0	 movzx	 eax, al
  00140	0b d0		 or	 edx, eax

; 1990 :             end = stbtt__buf_get16(&fdselect);
; 1991 :             if (glyph_index >= start && glyph_index < end) {

  00142	41 3b f9	 cmp	 edi, r9d
  00145	7c 04		 jl	 SHORT $LN8@stbtt__cid
  00147	3b fa		 cmp	 edi, edx
  00149	7c 0d		 jl	 SHORT $LN89@stbtt__cid
$LN8@stbtt__cid:

; 1986 :         nranges = stbtt__buf_get16(&fdselect);
; 1987 :         start = stbtt__buf_get16(&fdselect);
; 1988 :         for (i = 0; i < nranges; i++) {

  0014b	41 ff c0	 inc	 r8d

; 1993 :                 break;
; 1994 :             }
; 1995 :             start = end;

  0014e	44 8b ca	 mov	 r9d, edx
  00151	45 3b c3	 cmp	 r8d, r11d
  00154	7c aa		 jl	 SHORT $LL4@stbtt__cid

; 1986 :         nranges = stbtt__buf_get16(&fdselect);
; 1987 :         start = stbtt__buf_get16(&fdselect);
; 1988 :         for (i = 0; i < nranges; i++) {

  00156	eb 45		 jmp	 SHORT $LN3@stbtt__cid
$LN89@stbtt__cid:

; 1992 :                 fdselector = v;

  00158	41 8b ea	 mov	 ebp, r10d
  0015b	eb 40		 jmp	 SHORT $LN3@stbtt__cid
$LN18@stbtt__cid:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  0015d	8b cb		 mov	 ecx, ebx
$LN113@stbtt__cid:

; 1138 :     stbtt__buf_seek(b, b->cursor + o);

  0015f	03 f9		 add	 edi, ecx

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00161	3b fb		 cmp	 edi, ebx
  00163	7f 04		 jg	 SHORT $LN30@stbtt__cid
  00165	85 ff		 test	 edi, edi
  00167	79 1a		 jns	 SHORT $LN26@stbtt__cid
$LN30@stbtt__cid:
  00169	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  0016f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN26@stbtt__cid:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  00183	3b fb		 cmp	 edi, ebx
  00185	7f 11		 jg	 SHORT $LN112@stbtt__cid
  00187	85 ff		 test	 edi, edi
  00189	78 0d		 js	 SHORT $LN112@stbtt__cid

; 1118 :     if (b->cursor >= b->size)

  0018b	3b fb		 cmp	 edi, ebx
  0018d	7d 09		 jge	 SHORT $LN112@stbtt__cid

; 1120 :     return b->data[b->cursor++];

  0018f	48 63 c7	 movsxd	 rax, edi
  00192	0f b6 0c 30	 movzx	 ecx, BYTE PTR [rax+rsi]
  00196	eb 02		 jmp	 SHORT $LN34@stbtt__cid
$LN112@stbtt__cid:

; 1119 :         return 0;

  00198	32 c9		 xor	 cl, cl
$LN34@stbtt__cid:

; 1981 :         // untested
; 1982 :         stbtt__buf_skip(&fdselect, glyph_index);
; 1983 :         fdselector = stbtt__buf_get8(&fdselect);

  0019a	0f b6 e9	 movzx	 ebp, cl
$LN3@stbtt__cid:

; 1996 :         }
; 1997 :     }
; 1998 :     if (fdselector == -1) stbtt__new_buf(NULL, 0);
; 1999 :     return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));

  0019d	41 0f 10 86 80
	00 00 00	 movups	 xmm0, XMMWORD PTR [r14+128]
  001a5	44 8b c5	 mov	 r8d, ebp
  001a8	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T2[rsp]
  001ad	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T4[rsp]
  001b2	0f 29 44 24 20	 movaps	 XMMWORD PTR $T2[rsp], xmm0
  001b7	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  001bc	41 0f 10 4e 40	 movups	 xmm1, XMMWORD PTR [r14+64]
  001c1	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  001c6	49 8b cf	 mov	 rcx, r15
  001c9	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T3[rsp]
  001ce	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  001d1	0f 29 4c 24 30	 movaps	 XMMWORD PTR $T3[rsp], xmm1
  001d6	0f 29 44 24 20	 movaps	 XMMWORD PTR $T1[rsp], xmm0
  001db	e8 00 00 00 00	 call	 ?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs

; 2000 : }

  001e0	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001e5	49 8b c7	 mov	 rax, r15
  001e8	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  001ed	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  001f5	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001f9	41 5f		 pop	 r15
  001fb	41 5e		 pop	 r14
  001fd	5f		 pop	 rdi
  001fe	c3		 ret	 0
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z ENDP ; stbtt__cid_get_glyph_subrs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
clear_stack$1$ = 64
$T1 = 80
$T2 = 80
$T3 = 80
b$ = 80
maskbits$1$ = 96
in_header$1$ = 100
subr_stack_height$1$ = 104
has_subrs$1$ = 108
glyph_index$GSCopy$1$ = 112
info$GSCopy$1$ = 120
$T4 = 128
$T5 = 128
subrs$ = 144
$T6 = 160
s$ = 176
subr_stack$ = 368
__$ArrayPad$ = 528
info$ = 768
glyph_index$ = 776
c$ = 784
?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z PROC ; stbtt__run_charstring

; 2003 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 20	 mov	 QWORD PTR [r11+32], rbx
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	49 8d ab 08 fe
	ff ff		 lea	 rbp, QWORD PTR [r11-504]
  00019	48 81 ec c0 02
	00 00		 sub	 rsp, 704		; 000002c0H
  00020	41 0f 29 73 b8	 movaps	 XMMWORD PTR [r11-72], xmm6
  00025	41 0f 29 7b a8	 movaps	 XMMWORD PTR [r11-88], xmm7
  0002a	45 0f 29 4b 88	 movaps	 XMMWORD PTR [r11-120], xmm9
  0002f	45 0f 29 93 78
	ff ff ff	 movaps	 XMMWORD PTR [r11-136], xmm10
  00037	45 0f 29 9b 68
	ff ff ff	 movaps	 XMMWORD PTR [r11-152], xmm11
  0003f	45 0f 29 a3 58
	ff ff ff	 movaps	 XMMWORD PTR [r11-168], xmm12
  00047	45 0f 29 ab 48
	ff ff ff	 movaps	 XMMWORD PTR [r11-184], xmm13
  0004f	45 0f 29 b3 38
	ff ff ff	 movaps	 XMMWORD PTR [r11-200], xmm14
  00057	45 0f 29 bb 28
	ff ff ff	 movaps	 XMMWORD PTR [r11-216], xmm15
  0005f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00066	48 33 c4	 xor	 rax, rsp
  00069	48 89 85 10 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 4c 24 78	 mov	 QWORD PTR info$GSCopy$1$[rsp], rcx

; 2004 :     int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;

  00078	33 c9		 xor	 ecx, ecx
  0007a	89 54 24 70	 mov	 DWORD PTR glyph_index$GSCopy$1$[rsp], edx
  0007e	4d 8b f0	 mov	 r14, r8
  00081	89 4c 24 60	 mov	 DWORD PTR maskbits$1$[rsp], ecx
  00085	44 8b e9	 mov	 r13d, ecx
  00088	89 4c 24 68	 mov	 DWORD PTR subr_stack_height$1$[rsp], ecx

; 2005 :     int has_subrs = 0, clear_stack;
; 2006 :     float s[48];
; 2007 :     stbtt__buf subr_stack[10], subrs = info->subrs, b;

  0008c	0f 10 40 70	 movups	 xmm0, XMMWORD PTR [rax+112]
  00090	8b f9		 mov	 edi, ecx
  00092	89 4c 24 6c	 mov	 DWORD PTR has_subrs$1$[rsp], ecx

; 2008 :     float f;
; 2009 : 
; 2010 : #define STBTT__CSERR(s) (0)
; 2011 : 
; 2012 :     // this currently ignores the initial width value, which isn't needed if we have hmtx
; 2013 :     b = stbtt__cff_index_get(info->charstrings, glyph_index);

  00096	0f 10 48 50	 movups	 xmm1, XMMWORD PTR [rax+80]
  0009a	44 8b c2	 mov	 r8d, edx
  0009d	48 8d 55 80	 lea	 rdx, QWORD PTR $T4[rbp-256]
  000a1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  000a6	45 0f 29 43 98	 movaps	 XMMWORD PTR [r11-104], xmm8
  000ab	0f 11 45 90	 movups	 XMMWORD PTR subrs$[rbp-256], xmm0
  000af	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR in_header$1$[rsp], 1
  000b7	0f 29 4d 80	 movaps	 XMMWORD PTR $T4[rbp-256], xmm1
  000bb	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  000c0	f3 44 0f 10 65
	cc		 movss	 xmm12, DWORD PTR s$[rbp-228]
  000c6	0f 57 f6	 xorps	 xmm6, xmm6
  000c9	f3 44 0f 10 75
	c8		 movss	 xmm14, DWORD PTR s$[rbp-232]
  000cf	45 33 c9	 xor	 r9d, r9d
  000d2	f3 44 0f 10 7d
	c4		 movss	 xmm15, DWORD PTR s$[rbp-236]
  000d8	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000db	f3 44 0f 10 55
	bc		 movss	 xmm10, DWORD PTR s$[rbp-244]
  000e1	f3 44 0f 10 6d
	b8		 movss	 xmm13, DWORD PTR s$[rbp-248]
  000e7	f3 44 0f 10 5d
	b4		 movss	 xmm11, DWORD PTR s$[rbp-252]
  000ed	f3 44 0f 10 4d
	b0		 movss	 xmm9, DWORD PTR s$[rbp-256]
  000f3	f3 0f 10 7d c0	 movss	 xmm7, DWORD PTR s$[rbp-240]
  000f8	0f 29 44 24 50	 movaps	 XMMWORD PTR b$[rsp], xmm0
  000fd	44 8b 7c 24 58	 mov	 r15d, DWORD PTR b$[rsp+8]
$LN278@stbtt__run:

; 2014 :     while (b.cursor < b.size) {

  00102	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp+8]
  00107	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
  0010e	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR __xmm@80000000800000008000000080000000
  00116	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0011a	44 3b f8	 cmp	 r15d, eax
  0011d	0f 8d ea 01 00
	00		 jge	 $LN3@stbtt__run

; 1120 :     return b->data[b->cursor++];

  00123	48 8b 54 24 50	 mov	 rdx, QWORD PTR b$[rsp]

; 2015 :         i = 0;

  00128	41 8b d9	 mov	 ebx, r9d

; 1120 :     return b->data[b->cursor++];

  0012b	49 63 c7	 movsxd	 rax, r15d
  0012e	41 ff c7	 inc	 r15d

; 2016 :         clear_stack = 1;

  00131	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR clear_stack$1$[rsp], 1

; 1120 :     return b->data[b->cursor++];

  00139	4d 63 c7	 movsxd	 r8, r15d
  0013c	44 89 7c 24 58	 mov	 DWORD PTR b$[rsp+8], r15d
  00141	44 0f b6 24 10	 movzx	 r12d, BYTE PTR [rax+rdx]

; 2017 :         b0 = stbtt__buf_get8(&b);
; 2018 :         switch (b0) {

  00146	41 8d 44 24 ff	 lea	 eax, DWORD PTR [r12-1]
  0014b	83 f8 1e	 cmp	 eax, 30
  0014e	0f 87 9c 0a 00
	00		 ja	 $LN94@stbtt__run
  00154	48 98		 cdqe
  00156	41 8b 8c 82 00
	00 00 00	 mov	 ecx, DWORD PTR $LN267@stbtt__run[r10+rax*4]
  0015e	49 03 ca	 add	 rcx, r10
  00161	ff e1		 jmp	 rcx
$LN29@stbtt__run:

; 2019 :             // @TODO implement hinting
; 2020 :         case 0x13: // hintmask
; 2021 :         case 0x14: // cntrmask
; 2022 :             if (in_header)

  00163	83 7c 24 64 00	 cmp	 DWORD PTR in_header$1$[rsp], 0
  00168	8b 74 24 60	 mov	 esi, DWORD PTR maskbits$1$[rsp]
  0016c	74 0d		 je	 SHORT $LN31@stbtt__run

; 2023 :                 maskbits += (sp / 2); // implicit "vstem"

  0016e	8b c7		 mov	 eax, edi
  00170	99		 cdq
  00171	2b c2		 sub	 eax, edx
  00173	d1 f8		 sar	 eax, 1
  00175	03 f0		 add	 esi, eax
  00177	89 74 24 60	 mov	 DWORD PTR maskbits$1$[rsp], esi
$LN31@stbtt__run:

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  0017b	8b 5c 24 5c	 mov	 ebx, DWORD PTR b$[rsp+12]

; 2024 :             in_header = 0;
; 2025 :             stbtt__buf_skip(&b, (maskbits + 7) / 8);

  0017f	8d 46 07	 lea	 eax, DWORD PTR [rsi+7]
  00182	99		 cdq
  00183	44 89 4c 24 64	 mov	 DWORD PTR in_header$1$[rsp], r9d
  00188	83 e2 07	 and	 edx, 7
  0018b	44 8d 3c 02	 lea	 r15d, DWORD PTR [rdx+rax]
  0018f	41 c1 ff 03	 sar	 r15d, 3
  00193	45 03 f8	 add	 r15d, r8d

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00196	44 3b fb	 cmp	 r15d, ebx
  00199	7f 05		 jg	 SHORT $LN118@stbtt__run
  0019b	45 85 ff	 test	 r15d, r15d
  0019e	79 1d		 jns	 SHORT $LN114@stbtt__run
$LN118@stbtt__run:
  001a0	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001ba	45 33 c9	 xor	 r9d, r9d
$LN114@stbtt__run:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  001bd	44 3b fb	 cmp	 r15d, ebx
  001c0	7f 1d		 jg	 SHORT $LN120@stbtt__run
  001c2	45 85 ff	 test	 r15d, r15d
  001c5	78 18		 js	 SHORT $LN120@stbtt__run
  001c7	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  001cb	41 8b c1	 mov	 eax, r9d
  001ce	85 c9		 test	 ecx, ecx

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  001d0	44 89 7c 24 58	 mov	 DWORD PTR b$[rsp+8], r15d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  001d5	0f 44 c7	 cmove	 eax, edi
  001d8	8b f8		 mov	 edi, eax
  001da	e9 23 ff ff ff	 jmp	 $LN278@stbtt__run
$LN120@stbtt__run:

; 2026 :             break;

  001df	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  001e3	41 8b c1	 mov	 eax, r9d
  001e6	85 c9		 test	 ecx, ecx

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  001e8	89 5c 24 58	 mov	 DWORD PTR b$[rsp+8], ebx
  001ec	44 8b fb	 mov	 r15d, ebx

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  001ef	0f 44 c7	 cmove	 eax, edi
  001f2	8b f8		 mov	 edi, eax
  001f4	e9 09 ff ff ff	 jmp	 $LN278@stbtt__run
$LN32@stbtt__run:

; 2027 : 
; 2028 :         case 0x01: // hstem
; 2029 :         case 0x03: // vstem
; 2030 :         case 0x12: // hstemhm
; 2031 :         case 0x17: // vstemhm
; 2032 :             maskbits += (sp / 2);
; 2033 :             break;

  001f9	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  001fd	8b c7		 mov	 eax, edi
  001ff	99		 cdq
  00200	2b c2		 sub	 eax, edx
  00202	d1 f8		 sar	 eax, 1
  00204	01 44 24 60	 add	 DWORD PTR maskbits$1$[rsp], eax

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00208	41 8b c1	 mov	 eax, r9d
  0020b	85 c9		 test	 ecx, ecx
  0020d	0f 44 c7	 cmove	 eax, edi
  00210	8b f8		 mov	 edi, eax
  00212	e9 eb fe ff ff	 jmp	 $LN278@stbtt__run
$LN36@stbtt__run:

; 2034 : 
; 2035 :         case 0x15: // rmoveto
; 2036 :             in_header = 0;

  00217	44 89 4c 24 64	 mov	 DWORD PTR in_header$1$[rsp], r9d

; 2037 :             if (sp < 2) return STBTT__CSERR("rmoveto stack");

  0021c	83 ff 02	 cmp	 edi, 2
  0021f	0f 8c e8 00 00
	00		 jl	 $LN3@stbtt__run

; 2038 :             stbtt__csctx_rmove_to(c, s[sp - 2], s[sp - 1]);

  00225	48 63 c7	 movsxd	 rax, edi
  00228	49 8b ce	 mov	 rcx, r14
  0022b	f3 0f 10 54 85
	ac		 movss	 xmm2, DWORD PTR s$[rbp+rax*4-260]
  00231	f3 0f 10 4c 85
	a8		 movss	 xmm1, DWORD PTR s$[rbp+rax*4-264]
  00237	e8 00 00 00 00	 call	 ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to

; 2039 :             break;

  0023c	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  00240	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00243	85 c9		 test	 ecx, ecx
  00245	41 8b c1	 mov	 eax, r9d
  00248	0f 44 c7	 cmove	 eax, edi
  0024b	8b f8		 mov	 edi, eax
  0024d	e9 b0 fe ff ff	 jmp	 $LN278@stbtt__run
$LN38@stbtt__run:

; 2040 :         case 0x04: // vmoveto
; 2041 :             in_header = 0;

  00252	44 89 4c 24 64	 mov	 DWORD PTR in_header$1$[rsp], r9d

; 2042 :             if (sp < 1) return STBTT__CSERR("vmoveto stack");

  00257	83 ff 01	 cmp	 edi, 1
  0025a	0f 8c ad 00 00
	00		 jl	 $LN3@stbtt__run

; 2043 :             stbtt__csctx_rmove_to(c, 0, s[sp - 1]);

  00260	48 63 c7	 movsxd	 rax, edi
  00263	0f 28 ce	 movaps	 xmm1, xmm6
  00266	49 8b ce	 mov	 rcx, r14
  00269	f3 0f 10 54 85
	ac		 movss	 xmm2, DWORD PTR s$[rbp+rax*4-260]
  0026f	e8 00 00 00 00	 call	 ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to

; 2044 :             break;

  00274	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  00278	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  0027b	85 c9		 test	 ecx, ecx
  0027d	41 8b c1	 mov	 eax, r9d
  00280	0f 44 c7	 cmove	 eax, edi
  00283	8b f8		 mov	 edi, eax
  00285	e9 78 fe ff ff	 jmp	 $LN278@stbtt__run
$LN40@stbtt__run:

; 2045 :         case 0x16: // hmoveto
; 2046 :             in_header = 0;

  0028a	44 89 4c 24 64	 mov	 DWORD PTR in_header$1$[rsp], r9d

; 2047 :             if (sp < 1) return STBTT__CSERR("hmoveto stack");

  0028f	83 ff 01	 cmp	 edi, 1
  00292	7c 79		 jl	 SHORT $LN3@stbtt__run

; 2048 :             stbtt__csctx_rmove_to(c, s[sp - 1], 0);

  00294	48 63 c7	 movsxd	 rax, edi
  00297	0f 28 d6	 movaps	 xmm2, xmm6
  0029a	49 8b ce	 mov	 rcx, r14
  0029d	f3 0f 10 4c 85
	ac		 movss	 xmm1, DWORD PTR s$[rbp+rax*4-260]
  002a3	e8 00 00 00 00	 call	 ?stbtt__csctx_rmove_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to

; 2049 :             break;

  002a8	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  002ac	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  002af	85 c9		 test	 ecx, ecx
  002b1	41 8b c1	 mov	 eax, r9d
  002b4	0f 44 c7	 cmove	 eax, edi
  002b7	8b f8		 mov	 edi, eax
  002b9	e9 44 fe ff ff	 jmp	 $LN278@stbtt__run
$LN42@stbtt__run:

; 2050 : 
; 2051 :         case 0x05: // rlineto
; 2052 :             if (sp < 2) return STBTT__CSERR("rlineto stack");

  002be	83 ff 02	 cmp	 edi, 2
  002c1	7c 4a		 jl	 SHORT $LN3@stbtt__run
  002c3	bb 01 00 00 00	 mov	 ebx, 1
  002c8	4c 8d 5d b0	 lea	 r11, QWORD PTR s$[rbp-256]
  002cc	0f 1f 40 00	 npad	 4
$LL8@stbtt__run:

; 2053 :             for (; i + 1 < sp; i += 2)
; 2054 :                 stbtt__csctx_rline_to(c, s[i], s[i + 1]);

  002d0	f3 41 0f 10 53
	04		 movss	 xmm2, DWORD PTR [r11+4]
  002d6	49 8b ce	 mov	 rcx, r14
  002d9	f3 41 0f 10 0b	 movss	 xmm1, DWORD PTR [r11]
  002de	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
  002e3	83 c3 02	 add	 ebx, 2
  002e6	4d 8d 5b 08	 lea	 r11, QWORD PTR [r11+8]
  002ea	3b df		 cmp	 ebx, edi
  002ec	7c e2		 jl	 SHORT $LL8@stbtt__run

; 2055 :             break;

  002ee	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  002f2	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  002f5	85 c9		 test	 ecx, ecx
  002f7	41 8b c1	 mov	 eax, r9d
  002fa	0f 44 c7	 cmove	 eax, edi
  002fd	8b f8		 mov	 edi, eax
  002ff	e9 fe fd ff ff	 jmp	 $LN278@stbtt__run
$LN44@stbtt__run:

; 2056 : 
; 2057 :             // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
; 2058 :             // starting from a different place.
; 2059 : 
; 2060 :         case 0x07: // vlineto
; 2061 :             if (sp < 1) return STBTT__CSERR("vlineto stack");

  00304	83 ff 01	 cmp	 edi, 1
  00307	0f 8d 8b 00 00
	00		 jge	 $vlineto$280
$LN3@stbtt__run:

; 2257 :     return STBTT__CSERR("no endchar");

  0030d	33 c0		 xor	 eax, eax
$LN1@stbtt__run:
  0030f	44 0f 28 84 24
	90 02 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+656]

; 2258 : 
; 2259 : #undef STBTT__CSERR
; 2260 : }

  00318	48 8b 8d 10 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  0031f	48 33 cc	 xor	 rcx, rsp
  00322	e8 00 00 00 00	 call	 __security_check_cookie
  00327	4c 8d 9c 24 c0
	02 00 00	 lea	 r11, QWORD PTR [rsp+704]
  0032f	49 8b 5b 58	 mov	 rbx, QWORD PTR [r11+88]
  00333	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00338	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  0033d	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  00342	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  00347	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  0034c	45 0f 28 63 90	 movaps	 xmm12, XMMWORD PTR [r11-112]
  00351	45 0f 28 6b 80	 movaps	 xmm13, XMMWORD PTR [r11-128]
  00356	45 0f 28 b3 70
	ff ff ff	 movaps	 xmm14, XMMWORD PTR [r11-144]
  0035e	45 0f 28 bb 60
	ff ff ff	 movaps	 xmm15, XMMWORD PTR [r11-160]
  00366	49 8b e3	 mov	 rsp, r11
  00369	41 5f		 pop	 r15
  0036b	41 5e		 pop	 r14
  0036d	41 5d		 pop	 r13
  0036f	41 5c		 pop	 r12
  00371	5f		 pop	 rdi
  00372	5e		 pop	 rsi
  00373	5d		 pop	 rbp
  00374	c3		 ret	 0
$LN47@stbtt__run:

; 2062 :             goto vlineto;
; 2063 :         case 0x06: // hlineto
; 2064 :             if (sp < 1) return STBTT__CSERR("hlineto stack");

  00375	83 ff 01	 cmp	 edi, 1
  00378	7c 93		 jl	 SHORT $LN3@stbtt__run
$LN9@stbtt__run:

; 2065 :             for (;;) {
; 2066 :                 if (i >= sp) break;

  0037a	3b df		 cmp	 ebx, edi
  0037c	0f 8d 5c 03 00
	00		 jge	 $LN276@stbtt__run

; 2067 :                 stbtt__csctx_rline_to(c, s[i], 0);

  00382	48 63 c3	 movsxd	 rax, ebx
  00385	0f 28 d6	 movaps	 xmm2, xmm6
  00388	49 8b ce	 mov	 rcx, r14
  0038b	f3 0f 10 4c 85
	b0		 movss	 xmm1, DWORD PTR s$[rbp+rax*4-256]
  00391	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2068 :                 i++;

  00396	ff c3		 inc	 ebx
$vlineto$280:

; 2069 :             vlineto:
; 2070 :                 if (i >= sp) break;

  00398	3b df		 cmp	 ebx, edi
  0039a	0f 8d 3e 03 00
	00		 jge	 $LN276@stbtt__run

; 2071 :                 stbtt__csctx_rline_to(c, 0, s[i]);

  003a0	48 63 c3	 movsxd	 rax, ebx
  003a3	0f 28 ce	 movaps	 xmm1, xmm6
  003a6	49 8b ce	 mov	 rcx, r14
  003a9	f3 0f 10 54 85
	b0		 movss	 xmm2, DWORD PTR s$[rbp+rax*4-256]
  003af	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2072 :                 i++;

  003b4	ff c3		 inc	 ebx

; 2073 :             }

  003b6	eb c2		 jmp	 SHORT $LN9@stbtt__run
$LN51@stbtt__run:

; 2074 :             break;
; 2075 : 
; 2076 :         case 0x1F: // hvcurveto
; 2077 :             if (sp < 4) return STBTT__CSERR("hvcurveto stack");

  003b8	83 ff 04	 cmp	 edi, 4
  003bb	0f 8c 4c ff ff
	ff		 jl	 $LN3@stbtt__run

; 2078 :             goto hvcurveto;

  003c1	eb 68		 jmp	 SHORT $hvcurveto$281
$LN54@stbtt__run:

; 2079 :         case 0x1E: // vhcurveto
; 2080 :             if (sp < 4) return STBTT__CSERR("vhcurveto stack");

  003c3	83 ff 04	 cmp	 edi, 4
  003c6	0f 8c 41 ff ff
	ff		 jl	 $LN3@stbtt__run
$LN12@stbtt__run:

; 2081 :             for (;;) {
; 2082 :                 if (i + 3 >= sp) break;

  003cc	8d 43 03	 lea	 eax, DWORD PTR [rbx+3]
  003cf	3b c7		 cmp	 eax, edi
  003d1	0f 8d 07 03 00
	00		 jge	 $LN276@stbtt__run

; 2083 :                 stbtt__csctx_rccurve_to(c, 0, s[i], s[i + 1], s[i + 2], s[i + 3], (sp - i == 5) ? s[i + 4] : 0.0f);

  003d7	8b c7		 mov	 eax, edi
  003d9	8d 73 04	 lea	 esi, DWORD PTR [rbx+4]
  003dc	2b c3		 sub	 eax, ebx
  003de	83 f8 05	 cmp	 eax, 5
  003e1	75 0b		 jne	 SHORT $LN102@stbtt__run
  003e3	48 63 c6	 movsxd	 rax, esi
  003e6	f3 0f 10 44 85
	b0		 movss	 xmm0, DWORD PTR s$[rbp+rax*4-256]
  003ec	eb 03		 jmp	 SHORT $LN103@stbtt__run
$LN102@stbtt__run:
  003ee	0f 28 c6	 movaps	 xmm0, xmm6
$LN103@stbtt__run:
  003f1	48 63 c3	 movsxd	 rax, ebx
  003f4	49 8b ce	 mov	 rcx, r14
  003f7	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  003fd	f3 0f 10 4c 85
	b8		 movss	 xmm1, DWORD PTR s$[rbp+rax*4-248]
  00403	f3 0f 10 44 85
	bc		 movss	 xmm0, DWORD PTR s$[rbp+rax*4-244]
  00409	f3 0f 10 5c 85
	b4		 movss	 xmm3, DWORD PTR s$[rbp+rax*4-252]
  0040f	f3 0f 10 54 85
	b0		 movss	 xmm2, DWORD PTR s$[rbp+rax*4-256]
  00415	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0041b	f3 0f 11 4c 24
	20		 movss	 DWORD PTR [rsp+32], xmm1
  00421	0f 28 ce	 movaps	 xmm1, xmm6
  00424	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2084 :                 i += 4;

  00429	8b de		 mov	 ebx, esi
$hvcurveto$281:

; 2085 :             hvcurveto:
; 2086 :                 if (i + 3 >= sp) break;

  0042b	8d 43 03	 lea	 eax, DWORD PTR [rbx+3]
  0042e	3b c7		 cmp	 eax, edi
  00430	0f 8d a8 02 00
	00		 jge	 $LN276@stbtt__run

; 2087 :                 stbtt__csctx_rccurve_to(c, s[i], 0, s[i + 1], s[i + 2], (sp - i == 5) ? s[i + 4] : 0.0f, s[i + 3]);

  00436	48 63 cb	 movsxd	 rcx, ebx
  00439	8d 73 04	 lea	 esi, DWORD PTR [rbx+4]
  0043c	8b c7		 mov	 eax, edi
  0043e	2b c3		 sub	 eax, ebx
  00440	f3 0f 10 4c 8d
	bc		 movss	 xmm1, DWORD PTR s$[rbp+rcx*4-244]
  00446	83 f8 05	 cmp	 eax, 5
  00449	75 0b		 jne	 SHORT $LN104@stbtt__run
  0044b	48 63 c6	 movsxd	 rax, esi
  0044e	f3 0f 10 44 85
	b0		 movss	 xmm0, DWORD PTR s$[rbp+rax*4-256]
  00454	eb 03		 jmp	 SHORT $LN105@stbtt__run
$LN104@stbtt__run:
  00456	0f 28 c6	 movaps	 xmm0, xmm6
$LN105@stbtt__run:
  00459	f3 0f 10 5c 8d
	b4		 movss	 xmm3, DWORD PTR s$[rbp+rcx*4-252]
  0045f	0f 28 d6	 movaps	 xmm2, xmm6
  00462	f3 0f 11 4c 24
	30		 movss	 DWORD PTR [rsp+48], xmm1
  00468	f3 0f 10 4c 8d
	b0		 movss	 xmm1, DWORD PTR s$[rbp+rcx*4-256]
  0046e	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00474	f3 0f 10 44 8d
	b8		 movss	 xmm0, DWORD PTR s$[rbp+rcx*4-248]
  0047a	49 8b ce	 mov	 rcx, r14
  0047d	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00483	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2088 :                 i += 4;

  00488	8b de		 mov	 ebx, esi

; 2089 :             }

  0048a	e9 3d ff ff ff	 jmp	 $LN12@stbtt__run
$LN58@stbtt__run:

; 2090 :             break;
; 2091 : 
; 2092 :         case 0x08: // rrcurveto
; 2093 :             if (sp < 6) return STBTT__CSERR("rcurveline stack");

  0048f	83 ff 06	 cmp	 edi, 6
  00492	0f 8c 75 fe ff
	ff		 jl	 $LN3@stbtt__run
  00498	be 05 00 00 00	 mov	 esi, 5
  0049d	48 8d 5d c0	 lea	 rbx, QWORD PTR s$[rbp-240]
$LL17@stbtt__run:

; 2094 :             for (; i + 5 < sp; i += 6)
; 2095 :                 stbtt__csctx_rccurve_to(c, s[i], s[i + 1], s[i + 2], s[i + 3], s[i + 4], s[i + 5]);

  004a1	f3 0f 10 43 04	 movss	 xmm0, DWORD PTR [rbx+4]
  004a6	49 8b ce	 mov	 rcx, r14
  004a9	f3 0f 10 0b	 movss	 xmm1, DWORD PTR [rbx]
  004ad	f3 0f 10 5b f8	 movss	 xmm3, DWORD PTR [rbx-8]
  004b2	f3 0f 10 53 f4	 movss	 xmm2, DWORD PTR [rbx-12]
  004b7	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  004bd	f3 0f 10 43 fc	 movss	 xmm0, DWORD PTR [rbx-4]
  004c2	f3 0f 11 4c 24
	28		 movss	 DWORD PTR [rsp+40], xmm1
  004c8	f3 0f 10 4b f0	 movss	 xmm1, DWORD PTR [rbx-16]
  004cd	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  004d3	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  004d8	83 c6 06	 add	 esi, 6
  004db	48 8d 5b 18	 lea	 rbx, QWORD PTR [rbx+24]
  004df	3b f7		 cmp	 esi, edi
  004e1	7c be		 jl	 SHORT $LL17@stbtt__run

; 2096 :             break;

  004e3	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  004e7	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  004ea	85 c9		 test	 ecx, ecx
  004ec	41 8b c1	 mov	 eax, r9d
  004ef	0f 44 c7	 cmove	 eax, edi
  004f2	8b f8		 mov	 edi, eax
  004f4	e9 09 fc ff ff	 jmp	 $LN278@stbtt__run
$LN60@stbtt__run:

; 2097 : 
; 2098 :         case 0x18: // rcurveline
; 2099 :             if (sp < 8) return STBTT__CSERR("rcurveline stack");

  004f9	83 ff 08	 cmp	 edi, 8
  004fc	0f 8c 0b fe ff
	ff		 jl	 $LN3@stbtt__run

; 2100 :             for (; i + 5 < sp - 2; i += 6)

  00502	44 8d 6f fe	 lea	 r13d, DWORD PTR [rdi-2]
  00506	41 83 fd 05	 cmp	 r13d, 5
  0050a	7e 67		 jle	 SHORT $LN266@stbtt__run
  0050c	41 bc 05 00 00
	00		 mov	 r12d, 5
  00512	48 8d 75 c0	 lea	 rsi, QWORD PTR s$[rbp-240]
  00516	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL20@stbtt__run:

; 2101 :                 stbtt__csctx_rccurve_to(c, s[i], s[i + 1], s[i + 2], s[i + 3], s[i + 4], s[i + 5]);

  00520	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [rsi+4]
  00525	49 8b ce	 mov	 rcx, r14
  00528	f3 0f 10 0e	 movss	 xmm1, DWORD PTR [rsi]
  0052c	f3 0f 10 5e f8	 movss	 xmm3, DWORD PTR [rsi-8]
  00531	f3 0f 10 56 f4	 movss	 xmm2, DWORD PTR [rsi-12]
  00536	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0053c	f3 0f 10 46 fc	 movss	 xmm0, DWORD PTR [rsi-4]
  00541	f3 0f 11 4c 24
	28		 movss	 DWORD PTR [rsp+40], xmm1
  00547	f3 0f 10 4e f0	 movss	 xmm1, DWORD PTR [rsi-16]
  0054c	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00552	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  00557	83 c3 06	 add	 ebx, 6
  0055a	48 8d 76 18	 lea	 rsi, QWORD PTR [rsi+24]
  0055e	41 83 c4 06	 add	 r12d, 6
  00562	8b c3		 mov	 eax, ebx
  00564	45 3b e5	 cmp	 r12d, r13d
  00567	7c b7		 jl	 SHORT $LL20@stbtt__run

; 2102 :             if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");

  00569	ff c0		 inc	 eax
  0056b	3b c7		 cmp	 eax, edi
  0056d	0f 8d 9a fd ff
	ff		 jge	 $LN3@stbtt__run
$LN266@stbtt__run:

; 2103 :             stbtt__csctx_rline_to(c, s[i], s[i + 1]);

  00573	48 63 c3	 movsxd	 rax, ebx
  00576	49 8b ce	 mov	 rcx, r14
  00579	f3 0f 10 54 85
	b4		 movss	 xmm2, DWORD PTR s$[rbp+rax*4-252]
  0057f	f3 0f 10 4c 85
	b0		 movss	 xmm1, DWORD PTR s$[rbp+rax*4-256]
  00585	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 2104 :             break;

  0058a	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  0058e	45 33 c9	 xor	 r9d, r9d
  00591	44 8b 6c 24 68	 mov	 r13d, DWORD PTR subr_stack_height$1$[rsp]

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00596	85 c9		 test	 ecx, ecx
  00598	41 8b c1	 mov	 eax, r9d
  0059b	0f 44 c7	 cmove	 eax, edi
  0059e	8b f8		 mov	 edi, eax
  005a0	e9 5d fb ff ff	 jmp	 $LN278@stbtt__run
$LN63@stbtt__run:

; 2105 : 
; 2106 :         case 0x19: // rlinecurve
; 2107 :             if (sp < 8) return STBTT__CSERR("rlinecurve stack");

  005a5	83 ff 08	 cmp	 edi, 8
  005a8	0f 8c 5f fd ff
	ff		 jl	 $LN3@stbtt__run

; 2108 :             for (; i + 1 < sp - 6; i += 2)

  005ae	44 8d 67 fa	 lea	 r12d, DWORD PTR [rdi-6]
  005b2	41 83 fc 01	 cmp	 r12d, 1
  005b6	7e 38		 jle	 SHORT $LN265@stbtt__run
  005b8	be 01 00 00 00	 mov	 esi, 1
  005bd	4c 8d 5d b0	 lea	 r11, QWORD PTR s$[rbp-256]
$LL23@stbtt__run:

; 2109 :                 stbtt__csctx_rline_to(c, s[i], s[i + 1]);

  005c1	f3 41 0f 10 53
	04		 movss	 xmm2, DWORD PTR [r11+4]
  005c7	49 8b ce	 mov	 rcx, r14
  005ca	f3 41 0f 10 0b	 movss	 xmm1, DWORD PTR [r11]
  005cf	e8 00 00 00 00	 call	 ?stbtt__csctx_rline_to@@YAXPEAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
  005d4	83 c3 02	 add	 ebx, 2
  005d7	4d 8d 5b 08	 lea	 r11, QWORD PTR [r11+8]
  005db	83 c6 02	 add	 esi, 2
  005de	8b c3		 mov	 eax, ebx
  005e0	41 3b f4	 cmp	 esi, r12d
  005e3	7c dc		 jl	 SHORT $LL23@stbtt__run

; 2110 :             if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");

  005e5	83 c0 05	 add	 eax, 5
  005e8	3b c7		 cmp	 eax, edi
  005ea	0f 8d 1d fd ff
	ff		 jge	 $LN3@stbtt__run
$LN265@stbtt__run:

; 2111 :             stbtt__csctx_rccurve_to(c, s[i], s[i + 1], s[i + 2], s[i + 3], s[i + 4], s[i + 5]);

  005f0	48 63 c3	 movsxd	 rax, ebx
  005f3	49 8b ce	 mov	 rcx, r14
  005f6	f3 0f 10 44 85
	c4		 movss	 xmm0, DWORD PTR s$[rbp+rax*4-236]
  005fc	f3 0f 10 54 85
	c0		 movss	 xmm2, DWORD PTR s$[rbp+rax*4-240]
  00602	f3 0f 10 5c 85
	b8		 movss	 xmm3, DWORD PTR s$[rbp+rax*4-248]
  00608	f3 0f 10 4c 85
	b0		 movss	 xmm1, DWORD PTR s$[rbp+rax*4-256]
  0060e	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00614	f3 0f 10 44 85
	bc		 movss	 xmm0, DWORD PTR s$[rbp+rax*4-244]
  0061a	f3 0f 11 54 24
	28		 movss	 DWORD PTR [rsp+40], xmm2
  00620	f3 0f 10 54 85
	b4		 movss	 xmm2, DWORD PTR s$[rbp+rax*4-252]
  00626	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0062c	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2112 :             break;

  00631	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  00635	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00638	85 c9		 test	 ecx, ecx
  0063a	41 8b c1	 mov	 eax, r9d
  0063d	0f 44 c7	 cmove	 eax, edi
  00640	8b f8		 mov	 edi, eax
  00642	e9 bb fa ff ff	 jmp	 $LN278@stbtt__run
$LN66@stbtt__run:

; 2113 : 
; 2114 :         case 0x1A: // vvcurveto
; 2115 :         case 0x1B: // hhcurveto
; 2116 :             if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");

  00647	83 ff 04	 cmp	 edi, 4
  0064a	0f 8c bd fc ff
	ff		 jl	 $LN3@stbtt__run

; 2117 :             f = 0.0;
; 2118 :             if (sp & 1) { f = s[i]; i++; }

  00650	8b c7		 mov	 eax, edi
  00652	0f 28 d6	 movaps	 xmm2, xmm6
  00655	83 e0 01	 and	 eax, 1
  00658	74 04		 je	 SHORT $LN69@stbtt__run
  0065a	41 0f 28 d1	 movaps	 xmm2, xmm9
$LN69@stbtt__run:

; 2119 :             for (; i + 3 < sp; i += 4) {

  0065e	8d 70 03	 lea	 esi, DWORD PTR [rax+3]
  00661	3b f7		 cmp	 esi, edi
  00663	7d 7c		 jge	 SHORT $LN269@stbtt__run

; 2120 :                 if (b0 == 0x1B)

  00665	48 8d 5d b8	 lea	 rbx, QWORD PTR s$[rbp-248]
  00669	48 8d 1c 83	 lea	 rbx, QWORD PTR [rbx+rax*4]
  0066d	0f 1f 00	 npad	 3
$LL26@stbtt__run:
  00670	f3 0f 10 43 04	 movss	 xmm0, DWORD PTR [rbx+4]
  00675	f3 0f 10 2b	 movss	 xmm5, DWORD PTR [rbx]
  00679	f3 0f 10 4b f8	 movss	 xmm1, DWORD PTR [rbx-8]
  0067e	41 80 fc 1b	 cmp	 r12b, 27
  00682	75 0b		 jne	 SHORT $LN70@stbtt__run

; 2121 :                     stbtt__csctx_rccurve_to(c, s[i], f, s[i + 1], s[i + 2], s[i + 3], 0.0);

  00684	0f 28 d8	 movaps	 xmm3, xmm0
  00687	0f 28 e1	 movaps	 xmm4, xmm1
  0068a	0f 28 c6	 movaps	 xmm0, xmm6
  0068d	eb 09		 jmp	 SHORT $LN71@stbtt__run
$LN70@stbtt__run:

; 2122 :                 else
; 2123 :                     stbtt__csctx_rccurve_to(c, f, s[i], s[i + 1], s[i + 2], 0.0, s[i + 3]);

  0068f	0f 28 e2	 movaps	 xmm4, xmm2
  00692	0f 28 de	 movaps	 xmm3, xmm6
  00695	0f 28 d1	 movaps	 xmm2, xmm1
$LN71@stbtt__run:

; 2124 :                 f = 0.0;

  00698	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0069e	0f 28 cc	 movaps	 xmm1, xmm4
  006a1	f3 0f 11 5c 24
	28		 movss	 DWORD PTR [rsp+40], xmm3
  006a7	49 8b ce	 mov	 rcx, r14
  006aa	f3 0f 10 5b fc	 movss	 xmm3, DWORD PTR [rbx-4]
  006af	f3 0f 11 6c 24
	20		 movss	 DWORD PTR [rsp+32], xmm5
  006b5	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
  006ba	83 c6 04	 add	 esi, 4
  006bd	48 83 c3 10	 add	 rbx, 16
  006c1	0f 28 d6	 movaps	 xmm2, xmm6
  006c4	3b f7		 cmp	 esi, edi
  006c6	7c a8		 jl	 SHORT $LL26@stbtt__run

; 2125 :             }
; 2126 :             break;

  006c8	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  006cc	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  006cf	85 c9		 test	 ecx, ecx
  006d1	41 8b c1	 mov	 eax, r9d
  006d4	0f 44 c7	 cmove	 eax, edi
  006d7	8b f8		 mov	 edi, eax
  006d9	e9 24 fa ff ff	 jmp	 $LN278@stbtt__run
$LN276@stbtt__run:

; 2065 :             for (;;) {
; 2066 :                 if (i >= sp) break;

  006de	45 33 c9	 xor	 r9d, r9d
$LN269@stbtt__run:
  006e1	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  006e5	41 8b c1	 mov	 eax, r9d
  006e8	85 c9		 test	 ecx, ecx
  006ea	0f 44 c7	 cmove	 eax, edi
  006ed	8b f8		 mov	 edi, eax
  006ef	e9 0e fa ff ff	 jmp	 $LN278@stbtt__run
$LN72@stbtt__run:

; 2127 : 
; 2128 :         case 0x0A: // callsubr
; 2129 :             if (!has_subrs) {

  006f4	83 7c 24 6c 00	 cmp	 DWORD PTR has_subrs$1$[rsp], 0
  006f9	4c 8b 7c 24 78	 mov	 r15, QWORD PTR info$GSCopy$1$[rsp]
  006fe	75 31		 jne	 SHORT $LN73@stbtt__run

; 2130 :                 if (info->fdselect.size)

  00700	41 83 bf 9c 00
	00 00 00	 cmp	 DWORD PTR [r15+156], 0
  00708	74 18		 je	 SHORT $LN74@stbtt__run

; 2131 :                     subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);

  0070a	44 8b 44 24 70	 mov	 r8d, DWORD PTR glyph_index$GSCopy$1$[rsp]
  0070f	48 8d 4d a0	 lea	 rcx, QWORD PTR $T6[rbp-256]
  00713	49 8b d7	 mov	 rdx, r15
  00716	e8 00 00 00 00	 call	 ?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PEBUstbtt_fontinfo@@H@Z ; stbtt__cid_get_glyph_subrs
  0071b	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0071e	0f 11 45 90	 movups	 XMMWORD PTR subrs$[rbp-256], xmm0
$LN74@stbtt__run:

; 2132 :                 has_subrs = 1;

  00722	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR has_subrs$1$[rsp], 1
  0072a	eb 05		 jmp	 SHORT $LN73@stbtt__run
$LN271@stbtt__run:

; 2017 :         b0 = stbtt__buf_get8(&b);
; 2018 :         switch (b0) {

  0072c	4c 8b 7c 24 78	 mov	 r15, QWORD PTR info$GSCopy$1$[rsp]
$LN73@stbtt__run:

; 2133 :             }
; 2134 :             // fallthrough
; 2135 :         case 0x1D: // callgsubr
; 2136 :             if (sp < 1) return STBTT__CSERR("call(g|)subr stack");

  00731	83 ff 01	 cmp	 edi, 1
  00734	0f 8c d3 fb ff
	ff		 jl	 $LN3@stbtt__run

; 2137 :             v = (int)s[--sp];

  0073a	ff cf		 dec	 edi

; 2138 :             if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");

  0073c	41 83 fd 0a	 cmp	 r13d, 10
  00740	0f 8d c7 fb ff
	ff		 jge	 $LN3@stbtt__run

; 2139 :             subr_stack[subr_stack_height++] = b;

  00746	0f 28 44 24 50	 movaps	 xmm0, XMMWORD PTR b$[rsp]
  0074b	49 63 c5	 movsxd	 rax, r13d
  0074e	41 ff c5	 inc	 r13d
  00751	48 03 c0	 add	 rax, rax
  00754	44 89 6c 24 68	 mov	 DWORD PTR subr_stack_height$1$[rsp], r13d
  00759	0f 11 44 c5 70	 movups	 XMMWORD PTR subr_stack$[rbp+rax*8-256], xmm0
  0075e	48 63 c7	 movsxd	 rax, edi
  00761	f3 0f 2c 5c 85
	b0		 cvttss2si ebx, DWORD PTR s$[rbp+rax*4-256]

; 2140 :             b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);

  00767	48 8d 45 90	 lea	 rax, QWORD PTR subrs$[rbp-256]
  0076b	41 83 fc 0a	 cmp	 r12d, 10
  0076f	74 04		 je	 SHORT $LN107@stbtt__run
  00771	49 8d 47 60	 lea	 rax, QWORD PTR [r15+96]
$LN107@stbtt__run:
  00775	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00778	0f 29 44 24 50	 movaps	 XMMWORD PTR $T2[rsp], xmm0

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  0077d	66 0f 73 d8 08	 psrldq	 xmm0, 8
  00782	66 48 0f 7e c0	 movq	 rax, xmm0
  00787	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0078b	85 c0		 test	 eax, eax
  0078d	79 1a		 jns	 SHORT $LN132@stbtt__run
  0078f	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00795	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0079c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  007a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN132@stbtt__run:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  007a9	44 8b 44 24 5c	 mov	 r8d, DWORD PTR $T2[rsp+12]
  007ae	b8 00 00 00 00	 mov	 eax, 0

; 1118 :     if (b->cursor >= b->size)

  007b3	4c 8b 4c 24 50	 mov	 r9, QWORD PTR $T2[rsp]

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  007b8	45 85 c0	 test	 r8d, r8d
  007bb	41 8b c8	 mov	 ecx, r8d
  007be	0f 49 c8	 cmovns	 ecx, eax
  007c1	89 4c 24 58	 mov	 DWORD PTR $T2[rsp+8], ecx

; 1118 :     if (b->cursor >= b->size)

  007c5	41 3b c8	 cmp	 ecx, r8d
  007c8	7d 0e		 jge	 SHORT $LN150@stbtt__run

; 1120 :     return b->data[b->cursor++];

  007ca	48 63 c1	 movsxd	 rax, ecx
  007cd	ff c1		 inc	 ecx
  007cf	89 4c 24 58	 mov	 DWORD PTR $T2[rsp+8], ecx
  007d3	42 0f b6 04 08	 movzx	 eax, BYTE PTR [rax+r9]
$LN150@stbtt__run:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  007d8	0f b6 d0	 movzx	 edx, al

; 1118 :     if (b->cursor >= b->size)

  007db	41 3b c8	 cmp	 ecx, r8d
  007de	7c 04		 jl	 SHORT $LN237@stbtt__run

; 1119 :         return 0;

  007e0	32 c0		 xor	 al, al
  007e2	eb 0e		 jmp	 SHORT $LN238@stbtt__run
$LN237@stbtt__run:

; 1120 :     return b->data[b->cursor++];

  007e4	48 63 c1	 movsxd	 rax, ecx
  007e7	ff c1		 inc	 ecx
  007e9	89 4c 24 58	 mov	 DWORD PTR $T2[rsp+8], ecx
  007ed	42 0f b6 04 08	 movzx	 eax, BYTE PTR [rax+r9]
$LN238@stbtt__run:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  007f2	c1 e2 08	 shl	 edx, 8
  007f5	0f b6 c0	 movzx	 eax, al
  007f8	0b d0		 or	 edx, eax

; 1963 :     if (count >= 33900)

  007fa	81 fa 6c 84 00
	00		 cmp	 edx, 33900		; 0000846cH
  00800	72 07		 jb	 SHORT $LN123@stbtt__run

; 1964 :         bias = 32768;

  00802	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00807	eb 13		 jmp	 SHORT $LN125@stbtt__run
$LN123@stbtt__run:

; 1965 :     else if (count >= 1240)

  00809	81 fa d8 04 00
	00		 cmp	 edx, 1240		; 000004d8H
  0080f	b8 6b 00 00 00	 mov	 eax, 107		; 0000006bH
  00814	b9 6b 04 00 00	 mov	 ecx, 1131		; 0000046bH
  00819	0f 43 c1	 cmovae	 eax, ecx
$LN125@stbtt__run:

; 1966 :         bias = 1131;
; 1967 :     n += bias;

  0081c	03 d8		 add	 ebx, eax

; 1968 :     if (n < 0 || n >= count)

  0081e	78 24		 js	 SHORT $LN156@stbtt__run
  00820	3b da		 cmp	 ebx, edx
  00822	7d 20		 jge	 SHORT $LN156@stbtt__run

; 1969 :         return stbtt__new_buf(NULL, 0);
; 1970 :     return stbtt__cff_index_get(idx, n);

  00824	0f 28 44 24 50	 movaps	 xmm0, XMMWORD PTR $T2[rsp]
  00829	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T1[rsp]
  0082e	44 8b c3	 mov	 r8d, ebx
  00831	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR $T1[rsp], xmm0
  00837	48 8d 4d 80	 lea	 rcx, QWORD PTR $T5[rbp-256]
  0083b	e8 00 00 00 00	 call	 ?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
  00840	33 c9		 xor	 ecx, ecx
  00842	eb 0a		 jmp	 SHORT $LN122@stbtt__run
$LN156@stbtt__run:

; 1155 :     r.data = (stbtt_uint8*)p;

  00844	33 c9		 xor	 ecx, ecx
  00846	48 89 4d 80	 mov	 QWORD PTR $T5[rbp-256], rcx

; 1156 :     r.size = (int)size;
; 1157 :     r.cursor = 0;

  0084a	48 89 4d 88	 mov	 QWORD PTR $T5[rbp-248], rcx
$LN122@stbtt__run:

; 2140 :             b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);

  0084e	0f 28 45 80	 movaps	 xmm0, XMMWORD PTR $T5[rbp-256]
  00852	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR b$[rsp], xmm0

; 2141 :             if (b.size == 0) return STBTT__CSERR("subr not found");

  00858	66 0f 73 d8 08	 psrldq	 xmm0, 8
  0085d	66 48 0f 7e c0	 movq	 rax, xmm0
  00862	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00866	85 c0		 test	 eax, eax
  00868	0f 84 9f fa ff
	ff		 je	 $LN3@stbtt__run

; 2142 :             b.cursor = 0;
; 2143 :             clear_stack = 0;
; 2144 :             break;

  0086e	45 33 c9	 xor	 r9d, r9d
  00871	89 4c 24 58	 mov	 DWORD PTR b$[rsp+8], ecx

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00875	85 c9		 test	 ecx, ecx
  00877	41 8b c1	 mov	 eax, r9d
  0087a	44 8b f9	 mov	 r15d, ecx
  0087d	0f 44 c7	 cmove	 eax, edi
  00880	8b f8		 mov	 edi, eax
  00882	e9 7b f8 ff ff	 jmp	 $LN278@stbtt__run
$LN79@stbtt__run:

; 2145 : 
; 2146 :         case 0x0B: // return
; 2147 :             if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");

  00887	45 85 ed	 test	 r13d, r13d
  0088a	0f 8e 7d fa ff
	ff		 jle	 $LN3@stbtt__run

; 2148 :             b = subr_stack[--subr_stack_height];

  00890	41 ff cd	 dec	 r13d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00893	41 8b c9	 mov	 ecx, r9d
  00896	49 63 c5	 movsxd	 rax, r13d
  00899	48 03 c0	 add	 rax, rax
  0089c	44 89 6c 24 68	 mov	 DWORD PTR subr_stack_height$1$[rsp], r13d
  008a1	85 c9		 test	 ecx, ecx
  008a3	0f 10 44 c5 70	 movups	 xmm0, XMMWORD PTR subr_stack$[rbp+rax*8-256]
  008a8	41 8b c1	 mov	 eax, r9d
  008ab	0f 44 c7	 cmove	 eax, edi
  008ae	0f 11 44 24 50	 movups	 XMMWORD PTR b$[rsp], xmm0
  008b3	44 8b 7c 24 58	 mov	 r15d, DWORD PTR b$[rsp+8]
  008b8	8b f8		 mov	 edi, eax
  008ba	e9 43 f8 ff ff	 jmp	 $LN278@stbtt__run
$LN82@stbtt__run:

; 1118 :     if (b->cursor >= b->size)

  008bf	48 8b 44 24 58	 mov	 rax, QWORD PTR b$[rsp+8]
  008c4	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  008c8	44 3b c0	 cmp	 r8d, eax
  008cb	7c 04		 jl	 SHORT $LN160@stbtt__run

; 1119 :         return 0;

  008cd	32 c0		 xor	 al, al
  008cf	eb 0e		 jmp	 SHORT $LN159@stbtt__run
$LN160@stbtt__run:

; 1120 :     return b->data[b->cursor++];

  008d1	41 0f b6 04 10	 movzx	 eax, BYTE PTR [r8+rdx]
  008d6	45 8d 78 01	 lea	 r15d, DWORD PTR [r8+1]
  008da	44 89 7c 24 58	 mov	 DWORD PTR b$[rsp+8], r15d
$LN159@stbtt__run:

; 2155 : 
; 2156 :         case 0x0C: { // two-byte escape
; 2157 :             float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
; 2158 :             float dx, dy;
; 2159 :             int b1 = stbtt__buf_get8(&b);

  008df	0f b6 c8	 movzx	 ecx, al

; 2160 :             switch (b1) {

  008e2	83 e9 22	 sub	 ecx, 34			; 00000022H
  008e5	0f 84 fd 01 00
	00		 je	 $LN83@stbtt__run
  008eb	83 e9 01	 sub	 ecx, 1
  008ee	0f 84 77 01 00
	00		 je	 $LN85@stbtt__run
  008f4	83 e9 01	 sub	 ecx, 1
  008f7	0f 84 e8 00 00
	00		 je	 $LN87@stbtt__run
  008fd	83 f9 01	 cmp	 ecx, 1
  00900	0f 85 07 fa ff
	ff		 jne	 $LN3@stbtt__run

; 2209 : 
; 2210 :             case 0x25: // flex1
; 2211 :                 if (sp < 11) return STBTT__CSERR("flex1 stack");

  00906	83 ff 0b	 cmp	 edi, 11
  00909	0f 8c fe f9 ff
	ff		 jl	 $LN3@stbtt__run

; 2212 :                 dx1 = s[0];
; 2213 :                 dy1 = s[1];
; 2214 :                 dx2 = s[2];
; 2215 :                 dy2 = s[3];
; 2216 :                 dx3 = s[4];
; 2217 :                 dy3 = s[5];
; 2218 :                 dx4 = s[6];
; 2219 :                 dy4 = s[7];
; 2220 :                 dx5 = s[8];
; 2221 :                 dy5 = s[9];
; 2222 :                 dx6 = dy6 = s[10];
; 2223 :                 dx = dx1 + dx2 + dx3 + dx4 + dx5;

  0090f	f3 0f 10 65 c0	 movss	 xmm4, DWORD PTR s$[rbp-240]
  00914	41 0f 28 d5	 movaps	 xmm2, xmm13
  00918	f3 0f 10 7d d8	 movss	 xmm7, DWORD PTR s$[rbp-216]
  0091d	f3 41 0f 58 d1	 addss	 xmm2, xmm9

; 2224 :                 dy = dy1 + dy2 + dy3 + dy4 + dy5;

  00922	41 0f 28 da	 movaps	 xmm3, xmm10
  00926	44 0f 28 c7	 movaps	 xmm8, xmm7
  0092a	f3 41 0f 58 db	 addss	 xmm3, xmm11
  0092f	f3 0f 58 d4	 addss	 xmm2, xmm4
  00933	f3 41 0f 58 df	 addss	 xmm3, xmm15
  00938	f3 41 0f 58 d6	 addss	 xmm2, xmm14
  0093d	f3 41 0f 58 dc	 addss	 xmm3, xmm12
  00942	f3 0f 58 55 d0	 addss	 xmm2, DWORD PTR s$[rbp-224]
  00947	f3 0f 58 5d d4	 addss	 xmm3, DWORD PTR s$[rbp-220]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

  0094c	0f 28 ca	 movaps	 xmm1, xmm2
  0094f	0f 54 0d 00 00
	00 00		 andps	 xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
  00956	0f 28 c3	 movaps	 xmm0, xmm3
  00959	0f 54 05 00 00
	00 00		 andps	 xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2225 :                 if (STBTT_fabs(dx) > STBTT_fabs(dy))

  00960	0f 2f c8	 comiss	 xmm1, xmm0
  00963	76 08		 jbe	 SHORT $LN91@stbtt__run

; 2226 :                     dy6 = -dy;

  00965	0f 28 fb	 movaps	 xmm7, xmm3
  00968	0f 57 fd	 xorps	 xmm7, xmm5
  0096b	eb 08		 jmp	 SHORT $LN92@stbtt__run
$LN91@stbtt__run:

; 2227 :                 else
; 2228 :                     dx6 = -dx;

  0096d	44 0f 28 c2	 movaps	 xmm8, xmm2
  00971	44 0f 57 c5	 xorps	 xmm8, xmm5
$LN92@stbtt__run:

; 2229 :                 stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

  00975	f3 44 0f 11 7c
	24 30		 movss	 DWORD PTR [rsp+48], xmm15
  0097c	41 0f 28 dd	 movaps	 xmm3, xmm13
  00980	f3 0f 11 64 24
	28		 movss	 DWORD PTR [rsp+40], xmm4
  00986	41 0f 28 d3	 movaps	 xmm2, xmm11
  0098a	41 0f 28 c9	 movaps	 xmm1, xmm9
  0098e	f3 44 0f 11 54
	24 20		 movss	 DWORD PTR [rsp+32], xmm10
  00995	49 8b ce	 mov	 rcx, r14
  00998	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2230 :                 stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

  0099d	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR s$[rbp-220]
  009a2	41 0f 28 d4	 movaps	 xmm2, xmm12
  009a6	f3 0f 10 5d d0	 movss	 xmm3, DWORD PTR s$[rbp-224]
  009ab	41 0f 28 ce	 movaps	 xmm1, xmm14
  009af	f3 0f 11 7c 24
	30		 movss	 DWORD PTR [rsp+48], xmm7
  009b5	49 8b ce	 mov	 rcx, r14
  009b8	f3 44 0f 11 44
	24 28		 movss	 DWORD PTR [rsp+40], xmm8
  009bf	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  009c5	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2231 :                 break;

  009ca	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  009ce	45 33 c9	 xor	 r9d, r9d
  009d1	f3 0f 10 7d c0	 movss	 xmm7, DWORD PTR s$[rbp-240]

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  009d6	85 c9		 test	 ecx, ecx
  009d8	41 8b c1	 mov	 eax, r9d
  009db	0f 44 c7	 cmove	 eax, edi
  009de	8b f8		 mov	 edi, eax
  009e0	e9 1d f7 ff ff	 jmp	 $LN278@stbtt__run
$LN87@stbtt__run:

; 2194 : 
; 2195 :             case 0x24: // hflex1
; 2196 :                 if (sp < 9) return STBTT__CSERR("hflex1 stack");

  009e5	83 ff 09	 cmp	 edi, 9
  009e8	0f 8c 1f f9 ff
	ff		 jl	 $LN3@stbtt__run

; 2197 :                 dx1 = s[0];
; 2198 :                 dy1 = s[1];
; 2199 :                 dx2 = s[2];
; 2200 :                 dy2 = s[3];
; 2201 :                 dx3 = s[4];
; 2202 :                 dx4 = s[5];
; 2203 :                 dx5 = s[6];
; 2204 :                 dy5 = s[7];
; 2205 :                 dx6 = s[8];
; 2206 :                 stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);

  009ee	f3 0f 11 74 24
	30		 movss	 DWORD PTR [rsp+48], xmm6
  009f4	41 0f 28 dd	 movaps	 xmm3, xmm13
  009f8	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  009fe	41 0f 28 d3	 movaps	 xmm2, xmm11
  00a02	41 0f 28 c9	 movaps	 xmm1, xmm9
  00a06	f3 44 0f 11 54
	24 20		 movss	 DWORD PTR [rsp+32], xmm10
  00a0d	49 8b ce	 mov	 rcx, r14
  00a10	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2207 :                 stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1 + dy2 + dy5));

  00a15	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR s$[rbp-224]
  00a1a	41 0f 28 da	 movaps	 xmm3, xmm10
  00a1e	f3 41 0f 58 db	 addss	 xmm3, xmm11
  00a23	0f 28 d6	 movaps	 xmm2, xmm6
  00a26	41 0f 28 cf	 movaps	 xmm1, xmm15
  00a2a	49 8b ce	 mov	 rcx, r14
  00a2d	f3 41 0f 58 dc	 addss	 xmm3, xmm12
  00a32	0f 57 1d 00 00
	00 00		 xorps	 xmm3, DWORD PTR __xmm@80000000800000008000000080000000
  00a39	f3 0f 11 5c 24
	30		 movss	 DWORD PTR [rsp+48], xmm3
  00a3f	41 0f 28 de	 movaps	 xmm3, xmm14
  00a43	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00a49	f3 44 0f 11 64
	24 20		 movss	 DWORD PTR [rsp+32], xmm12
  00a50	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2208 :                 break;

  00a55	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  00a59	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00a5c	85 c9		 test	 ecx, ecx
  00a5e	41 8b c1	 mov	 eax, r9d
  00a61	0f 44 c7	 cmove	 eax, edi
  00a64	8b f8		 mov	 edi, eax
  00a66	e9 97 f6 ff ff	 jmp	 $LN278@stbtt__run
$LN85@stbtt__run:

; 2165 :                 dx1 = s[0];
; 2166 :                 dx2 = s[1];
; 2167 :                 dy2 = s[2];
; 2168 :                 dx3 = s[3];
; 2169 :                 dx4 = s[4];
; 2170 :                 dx5 = s[5];
; 2171 :                 dx6 = s[6];
; 2172 :                 stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
; 2173 :                 stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
; 2174 :                 break;
; 2175 : 
; 2176 :             case 0x23: // flex
; 2177 :                 if (sp < 13) return STBTT__CSERR("flex stack");

  00a6b	83 ff 0d	 cmp	 edi, 13
  00a6e	0f 8c 99 f8 ff
	ff		 jl	 $LN3@stbtt__run

; 2178 :                 dx1 = s[0];
; 2179 :                 dy1 = s[1];
; 2180 :                 dx2 = s[2];
; 2181 :                 dy2 = s[3];
; 2182 :                 dx3 = s[4];
; 2183 :                 dy3 = s[5];
; 2184 :                 dx4 = s[6];
; 2185 :                 dy4 = s[7];
; 2186 :                 dx5 = s[8];
; 2187 :                 dy5 = s[9];
; 2188 :                 dx6 = s[10];
; 2189 :                 dy6 = s[11];
; 2190 :                 //fd is s[12]
; 2191 :                 stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

  00a74	f3 44 0f 11 7c
	24 30		 movss	 DWORD PTR [rsp+48], xmm15
  00a7b	41 0f 28 dd	 movaps	 xmm3, xmm13
  00a7f	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  00a85	41 0f 28 d3	 movaps	 xmm2, xmm11
  00a89	41 0f 28 c9	 movaps	 xmm1, xmm9
  00a8d	f3 44 0f 11 54
	24 20		 movss	 DWORD PTR [rsp+32], xmm10
  00a94	49 8b ce	 mov	 rcx, r14
  00a97	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2192 :                 stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

  00a9c	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR s$[rbp-216]
  00aa1	41 0f 28 d4	 movaps	 xmm2, xmm12
  00aa5	f3 0f 10 5d dc	 movss	 xmm3, DWORD PTR s$[rbp-212]
  00aaa	41 0f 28 ce	 movaps	 xmm1, xmm14
  00aae	f3 0f 11 5c 24
	30		 movss	 DWORD PTR [rsp+48], xmm3
  00ab4	49 8b ce	 mov	 rcx, r14
  00ab7	f3 0f 10 5d d0	 movss	 xmm3, DWORD PTR s$[rbp-224]
  00abc	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00ac2	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR s$[rbp-220]
  00ac7	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00acd	e8 00 00 00 00	 call	 ?stbtt__csctx_rccurve_to@@YAXPEAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2193 :                 break;

  00ad2	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  00ad6	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00ad9	85 c9		 test	 ecx, ecx
  00adb	41 8b c1	 mov	 eax, r9d
  00ade	0f 44 c7	 cmove	 eax, edi
  00ae1	8b f8		 mov	 edi, eax
  00ae3	e9 1a f6 ff ff	 jmp	 $LN278@stbtt__run
$LN83@stbtt__run:

; 2161 :                 // @TODO These "flex" implementations ignore the flex-depth and resolution,
; 2162 :                 // and always draw beziers.
; 2163 :             case 0x22: // hflex
; 2164 :                 if (sp < 7) return STBTT__CSERR("hflex stack");

  00ae8	83 ff 07	 cmp	 edi, 7
  00aeb	0f 8c 1c f8 ff
	ff		 jl	 $LN3@stbtt__run

; 1951 :     float cy1 = ctx->y + dy1;

  00af1	f3 41 0f 10 66
	14		 movss	 xmm4, DWORD PTR [r14+20]

; 1953 :     float cy2 = cy1 + dy2;

  00af7	41 0f 28 cd	 movaps	 xmm1, xmm13
  00afb	f3 0f 58 e6	 addss	 xmm4, xmm6
  00aff	41 0f 28 e9	 movaps	 xmm5, xmm9
  00b03	f3 41 0f 58 6e
	10		 addss	 xmm5, DWORD PTR [r14+16]
  00b09	41 0f 28 db	 movaps	 xmm3, xmm11

; 1954 :     ctx->x = cx2 + dx3;

  00b0d	41 0f 28 d2	 movaps	 xmm2, xmm10

; 1955 :     ctx->y = cy2 + dy3;
; 1956 :     stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);

  00b11	f3 0f 2c d4	 cvttss2si edx, xmm4
  00b15	f3 0f 58 cc	 addss	 xmm1, xmm4
  00b19	f3 0f 58 dd	 addss	 xmm3, xmm5
  00b1d	f3 44 0f 2c d5	 cvttss2si r10d, xmm5
  00b22	0f 28 c1	 movaps	 xmm0, xmm1
  00b25	f3 0f 58 d3	 addss	 xmm2, xmm3
  00b29	f3 0f 58 c6	 addss	 xmm0, xmm6
  00b2d	f3 0f 2c c1	 cvttss2si eax, xmm1
  00b31	f3 0f 2c cb	 cvttss2si ecx, xmm3
  00b35	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00b39	f3 44 0f 2c c8	 cvttss2si r9d, xmm0
  00b3e	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00b42	49 8b ce	 mov	 rcx, r14
  00b45	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00b49	b2 04		 mov	 dl, 4
  00b4b	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  00b50	f3 44 0f 2c c2	 cvttss2si r8d, xmm2
  00b55	f3 41 0f 11 56
	10		 movss	 DWORD PTR [r14+16], xmm2
  00b5b	f3 41 0f 11 46
	14		 movss	 DWORD PTR [r14+20], xmm0
  00b61	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v

; 1951 :     float cy1 = ctx->y + dy1;

  00b66	f3 41 0f 10 66
	14		 movss	 xmm4, DWORD PTR [r14+20]
  00b6c	0f 28 ef	 movaps	 xmm5, xmm7
  00b6f	f3 41 0f 58 6e
	10		 addss	 xmm5, DWORD PTR [r14+16]
  00b75	f3 0f 58 e6	 addss	 xmm4, xmm6

; 1952 :     float cx2 = cx1 + dx2;

  00b79	41 0f 28 df	 movaps	 xmm3, xmm15

; 1954 :     ctx->x = cx2 + dx3;

  00b7d	41 0f 28 d6	 movaps	 xmm2, xmm14
  00b81	f3 0f 58 dd	 addss	 xmm3, xmm5
  00b85	0f 28 cc	 movaps	 xmm1, xmm4

; 1955 :     ctx->y = cy2 + dy3;
; 1956 :     stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);

  00b88	f3 0f 2c d4	 cvttss2si edx, xmm4
  00b8c	f3 41 0f 5c cd	 subss	 xmm1, xmm13
  00b91	f3 0f 58 d3	 addss	 xmm2, xmm3
  00b95	f3 0f 2c cb	 cvttss2si ecx, xmm3
  00b99	0f 28 c1	 movaps	 xmm0, xmm1
  00b9c	f3 41 0f 11 56
	10		 movss	 DWORD PTR [r14+16], xmm2
  00ba2	f3 0f 58 c6	 addss	 xmm0, xmm6
  00ba6	f3 0f 2c c1	 cvttss2si eax, xmm1
  00baa	f3 44 0f 2c d5	 cvttss2si r10d, xmm5
  00baf	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00bb3	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00bb7	49 8b ce	 mov	 rcx, r14
  00bba	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00bbe	b2 04		 mov	 dl, 4
  00bc0	f3 44 0f 2c c8	 cvttss2si r9d, xmm0
  00bc5	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  00bca	f3 44 0f 2c c2	 cvttss2si r8d, xmm2
  00bcf	f3 41 0f 11 46
	14		 movss	 DWORD PTR [r14+20], xmm0
  00bd5	e8 00 00 00 00	 call	 ?stbtt__csctx_v@@YAXPEAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v

; 2232 : 
; 2233 :             default:
; 2234 :                 return STBTT__CSERR("unimplemented");
; 2235 :             }
; 2236 :         } break;

  00bda	8b 4c 24 40	 mov	 ecx, DWORD PTR clear_stack$1$[rsp]
  00bde	45 33 c9	 xor	 r9d, r9d

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00be1	85 c9		 test	 ecx, ecx
  00be3	41 8b c1	 mov	 eax, r9d
  00be6	0f 44 c7	 cmove	 eax, edi
  00be9	8b f8		 mov	 edi, eax
  00beb	e9 12 f5 ff ff	 jmp	 $LN278@stbtt__run
$LN94@stbtt__run:

; 2237 : 
; 2238 :         default:
; 2239 :             if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254)) //-V560

  00bf0	41 81 fc ff 00
	00 00		 cmp	 r12d, 255		; 000000ffH
  00bf7	74 75		 je	 SHORT $LN264@stbtt__run
  00bf9	41 83 fc 1c	 cmp	 r12d, 28
  00bfd	74 10		 je	 SHORT $LN97@stbtt__run
  00bff	41 8d 44 24 e0	 lea	 eax, DWORD PTR [r12-32]
  00c04	3d de 00 00 00	 cmp	 eax, 222		; 000000deH
  00c09	0f 87 fe f6 ff
	ff		 ja	 $LN3@stbtt__run
$LN97@stbtt__run:

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00c0f	8b 5c 24 5c	 mov	 ebx, DWORD PTR b$[rsp+12]

; 1138 :     stbtt__buf_seek(b, b->cursor + o);

  00c13	41 ff cf	 dec	 r15d

; 1132 :     STBTT_assert(!(o > b->size || o < 0));

  00c16	44 3b fb	 cmp	 r15d, ebx
  00c19	7f 05		 jg	 SHORT $LN190@stbtt__run
  00c1b	45 85 ff	 test	 r15d, r15d
  00c1e	79 1a		 jns	 SHORT $LN186@stbtt__run
$LN190@stbtt__run:
  00c20	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00c26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00c2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@CPAEOPEI@?$AA?$CB?$AA?$CI?$AAo?$AA?5?$AA?$DO?$AA?5?$AAb?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$HM@
  00c34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN186@stbtt__run:

; 1133 :     b->cursor = (o > b->size || o < 0) ? b->size : o;

  00c3a	44 3b fb	 cmp	 r15d, ebx
  00c3d	7f 0a		 jg	 SHORT $LN192@stbtt__run
  00c3f	44 89 7c 24 58	 mov	 DWORD PTR b$[rsp+8], r15d
  00c44	45 85 ff	 test	 r15d, r15d
  00c47	79 04		 jns	 SHORT $LN193@stbtt__run
$LN192@stbtt__run:
  00c49	89 5c 24 58	 mov	 DWORD PTR b$[rsp+8], ebx
$LN193@stbtt__run:

; 2245 :             }
; 2246 :             else {
; 2247 :                 stbtt__buf_skip(&b, -1);
; 2248 :                 f = (float)(stbtt_int16)stbtt__cff_int(&b);

  00c4d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR b$[rsp]
  00c52	e8 00 00 00 00	 call	 ?stbtt__cff_int@@YAIPEAUstbtt__buf@@@Z ; stbtt__cff_int
  00c57	44 8b 7c 24 58	 mov	 r15d, DWORD PTR b$[rsp+8]
  00c5c	45 33 c9	 xor	 r9d, r9d
  00c5f	0f bf c8	 movsx	 ecx, ax
  00c62	66 0f 6e c1	 movd	 xmm0, ecx
  00c66	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00c69	e9 90 00 00 00	 jmp	 $LN98@stbtt__run
$LN264@stbtt__run:

; 1118 :     if (b->cursor >= b->size)

  00c6e	8b 5c 24 5c	 mov	 ebx, DWORD PTR b$[rsp+12]
  00c72	44 3b c3	 cmp	 r8d, ebx
  00c75	7c 04		 jl	 SHORT $LN181@stbtt__run

; 1119 :         return 0;

  00c77	32 c0		 xor	 al, al
  00c79	eb 11		 jmp	 SHORT $LN180@stbtt__run
$LN181@stbtt__run:

; 1120 :     return b->data[b->cursor++];

  00c7b	41 0f b6 04 10	 movzx	 eax, BYTE PTR [r8+rdx]
  00c80	45 8d 78 01	 lea	 r15d, DWORD PTR [r8+1]
  00c84	44 89 7c 24 58	 mov	 DWORD PTR b$[rsp+8], r15d
  00c89	45 8b c7	 mov	 r8d, r15d
$LN180@stbtt__run:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00c8c	0f b6 c8	 movzx	 ecx, al
  00c8f	44 3b c3	 cmp	 r8d, ebx

; 1118 :     if (b->cursor >= b->size)

  00c92	7c 04		 jl	 SHORT $LN240@stbtt__run

; 1119 :         return 0;

  00c94	32 c0		 xor	 al, al
  00c96	eb 0f		 jmp	 SHORT $LN241@stbtt__run
$LN240@stbtt__run:

; 1120 :     return b->data[b->cursor++];

  00c98	49 63 c7	 movsxd	 rax, r15d
  00c9b	41 ff c7	 inc	 r15d
  00c9e	44 89 7c 24 58	 mov	 DWORD PTR b$[rsp+8], r15d
  00ca3	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
$LN241@stbtt__run:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00ca7	c1 e1 08	 shl	 ecx, 8
  00caa	0f b6 c0	 movzx	 eax, al
  00cad	0b c8		 or	 ecx, eax

; 1118 :     if (b->cursor >= b->size)

  00caf	44 3b fb	 cmp	 r15d, ebx
  00cb2	7c 04		 jl	 SHORT $LN243@stbtt__run

; 1119 :         return 0;

  00cb4	32 c0		 xor	 al, al
  00cb6	eb 0f		 jmp	 SHORT $LN244@stbtt__run
$LN243@stbtt__run:

; 1120 :     return b->data[b->cursor++];

  00cb8	49 63 c7	 movsxd	 rax, r15d
  00cbb	41 ff c7	 inc	 r15d
  00cbe	44 89 7c 24 58	 mov	 DWORD PTR b$[rsp+8], r15d
  00cc3	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
$LN244@stbtt__run:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00cc7	c1 e1 08	 shl	 ecx, 8
  00cca	0f b6 c0	 movzx	 eax, al
  00ccd	0b c8		 or	 ecx, eax

; 1118 :     if (b->cursor >= b->size)

  00ccf	44 3b fb	 cmp	 r15d, ebx
  00cd2	7c 04		 jl	 SHORT $LN246@stbtt__run

; 1119 :         return 0;

  00cd4	32 c0		 xor	 al, al
  00cd6	eb 0f		 jmp	 SHORT $LN247@stbtt__run
$LN246@stbtt__run:

; 1120 :     return b->data[b->cursor++];

  00cd8	49 63 c7	 movsxd	 rax, r15d
  00cdb	41 ff c7	 inc	 r15d
  00cde	44 89 7c 24 58	 mov	 DWORD PTR b$[rsp+8], r15d
  00ce3	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
$LN247@stbtt__run:

; 1147 :         v = (v << 8) | stbtt__buf_get8(b);

  00ce7	c1 e1 08	 shl	 ecx, 8
  00cea	0f b6 c0	 movzx	 eax, al
  00ced	0b c8		 or	 ecx, eax
  00cef	66 0f 6e c1	 movd	 xmm0, ecx

; 2240 :                 return STBTT__CSERR("reserved operator");
; 2241 : 
; 2242 :             // push immediate
; 2243 :             if (b0 == 255) {
; 2244 :                 f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;

  00cf3	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00cf6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@37800000
$LN98@stbtt__run:

; 2249 :             }
; 2250 :             if (sp >= 48) return STBTT__CSERR("push stack overflow");

  00cfe	83 ff 30	 cmp	 edi, 48			; 00000030H
  00d01	0f 8d 06 f6 ff
	ff		 jge	 $LN3@stbtt__run

; 2251 :             s[sp++] = f;

  00d07	48 63 c7	 movsxd	 rax, edi

; 2252 :             clear_stack = 0;
; 2253 :             break;
; 2254 :         }
; 2255 :         if (clear_stack) sp = 0;
; 2256 :     }

  00d0a	41 8b c9	 mov	 ecx, r9d
  00d0d	ff c7		 inc	 edi
  00d0f	85 c9		 test	 ecx, ecx
  00d11	f3 0f 11 44 85
	b0		 movss	 DWORD PTR s$[rbp+rax*4-256], xmm0
  00d17	41 8b c1	 mov	 eax, r9d
  00d1a	f3 44 0f 10 65
	cc		 movss	 xmm12, DWORD PTR s$[rbp-228]
  00d20	0f 44 c7	 cmove	 eax, edi
  00d23	f3 44 0f 10 75
	c8		 movss	 xmm14, DWORD PTR s$[rbp-232]
  00d29	8b f8		 mov	 edi, eax
  00d2b	f3 44 0f 10 7d
	c4		 movss	 xmm15, DWORD PTR s$[rbp-236]
  00d31	f3 44 0f 10 55
	bc		 movss	 xmm10, DWORD PTR s$[rbp-244]
  00d37	f3 44 0f 10 6d
	b8		 movss	 xmm13, DWORD PTR s$[rbp-248]
  00d3d	f3 44 0f 10 5d
	b4		 movss	 xmm11, DWORD PTR s$[rbp-252]
  00d43	f3 44 0f 10 4d
	b0		 movss	 xmm9, DWORD PTR s$[rbp-256]
  00d49	f3 0f 10 7d c0	 movss	 xmm7, DWORD PTR s$[rbp-240]
  00d4e	e9 af f3 ff ff	 jmp	 $LN278@stbtt__run
$LN81@stbtt__run:

; 2149 :             clear_stack = 0;
; 2150 :             break;
; 2151 : 
; 2152 :         case 0x0E: // endchar
; 2153 :             stbtt__csctx_close_shape(c);

  00d53	49 8b ce	 mov	 rcx, r14
  00d56	e8 00 00 00 00	 call	 ?stbtt__csctx_close_shape@@YAXPEAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape

; 2154 :             return 1;

  00d5b	b8 01 00 00 00	 mov	 eax, 1
  00d60	e9 aa f5 ff ff	 jmp	 $LN1@stbtt__run
  00d65	0f 1f 00	 npad	 3
$LN267@stbtt__run:

; 2258 : 
; 2259 : #undef STBTT__CSERR
; 2260 : }

  00d68	00 00 00 00	 DD	 $LN32@stbtt__run
  00d6c	00 00 00 00	 DD	 $LN94@stbtt__run
  00d70	00 00 00 00	 DD	 $LN32@stbtt__run
  00d74	00 00 00 00	 DD	 $LN38@stbtt__run
  00d78	00 00 00 00	 DD	 $LN42@stbtt__run
  00d7c	00 00 00 00	 DD	 $LN47@stbtt__run
  00d80	00 00 00 00	 DD	 $LN44@stbtt__run
  00d84	00 00 00 00	 DD	 $LN58@stbtt__run
  00d88	00 00 00 00	 DD	 $LN94@stbtt__run
  00d8c	00 00 00 00	 DD	 $LN72@stbtt__run
  00d90	00 00 00 00	 DD	 $LN79@stbtt__run
  00d94	00 00 00 00	 DD	 $LN82@stbtt__run
  00d98	00 00 00 00	 DD	 $LN94@stbtt__run
  00d9c	00 00 00 00	 DD	 $LN81@stbtt__run
  00da0	00 00 00 00	 DD	 $LN94@stbtt__run
  00da4	00 00 00 00	 DD	 $LN94@stbtt__run
  00da8	00 00 00 00	 DD	 $LN94@stbtt__run
  00dac	00 00 00 00	 DD	 $LN32@stbtt__run
  00db0	00 00 00 00	 DD	 $LN29@stbtt__run
  00db4	00 00 00 00	 DD	 $LN29@stbtt__run
  00db8	00 00 00 00	 DD	 $LN36@stbtt__run
  00dbc	00 00 00 00	 DD	 $LN40@stbtt__run
  00dc0	00 00 00 00	 DD	 $LN32@stbtt__run
  00dc4	00 00 00 00	 DD	 $LN60@stbtt__run
  00dc8	00 00 00 00	 DD	 $LN63@stbtt__run
  00dcc	00 00 00 00	 DD	 $LN66@stbtt__run
  00dd0	00 00 00 00	 DD	 $LN66@stbtt__run
  00dd4	00 00 00 00	 DD	 $LN94@stbtt__run
  00dd8	00 00 00 00	 DD	 $LN271@stbtt__run
  00ddc	00 00 00 00	 DD	 $LN54@stbtt__run
  00de0	00 00 00 00	 DD	 $LN51@stbtt__run
?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ENDP ; stbtt__run_charstring
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
count_ctx$ = 32
output_ctx$ = 88
info$ = 160
glyph_index$ = 168
pvertices$ = 176
?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeT2

; 2263 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 2264 :     // runs the charstring twice, once to count and once to output (to avoid realloc)
; 2265 :     stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);

  00017	33 ed		 xor	 ebp, ebp
  00019	48 c7 40 88 01
	00 00 00	 mov	 QWORD PTR [rax-120], 1
  00021	0f 57 c0	 xorps	 xmm0, xmm0
  00024	48 89 68 b0	 mov	 QWORD PTR [rax-80], rbp
  00028	0f 57 c9	 xorps	 xmm1, xmm1
  0002b	89 68 b8	 mov	 DWORD PTR [rax-72], ebp
  0002e	49 8b d8	 mov	 rbx, r8

; 2266 :     stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);

  00031	48 89 68 c0	 mov	 QWORD PTR [rax-64], rbp

; 2267 :     if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {

  00035	4c 8d 40 88	 lea	 r8, QWORD PTR [rax-120]
  00039	89 68 f0	 mov	 DWORD PTR [rax-16], ebp
  0003c	0f 11 40 90	 movups	 XMMWORD PTR [rax-112], xmm0
  00040	8b fa		 mov	 edi, edx
  00042	48 8b f1	 mov	 rsi, rcx
  00045	f3 0f 7f 48 a0	 movdqu	 XMMWORD PTR [rax-96], xmm1
  0004a	0f 11 40 c8	 movups	 XMMWORD PTR [rax-56], xmm0
  0004e	f3 0f 7f 48 d8	 movdqu	 XMMWORD PTR [rax-40], xmm1
  00053	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
  00058	85 c0		 test	 eax, eax
  0005a	74 6f		 je	 SHORT $LN6@stbtt__Get

; 2268 :         *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices * sizeof(stbtt_vertex), info->userdata);

  0005c	48 63 44 24 50	 movsxd	 rax, DWORD PTR count_ctx$[rsp+48]
  00061	48 6b c8 0e	 imul	 rcx, rax, 14
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0006c	48 85 c0	 test	 rax, rax
  0006f	74 06		 je	 SHORT $LN10@stbtt__Get

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00071	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN10@stbtt__Get:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2270 :         if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {

  0007d	4c 8d 44 24 58	 lea	 r8, QWORD PTR output_ctx$[rsp]
  00082	8b d7		 mov	 edx, edi
  00084	48 8b ce	 mov	 rcx, rsi
  00087	48 89 03	 mov	 QWORD PTR [rbx], rax
  0008a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR output_ctx$[rsp+40], rax
  00092	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
  00097	85 c0		 test	 eax, eax
  00099	74 30		 je	 SHORT $LN6@stbtt__Get

; 2271 :             STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);

  0009b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR output_ctx$[rsp+48]
  000a2	3b 44 24 50	 cmp	 eax, DWORD PTR count_ctx$[rsp+48]
  000a6	74 28		 je	 SHORT $LN1@stbtt__Get
  000a8	41 b8 df 08 00
	00		 mov	 r8d, 2271		; 000008dfH
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GE@KABFAMEA@?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAc?$AAt?$AAx?$AA?4?$AAn?$AAu?$AAm?$AA_@
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c2	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR output_ctx$[rsp+48]

; 2272 :             return output_ctx.num_vertices;

  000c9	eb 05		 jmp	 SHORT $LN1@stbtt__Get
$LN6@stbtt__Get:

; 2273 :         }
; 2274 :     }
; 2275 :     *pvertices = NULL;

  000cb	48 89 2b	 mov	 QWORD PTR [rbx], rbp

; 2276 :     return 0;

  000ce	33 c0		 xor	 eax, eax
$LN1@stbtt__Get:

; 2277 : }

  000d0	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  000d8	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000dc	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  000e0	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000e4	49 8b e3	 mov	 rsp, r11
  000e7	5f		 pop	 rdi
  000e8	c3		 ret	 0
?stbtt__GetGlyphShapeT2@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeT2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
c$ = 32
info$ = 112
glyph_index$ = 120
x0$ = 128
y0$ = 136
x1$ = 144
y1$ = 152
?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z PROC ; stbtt__GetGlyphInfoT2

; 2280 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00010	49 8b f0	 mov	 rsi, r8

; 2281 :     stbtt__csctx c = STBTT__CSCTX_INIT(1);

  00013	48 c7 40 b8 01
	00 00 00	 mov	 QWORD PTR [rax-72], 1
  0001b	33 db		 xor	 ebx, ebx

; 2282 :     int r = stbtt__run_charstring(info, glyph_index, &c);

  0001d	4c 8d 40 b8	 lea	 r8, QWORD PTR [rax-72]
  00021	0f 57 c0	 xorps	 xmm0, xmm0
  00024	48 89 58 e0	 mov	 QWORD PTR [rax-32], rbx
  00028	0f 57 c9	 xorps	 xmm1, xmm1
  0002b	89 58 e8	 mov	 DWORD PTR [rax-24], ebx
  0002e	0f 11 40 c0	 movups	 XMMWORD PTR [rax-64], xmm0
  00032	49 8b f9	 mov	 rdi, r9
  00035	f3 0f 7f 48 d0	 movdqu	 XMMWORD PTR [rax-48], xmm1
  0003a	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
  0003f	8b d0		 mov	 edx, eax

; 2283 :     if (x0)  *x0 = r ? c.min_x : 0;

  00041	48 85 f6	 test	 rsi, rsi
  00044	74 0b		 je	 SHORT $LN2@stbtt__Get
  00046	85 d2		 test	 edx, edx
  00048	8b c3		 mov	 eax, ebx
  0004a	0f 45 44 24 38	 cmovne	 eax, DWORD PTR c$[rsp+24]
  0004f	89 06		 mov	 DWORD PTR [rsi], eax
$LN2@stbtt__Get:

; 2284 :     if (y0)  *y0 = r ? c.min_y : 0;

  00051	48 85 ff	 test	 rdi, rdi
  00054	74 0b		 je	 SHORT $LN3@stbtt__Get
  00056	85 d2		 test	 edx, edx
  00058	8b c3		 mov	 eax, ebx
  0005a	0f 45 44 24 40	 cmovne	 eax, DWORD PTR c$[rsp+32]
  0005f	89 07		 mov	 DWORD PTR [rdi], eax
$LN3@stbtt__Get:

; 2285 :     if (x1)  *x1 = r ? c.max_x : 0;

  00061	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR x1$[rsp]
  00069	48 85 c9	 test	 rcx, rcx
  0006c	74 0b		 je	 SHORT $LN4@stbtt__Get
  0006e	85 d2		 test	 edx, edx
  00070	8b c3		 mov	 eax, ebx
  00072	0f 45 44 24 3c	 cmovne	 eax, DWORD PTR c$[rsp+28]
  00077	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbtt__Get:

; 2286 :     if (y1)  *y1 = r ? c.max_y : 0;

  00079	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR y1$[rsp]
  00081	48 85 c0	 test	 rax, rax
  00084	74 0b		 je	 SHORT $LN5@stbtt__Get
  00086	85 d2		 test	 edx, edx
  00088	8b cb		 mov	 ecx, ebx
  0008a	0f 45 4c 24 44	 cmovne	 ecx, DWORD PTR c$[rsp+36]
  0008f	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbtt__Get:

; 2287 :     return r ? c.num_vertices : 0;
; 2288 : }

  00091	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00096	85 d2		 test	 edx, edx
  00098	0f 45 5c 24 50	 cmovne	 ebx, DWORD PTR c$[rsp+48]
  0009d	8b c3		 mov	 eax, ebx
  0009f	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000a4	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
?stbtt__GetGlyphInfoT2@@YAHPEBUstbtt_fontinfo@@HPEAH111@Z ENDP ; stbtt__GetGlyphInfoT2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
count_ctx$1 = 32
output_ctx$2 = 88
info$ = 160
glyph_index$ = 168
pvertices$ = 176
stbtt_GetGlyphShape PROC

; 2291 : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 2292 :     if (!info->cff.size)

  00012	83 79 4c 00	 cmp	 DWORD PTR [rcx+76], 0
  00016	49 8b f0	 mov	 rsi, r8
  00019	8b ea		 mov	 ebp, edx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	75 0a		 jne	 SHORT $LN2@stbtt_GetG

; 2293 :         return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);

  00020	e8 00 00 00 00	 call	 ?stbtt__GetGlyphShapeTT@@YAHPEBUstbtt_fontinfo@@HPEAPEAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeTT
  00025	e9 ce 00 00 00	 jmp	 $LN3@stbtt_GetG
$LN2@stbtt_GetG:
  0002a	0f 57 c0	 xorps	 xmm0, xmm0
  0002d	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx

; 2265 :     stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);

  00035	33 db		 xor	 ebx, ebx
  00037	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR count_ctx$1[rsp], 1
  00040	0f 57 c9	 xorps	 xmm1, xmm1
  00043	48 89 5c 24 48	 mov	 QWORD PTR count_ctx$1[rsp+40], rbx

; 2266 :     stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
; 2267 :     if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {

  00048	4c 8d 44 24 20	 lea	 r8, QWORD PTR count_ctx$1[rsp]
  0004d	89 5c 24 50	 mov	 DWORD PTR count_ctx$1[rsp+48], ebx
  00051	48 89 5c 24 58	 mov	 QWORD PTR output_ctx$2[rsp], rbx
  00056	89 9c 24 88 00
	00 00		 mov	 DWORD PTR output_ctx$2[rsp+48], ebx
  0005d	0f 11 44 24 28	 movups	 XMMWORD PTR count_ctx$1[rsp+8], xmm0
  00062	f3 0f 7f 4c 24
	38		 movdqu	 XMMWORD PTR count_ctx$1[rsp+24], xmm1
  00068	0f 11 44 24 60	 movups	 XMMWORD PTR output_ctx$2[rsp+8], xmm0
  0006d	f3 0f 7f 4c 24
	70		 movdqu	 XMMWORD PTR output_ctx$2[rsp+24], xmm1
  00073	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
  00078	85 c0		 test	 eax, eax
  0007a	74 6f		 je	 SHORT $LN10@stbtt_GetG

; 2268 :         *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices * sizeof(stbtt_vertex), info->userdata);

  0007c	48 63 44 24 50	 movsxd	 rax, DWORD PTR count_ctx$1[rsp+48]
  00081	48 6b c8 0e	 imul	 rcx, rax, 14
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00085	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0008c	48 85 c0	 test	 rax, rax
  0008f	74 06		 je	 SHORT $LN14@stbtt_GetG

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00091	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN14@stbtt_GetG:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2270 :         if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {

  0009d	4c 8d 44 24 58	 lea	 r8, QWORD PTR output_ctx$2[rsp]
  000a2	8b d5		 mov	 edx, ebp
  000a4	48 8b cf	 mov	 rcx, rdi
  000a7	48 89 06	 mov	 QWORD PTR [rsi], rax
  000aa	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR output_ctx$2[rsp+40], rax
  000b2	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring
  000b7	85 c0		 test	 eax, eax
  000b9	74 30		 je	 SHORT $LN10@stbtt_GetG

; 2271 :             STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);

  000bb	8b 9c 24 88 00
	00 00		 mov	 ebx, DWORD PTR output_ctx$2[rsp+48]
  000c2	3b 5c 24 50	 cmp	 ebx, DWORD PTR count_ctx$1[rsp+48]
  000c6	74 26		 je	 SHORT $LN5@stbtt_GetG
  000c8	41 b8 df 08 00
	00		 mov	 r8d, 2271		; 000008dfH
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GE@KABFAMEA@?$AAo?$AAu?$AAt?$AAp?$AAu?$AAt?$AA_?$AAc?$AAt?$AAx?$AA?4?$AAn?$AAu?$AAm?$AA_@
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e2	8b 9c 24 88 00
	00 00		 mov	 ebx, DWORD PTR output_ctx$2[rsp+48]

; 2272 :             return output_ctx.num_vertices;

  000e9	eb 03		 jmp	 SHORT $LN5@stbtt_GetG
$LN10@stbtt_GetG:

; 2273 :         }
; 2274 :     }
; 2275 :     *pvertices = NULL;

  000eb	48 89 1e	 mov	 QWORD PTR [rsi], rbx
$LN5@stbtt_GetG:

; 2294 :     else
; 2295 :         return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);

  000ee	8b c3		 mov	 eax, ebx
  000f0	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
$LN3@stbtt_GetG:

; 2296 : }

  000f8	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  00100	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  00104	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00108	49 8b e3	 mov	 rsp, r11
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
stbtt_GetGlyphShape ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 24
glyph_index$ = 32
advanceWidth$ = 40
leftSideBearing$ = 48
stbtt_GetGlyphHMetrics PROC

; 2299 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15

; 2300 :     stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data + info->hhea + 34);

  00018	4c 8b 71 08	 mov	 r14, QWORD PTR [rcx+8]
  0001c	4d 8b d9	 mov	 r11, r9
  0001f	48 63 41 24	 movsxd	 rax, DWORD PTR [rcx+36]
  00023	4d 8b d0	 mov	 r10, r8
  00026	8b f2		 mov	 esi, edx
  00028	48 8b f9	 mov	 rdi, rcx

; 2301 :     if (glyph_index < numOfLongHorMetrics) {

  0002b	41 b9 00 01 00
	00		 mov	 r9d, 256		; 00000100H

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00031	42 0f b6 6c 30
	22		 movzx	 ebp, BYTE PTR [rax+r14+34]
  00037	46 0f b6 7c 30
	23		 movzx	 r15d, BYTE PTR [rax+r14+35]

; 2301 :     if (glyph_index < numOfLongHorMetrics) {

  0003d	8b dd		 mov	 ebx, ebp
  0003f	c1 e3 08	 shl	 ebx, 8
  00042	41 03 df	 add	 ebx, r15d
  00045	3b d3		 cmp	 edx, ebx
  00047	7d 59		 jge	 SHORT $LN2@stbtt_GetG

; 2302 :         if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * glyph_index);

  00049	4d 85 c0	 test	 r8, r8
  0004c	74 2b		 je	 SHORT $LN21@stbtt_GetG
  0004e	48 63 49 28	 movsxd	 rcx, DWORD PTR [rcx+40]
  00052	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [rdx*4]
  00059	4c 63 c0	 movsxd	 r8, eax
  0005c	49 8d 04 0e	 lea	 rax, QWORD PTR [r14+rcx]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00060	41 0f bf c9	 movsx	 ecx, r9w
  00064	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  00069	41 0f b6 44 00
	01		 movzx	 eax, BYTE PTR [r8+rax+1]
  0006f	0f af d1	 imul	 edx, ecx
  00072	66 03 c2	 add	 ax, dx

; 2302 :         if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * glyph_index);

  00075	98		 cwde
  00076	41 89 02	 mov	 DWORD PTR [r10], eax
$LN21@stbtt_GetG:

; 2303 :         if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4 * glyph_index + 2);

  00079	4d 85 db	 test	 r11, r11
  0007c	0f 84 8c 00 00
	00		 je	 $LN7@stbtt_GetG
  00082	48 63 57 28	 movsxd	 rdx, DWORD PTR [rdi+40]
  00086	8d 04 b5 00 00
	00 00		 lea	 eax, DWORD PTR [rsi*4]
  0008d	4c 63 c0	 movsxd	 r8, eax
  00090	49 8d 04 16	 lea	 rax, QWORD PTR [r14+rdx]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00094	41 0f b6 54 00
	02		 movzx	 edx, BYTE PTR [r8+rax+2]
  0009a	41 0f b6 44 00
	03		 movzx	 eax, BYTE PTR [r8+rax+3]

; 2304 :     }

  000a0	eb 5e		 jmp	 SHORT $LN23@stbtt_GetG
$LN2@stbtt_GetG:

; 2305 :     else {
; 2306 :         if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * (numOfLongHorMetrics - 1));

  000a2	4d 85 d2	 test	 r10, r10
  000a5	74 2d		 je	 SHORT $LN22@stbtt_GetG
  000a7	48 63 49 28	 movsxd	 rcx, DWORD PTR [rcx+40]
  000ab	48 8b d5	 mov	 rdx, rbp
  000ae	48 c1 e2 08	 shl	 rdx, 8
  000b2	49 03 ce	 add	 rcx, r14
  000b5	49 03 d7	 add	 rdx, r15

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000b8	0f b6 44 91 fd	 movzx	 eax, BYTE PTR [rcx+rdx*4-3]

; 2305 :     else {
; 2306 :         if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * (numOfLongHorMetrics - 1));

  000bd	4c 8d 04 91	 lea	 r8, QWORD PTR [rcx+rdx*4]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000c1	0f b6 54 91 fc	 movzx	 edx, BYTE PTR [rcx+rdx*4-4]
  000c6	41 0f bf c9	 movsx	 ecx, r9w
  000ca	0f af d1	 imul	 edx, ecx
  000cd	66 03 c2	 add	 ax, dx

; 2305 :     else {
; 2306 :         if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * (numOfLongHorMetrics - 1));

  000d0	98		 cwde
  000d1	41 89 02	 mov	 DWORD PTR [r10], eax
$LN22@stbtt_GetG:

; 2307 :         if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4 * numOfLongHorMetrics + 2 * (glyph_index - numOfLongHorMetrics));

  000d4	4d 85 db	 test	 r11, r11
  000d7	74 35		 je	 SHORT $LN7@stbtt_GetG
  000d9	4c 63 47 28	 movsxd	 r8, DWORD PTR [rdi+40]
  000dd	2b f3		 sub	 esi, ebx
  000df	48 8b cd	 mov	 rcx, rbp
  000e2	48 c1 e1 08	 shl	 rcx, 8
  000e6	49 03 cf	 add	 rcx, r15
  000e9	8d 04 36	 lea	 eax, DWORD PTR [rsi+rsi]
  000ec	48 98		 cdqe
  000ee	49 03 c6	 add	 rax, r14
  000f1	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000f5	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  000fa	41 0f b6 44 00
	01		 movzx	 eax, BYTE PTR [r8+rax+1]
$LN23@stbtt_GetG:

; 2308 :     }
; 2309 : }

  00100	41 0f bf c9	 movsx	 ecx, r9w
  00104	0f af d1	 imul	 edx, ecx
  00107	66 03 c2	 add	 ax, dx
  0010a	98		 cwde
  0010b	41 89 03	 mov	 DWORD PTR [r11], eax
$LN7@stbtt_GetG:
  0010e	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  00113	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]
  00118	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  0011d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00122	41 5f		 pop	 r15
  00124	41 5e		 pop	 r14
  00126	c3		 ret	 0
stbtt_GetGlyphHMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 8
ascent$ = 16
descent$ = 24
lineGap$ = 32
stbtt_GetFontVMetrics PROC

; 2608 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	49 8b f1	 mov	 rsi, r9
  00017	49 8b f8	 mov	 rdi, r8
  0001a	48 8b d9	 mov	 rbx, rcx

; 2609 :     if (ascent) *ascent = ttSHORT(info->data + info->hhea + 4);

  0001d	bd 00 01 00 00	 mov	 ebp, 256		; 00000100H
  00022	48 85 d2	 test	 rdx, rdx
  00025	74 23		 je	 SHORT $LN2@stbtt_GetF
  00027	4c 63 59 24	 movsxd	 r11, DWORD PTR [rcx+36]
  0002b	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0002f	44 0f bf d5	 movsx	 r10d, bp
  00033	45 0f b6 4c 03
	04		 movzx	 r9d, BYTE PTR [r11+rax+4]
  00039	41 0f b6 44 03
	05		 movzx	 eax, BYTE PTR [r11+rax+5]
  0003f	45 0f af ca	 imul	 r9d, r10d
  00043	66 41 03 c1	 add	 ax, r9w

; 2609 :     if (ascent) *ascent = ttSHORT(info->data + info->hhea + 4);

  00047	98		 cwde
  00048	89 02		 mov	 DWORD PTR [rdx], eax
$LN2@stbtt_GetF:

; 2610 :     if (descent) *descent = ttSHORT(info->data + info->hhea + 6);

  0004a	48 85 ff	 test	 rdi, rdi
  0004d	74 20		 je	 SHORT $LN3@stbtt_GetF
  0004f	4c 63 41 24	 movsxd	 r8, DWORD PTR [rcx+36]
  00053	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00057	0f bf cd	 movsx	 ecx, bp
  0005a	41 0f b6 54 00
	06		 movzx	 edx, BYTE PTR [r8+rax+6]
  00060	41 0f b6 44 00
	07		 movzx	 eax, BYTE PTR [r8+rax+7]
  00066	0f af d1	 imul	 edx, ecx
  00069	66 03 c2	 add	 ax, dx

; 2610 :     if (descent) *descent = ttSHORT(info->data + info->hhea + 6);

  0006c	98		 cwde
  0006d	89 07		 mov	 DWORD PTR [rdi], eax
$LN3@stbtt_GetF:

; 2611 :     if (lineGap) *lineGap = ttSHORT(info->data + info->hhea + 8);

  0006f	48 85 f6	 test	 rsi, rsi
  00072	74 20		 je	 SHORT $LN4@stbtt_GetF
  00074	4c 63 43 24	 movsxd	 r8, DWORD PTR [rbx+36]
  00078	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0007c	0f bf cd	 movsx	 ecx, bp
  0007f	41 0f b6 54 00
	08		 movzx	 edx, BYTE PTR [r8+rax+8]
  00085	41 0f b6 44 00
	09		 movzx	 eax, BYTE PTR [r8+rax+9]
  0008b	0f af d1	 imul	 edx, ecx
  0008e	66 03 c2	 add	 ax, dx

; 2611 :     if (lineGap) *lineGap = ttSHORT(info->data + info->hhea + 8);

  00091	98		 cwde
  00092	89 06		 mov	 DWORD PTR [rsi], eax
$LN4@stbtt_GetF:

; 2612 : }

  00094	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00099	48 8b 6c 24 10	 mov	 rbp, QWORD PTR [rsp+16]
  0009e	48 8b 74 24 18	 mov	 rsi, QWORD PTR [rsp+24]
  000a3	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  000a8	c3		 ret	 0
stbtt_GetFontVMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 8
height$ = 16
stbtt_ScaleForPixelHeight PROC

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  00000	4c 63 51 24	 movsxd	 r10, DWORD PTR [rcx+36]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00004	41 bb 00 01 00
	00		 mov	 r11d, 256		; 00000100H

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  0000a	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0000e	41 0f bf c3	 movsx	 eax, r11w
  00012	41 0f bf cb	 movsx	 ecx, r11w
  00016	43 0f b6 54 0a
	06		 movzx	 edx, BYTE PTR [r10+r9+6]
  0001c	0f af d0	 imul	 edx, eax
  0001f	43 0f b6 44 0a
	07		 movzx	 eax, BYTE PTR [r10+r9+7]
  00025	66 03 d0	 add	 dx, ax
  00028	43 0f b6 44 0a
	05		 movzx	 eax, BYTE PTR [r10+r9+5]

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  0002e	44 0f bf c2	 movsx	 r8d, dx

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00032	43 0f b6 54 0a
	04		 movzx	 edx, BYTE PTR [r10+r9+4]
  00038	0f af d1	 imul	 edx, ecx
  0003b	66 03 c2	 add	 ax, dx

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  0003e	98		 cwde
  0003f	41 2b c0	 sub	 eax, r8d
  00042	66 0f 6e c0	 movd	 xmm0, eax

; 2636 :     return (float)height / fheight;

  00046	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00049	f3 0f 5e c8	 divss	 xmm1, xmm0
  0004d	0f 28 c1	 movaps	 xmm0, xmm1

; 2637 : }

  00050	c3		 ret	 0
stbtt_ScaleForPixelHeight ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 8
pixels$ = 16
stbtt_ScaleForMappingEmToPixels PROC

; 2641 :     int unitsPerEm = ttUSHORT(info->data + info->head + 18);

  00000	48 63 51 1c	 movsxd	 rdx, DWORD PTR [rcx+28]
  00004	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00008	0f b6 4c 02 12	 movzx	 ecx, BYTE PTR [rdx+rax+18]
  0000d	0f b6 44 02 13	 movzx	 eax, BYTE PTR [rdx+rax+19]
  00012	c1 e1 08	 shl	 ecx, 8
  00015	03 c8		 add	 ecx, eax
  00017	66 0f 6e c1	 movd	 xmm0, ecx

; 2642 :     return pixels / unitsPerEm;

  0001b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0001e	f3 0f 5e c8	 divss	 xmm1, xmm0
  00022	0f 28 c1	 movaps	 xmm0, xmm1

; 2643 : }

  00025	c3		 ret	 0
stbtt_ScaleForMappingEmToPixels ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
c$1 = 32
font$ = 160
glyph$ = 168
scale_x$ = 176
scale_y$ = 184
shift_x$ = 192
shift_y$ = 200
ix0$ = 208
iy0$ = 216
ix1$ = 224
iy1$ = 232
stbtt_GetGlyphBitmapBoxSubpixel PROC

; 2656 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	57		 push	 rdi
  00008	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 1599 :     if (info->cff.size) {

  0000f	83 79 4c 00	 cmp	 DWORD PTR [rcx+76], 0

; 2656 : {

  00013	48 8b f9	 mov	 rdi, rcx
  00016	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  0001a	0f 28 fb	 movaps	 xmm7, xmm3
  0001d	44 0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm8
  00022	44 0f 28 c2	 movaps	 xmm8, xmm2

; 1599 :     if (info->cff.size) {

  00026	74 4b		 je	 SHORT $LN14@stbtt_GetG

; 2281 :     stbtt__csctx c = STBTT__CSCTX_INIT(1);

  00028	33 db		 xor	 ebx, ebx
  0002a	48 c7 40 88 01
	00 00 00	 mov	 QWORD PTR [rax-120], 1
  00032	0f 57 c0	 xorps	 xmm0, xmm0
  00035	48 89 58 b0	 mov	 QWORD PTR [rax-80], rbx
  00039	0f 57 c9	 xorps	 xmm1, xmm1
  0003c	89 58 b8	 mov	 DWORD PTR [rax-72], ebx

; 2282 :     int r = stbtt__run_charstring(info, glyph_index, &c);

  0003f	4c 8d 40 88	 lea	 r8, QWORD PTR [rax-120]
  00043	0f 11 40 90	 movups	 XMMWORD PTR [rax-112], xmm0
  00047	f3 0f 7f 48 a0	 movdqu	 XMMWORD PTR [rax-96], xmm1
  0004c	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring

; 2283 :     if (x0)  *x0 = r ? c.min_x : 0;

  00051	85 c0		 test	 eax, eax
  00053	44 8b db	 mov	 r11d, ebx

; 2284 :     if (y0)  *y0 = r ? c.min_y : 0;

  00056	8b fb		 mov	 edi, ebx

; 2285 :     if (x1)  *x1 = r ? c.max_x : 0;

  00058	44 8b c3	 mov	 r8d, ebx
  0005b	44 0f 45 5c 24
	38		 cmovne	 r11d, DWORD PTR c$1[rsp+24]
  00061	0f 45 7c 24 40	 cmovne	 edi, DWORD PTR c$1[rsp+32]
  00066	44 0f 45 44 24
	3c		 cmovne	 r8d, DWORD PTR c$1[rsp+28]

; 2286 :     if (y1)  *y1 = r ? c.max_y : 0;

  0006c	0f 45 5c 24 44	 cmovne	 ebx, DWORD PTR c$1[rsp+36]

; 1601 :     }

  00071	eb 7c		 jmp	 SHORT $LN2@stbtt_GetG
$LN14@stbtt_GetG:

; 1602 :     else {
; 1603 :         int g = stbtt__GetGlyfOffset(info, glyph_index);

  00073	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1604 :         if (g < 0) return 0;

  00078	85 c0		 test	 eax, eax
  0007a	0f 88 8c 01 00
	00		 js	 $LN49@stbtt_GetG

; 1605 : 
; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  00080	4c 8b 4f 08	 mov	 r9, QWORD PTR [rdi+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00084	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H

; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  00089	4c 63 d0	 movsxd	 r10, eax

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0008c	0f bf c3	 movsx	 eax, bx
  0008f	0f bf cb	 movsx	 ecx, bx
  00092	47 0f b6 44 11
	07		 movzx	 r8d, BYTE PTR [r9+r10+7]
  00098	43 0f b6 54 11
	02		 movzx	 edx, BYTE PTR [r9+r10+2]
  0009e	0f af d0	 imul	 edx, eax
  000a1	43 0f b6 44 11
	03		 movzx	 eax, BYTE PTR [r9+r10+3]
  000a7	66 03 d0	 add	 dx, ax
  000aa	43 0f b6 44 11
	05		 movzx	 eax, BYTE PTR [r9+r10+5]

; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  000b0	44 0f bf da	 movsx	 r11d, dx

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000b4	43 0f b6 54 11
	04		 movzx	 edx, BYTE PTR [r9+r10+4]
  000ba	0f af d1	 imul	 edx, ecx
  000bd	0f bf cb	 movsx	 ecx, bx
  000c0	66 03 d0	 add	 dx, ax
  000c3	43 0f b6 44 11
	09		 movzx	 eax, BYTE PTR [r9+r10+9]

; 1607 :         if (y0) *y0 = ttSHORT(info->data + g + 4);

  000c9	0f bf fa	 movsx	 edi, dx

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000cc	43 0f b6 54 11
	06		 movzx	 edx, BYTE PTR [r9+r10+6]
  000d2	0f af d1	 imul	 edx, ecx
  000d5	0f bf cb	 movsx	 ecx, bx
  000d8	66 44 03 c2	 add	 r8w, dx
  000dc	43 0f b6 54 11
	08		 movzx	 edx, BYTE PTR [r9+r10+8]
  000e2	0f af d1	 imul	 edx, ecx

; 1608 :         if (x1) *x1 = ttSHORT(info->data + g + 6);

  000e5	45 0f bf c0	 movsx	 r8d, r8w

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000e9	66 03 d0	 add	 dx, ax

; 1609 :         if (y1) *y1 = ttSHORT(info->data + g + 8);

  000ec	0f bf da	 movsx	 ebx, dx
$LN2@stbtt_GetG:

; 2667 :         if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);

  000ef	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR ix0$[rsp]
  000f7	0f 57 d2	 xorps	 xmm2, xmm2
  000fa	f3 0f 10 9c 24
	c0 00 00 00	 movss	 xmm3, DWORD PTR shift_x$[rsp]
  00103	0f 29 b4 24 80
	00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm6
  0010b	48 85 c9	 test	 rcx, rcx
  0010e	74 37		 je	 SHORT $LN8@stbtt_GetG
  00110	66 41 0f 6e cb	 movd	 xmm1, r11d
  00115	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00118	f3 41 0f 59 c8	 mulss	 xmm1, xmm8
  0011d	f3 0f 58 cb	 addss	 xmm1, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00121	0f 2f ca	 comiss	 xmm1, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2667 :         if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);

  00124	f3 0f 2c c1	 cvttss2si eax, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00128	73 10		 jae	 SHORT $LN47@stbtt_GetG
  0012a	66 0f 6e c0	 movd	 xmm0, eax
  0012e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00131	0f 2e c1	 ucomiss xmm0, xmm1
  00134	7a 02		 jp	 SHORT $LN51@stbtt_GetG
  00136	74 02		 je	 SHORT $LN47@stbtt_GetG
$LN51@stbtt_GetG:
  00138	ff c8		 dec	 eax
$LN47@stbtt_GetG:
  0013a	66 0f 6e c0	 movd	 xmm0, eax
  0013e	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2667 :         if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);

  00141	f3 0f 2c c0	 cvttss2si eax, xmm0
  00145	89 01		 mov	 DWORD PTR [rcx], eax
$LN8@stbtt_GetG:

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  00147	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR iy0$[rsp]
  0014f	f3 0f 10 b4 24
	c8 00 00 00	 movss	 xmm6, DWORD PTR shift_y$[rsp]
  00158	48 85 c9	 test	 rcx, rcx
  0015b	74 38		 je	 SHORT $LN9@stbtt_GetG
  0015d	66 0f 6e c3	 movd	 xmm0, ebx
  00161	0f 28 ce	 movaps	 xmm1, xmm6
  00164	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00167	f3 0f 59 c7	 mulss	 xmm0, xmm7
  0016b	f3 0f 5c c8	 subss	 xmm1, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  0016f	0f 2f ca	 comiss	 xmm1, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  00172	f3 0f 2c c1	 cvttss2si eax, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00176	73 10		 jae	 SHORT $LN48@stbtt_GetG
  00178	66 0f 6e c0	 movd	 xmm0, eax
  0017c	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0017f	0f 2e c1	 ucomiss xmm0, xmm1
  00182	7a 02		 jp	 SHORT $LN50@stbtt_GetG
  00184	74 02		 je	 SHORT $LN48@stbtt_GetG
$LN50@stbtt_GetG:
  00186	ff c8		 dec	 eax
$LN48@stbtt_GetG:
  00188	66 0f 6e c0	 movd	 xmm0, eax
  0018c	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  0018f	f3 0f 2c c0	 cvttss2si eax, xmm0
  00193	89 01		 mov	 DWORD PTR [rcx], eax
$LN9@stbtt_GetG:

; 2669 :         if (ix1) *ix1 = STBTT_iceil(x1 * scale_x + shift_x);

  00195	48 8b 9c 24 e0
	00 00 00	 mov	 rbx, QWORD PTR ix1$[rsp]
  0019d	48 85 db	 test	 rbx, rbx
  001a0	74 1c		 je	 SHORT $LN10@stbtt_GetG
  001a2	66 41 0f 6e c0	 movd	 xmm0, r8d
  001a7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001aa	f3 41 0f 59 c0	 mulss	 xmm0, xmm8
  001af	f3 0f 58 c3	 addss	 xmm0, xmm3
  001b3	e8 00 00 00 00	 call	 ceilf
  001b8	f3 0f 2c c0	 cvttss2si eax, xmm0
  001bc	89 03		 mov	 DWORD PTR [rbx], eax
$LN10@stbtt_GetG:

; 2670 :         if (iy1) *iy1 = STBTT_iceil(-y0 * scale_y + shift_y);

  001be	48 8b 9c 24 e8
	00 00 00	 mov	 rbx, QWORD PTR iy1$[rsp]
  001c6	48 85 db	 test	 rbx, rbx
  001c9	74 1d		 je	 SHORT $LN52@stbtt_GetG
  001cb	66 0f 6e cf	 movd	 xmm1, edi
  001cf	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001d2	f3 0f 59 cf	 mulss	 xmm1, xmm7
  001d6	f3 0f 5c f1	 subss	 xmm6, xmm1
  001da	0f 28 c6	 movaps	 xmm0, xmm6
  001dd	e8 00 00 00 00	 call	 ceilf
  001e2	f3 0f 2c c0	 cvttss2si eax, xmm0
  001e6	89 03		 mov	 DWORD PTR [rbx], eax
$LN52@stbtt_GetG:
  001e8	0f 28 b4 24 80
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+128]
$LN11@stbtt_GetG:

; 2671 :     }
; 2672 : }

  001f0	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  001f8	0f 28 7c 24 70	 movaps	 xmm7, XMMWORD PTR [rsp+112]
  001fd	44 0f 28 44 24
	60		 movaps	 xmm8, XMMWORD PTR [rsp+96]
  00203	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0020a	5f		 pop	 rdi
  0020b	c3		 ret	 0
$LN49@stbtt_GetG:

; 2657 :     int x0 = 0, y0 = 0, x1, y1; // =0 suppresses compiler warning
; 2658 :     if (!stbtt_GetGlyphBox(font, glyph, &x0, &y0, &x1, &y1)) {
; 2659 :         // e.g. space character
; 2660 :         if (ix0) *ix0 = 0;

  0020c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR ix0$[rsp]
  00214	33 db		 xor	 ebx, ebx
  00216	48 85 c0	 test	 rax, rax
  00219	74 02		 je	 SHORT $LN4@stbtt_GetG
  0021b	89 18		 mov	 DWORD PTR [rax], ebx
$LN4@stbtt_GetG:

; 2661 :         if (iy0) *iy0 = 0;

  0021d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR iy0$[rsp]
  00225	48 85 c0	 test	 rax, rax
  00228	74 02		 je	 SHORT $LN5@stbtt_GetG
  0022a	89 18		 mov	 DWORD PTR [rax], ebx
$LN5@stbtt_GetG:

; 2662 :         if (ix1) *ix1 = 0;

  0022c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR ix1$[rsp]
  00234	48 85 c0	 test	 rax, rax
  00237	74 02		 je	 SHORT $LN6@stbtt_GetG
  00239	89 18		 mov	 DWORD PTR [rax], ebx
$LN6@stbtt_GetG:

; 2663 :         if (iy1) *iy1 = 0;

  0023b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR iy1$[rsp]
  00243	48 85 c0	 test	 rax, rax
  00246	74 a8		 je	 SHORT $LN11@stbtt_GetG
  00248	89 18		 mov	 DWORD PTR [rax], ebx
  0024a	eb a4		 jmp	 SHORT $LN11@stbtt_GetG
stbtt_GetGlyphBitmapBoxSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
font$ = 96
glyph$ = 104
scale_x$ = 112
scale_y$ = 120
ix0$ = 128
iy0$ = 136
ix1$ = 144
iy1$ = 152
stbtt_GetGlyphBitmapBox PROC

; 2675 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2676 :     stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1);

  00004	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR iy1$[rsp]
  0000c	0f 57 c0	 xorps	 xmm0, xmm0
  0000f	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00014	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ix1$[rsp]
  0001c	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00021	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR iy0$[rsp]
  00029	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0002e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ix0$[rsp]
  00036	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0003b	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  00041	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00047	e8 00 00 00 00	 call	 stbtt_GetGlyphBitmapBoxSubpixel

; 2677 : }

  0004c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00050	c3		 ret	 0
stbtt_GetGlyphBitmapBox ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
hh$ = 48
size$dead$ = 56
userdata$dead$ = 64
?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z PROC ; stbtt__hheap_alloc

; 2706 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2707 :     if (hh->first_free) {

  00006	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 85 c0	 test	 rax, rax
  00010	74 0d		 je	 SHORT $LN2@stbtt__hhe

; 2708 :         void* p = hh->first_free;
; 2709 :         hh->first_free = *(void**)p;

  00012	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00015	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 2724 :     }
; 2725 : }

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
$LN2@stbtt__hhe:

; 2710 :         return p;
; 2711 :     }
; 2712 :     else {
; 2713 :         if (hh->num_remaining_in_head_chunk == 0) {

  0001f	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00022	85 c0		 test	 eax, eax
  00024	75 39		 jne	 SHORT $LN17@stbtt__hhe
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0002d	48 85 c0	 test	 rax, rax
  00030	74 06		 je	 SHORT $LN10@stbtt__hhe

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00032	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN10@stbtt__hhe:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00038	b9 08 64 00 00	 mov	 ecx, 25608		; 00006408H
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00043	48 8b c8	 mov	 rcx, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2716 :             if (c == NULL)

  00046	48 85 c0	 test	 rax, rax
  00049	75 06		 jne	 SHORT $LN5@stbtt__hhe

; 2724 :     }
; 2725 : }

  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN5@stbtt__hhe:

; 2717 :                 return NULL;
; 2718 :             c->next = hh->head;

  00051	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00054	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2719 :             hh->head = c;
; 2720 :             hh->num_remaining_in_head_chunk = count;

  00057	b8 20 03 00 00	 mov	 eax, 800		; 00000320H
  0005c	48 89 0b	 mov	 QWORD PTR [rbx], rcx
$LN17@stbtt__hhe:

; 2721 :         }
; 2722 :         --hh->num_remaining_in_head_chunk;

  0005f	ff c8		 dec	 eax

; 2723 :         return (char*)(hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;

  00061	48 63 c8	 movsxd	 rcx, eax
  00064	89 43 10	 mov	 DWORD PTR [rbx+16], eax
  00067	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0006a	48 83 c0 08	 add	 rax, 8
  0006e	48 c1 e1 05	 shl	 rcx, 5
  00072	48 03 c1	 add	 rax, rcx

; 2724 :     }
; 2725 : }

  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
?stbtt__hheap_alloc@@YAPEAXPEAUstbtt__hheap@@_KPEAX@Z ENDP ; stbtt__hheap_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
hh$ = 8
p$ = 16
?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z PROC	; stbtt__hheap_free

; 2729 :     *(void**)p = hh->first_free;

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 89 02	 mov	 QWORD PTR [rdx], rax

; 2730 :     hh->first_free = p;

  00007	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 2731 : }

  0000b	c3		 ret	 0
?stbtt__hheap_free@@YAXPEAUstbtt__hheap@@PEAX@Z ENDP	; stbtt__hheap_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
hh$ = 48
userdata$dead$ = 56
?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z PROC	; stbtt__hheap_cleanup

; 2734 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2735 :     stbtt__hheap_chunk* c = hh->head;

  00004	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 2736 :     while (c) {

  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 2d		 je	 SHORT $LN3@stbtt__hhe
  0000c	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
$LL2@stbtt__hhe:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2737 :         stbtt__hheap_chunk* n = c->next;

  00018	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0001b	48 85 c0	 test	 rax, rax
  0001e	74 06		 je	 SHORT $LN7@stbtt__hhe

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00020	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN7@stbtt__hhe:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2739 :         c = n;

  0002c	48 8b cb	 mov	 rcx, rbx
  0002f	48 85 db	 test	 rbx, rbx
  00032	75 dd		 jne	 SHORT $LL2@stbtt__hhe

; 2736 :     while (c) {

  00034	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]
$LN3@stbtt__hhe:

; 2740 :     }
; 2741 : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
?stbtt__hheap_cleanup@@YAXPEAUstbtt__hheap@@PEAX@Z ENDP	; stbtt__hheap_cleanup
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
hh$ = 64
e$ = 72
off_x$ = 80
start_point$ = 88
userdata$dead$ = 96
?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z PROC ; stbtt__new_active

; 2794 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2707 :     if (hh->first_free) {

  0000f	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]

; 2794 : {

  00013	41 8b f0	 mov	 esi, r8d
  00016	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0001b	0f 28 f3	 movaps	 xmm6, xmm3
  0001e	48 8b fa	 mov	 rdi, rdx
  00021	48 8b d9	 mov	 rbx, rcx

; 2707 :     if (hh->first_free) {

  00024	4d 85 c9	 test	 r9, r9
  00027	74 09		 je	 SHORT $LN13@stbtt__new

; 2708 :         void* p = hh->first_free;
; 2709 :         hh->first_free = *(void**)p;

  00029	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0002c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2710 :         return p;

  00030	eb 55		 jmp	 SHORT $LN14@stbtt__new
$LN13@stbtt__new:

; 2711 :     }
; 2712 :     else {
; 2713 :         if (hh->num_remaining_in_head_chunk == 0) {

  00032	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00035	85 c0		 test	 eax, eax
  00037	75 38		 jne	 SHORT $LN28@stbtt__new
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00040	48 85 c0	 test	 rax, rax
  00043	74 06		 je	 SHORT $LN21@stbtt__new

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00045	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN21@stbtt__new:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0004b	b9 08 64 00 00	 mov	 ecx, 25608		; 00006408H
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00056	48 8b c8	 mov	 rcx, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2716 :             if (c == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	75 05		 jne	 SHORT $LN16@stbtt__new

; 2717 :                 return NULL;

  0005e	45 33 c9	 xor	 r9d, r9d
  00061	eb 24		 jmp	 SHORT $LN14@stbtt__new
$LN16@stbtt__new:

; 2718 :             c->next = hh->head;

  00063	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00066	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2719 :             hh->head = c;
; 2720 :             hh->num_remaining_in_head_chunk = count;

  00069	b8 20 03 00 00	 mov	 eax, 800		; 00000320H
  0006e	48 89 0b	 mov	 QWORD PTR [rbx], rcx
$LN28@stbtt__new:

; 2721 :         }
; 2722 :         --hh->num_remaining_in_head_chunk;
; 2723 :         return (char*)(hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;

  00071	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
  00074	ff c8		 dec	 eax
  00076	48 63 c8	 movsxd	 rcx, eax
  00079	49 83 c1 08	 add	 r9, 8
  0007d	48 c1 e1 05	 shl	 rcx, 5
  00081	4c 03 c9	 add	 r9, rcx
  00084	89 43 10	 mov	 DWORD PTR [rbx+16], eax
$LN14@stbtt__new:

; 2795 :     stbtt__active_edge* z = (stbtt__active_edge*)stbtt__hheap_alloc(hh, sizeof(*z), userdata);
; 2796 :     float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);

  00087	f3 0f 10 4f 08	 movss	 xmm1, DWORD PTR [rdi+8]
  0008c	f3 0f 10 47 0c	 movss	 xmm0, DWORD PTR [rdi+12]
  00091	f3 0f 5c 0f	 subss	 xmm1, DWORD PTR [rdi]
  00095	f3 0f 5c 47 04	 subss	 xmm0, DWORD PTR [rdi+4]
  0009a	f3 0f 5e c8	 divss	 xmm1, xmm0

; 2797 :     STBTT_assert(z != NULL);

  0009e	4d 85 c9	 test	 r9, r9
  000a1	75 1e		 jne	 SHORT $LN5@stbtt__new
  000a3	41 b8 ed 0a 00
	00		 mov	 r8d, 2797		; 00000aedH
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@EHPNOHML@?$AAz?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2798 :     //STBTT_assert(e->y0 <= start_point);
; 2799 :     if (!z) return z;

  000bd	33 c0		 xor	 eax, eax
  000bf	eb 6f		 jmp	 SHORT $LN1@stbtt__new
$LN5@stbtt__new:

; 2800 :     z->fdx = dxdy;
; 2801 :     z->fdy = dxdy != 0.0f ? (1.0f / dxdy) : 0.0f;

  000c1	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  000c9	0f 57 c0	 xorps	 xmm0, xmm0
  000cc	0f 2e c8	 ucomiss xmm1, xmm0
  000cf	f3 41 0f 11 49
	0c		 movss	 DWORD PTR [r9+12], xmm1
  000d5	7a 02		 jp	 SHORT $LN29@stbtt__new
  000d7	74 07		 je	 SHORT $LN9@stbtt__new
$LN29@stbtt__new:
  000d9	0f 28 c2	 movaps	 xmm0, xmm2
  000dc	f3 0f 5e c1	 divss	 xmm0, xmm1
$LN9@stbtt__new:
  000e0	f3 41 0f 11 41
	10		 movss	 DWORD PTR [r9+16], xmm0

; 2802 :     z->fx = e->x0 + dxdy * (start_point - e->y0);

  000e6	f3 0f 5c 77 04	 subss	 xmm6, DWORD PTR [rdi+4]
  000eb	66 0f 6e c6	 movd	 xmm0, esi

; 2803 :     z->fx -= off_x;

  000ef	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000f2	f3 0f 59 f1	 mulss	 xmm6, xmm1
  000f6	f3 0f 58 37	 addss	 xmm6, DWORD PTR [rdi]
  000fa	f3 0f 5c f0	 subss	 xmm6, xmm0
  000fe	f3 41 0f 11 71
	08		 movss	 DWORD PTR [r9+8], xmm6

; 2804 :     z->direction = e->invert ? 1.0f : -1.0f;

  00104	83 7f 10 00	 cmp	 DWORD PTR [rdi+16], 0
  00108	75 08		 jne	 SHORT $LN11@stbtt__new
  0010a	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@bf800000
$LN11@stbtt__new:
  00112	f3 41 0f 11 51
	14		 movss	 DWORD PTR [r9+20], xmm2

; 2805 :     z->sy = e->y0;
; 2806 :     z->ey = e->y1;
; 2807 :     z->next = 0;
; 2808 :     return z;

  00118	49 8b c1	 mov	 rax, r9
  0011b	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  0011e	41 89 49 18	 mov	 DWORD PTR [r9+24], ecx
  00122	8b 4f 0c	 mov	 ecx, DWORD PTR [rdi+12]
  00125	41 89 49 1c	 mov	 DWORD PTR [r9+28], ecx
  00129	49 c7 01 00 00
	00 00		 mov	 QWORD PTR [r9], 0
$LN1@stbtt__new:

; 2809 : }

  00130	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00135	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0013a	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0013f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00143	5f		 pop	 rdi
  00144	c3		 ret	 0
?stbtt__new_active@@YAPEAUstbtt__active_edge@@PEAUstbtt__hheap@@PEAUstbtt__edge@@HMPEAX@Z ENDP ; stbtt__new_active
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
scanline$ = 144
x$ = 152
e$ = 160
x0$ = 168
y0$ = 176
x1$ = 184
y1$ = 192
?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z PROC ; stbtt__handle_clipped_edge

; 2969 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	0f 29 74 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm6
  00017	49 8b d8	 mov	 rbx, r8

; 2970 :     if (y0 == y1) return;

  0001a	f3 0f 10 b4 24
	c0 00 00 00	 movss	 xmm6, DWORD PTR y1$[rsp]
  00023	48 8b f1	 mov	 rsi, rcx
  00026	44 0f 29 44 24
	50		 movaps	 XMMWORD PTR [rsp+80], xmm8
  0002c	44 0f 28 c3	 movaps	 xmm8, xmm3
  00030	44 0f 29 5c 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm11
  00036	f3 44 0f 10 9c
	24 b0 00 00 00	 movss	 xmm11, DWORD PTR y0$[rsp]
  00040	44 0f 2e de	 ucomiss xmm11, xmm6
  00044	48 63 fa	 movsxd	 rdi, edx
  00047	7a 06		 jp	 SHORT $LN54@stbtt__han
  00049	0f 84 30 02 00
	00		 je	 $LN42@stbtt__han
$LN54@stbtt__han:

; 2971 :     STBTT_assert(y0 < y1);

  0004f	41 0f 2f f3	 comiss	 xmm6, xmm11
  00053	77 1a		 ja	 SHORT $LN2@stbtt__han
  00055	41 b8 9b 0b 00
	00		 mov	 r8d, 2971		; 00000b9bH
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@ENLNFFAM@?$AAy?$AA0?$AA?5?$AA?$DM?$AA?5?$AAy?$AA1@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN2@stbtt__han:

; 2972 :     STBTT_assert(e->sy <= e->ey);

  0006f	f3 0f 10 5b 1c	 movss	 xmm3, DWORD PTR [rbx+28]
  00074	0f 2f 5b 18	 comiss	 xmm3, DWORD PTR [rbx+24]
  00078	73 1f		 jae	 SHORT $LN5@stbtt__han
  0007a	41 b8 9c 0b 00
	00		 mov	 r8d, 2972		; 00000b9cH
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@JGPMADBG@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAe?$AA?9?$AA?$DO?$AAe?$AAy@
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00094	f3 0f 10 5b 1c	 movss	 xmm3, DWORD PTR [rbx+28]
$LN5@stbtt__han:

; 2973 :     if (y0 > e->ey) return;

  00099	44 0f 2f db	 comiss	 xmm11, xmm3
  0009d	0f 87 dc 01 00
	00		 ja	 $LN42@stbtt__han

; 2974 :     if (y1 < e->sy) return;

  000a3	f3 0f 10 63 18	 movss	 xmm4, DWORD PTR [rbx+24]
  000a8	0f 2f e6	 comiss	 xmm4, xmm6
  000ab	0f 87 ce 01 00
	00		 ja	 $LN42@stbtt__han

; 2975 :     if (y0 < e->sy) {

  000b1	41 0f 2f e3	 comiss	 xmm4, xmm11
  000b5	0f 29 7c 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm7
  000ba	f3 0f 10 bc 24
	b8 00 00 00	 movss	 xmm7, DWORD PTR x1$[rsp]
  000c3	44 0f 29 4c 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm9
  000c9	44 0f 29 54 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm10
  000cf	76 29		 jbe	 SHORT $LN29@stbtt__han

; 2976 :         x0 += (x1 - x0) * (e->sy - y0) / (y1 - y0);

  000d1	0f 28 d4	 movaps	 xmm2, xmm4
  000d4	0f 28 c7	 movaps	 xmm0, xmm7
  000d7	f3 41 0f 5c d3	 subss	 xmm2, xmm11
  000dc	0f 28 ce	 movaps	 xmm1, xmm6
  000df	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  000e4	f3 41 0f 5c cb	 subss	 xmm1, xmm11

; 2977 :         y0 = e->sy;

  000e9	44 0f 28 dc	 movaps	 xmm11, xmm4
  000ed	f3 0f 59 d0	 mulss	 xmm2, xmm0
  000f1	f3 0f 5e d1	 divss	 xmm2, xmm1
  000f5	f3 44 0f 58 c2	 addss	 xmm8, xmm2
$LN29@stbtt__han:

; 2978 :     }
; 2979 :     if (y1 > e->ey) {

  000fa	0f 2f f3	 comiss	 xmm6, xmm3
  000fd	76 23		 jbe	 SHORT $LN30@stbtt__han

; 2980 :         x1 += (x1 - x0) * (e->ey - y1) / (y1 - y0);

  000ff	0f 28 c7	 movaps	 xmm0, xmm7
  00102	0f 28 cb	 movaps	 xmm1, xmm3
  00105	f3 0f 5c ce	 subss	 xmm1, xmm6
  00109	f3 41 0f 5c f3	 subss	 xmm6, xmm11
  0010e	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  00113	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00117	f3 0f 5e ce	 divss	 xmm1, xmm6

; 2981 :         y1 = e->ey;

  0011b	0f 28 f3	 movaps	 xmm6, xmm3
  0011e	f3 0f 58 f9	 addss	 xmm7, xmm1
$LN30@stbtt__han:

; 2982 :     }
; 2983 : 
; 2984 :     if (x0 == x)

  00122	66 44 0f 6e cf	 movd	 xmm9, edi
  00127	8d 47 01	 lea	 eax, DWORD PTR [rdi+1]
  0012a	45 0f 5b c9	 cvtdq2ps xmm9, xmm9
  0012e	66 44 0f 6e d0	 movd	 xmm10, eax
  00133	45 0f 2e c1	 ucomiss xmm8, xmm9
  00137	45 0f 5b d2	 cvtdq2ps xmm10, xmm10
  0013b	7a 1b		 jp	 SHORT $LN31@stbtt__han
  0013d	75 19		 jne	 SHORT $LN31@stbtt__han

; 2985 :         STBTT_assert(x1 <= x + 1);

  0013f	44 0f 2f d7	 comiss	 xmm10, xmm7
  00143	0f 83 88 00 00
	00		 jae	 $LN21@stbtt__han
  00149	41 b8 a9 0b 00
	00		 mov	 r8d, 2985		; 00000ba9H
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@NJPIGMLC@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AA1@
  00156	eb 6c		 jmp	 SHORT $LN58@stbtt__han
$LN31@stbtt__han:

; 2986 :     else if (x0 == x + 1)

  00158	45 0f 2e c2	 ucomiss xmm8, xmm10
  0015c	7a 17		 jp	 SHORT $LN33@stbtt__han
  0015e	75 15		 jne	 SHORT $LN33@stbtt__han

; 2987 :         STBTT_assert(x1 >= x);

  00160	41 0f 2f f9	 comiss	 xmm7, xmm9
  00164	73 6b		 jae	 SHORT $LN21@stbtt__han
  00166	41 b8 ab 0b 00
	00		 mov	 r8d, 2987		; 00000babH
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@FAAMJPKE@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx@
  00173	eb 4f		 jmp	 SHORT $LN58@stbtt__han
$LN33@stbtt__han:

; 2988 :     else if (x0 <= x)

  00175	45 0f 2f c8	 comiss	 xmm9, xmm8
  00179	72 15		 jb	 SHORT $LN35@stbtt__han

; 2989 :         STBTT_assert(x1 <= x);

  0017b	44 0f 2f cf	 comiss	 xmm9, xmm7
  0017f	73 50		 jae	 SHORT $LN21@stbtt__han
  00181	41 b8 ad 0b 00
	00		 mov	 r8d, 2989		; 00000badH
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@FEPJEPJJ@?$AAx?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAx@
  0018e	eb 34		 jmp	 SHORT $LN58@stbtt__han
$LN35@stbtt__han:

; 2990 :     else if (x0 >= x + 1)

  00190	45 0f 2f c2	 comiss	 xmm8, xmm10
  00194	72 15		 jb	 SHORT $LN22@stbtt__han

; 2991 :         STBTT_assert(x1 >= x + 1);

  00196	41 0f 2f fa	 comiss	 xmm7, xmm10
  0019a	73 35		 jae	 SHORT $LN21@stbtt__han
  0019c	41 b8 af 0b 00
	00		 mov	 r8d, 2991		; 00000bafH
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@NMCMAHDB@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AA1@
  001a9	eb 19		 jmp	 SHORT $LN58@stbtt__han
$LN22@stbtt__han:

; 2992 :     else
; 2993 :         STBTT_assert(x1 >= x && x1 <= x + 1);

  001ab	41 0f 2f f9	 comiss	 xmm7, xmm9
  001af	72 06		 jb	 SHORT $LN50@stbtt__han
  001b1	44 0f 2f d7	 comiss	 xmm10, xmm7
  001b5	73 1a		 jae	 SHORT $LN21@stbtt__han
$LN50@stbtt__han:
  001b7	41 b8 b1 0b 00
	00		 mov	 r8d, 2993		; 00000bb1H
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@IKFPJDAK@?$AAx?$AA1?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA1?$AA?5?$AA?$DM@
$LN58@stbtt__han:

; 2994 : 
; 2995 :     if (x0 <= x && x1 <= x)

  001c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN21@stbtt__han:
  001d1	45 0f 2f c8	 comiss	 xmm9, xmm8
  001d5	72 1c		 jb	 SHORT $LN39@stbtt__han
  001d7	44 0f 2f cf	 comiss	 xmm9, xmm7
  001db	72 16		 jb	 SHORT $LN39@stbtt__han

; 2996 :         scanline[x] += e->direction * (y1 - y0);

  001dd	f3 41 0f 5c f3	 subss	 xmm6, xmm11
  001e2	f3 0f 59 73 14	 mulss	 xmm6, DWORD PTR [rbx+20]
  001e7	f3 0f 58 34 be	 addss	 xmm6, DWORD PTR [rsi+rdi*4]
  001ec	f3 0f 11 34 be	 movss	 DWORD PTR [rsi+rdi*4], xmm6
  001f1	eb 7b		 jmp	 SHORT $LN57@stbtt__han
$LN39@stbtt__han:

; 2997 :     else if (x0 >= x + 1 && x1 >= x + 1)

  001f3	45 0f 2f c2	 comiss	 xmm8, xmm10
  001f7	72 06		 jb	 SHORT $LN25@stbtt__han
  001f9	41 0f 2f fa	 comiss	 xmm7, xmm10
  001fd	73 6f		 jae	 SHORT $LN57@stbtt__han
$LN25@stbtt__han:

; 2998 :         ;
; 2999 :     else {
; 3000 :         STBTT_assert(x0 >= x && x0 <= x + 1 && x1 >= x && x1 <= x + 1);

  001ff	45 0f 2f c1	 comiss	 xmm8, xmm9
  00203	72 12		 jb	 SHORT $LN52@stbtt__han
  00205	45 0f 2f d0	 comiss	 xmm10, xmm8
  00209	72 0c		 jb	 SHORT $LN52@stbtt__han
  0020b	41 0f 2f f9	 comiss	 xmm7, xmm9
  0020f	72 06		 jb	 SHORT $LN52@stbtt__han
  00211	44 0f 2f d7	 comiss	 xmm10, xmm7
  00215	73 1a		 jae	 SHORT $LN23@stbtt__han
$LN52@stbtt__han:
  00217	41 b8 b8 0b 00
	00		 mov	 r8d, 3000		; 00000bb8H
  0021d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GC@IACIBKNK@?$AAx?$AA0?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAx?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA0?$AA?5?$AA?$DM@
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN23@stbtt__han:

; 3001 :         scanline[x] += e->direction * (y1 - y0) * (1 - ((x0 - x) + (x1 - x)) / 2); // coverage = 1 - average x position

  00231	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00239	f3 45 0f 5c c1	 subss	 xmm8, xmm9
  0023e	f3 41 0f 5c f9	 subss	 xmm7, xmm9
  00243	f3 41 0f 5c f3	 subss	 xmm6, xmm11
  00248	f3 44 0f 58 c7	 addss	 xmm8, xmm7
  0024d	f3 0f 59 73 14	 mulss	 xmm6, DWORD PTR [rbx+20]
  00252	f3 44 0f 59 05
	00 00 00 00	 mulss	 xmm8, DWORD PTR __real@3f000000
  0025b	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  00260	f3 0f 59 c6	 mulss	 xmm0, xmm6
  00264	f3 0f 58 04 be	 addss	 xmm0, DWORD PTR [rsi+rdi*4]
  00269	f3 0f 11 04 be	 movss	 DWORD PTR [rsi+rdi*4], xmm0
$LN57@stbtt__han:
  0026e	44 0f 28 4c 24
	40		 movaps	 xmm9, XMMWORD PTR [rsp+64]
  00274	0f 28 7c 24 60	 movaps	 xmm7, XMMWORD PTR [rsp+96]
  00279	44 0f 28 54 24
	30		 movaps	 xmm10, XMMWORD PTR [rsp+48]
$LN42@stbtt__han:

; 3002 :     }
; 3003 : }

  0027f	0f 28 74 24 70	 movaps	 xmm6, XMMWORD PTR [rsp+112]
  00284	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  0028c	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00290	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00294	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  00299	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  0029e	49 8b e3	 mov	 rsp, r11
  002a1	5f		 pop	 rdi
  002a2	c3		 ret	 0
?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ENDP ; stbtt__handle_clipped_edge
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
scanline$ = 256
scanline_fill$ = 264
len$ = 272
e$ = 280
y_bottom$1$ = 288
y_top$ = 288
?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z PROC ; stbtt__fill_active_edges_new

; 3006 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  00007	57		 push	 rdi
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00013	0f 29 70 d8	 movaps	 XMMWORD PTR [rax-40], xmm6
  00017	49 8b f9	 mov	 rdi, r9
  0001a	44 0f 29 58 88	 movaps	 XMMWORD PTR [rax-120], xmm11
  0001f	45 8b f0	 mov	 r14d, r8d

; 3007 :     float y_bottom = y_top + 1;

  00022	f3 44 0f 10 9c
	24 20 01 00 00	 movss	 xmm11, DWORD PTR y_top$[rsp]
  0002c	4c 8b fa	 mov	 r15, rdx
  0002f	41 0f 28 f3	 movaps	 xmm6, xmm11
  00033	48 8b f1	 mov	 rsi, rcx
  00036	f3 0f 58 35 00
	00 00 00	 addss	 xmm6, DWORD PTR __real@3f800000
  0003e	f3 0f 11 b4 24
	20 01 00 00	 movss	 DWORD PTR y_bottom$1$[rsp], xmm6

; 3008 : 
; 3009 :     while (e) {

  00047	4d 85 c9	 test	 r9, r9
  0004a	0f 84 c0 06 00
	00		 je	 $LN3@stbtt__fil
  00050	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00054	0f 57 c9	 xorps	 xmm1, xmm1
  00057	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0005b	0f 29 78 c8	 movaps	 XMMWORD PTR [rax-56], xmm7
  0005f	44 0f 29 40 b8	 movaps	 XMMWORD PTR [rax-72], xmm8
  00064	44 0f 29 48 a8	 movaps	 XMMWORD PTR [rax-88], xmm9
  00069	44 0f 29 50 98	 movaps	 XMMWORD PTR [rax-104], xmm10
  0006e	44 0f 29 64 24
	70		 movaps	 XMMWORD PTR [rsp+112], xmm12
  00074	44 0f 29 6c 24
	60		 movaps	 XMMWORD PTR [rsp+96], xmm13
  0007a	44 0f 29 7c 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm15
  00080	44 0f 29 74 24
	50		 movaps	 XMMWORD PTR [rsp+80], xmm14
  00086	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@stbtt__fil:

; 3010 :         // brute force every pixel
; 3011 : 
; 3012 :         // compute intersection points with top & bottom
; 3013 :         STBTT_assert(e->ey >= y_top);

  00090	f3 0f 10 47 1c	 movss	 xmm0, DWORD PTR [rdi+28]
  00095	41 0f 2f c3	 comiss	 xmm0, xmm11
  00099	73 1d		 jae	 SHORT $LN4@stbtt__fil
  0009b	41 b8 c5 0b 00
	00		 mov	 r8d, 3013		; 00000bc5H
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@MDBOACOJ@?$AAe?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAy?$AA_?$AAt?$AAo?$AAp@
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b5	0f 57 c9	 xorps	 xmm1, xmm1
$LN4@stbtt__fil:

; 3014 : 
; 3015 :         if (e->fdx == 0) {

  000b8	f3 44 0f 10 7f
	0c		 movss	 xmm15, DWORD PTR [rdi+12]
  000be	44 0f 2e f9	 ucomiss xmm15, xmm1
  000c2	f3 0f 10 7f 08	 movss	 xmm7, DWORD PTR [rdi+8]
  000c7	7a 79		 jp	 SHORT $LN22@stbtt__fil
  000c9	75 77		 jne	 SHORT $LN22@stbtt__fil

; 3016 :             float x0 = e->fx;
; 3017 :             if (x0 < len) {

  000cb	66 41 0f 6e c6	 movd	 xmm0, r14d
  000d0	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000d3	0f 2f c7	 comiss	 xmm0, xmm7
  000d6	0f 86 da 05 00
	00		 jbe	 $LN20@stbtt__fil

; 3018 :                 if (x0 >= 0) {

  000dc	0f 2f f9	 comiss	 xmm7, xmm1
  000df	4c 8b c7	 mov	 r8, rdi
  000e2	f3 0f 11 74 24
	30		 movss	 DWORD PTR [rsp+48], xmm6
  000e8	0f 28 df	 movaps	 xmm3, xmm7
  000eb	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  000f1	f3 44 0f 11 5c
	24 20		 movss	 DWORD PTR [rsp+32], xmm11
  000f8	72 38		 jb	 SHORT $LN25@stbtt__fil

; 3019 :                     stbtt__handle_clipped_edge(scanline, (int)x0, e, x0, y_top, x0, y_bottom);

  000fa	f3 0f 2c df	 cvttss2si ebx, xmm7
  000fe	48 8b ce	 mov	 rcx, rsi
  00101	8b d3		 mov	 edx, ebx
  00103	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3020 :                     stbtt__handle_clipped_edge(scanline_fill - 1, (int)x0 + 1, e, x0, y_top, x0, y_bottom);

  00108	f3 0f 11 74 24
	30		 movss	 DWORD PTR [rsp+48], xmm6
  0010e	8d 53 01	 lea	 edx, DWORD PTR [rbx+1]
  00111	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  00117	49 8d 4f fc	 lea	 rcx, QWORD PTR [r15-4]
  0011b	0f 28 df	 movaps	 xmm3, xmm7
  0011e	f3 44 0f 11 5c
	24 20		 movss	 DWORD PTR [rsp+32], xmm11
  00125	4c 8b c7	 mov	 r8, rdi
  00128	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3021 :                 }

  0012d	e9 84 05 00 00	 jmp	 $LN20@stbtt__fil
$LN25@stbtt__fil:

; 3022 :                 else {
; 3023 :                     stbtt__handle_clipped_edge(scanline_fill - 1, 0, e, x0, y_top, x0, y_bottom);

  00132	49 8d 4f fc	 lea	 rcx, QWORD PTR [r15-4]
  00136	33 d2		 xor	 edx, edx
  00138	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3024 :                 }
; 3025 :             }
; 3026 :         }

  0013d	e9 74 05 00 00	 jmp	 $LN20@stbtt__fil
$LN22@stbtt__fil:

; 3027 :         else {
; 3028 :             float x0 = e->fx;
; 3029 :             float dx = e->fdx;
; 3030 :             float xb = x0 + dx;
; 3031 :             float x_top, x_bottom;
; 3032 :             float sy0, sy1;
; 3033 :             float dy = e->fdy;
; 3034 :             STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

  00142	f3 44 0f 10 6f
	18		 movss	 xmm13, DWORD PTR [rdi+24]
  00148	45 0f 28 e7	 movaps	 xmm12, xmm15
  0014c	41 0f 2f f5	 comiss	 xmm6, xmm13
  00150	f3 44 0f 10 77
	10		 movss	 xmm14, DWORD PTR [rdi+16]
  00156	f3 44 0f 58 e7	 addss	 xmm12, xmm7
  0015b	72 0c		 jb	 SHORT $LN77@stbtt__fil
  0015d	f3 44 0f 10 57
	1c		 movss	 xmm10, DWORD PTR [rdi+28]
  00163	45 0f 2f d3	 comiss	 xmm10, xmm11
  00167	73 29		 jae	 SHORT $LN7@stbtt__fil
$LN77@stbtt__fil:
  00169	41 b8 da 0b 00
	00		 mov	 r8d, 3034		; 00000bdaH
  0016f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@KOIFPDFH@?$AAe?$AA?9?$AA?$DO?$AAs?$AAy?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAy?$AA_?$AAb?$AAo?$AAt?$AAt@
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00183	f3 44 0f 10 6f
	18		 movss	 xmm13, DWORD PTR [rdi+24]
  00189	0f 57 c9	 xorps	 xmm1, xmm1
  0018c	f3 44 0f 10 57
	1c		 movss	 xmm10, DWORD PTR [rdi+28]
$LN7@stbtt__fil:

; 3035 : 
; 3036 :             // compute endpoints of line segment clipped to this scanline (if the
; 3037 :             // line segment starts on this scanline. x0 is the intersection of the
; 3038 :             // line with y_top, but that may be off the line segment.
; 3039 :             if (e->sy > y_top) {

  00192	45 0f 2f eb	 comiss	 xmm13, xmm11
  00196	76 15		 jbe	 SHORT $LN27@stbtt__fil

; 3040 :                 x_top = x0 + dx * (e->sy - y_top);

  00198	45 0f 28 cd	 movaps	 xmm9, xmm13
  0019c	f3 45 0f 5c cb	 subss	 xmm9, xmm11
  001a1	f3 45 0f 59 cf	 mulss	 xmm9, xmm15
  001a6	f3 44 0f 58 cf	 addss	 xmm9, xmm7

; 3041 :                 sy0 = e->sy;
; 3042 :             }

  001ab	eb 08		 jmp	 SHORT $LN28@stbtt__fil
$LN27@stbtt__fil:

; 3043 :             else {
; 3044 :                 x_top = x0;

  001ad	44 0f 28 cf	 movaps	 xmm9, xmm7

; 3045 :                 sy0 = y_top;

  001b1	45 0f 28 eb	 movaps	 xmm13, xmm11
$LN28@stbtt__fil:

; 3046 :             }
; 3047 :             if (e->ey < y_bottom) {

  001b5	41 0f 2f f2	 comiss	 xmm6, xmm10
  001b9	76 15		 jbe	 SHORT $LN29@stbtt__fil

; 3048 :                 x_bottom = x0 + dx * (e->ey - y_top);

  001bb	45 0f 28 c2	 movaps	 xmm8, xmm10
  001bf	f3 45 0f 5c c3	 subss	 xmm8, xmm11
  001c4	f3 45 0f 59 c7	 mulss	 xmm8, xmm15
  001c9	f3 44 0f 58 c7	 addss	 xmm8, xmm7

; 3049 :                 sy1 = e->ey;
; 3050 :             }

  001ce	eb 08		 jmp	 SHORT $LN30@stbtt__fil
$LN29@stbtt__fil:

; 3051 :             else {
; 3052 :                 x_bottom = xb;

  001d0	45 0f 28 c4	 movaps	 xmm8, xmm12

; 3053 :                 sy1 = y_bottom;

  001d4	44 0f 28 d6	 movaps	 xmm10, xmm6
$LN30@stbtt__fil:

; 3054 :             }
; 3055 : 
; 3056 :             if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {

  001d8	44 0f 2f c9	 comiss	 xmm9, xmm1
  001dc	0f 82 f0 02 00
	00		 jb	 $LN31@stbtt__fil
  001e2	44 0f 2f c1	 comiss	 xmm8, xmm1
  001e6	0f 82 e6 02 00
	00		 jb	 $LN31@stbtt__fil
  001ec	66 41 0f 6e c6	 movd	 xmm0, r14d
  001f1	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001f4	41 0f 2f c1	 comiss	 xmm0, xmm9
  001f8	0f 86 d4 02 00
	00		 jbe	 $LN31@stbtt__fil
  001fe	41 0f 2f c0	 comiss	 xmm0, xmm8
  00202	0f 86 ca 02 00
	00		 jbe	 $LN31@stbtt__fil

; 3057 :                 // from here on, we don't have to range check x values
; 3058 : 
; 3059 :                 if ((int)x_top == (int)x_bottom) {

  00208	f3 41 0f 2c d9	 cvttss2si ebx, xmm9
  0020d	f3 41 0f 2c c0	 cvttss2si eax, xmm8
  00212	3b d8		 cmp	 ebx, eax
  00214	0f 85 82 00 00
	00		 jne	 $LN33@stbtt__fil

; 3060 :                     float height;
; 3061 :                     // simple case, only spans one pixel
; 3062 :                     int x = (int)x_top;
; 3063 :                     height = sy1 - sy0;

  0021a	f3 45 0f 5c d5	 subss	 xmm10, xmm13

; 3064 :                     STBTT_assert(x >= 0 && x < len);

  0021f	85 db		 test	 ebx, ebx
  00221	78 05		 js	 SHORT $LN52@stbtt__fil
  00223	41 3b de	 cmp	 ebx, r14d
  00226	7c 1a		 jl	 SHORT $LN10@stbtt__fil
$LN52@stbtt__fil:
  00228	41 b8 f8 0b 00
	00		 mov	 r8d, 3064		; 00000bf8H
  0022e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@GDDDMDCC@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$DM?$AA?5?$AAl@
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN10@stbtt__fil:

; 3065 :                     scanline[x] += e->direction * (1 - ((x_top - x) + (x_bottom - x)) / 2) * height;

  00242	0f 57 c0	 xorps	 xmm0, xmm0
  00245	48 63 c3	 movsxd	 rax, ebx
  00248	f3 0f 2a c3	 cvtsi2ss xmm0, ebx
  0024c	f3 44 0f 5c c0	 subss	 xmm8, xmm0
  00251	f3 44 0f 5c c8	 subss	 xmm9, xmm0
  00256	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0025e	f3 45 0f 58 c1	 addss	 xmm8, xmm9
  00263	f3 44 0f 59 05
	00 00 00 00	 mulss	 xmm8, DWORD PTR __real@3f000000
  0026c	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  00271	f3 0f 59 47 14	 mulss	 xmm0, DWORD PTR [rdi+20]
  00276	f3 41 0f 59 c2	 mulss	 xmm0, xmm10
  0027b	f3 0f 58 04 86	 addss	 xmm0, DWORD PTR [rsi+rax*4]
  00280	f3 0f 11 04 86	 movss	 DWORD PTR [rsi+rax*4], xmm0

; 3066 :                     scanline_fill[x] += e->direction * height; // everything right of this pixel is filled

  00285	f3 44 0f 59 57
	14		 mulss	 xmm10, DWORD PTR [rdi+20]
  0028b	f3 45 0f 58 14
	87		 addss	 xmm10, DWORD PTR [r15+rax*4]
  00291	f3 45 0f 11 14
	87		 movss	 DWORD PTR [r15+rax*4], xmm10

; 3067 :                 }

  00297	e9 1a 04 00 00	 jmp	 $LN20@stbtt__fil
$LN33@stbtt__fil:

; 3068 :                 else {
; 3069 :                     int x, x1, x2;
; 3070 :                     float y_crossing, step, sign, area;
; 3071 :                     // covers 2+ pixels
; 3072 :                     if (x_top > x_bottom) {

  0029c	45 0f 2f c8	 comiss	 xmm9, xmm8
  002a0	76 37		 jbe	 SHORT $LN35@stbtt__fil

; 3073 :                         // flip scanline vertically; signed area is the same
; 3074 :                         float t;
; 3075 :                         sy0 = y_bottom - (sy0 - y_top);
; 3076 :                         sy1 = y_bottom - (sy1 - y_top);
; 3077 :                         t = sy0, sy0 = sy1, sy1 = t;
; 3078 :                         t = x_bottom, x_bottom = x_top, x_top = t;
; 3079 :                         dx = -dx;
; 3080 :                         dy = -dy;

  002a2	44 0f 57 35 00
	00 00 00	 xorps	 xmm14, DWORD PTR __xmm@80000000800000008000000080000000
  002aa	f3 45 0f 5c eb	 subss	 xmm13, xmm11
  002af	0f 28 c6	 movaps	 xmm0, xmm6
  002b2	f3 45 0f 5c d3	 subss	 xmm10, xmm11

; 3081 :                         t = x0, x0 = xb, xb = t;

  002b7	41 0f 28 fc	 movaps	 xmm7, xmm12
  002bb	f3 41 0f 5c c5	 subss	 xmm0, xmm13
  002c0	44 0f 28 ee	 movaps	 xmm13, xmm6
  002c4	f3 45 0f 5c ea	 subss	 xmm13, xmm10
  002c9	44 0f 28 d0	 movaps	 xmm10, xmm0
  002cd	41 0f 28 c0	 movaps	 xmm0, xmm8
  002d1	45 0f 28 c1	 movaps	 xmm8, xmm9
  002d5	44 0f 28 c8	 movaps	 xmm9, xmm0
$LN35@stbtt__fil:

; 3082 :                         // [DEAR IMGUI] Fix static analyzer warning
; 3083 :                         (void)dx; // [ImGui: fix static analyzer warning]
; 3084 :                     }
; 3085 : 
; 3086 :                     x1 = (int)x_top;
; 3087 :                     x2 = (int)x_bottom;
; 3088 :                     // compute intersection with y axis at x1+1
; 3089 :                     y_crossing = (x1 + 1 - x0) * dy + y_top;
; 3090 : 
; 3091 :                     sign = e->direction;
; 3092 :                     // area of the rectangle covered from y0..y_crossing
; 3093 :                     area = sign * (y_crossing - sy0);
; 3094 :                     // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
; 3095 :                     scanline[x1] += area * (1 - ((x_top - x1) + (x1 + 1 - x1)) / 2);

  002d9	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f800000
  002e1	f3 44 0f 10 3d
	00 00 00 00	 movss	 xmm15, DWORD PTR __real@3f000000
  002ea	f3 45 0f 2c c1	 cvttss2si r8d, xmm9
  002ef	f3 41 0f 2c e8	 cvttss2si ebp, xmm8
  002f4	49 63 c0	 movsxd	 rax, r8d
  002f7	41 8d 48 01	 lea	 ecx, DWORD PTR [r8+1]
  002fb	48 63 d1	 movsxd	 rdx, ecx
  002fe	66 41 0f 6e c0	 movd	 xmm0, r8d
  00303	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 3096 : 
; 3097 :                     step = sign * dy;
; 3098 :                     for (x = x1 + 1; x < x2; ++x) {

  00306	48 63 dd	 movsxd	 rbx, ebp
  00309	66 44 0f 6e e1	 movd	 xmm12, ecx
  0030e	f3 44 0f 5c c8	 subss	 xmm9, xmm0
  00313	0f 28 c4	 movaps	 xmm0, xmm4
  00316	45 0f 5b e4	 cvtdq2ps xmm12, xmm12
  0031a	f3 44 0f 58 cc	 addss	 xmm9, xmm4
  0031f	f3 44 0f 5c e7	 subss	 xmm12, xmm7
  00324	f3 0f 10 7f 14	 movss	 xmm7, DWORD PTR [rdi+20]
  00329	0f 28 d7	 movaps	 xmm2, xmm7
  0032c	f3 41 0f 59 d6	 mulss	 xmm2, xmm14
  00331	f3 45 0f 59 cf	 mulss	 xmm9, xmm15
  00336	f3 45 0f 59 e6	 mulss	 xmm12, xmm14
  0033b	f3 41 0f 5c c1	 subss	 xmm0, xmm9
  00340	f3 45 0f 58 e3	 addss	 xmm12, xmm11
  00345	41 0f 28 f4	 movaps	 xmm6, xmm12
  00349	f3 41 0f 5c f5	 subss	 xmm6, xmm13
  0034e	f3 0f 59 f7	 mulss	 xmm6, xmm7
  00352	f3 0f 59 c6	 mulss	 xmm0, xmm6
  00356	f3 0f 58 04 86	 addss	 xmm0, DWORD PTR [rsi+rax*4]
  0035b	f3 0f 11 04 86	 movss	 DWORD PTR [rsi+rax*4], xmm0
  00360	48 3b d3	 cmp	 rdx, rbx
  00363	0f 8d bd 00 00
	00		 jge	 $LN68@stbtt__fil
  00369	48 8b c3	 mov	 rax, rbx
  0036c	48 2b c2	 sub	 rax, rdx
  0036f	48 83 f8 04	 cmp	 rax, 4
  00373	0f 8c 88 00 00
	00		 jl	 $LN78@stbtt__fil
  00379	48 8b cb	 mov	 rcx, rbx
  0037c	48 8d 46 08	 lea	 rax, QWORD PTR [rsi+8]
  00380	48 2b ca	 sub	 rcx, rdx
  00383	48 8d 04 90	 lea	 rax, QWORD PTR [rax+rdx*4]
  00387	48 83 e9 04	 sub	 rcx, 4
  0038b	0f 28 da	 movaps	 xmm3, xmm2
  0038e	48 c1 e9 02	 shr	 rcx, 2
  00392	48 ff c1	 inc	 rcx
  00395	f3 41 0f 59 df	 mulss	 xmm3, xmm15
  0039a	48 8d 14 8a	 lea	 rdx, QWORD PTR [rdx+rcx*4]
  0039e	66 90		 npad	 2
$LL70@stbtt__fil:

; 3099 :                         scanline[x] += area + step / 2;

  003a0	0f 28 c3	 movaps	 xmm0, xmm3
  003a3	0f 28 cb	 movaps	 xmm1, xmm3
  003a6	f3 0f 58 c6	 addss	 xmm0, xmm6

; 3100 :                         area += step;

  003aa	f3 0f 58 f2	 addss	 xmm6, xmm2
  003ae	f3 0f 58 40 f8	 addss	 xmm0, DWORD PTR [rax-8]
  003b3	f3 0f 11 40 f8	 movss	 DWORD PTR [rax-8], xmm0
  003b8	0f 28 c3	 movaps	 xmm0, xmm3
  003bb	f3 0f 58 c6	 addss	 xmm0, xmm6
  003bf	f3 0f 58 f2	 addss	 xmm6, xmm2
  003c3	f3 0f 58 40 fc	 addss	 xmm0, DWORD PTR [rax-4]
  003c8	f3 0f 58 ce	 addss	 xmm1, xmm6
  003cc	f3 0f 58 f2	 addss	 xmm6, xmm2
  003d0	f3 0f 11 40 fc	 movss	 DWORD PTR [rax-4], xmm0
  003d5	0f 28 c3	 movaps	 xmm0, xmm3
  003d8	f3 0f 58 08	 addss	 xmm1, DWORD PTR [rax]
  003dc	f3 0f 58 c6	 addss	 xmm0, xmm6
  003e0	f3 0f 58 f2	 addss	 xmm6, xmm2
  003e4	f3 0f 11 08	 movss	 DWORD PTR [rax], xmm1
  003e8	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [rax+4]
  003ed	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  003f2	48 83 c0 10	 add	 rax, 16
  003f6	48 83 e9 01	 sub	 rcx, 1
  003fa	75 a4		 jne	 SHORT $LL70@stbtt__fil

; 3096 : 
; 3097 :                     step = sign * dy;
; 3098 :                     for (x = x1 + 1; x < x2; ++x) {

  003fc	48 3b d3	 cmp	 rdx, rbx
  003ff	7d 25		 jge	 SHORT $LN68@stbtt__fil
$LN78@stbtt__fil:
  00401	0f 28 ca	 movaps	 xmm1, xmm2
  00404	f3 41 0f 59 cf	 mulss	 xmm1, xmm15
$LC63@stbtt__fil:

; 3099 :                         scanline[x] += area + step / 2;

  00409	0f 28 c1	 movaps	 xmm0, xmm1
  0040c	f3 0f 58 c6	 addss	 xmm0, xmm6

; 3100 :                         area += step;

  00410	f3 0f 58 f2	 addss	 xmm6, xmm2
  00414	f3 0f 58 04 96	 addss	 xmm0, DWORD PTR [rsi+rdx*4]
  00419	f3 0f 11 04 96	 movss	 DWORD PTR [rsi+rdx*4], xmm0
  0041e	48 ff c2	 inc	 rdx
  00421	48 3b d3	 cmp	 rdx, rbx
  00424	7c e3		 jl	 SHORT $LC63@stbtt__fil
$LN68@stbtt__fil:

; 3102 :                     y_crossing += dy * (x2 - (x1 + 1));

  00426	8b c5		 mov	 eax, ebp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

  00428	0f 28 ce	 movaps	 xmm1, xmm6
  0042b	0f 54 0d 00 00
	00 00		 andps	 xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3102 :                     y_crossing += dy * (x2 - (x1 + 1));

  00432	41 2b c0	 sub	 eax, r8d
  00435	ff c8		 dec	 eax
  00437	66 0f 6e c0	 movd	 xmm0, eax
  0043b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0043e	f3 41 0f 59 c6	 mulss	 xmm0, xmm14
  00443	f3 44 0f 58 e0	 addss	 xmm12, xmm0

; 3103 : 
; 3104 :                     STBTT_assert(STBTT_fabs(area) <= 1.01f);

  00448	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f8147ae
  00450	0f 2f c1	 comiss	 xmm0, xmm1
  00453	73 22		 jae	 SHORT $LN16@stbtt__fil
  00455	41 b8 20 0c 00
	00		 mov	 r8d, 3104		; 00000c20H
  0045b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00462	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@PHOJNIKI@?$AAf?$AAa?$AAb?$AAs?$AAf?$AA?$CI?$AAa?$AAr?$AAe?$AAa?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5@
  00469	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0046f	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f800000
$LN16@stbtt__fil:

; 3105 : 
; 3106 :                     scanline[x2] += area + sign * (1 - ((x2 - x2) + (x_bottom - x2)) / 2) * (sy1 - y_crossing);

  00477	0f 57 c0	 xorps	 xmm0, xmm0
  0047a	0f 28 cc	 movaps	 xmm1, xmm4
  0047d	f3 0f 2a c5	 cvtsi2ss xmm0, ebp
  00481	f3 44 0f 5c c0	 subss	 xmm8, xmm0
  00486	0f 57 c0	 xorps	 xmm0, xmm0
  00489	f3 44 0f 58 c0	 addss	 xmm8, xmm0
  0048e	41 0f 28 c2	 movaps	 xmm0, xmm10

; 3107 : 
; 3108 :                     scanline_fill[x2] += sign * (sy1 - sy0);

  00492	f3 45 0f 5c d5	 subss	 xmm10, xmm13
  00497	f3 41 0f 5c c4	 subss	 xmm0, xmm12
  0049c	f3 45 0f 59 c7	 mulss	 xmm8, xmm15
  004a1	f3 44 0f 59 d7	 mulss	 xmm10, xmm7
  004a6	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  004ab	f3 0f 59 cf	 mulss	 xmm1, xmm7
  004af	f3 0f 59 c8	 mulss	 xmm1, xmm0
  004b3	f3 0f 58 ce	 addss	 xmm1, xmm6
  004b7	f3 0f 58 0c 9e	 addss	 xmm1, DWORD PTR [rsi+rbx*4]
  004bc	f3 0f 11 0c 9e	 movss	 DWORD PTR [rsi+rbx*4], xmm1
  004c1	f3 45 0f 58 14
	9f		 addss	 xmm10, DWORD PTR [r15+rbx*4]
  004c7	f3 45 0f 11 14
	9f		 movss	 DWORD PTR [r15+rbx*4], xmm10

; 3109 :                 }
; 3110 :             }

  004cd	e9 db 01 00 00	 jmp	 $LN79@stbtt__fil
$LN31@stbtt__fil:

; 3111 :             else {
; 3112 :                 // if edge goes outside of box we're drawing, we require
; 3113 :                 // clipping logic. since this does not match the intended use
; 3114 :                 // of this library, we use a different, very slow brute
; 3115 :                 // force implementation
; 3116 :                 int x;
; 3117 :                 for (x = 0; x < len; ++x) {

  004d2	33 db		 xor	 ebx, ebx
  004d4	45 85 f6	 test	 r14d, r14d
  004d7	0f 8e d9 01 00
	00		 jle	 $LN20@stbtt__fil
  004dd	f3 44 0f 10 ac
	24 20 01 00 00	 movss	 xmm13, DWORD PTR y_bottom$1$[rsp]
  004e7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL21@stbtt__fil:
  004f0	45 0f 57 c9	 xorps	 xmm9, xmm9

; 3118 :                     // cases:
; 3119 :                     //
; 3120 :                     // there can be up to two intersections with the pixel. any intersection
; 3121 :                     // with left or right edges can be handled by splitting into two (or three)
; 3122 :                     // regions. intersections with top & bottom do not necessitate case-wise logic.
; 3123 :                     //
; 3124 :                     // the old way of doing this found the intersections with the left & right edges,
; 3125 :                     // then used some simple logic to produce up to three segments in sorted order
; 3126 :                     // from top-to-bottom. however, this had a problem: if an x edge was epsilon
; 3127 :                     // across the x border, then the corresponding y position might not be distinct
; 3128 :                     // from the other y segment, and it might ignored as an empty segment. to avoid
; 3129 :                     // that, we need to explicitly produce segments based on x positions.
; 3130 : 
; 3131 :                     // rename variables to clearly-defined pairs
; 3132 :                     float y0 = y_top;
; 3133 :                     float x1 = (float)(x);
; 3134 :                     float x2 = (float)(x + 1);

  004f4	8d 6b 01	 lea	 ebp, DWORD PTR [rbx+1]
  004f7	0f 57 f6	 xorps	 xmm6, xmm6
  004fa	f3 44 0f 2a cb	 cvtsi2ss xmm9, ebx
  004ff	f3 0f 2a f5	 cvtsi2ss xmm6, ebp

; 3135 :                     float x3 = xb;
; 3136 :                     float y3 = y_bottom;
; 3137 : 
; 3138 :                     // x = e->x + e->dx * (y-y_top)
; 3139 :                     // (y-y_top) = (x - e->x) / e->dx
; 3140 :                     // y = (x - e->x) / e->dx + y_top
; 3141 :                     float y1 = (x - x0) / dx + y_top;
; 3142 :                     float y2 = (x + 1 - x0) / dx + y_top;
; 3143 : 
; 3144 :                     if (x0 < x1 && x3 > x2) {         // three segments descending down-right

  00503	44 0f 2f cf	 comiss	 xmm9, xmm7
  00507	45 0f 28 d1	 movaps	 xmm10, xmm9
  0050b	44 0f 28 c6	 movaps	 xmm8, xmm6
  0050f	f3 44 0f 5c d7	 subss	 xmm10, xmm7
  00514	f3 44 0f 5c c7	 subss	 xmm8, xmm7
  00519	f3 45 0f 5e d7	 divss	 xmm10, xmm15
  0051e	f3 45 0f 5e c7	 divss	 xmm8, xmm15
  00523	f3 45 0f 58 d3	 addss	 xmm10, xmm11
  00528	f3 45 0f 58 c3	 addss	 xmm8, xmm11
  0052d	76 55		 jbe	 SHORT $LN36@stbtt__fil
  0052f	44 0f 2f e6	 comiss	 xmm12, xmm6
  00533	76 4f		 jbe	 SHORT $LN36@stbtt__fil

; 3145 :                         stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);

  00535	f3 44 0f 11 54
	24 30		 movss	 DWORD PTR [rsp+48], xmm10
  0053c	0f 28 df	 movaps	 xmm3, xmm7
  0053f	f3 44 0f 11 4c
	24 28		 movss	 DWORD PTR [rsp+40], xmm9
  00546	4c 8b c7	 mov	 r8, rdi
  00549	8b d3		 mov	 edx, ebx
  0054b	f3 44 0f 11 5c
	24 20		 movss	 DWORD PTR [rsp+32], xmm11
  00552	48 8b ce	 mov	 rcx, rsi
  00555	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3146 :                         stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x2, y2);

  0055a	f3 44 0f 11 44
	24 30		 movss	 DWORD PTR [rsp+48], xmm8
  00561	41 0f 28 d9	 movaps	 xmm3, xmm9
  00565	f3 0f 11 74 24
	28		 movss	 DWORD PTR [rsp+40], xmm6
  0056b	4c 8b c7	 mov	 r8, rdi
  0056e	8b d3		 mov	 edx, ebx
  00570	f3 44 0f 11 54
	24 20		 movss	 DWORD PTR [rsp+32], xmm10
  00577	48 8b ce	 mov	 rcx, rsi
  0057a	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3147 :                         stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
; 3148 :                     }

  0057f	e9 f9 00 00 00	 jmp	 $LN19@stbtt__fil
$LN36@stbtt__fil:

; 3149 :                     else if (x3 < x1 && x0 > x2) {  // three segments descending down-left

  00584	45 0f 2f cc	 comiss	 xmm9, xmm12
  00588	76 43		 jbe	 SHORT $LN38@stbtt__fil
  0058a	0f 2f fe	 comiss	 xmm7, xmm6
  0058d	76 3e		 jbe	 SHORT $LN38@stbtt__fil

; 3150 :                         stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);

  0058f	f3 44 0f 11 44
	24 30		 movss	 DWORD PTR [rsp+48], xmm8
  00596	0f 28 df	 movaps	 xmm3, xmm7
  00599	f3 0f 11 74 24
	28		 movss	 DWORD PTR [rsp+40], xmm6
  0059f	4c 8b c7	 mov	 r8, rdi
  005a2	8b d3		 mov	 edx, ebx
  005a4	f3 44 0f 11 5c
	24 20		 movss	 DWORD PTR [rsp+32], xmm11
  005ab	48 8b ce	 mov	 rcx, rsi
  005ae	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3151 :                         stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x1, y1);

  005b3	f3 44 0f 11 54
	24 30		 movss	 DWORD PTR [rsp+48], xmm10
  005ba	0f 28 de	 movaps	 xmm3, xmm6
  005bd	f3 44 0f 11 4c
	24 28		 movss	 DWORD PTR [rsp+40], xmm9
  005c4	f3 44 0f 11 44
	24 20		 movss	 DWORD PTR [rsp+32], xmm8

; 3152 :                         stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
; 3153 :                     }

  005cb	eb 30		 jmp	 SHORT $LN81@stbtt__fil
$LN38@stbtt__fil:

; 3154 :                     else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right

  005cd	44 0f 2f cf	 comiss	 xmm9, xmm7
  005d1	76 06		 jbe	 SHORT $LN40@stbtt__fil
  005d3	45 0f 2f e1	 comiss	 xmm12, xmm9
  005d7	77 0c		 ja	 SHORT $LN80@stbtt__fil
$LN40@stbtt__fil:

; 3155 :                         stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
; 3156 :                         stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
; 3157 :                     }
; 3158 :                     else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left

  005d9	45 0f 2f cc	 comiss	 xmm9, xmm12
  005dd	76 35		 jbe	 SHORT $LN42@stbtt__fil
  005df	41 0f 2f f9	 comiss	 xmm7, xmm9
  005e3	76 2f		 jbe	 SHORT $LN42@stbtt__fil
$LN80@stbtt__fil:

; 3111 :             else {
; 3112 :                 // if edge goes outside of box we're drawing, we require
; 3113 :                 // clipping logic. since this does not match the intended use
; 3114 :                 // of this library, we use a different, very slow brute
; 3115 :                 // force implementation
; 3116 :                 int x;
; 3117 :                 for (x = 0; x < len; ++x) {

  005e5	f3 44 0f 11 54
	24 30		 movss	 DWORD PTR [rsp+48], xmm10
  005ec	0f 28 df	 movaps	 xmm3, xmm7
  005ef	f3 44 0f 11 4c
	24 28		 movss	 DWORD PTR [rsp+40], xmm9
  005f6	f3 44 0f 11 5c
	24 20		 movss	 DWORD PTR [rsp+32], xmm11
$LN81@stbtt__fil:
  005fd	4c 8b c7	 mov	 r8, rdi
  00600	8b d3		 mov	 edx, ebx
  00602	48 8b ce	 mov	 rcx, rsi
  00605	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  0060a	41 0f 28 f1	 movaps	 xmm6, xmm9
  0060e	45 0f 28 c2	 movaps	 xmm8, xmm10
  00612	eb 69		 jmp	 SHORT $LN19@stbtt__fil
$LN42@stbtt__fil:

; 3159 :                         stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
; 3160 :                         stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
; 3161 :                     }
; 3162 :                     else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right

  00614	0f 2f f7	 comiss	 xmm6, xmm7
  00617	76 2c		 jbe	 SHORT $LN44@stbtt__fil
  00619	44 0f 2f e6	 comiss	 xmm12, xmm6
  0061d	76 26		 jbe	 SHORT $LN44@stbtt__fil

; 3163 :                         stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);

  0061f	f3 44 0f 11 44
	24 30		 movss	 DWORD PTR [rsp+48], xmm8
  00626	0f 28 df	 movaps	 xmm3, xmm7
  00629	f3 0f 11 74 24
	28		 movss	 DWORD PTR [rsp+40], xmm6
  0062f	4c 8b c7	 mov	 r8, rdi
  00632	8b d3		 mov	 edx, ebx
  00634	f3 44 0f 11 5c
	24 20		 movss	 DWORD PTR [rsp+32], xmm11
  0063b	48 8b ce	 mov	 rcx, rsi
  0063e	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3164 :                         stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
; 3165 :                     }

  00643	eb 38		 jmp	 SHORT $LN19@stbtt__fil
$LN44@stbtt__fil:

; 3166 :                     else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left

  00645	41 0f 2f f4	 comiss	 xmm6, xmm12
  00649	76 2b		 jbe	 SHORT $LN46@stbtt__fil
  0064b	0f 2f fe	 comiss	 xmm7, xmm6
  0064e	76 26		 jbe	 SHORT $LN46@stbtt__fil

; 3167 :                         stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);

  00650	f3 44 0f 11 44
	24 30		 movss	 DWORD PTR [rsp+48], xmm8
  00657	0f 28 df	 movaps	 xmm3, xmm7
  0065a	f3 0f 11 74 24
	28		 movss	 DWORD PTR [rsp+40], xmm6
  00660	4c 8b c7	 mov	 r8, rdi
  00663	8b d3		 mov	 edx, ebx
  00665	f3 44 0f 11 5c
	24 20		 movss	 DWORD PTR [rsp+32], xmm11
  0066c	48 8b ce	 mov	 rcx, rsi
  0066f	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 3168 :                         stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
; 3169 :                     }

  00674	eb 07		 jmp	 SHORT $LN19@stbtt__fil
$LN46@stbtt__fil:

; 3170 :                     else {  // one segment
; 3171 :                         stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x3, y3);

  00676	0f 28 f7	 movaps	 xmm6, xmm7
  00679	45 0f 28 c3	 movaps	 xmm8, xmm11
$LN19@stbtt__fil:

; 3111 :             else {
; 3112 :                 // if edge goes outside of box we're drawing, we require
; 3113 :                 // clipping logic. since this does not match the intended use
; 3114 :                 // of this library, we use a different, very slow brute
; 3115 :                 // force implementation
; 3116 :                 int x;
; 3117 :                 for (x = 0; x < len; ++x) {

  0067d	f3 44 0f 11 6c
	24 30		 movss	 DWORD PTR [rsp+48], xmm13
  00684	0f 28 de	 movaps	 xmm3, xmm6
  00687	f3 44 0f 11 64
	24 28		 movss	 DWORD PTR [rsp+40], xmm12
  0068e	4c 8b c7	 mov	 r8, rdi
  00691	8b d3		 mov	 edx, ebx
  00693	f3 44 0f 11 44
	24 20		 movss	 DWORD PTR [rsp+32], xmm8
  0069a	48 8b ce	 mov	 rcx, rsi
  0069d	e8 00 00 00 00	 call	 ?stbtt__handle_clipped_edge@@YAXPEAMHPEAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
  006a2	8b dd		 mov	 ebx, ebp
  006a4	41 3b ee	 cmp	 ebp, r14d
  006a7	0f 8c 43 fe ff
	ff		 jl	 $LL21@stbtt__fil
$LN79@stbtt__fil:

; 3172 :                     }
; 3173 :                 }
; 3174 :             }
; 3175 :         }
; 3176 :         e = e->next;

  006ad	f3 0f 10 b4 24
	20 01 00 00	 movss	 xmm6, DWORD PTR y_bottom$1$[rsp]
$LN20@stbtt__fil:
  006b6	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
  006b9	0f 57 c9	 xorps	 xmm1, xmm1
  006bc	48 85 ff	 test	 rdi, rdi
  006bf	0f 85 cb f9 ff
	ff		 jne	 $LL2@stbtt__fil

; 3008 : 
; 3009 :     while (e) {

  006c5	44 0f 28 7c 24
	40		 movaps	 xmm15, XMMWORD PTR [rsp+64]
  006cb	44 0f 28 74 24
	50		 movaps	 xmm14, XMMWORD PTR [rsp+80]
  006d1	44 0f 28 6c 24
	60		 movaps	 xmm13, XMMWORD PTR [rsp+96]
  006d7	44 0f 28 64 24
	70		 movaps	 xmm12, XMMWORD PTR [rsp+112]
  006dd	44 0f 28 94 24
	90 00 00 00	 movaps	 xmm10, XMMWORD PTR [rsp+144]
  006e6	44 0f 28 8c 24
	a0 00 00 00	 movaps	 xmm9, XMMWORD PTR [rsp+160]
  006ef	44 0f 28 84 24
	b0 00 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+176]
  006f8	0f 28 bc 24 c0
	00 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+192]
  00700	48 8b ac 24 08
	01 00 00	 mov	 rbp, QWORD PTR [rsp+264]
  00708	48 8b 9c 24 00
	01 00 00	 mov	 rbx, QWORD PTR [rsp+256]
$LN3@stbtt__fil:

; 3177 :     }
; 3178 : }

  00710	4c 8d 9c 24 e0
	00 00 00	 lea	 r11, QWORD PTR [rsp+224]
  00718	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  0071c	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00721	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  00726	49 8b e3	 mov	 rsp, r11
  00729	41 5f		 pop	 r15
  0072b	41 5e		 pop	 r14
  0072d	5f		 pop	 rdi
  0072e	c3		 ret	 0
?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z ENDP ; stbtt__fill_active_edges_new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
scanline$1$ = 48
y$1$ = 56
active$ = 64
scanline2$1$ = 72
result$GSCopy$1$ = 80
scanline_data$ = 96
__$ArrayPad$ = 624
result$ = 832
e$ = 840
n$ = 848
vsubsample$dead$ = 856
off_x$ = 864
off_y$ = 872
userdata$dead$ = 880
?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z PROC ; stbtt__rasterize_sorted_edges

; 3182 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec 38 03
	00 00		 sub	 rsp, 824		; 00000338H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3183 :     stbtt__hheap hh = { 0, 0, 0 };
; 3184 :     stbtt__active_edge* active = NULL;
; 3185 :     int y, j = 0, i;
; 3186 :     float scanline_data[129], * scanline, * scanline2;
; 3187 : 
; 3188 :     STBTT__NOTUSED(vsubsample);
; 3189 : 
; 3190 :     if (result->w > 64)

  0001c	8b 01		 mov	 eax, DWORD PTR [rcx]
  0001e	49 89 5b 20	 mov	 QWORD PTR [r11+32], rbx
  00022	49 89 6b f8	 mov	 QWORD PTR [r11-8], rbp
  00026	33 ed		 xor	 ebp, ebp
  00028	49 89 73 f0	 mov	 QWORD PTR [r11-16], rsi
  0002c	48 8b f2	 mov	 rsi, rdx
  0002f	49 89 7b e8	 mov	 QWORD PTR [r11-24], rdi
  00033	33 ff		 xor	 edi, edi
  00035	4d 89 63 e0	 mov	 QWORD PTR [r11-32], r12
  00039	4c 8b e1	 mov	 r12, rcx
  0003c	4d 89 6b d8	 mov	 QWORD PTR [r11-40], r13
  00040	45 33 ed	 xor	 r13d, r13d
  00043	4d 89 73 d0	 mov	 QWORD PTR [r11-48], r14
  00047	45 33 f6	 xor	 r14d, r14d
  0004a	4d 89 7b c8	 mov	 QWORD PTR [r11-56], r15
  0004e	45 33 ff	 xor	 r15d, r15d
  00051	45 0f 29 4b 88	 movaps	 XMMWORD PTR [r11-120], xmm9
  00056	49 63 d8	 movsxd	 rbx, r8d
  00059	48 89 4c 24 50	 mov	 QWORD PTR result$GSCopy$1$[rsp], rcx
  0005e	48 89 7c 24 40	 mov	 QWORD PTR active$[rsp], rdi
  00063	83 f8 40	 cmp	 eax, 64			; 00000040H
  00066	7e 2b		 jle	 SHORT $LN19@stbtt__ras

; 3191 :         scanline = (float*)STBTT_malloc((result->w * 2 + 1) * sizeof(float), userdata);

  00068	8d 04 45 01 00
	00 00		 lea	 eax, DWORD PTR [rax*2+1]
  0006f	48 63 c8	 movsxd	 rcx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00072	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3191 :         scanline = (float*)STBTT_malloc((result->w * 2 + 1) * sizeof(float), userdata);

  00079	48 c1 e1 02	 shl	 rcx, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0007d	48 85 c0	 test	 rax, rax
  00080	74 06		 je	 SHORT $LN34@stbtt__ras

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00082	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN34@stbtt__ras:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0008e	4c 8b d8	 mov	 r11, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3191 :         scanline = (float*)STBTT_malloc((result->w * 2 + 1) * sizeof(float), userdata);

  00091	eb 05		 jmp	 SHORT $LN118@stbtt__ras
$LN19@stbtt__ras:

; 3192 :     else
; 3193 :         scanline = scanline_data;

  00093	4c 8d 5c 24 60	 lea	 r11, QWORD PTR scanline_data$[rsp]
$LN118@stbtt__ras:

; 3194 : 
; 3195 :     scanline2 = scanline + result->w;
; 3196 : 
; 3197 :     y = off_y;

  00098	8b 8c 24 68 03
	00 00		 mov	 ecx, DWORD PTR off_y$[rsp]
  0009f	8b d1		 mov	 edx, ecx
  000a1	49 63 04 24	 movsxd	 rax, DWORD PTR [r12]

; 3198 :     e[n].y0 = (float)(off_y + result->h) + 1;

  000a5	f3 44 0f 10 0d
	00 00 00 00	 movss	 xmm9, DWORD PTR __real@3f800000
  000ae	89 4c 24 38	 mov	 DWORD PTR y$1$[rsp], ecx
  000b2	41 03 4c 24 04	 add	 ecx, DWORD PTR [r12+4]
  000b7	49 8d 04 83	 lea	 rax, QWORD PTR [r11+rax*4]
  000bb	4c 89 5c 24 30	 mov	 QWORD PTR scanline$1$[rsp], r11
  000c0	48 89 44 24 48	 mov	 QWORD PTR scanline2$1$[rsp], rax
  000c5	66 0f 6e c1	 movd	 xmm0, ecx
  000c9	48 8d 0c 9b	 lea	 rcx, QWORD PTR [rbx+rbx*4]
  000cd	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000d0	f3 41 0f 58 c1	 addss	 xmm0, xmm9
  000d5	f3 0f 11 44 8e
	04		 movss	 DWORD PTR [rsi+rcx*4+4], xmm0

; 3199 : 
; 3200 :     while (j < result->h) {

  000db	41 39 7c 24 04	 cmp	 DWORD PTR [r12+4], edi
  000e0	0f 8e 99 03 00
	00		 jle	 $LN3@stbtt__ras
  000e6	0f 29 b4 24 f0
	02 00 00	 movaps	 XMMWORD PTR [rsp+752], xmm6
  000ee	0f 29 bc 24 e0
	02 00 00	 movaps	 XMMWORD PTR [rsp+736], xmm7
  000f6	0f 57 ff	 xorps	 xmm7, xmm7
  000f9	44 0f 29 84 24
	d0 02 00 00	 movaps	 XMMWORD PTR [rsp+720], xmm8
  00102	44 0f 29 94 24
	b0 02 00 00	 movaps	 XMMWORD PTR [rsp+688], xmm10
  0010b	f3 44 0f 10 15
	00 00 00 00	 movss	 xmm10, DWORD PTR __real@bf800000
  00114	44 0f 29 9c 24
	a0 02 00 00	 movaps	 XMMWORD PTR [rsp+672], xmm11
  0011d	f3 44 0f 10 1d
	00 00 00 00	 movss	 xmm11, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
  00126	44 0f 29 a4 24
	90 02 00 00	 movaps	 XMMWORD PTR [rsp+656], xmm12
  0012f	f3 44 0f 10 25
	00 00 00 00	 movss	 xmm12, DWORD PTR __real@437f0000
  00138	44 0f 29 ac 24
	80 02 00 00	 movaps	 XMMWORD PTR [rsp+640], xmm13
  00141	f3 44 0f 10 2d
	00 00 00 00	 movss	 xmm13, DWORD PTR __real@3f000000
  0014a	66 0f 1f 44 00
	00		 npad	 6
$LL2@stbtt__ras:

; 3201 :         // find center of pixel for this scanline
; 3202 :         float scan_y_top = y + 0.0f;
; 3203 :         float scan_y_bottom = y + 1.0f;
; 3204 :         stbtt__active_edge** step = &active;
; 3205 : 
; 3206 :         STBTT_memset(scanline, 0, result->w * sizeof(scanline[0]));

  00150	4d 63 04 24	 movsxd	 r8, DWORD PTR [r12]
  00154	48 8d 5c 24 40	 lea	 rbx, QWORD PTR active$[rsp]
  00159	66 44 0f 6e c2	 movd	 xmm8, edx
  0015e	49 8b cb	 mov	 rcx, r11
  00161	45 0f 5b c0	 cvtdq2ps xmm8, xmm8
  00165	49 c1 e0 02	 shl	 r8, 2
  00169	33 d2		 xor	 edx, edx
  0016b	41 0f 28 f0	 movaps	 xmm6, xmm8
  0016f	f3 45 0f 58 c1	 addss	 xmm8, xmm9
  00174	f3 0f 58 f7	 addss	 xmm6, xmm7
  00178	e8 00 00 00 00	 call	 memset

; 3207 :         STBTT_memset(scanline2, 0, (result->w + 1) * sizeof(scanline[0]));

  0017d	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  00181	33 d2		 xor	 edx, edx
  00183	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scanline2$1$[rsp]
  00188	ff c0		 inc	 eax
  0018a	4c 63 c0	 movsxd	 r8, eax
  0018d	49 c1 e0 02	 shl	 r8, 2
  00191	e8 00 00 00 00	 call	 memset

; 3208 : 
; 3209 :         // update all active edges;
; 3210 :         // remove all active edges that terminate before the top of this scanline
; 3211 :         while (*step) {

  00196	48 85 ff	 test	 rdi, rdi
  00199	74 56		 je	 SHORT $LN92@stbtt__ras
  0019b	0f 1f 44 00 00	 npad	 5
$LL4@stbtt__ras:

; 3212 :             stbtt__active_edge* z = *step;
; 3213 :             if (z->ey <= scan_y_top) {

  001a0	0f 2f 77 1c	 comiss	 xmm6, DWORD PTR [rdi+28]
  001a4	72 3b		 jb	 SHORT $LN21@stbtt__ras

; 3214 :                 *step = z->next; // delete from list

  001a6	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  001a9	48 89 03	 mov	 QWORD PTR [rbx], rax

; 3215 :                 STBTT_assert(z->direction);

  001ac	f3 0f 10 47 14	 movss	 xmm0, DWORD PTR [rdi+20]
  001b1	0f 2e c7	 ucomiss xmm0, xmm7
  001b4	7a 1c		 jp	 SHORT $LN6@stbtt__ras
  001b6	75 1a		 jne	 SHORT $LN6@stbtt__ras
  001b8	41 b8 8f 0c 00
	00		 mov	 r8d, 3215		; 00000c8fH
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@LMAHJHLI@?$AAz?$AA?9?$AA?$DO?$AAd?$AAi?$AAr?$AAe?$AAc?$AAt?$AAi?$AAo?$AAn@
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN6@stbtt__ras:

; 2729 :     *(void**)p = hh->first_free;

  001d2	4c 89 37	 mov	 QWORD PTR [rdi], r14

; 2730 :     hh->first_free = p;

  001d5	4c 8b f7	 mov	 r14, rdi

; 3216 :                 z->direction = 0;

  001d8	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [rdi+20], 0

; 3217 :                 stbtt__hheap_free(&hh, z);
; 3218 :             }

  001df	eb 03		 jmp	 SHORT $LN22@stbtt__ras
$LN21@stbtt__ras:

; 3219 :             else {
; 3220 :                 step = &((*step)->next); // advance through list

  001e1	48 8b df	 mov	 rbx, rdi
$LN22@stbtt__ras:

; 3208 : 
; 3209 :         // update all active edges;
; 3210 :         // remove all active edges that terminate before the top of this scanline
; 3211 :         while (*step) {

  001e4	48 8b 3b	 mov	 rdi, QWORD PTR [rbx]
  001e7	48 85 ff	 test	 rdi, rdi
  001ea	75 b4		 jne	 SHORT $LL4@stbtt__ras
  001ec	48 8b 7c 24 40	 mov	 rdi, QWORD PTR active$[rsp]
$LN92@stbtt__ras:

; 3221 :             }
; 3222 :         }
; 3223 : 
; 3224 :         // insert all edges that start before the bottom of this scanline
; 3225 :         while (e->y0 <= scan_y_bottom) {

  001f1	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [rsi+4]
  001f6	44 0f 2f c0	 comiss	 xmm8, xmm0
  001fa	0f 82 6c 01 00
	00		 jb	 $LN10@stbtt__ras
  00200	44 8b a4 24 68
	03 00 00	 mov	 r12d, DWORD PTR off_y$[rsp]
$LL9@stbtt__ras:

; 3226 :             if (e->y0 != e->y1) {

  00208	0f 2e 46 0c	 ucomiss xmm0, DWORD PTR [rsi+12]
  0020c	7a 06		 jp	 SHORT $LN115@stbtt__ras
  0020e	0f 84 40 01 00
	00		 je	 $LN24@stbtt__ras
$LN115@stbtt__ras:

; 2707 :     if (hh->first_free) {

  00214	4d 85 f6	 test	 r14, r14
  00217	74 08		 je	 SHORT $LN54@stbtt__ras

; 2708 :         void* p = hh->first_free;

  00219	49 8b de	 mov	 rbx, r14

; 2709 :         hh->first_free = *(void**)p;

  0021c	4d 8b 36	 mov	 r14, QWORD PTR [r14]

; 2710 :         return p;

  0021f	eb 45		 jmp	 SHORT $LN55@stbtt__ras
$LN54@stbtt__ras:

; 2711 :     }
; 2712 :     else {
; 2713 :         if (hh->num_remaining_in_head_chunk == 0) {

  00221	85 ed		 test	 ebp, ebp
  00223	75 31		 jne	 SHORT $LN56@stbtt__ras
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00225	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0022c	48 85 c0	 test	 rax, rax
  0022f	74 06		 je	 SHORT $LN62@stbtt__ras

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00231	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN62@stbtt__ras:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00237	b9 08 64 00 00	 mov	 ecx, 25608		; 00006408H
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2716 :             if (c == NULL)

  00242	48 85 c0	 test	 rax, rax
  00245	75 04		 jne	 SHORT $LN57@stbtt__ras

; 2717 :                 return NULL;

  00247	33 db		 xor	 ebx, ebx
  00249	eb 1b		 jmp	 SHORT $LN55@stbtt__ras
$LN57@stbtt__ras:

; 2718 :             c->next = hh->head;

  0024b	4c 89 38	 mov	 QWORD PTR [rax], r15

; 2719 :             hh->head = c;
; 2720 :             hh->num_remaining_in_head_chunk = count;

  0024e	bd 20 03 00 00	 mov	 ebp, 800		; 00000320H
  00253	4c 8b f8	 mov	 r15, rax
$LN56@stbtt__ras:

; 2721 :         }
; 2722 :         --hh->num_remaining_in_head_chunk;

  00256	ff cd		 dec	 ebp

; 2723 :         return (char*)(hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;

  00258	49 8d 5f 08	 lea	 rbx, QWORD PTR [r15+8]
  0025c	48 63 c5	 movsxd	 rax, ebp
  0025f	48 c1 e0 05	 shl	 rax, 5
  00263	48 03 d8	 add	 rbx, rax
$LN55@stbtt__ras:

; 2796 :     float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);

  00266	f3 0f 10 56 08	 movss	 xmm2, DWORD PTR [rsi+8]
  0026b	f3 0f 10 46 0c	 movss	 xmm0, DWORD PTR [rsi+12]
  00270	f3 0f 5c 16	 subss	 xmm2, DWORD PTR [rsi]
  00274	f3 0f 5c 46 04	 subss	 xmm0, DWORD PTR [rsi+4]
  00279	f3 0f 5e d0	 divss	 xmm2, xmm0

; 2797 :     STBTT_assert(z != NULL);

  0027d	48 85 db	 test	 rbx, rbx
  00280	75 1f		 jne	 SHORT $LN113@stbtt__ras
  00282	41 b8 ed 0a 00
	00		 mov	 r8d, 2797		; 00000aedH
  00288	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0028f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@EHPNOHML@?$AAz?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0@
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2798 :     //STBTT_assert(e->y0 <= start_point);
; 2799 :     if (!z) return z;

  0029c	e9 b3 00 00 00	 jmp	 $LN24@stbtt__ras
$LN113@stbtt__ras:

; 2800 :     z->fdx = dxdy;
; 2801 :     z->fdy = dxdy != 0.0f ? (1.0f / dxdy) : 0.0f;

  002a1	0f 2e d7	 ucomiss xmm2, xmm7
  002a4	f3 0f 11 53 0c	 movss	 DWORD PTR [rbx+12], xmm2
  002a9	7a 07		 jp	 SHORT $LN114@stbtt__ras
  002ab	75 05		 jne	 SHORT $LN114@stbtt__ras
  002ad	0f 28 c7	 movaps	 xmm0, xmm7
  002b0	eb 08		 jmp	 SHORT $LN50@stbtt__ras
$LN114@stbtt__ras:
  002b2	41 0f 28 c1	 movaps	 xmm0, xmm9
  002b6	f3 0f 5e c2	 divss	 xmm0, xmm2
$LN50@stbtt__ras:
  002ba	f3 0f 11 43 10	 movss	 DWORD PTR [rbx+16], xmm0

; 2802 :     z->fx = e->x0 + dxdy * (start_point - e->y0);

  002bf	0f 28 ce	 movaps	 xmm1, xmm6
  002c2	f3 0f 5c 4e 04	 subss	 xmm1, DWORD PTR [rsi+4]
  002c7	66 0f 6e 84 24
	60 03 00 00	 movd	 xmm0, DWORD PTR off_x$[rsp]

; 2803 :     z->fx -= off_x;

  002d0	0f 5b c0	 cvtdq2ps xmm0, xmm0
  002d3	f3 0f 59 ca	 mulss	 xmm1, xmm2
  002d7	f3 0f 58 0e	 addss	 xmm1, DWORD PTR [rsi]
  002db	f3 0f 5c c8	 subss	 xmm1, xmm0
  002df	f3 0f 11 4b 08	 movss	 DWORD PTR [rbx+8], xmm1

; 2804 :     z->direction = e->invert ? 1.0f : -1.0f;

  002e4	83 7e 10 00	 cmp	 DWORD PTR [rsi+16], 0
  002e8	74 06		 je	 SHORT $LN51@stbtt__ras
  002ea	41 0f 28 c1	 movaps	 xmm0, xmm9
  002ee	eb 04		 jmp	 SHORT $LN52@stbtt__ras
$LN51@stbtt__ras:
  002f0	41 0f 28 c2	 movaps	 xmm0, xmm10
$LN52@stbtt__ras:
  002f4	f3 0f 11 43 14	 movss	 DWORD PTR [rbx+20], xmm0

; 2805 :     z->sy = e->y0;

  002f9	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  002fc	89 43 18	 mov	 DWORD PTR [rbx+24], eax

; 2806 :     z->ey = e->y1;

  002ff	f3 0f 10 46 0c	 movss	 xmm0, DWORD PTR [rsi+12]
  00304	f3 0f 11 43 1c	 movss	 DWORD PTR [rbx+28], xmm0

; 2807 :     z->next = 0;

  00309	0f 28 c8	 movaps	 xmm1, xmm0
  0030c	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 3227 :                 stbtt__active_edge* z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
; 3228 :                 if (z != NULL) {
; 3229 :                     if (j == 0 && off_y != 0) {

  00313	45 85 ed	 test	 r13d, r13d
  00316	75 12		 jne	 SHORT $LN13@stbtt__ras
  00318	45 85 e4	 test	 r12d, r12d
  0031b	74 0d		 je	 SHORT $LN13@stbtt__ras

; 3230 :                         if (z->ey < scan_y_top) {

  0031d	0f 2f f0	 comiss	 xmm6, xmm0
  00320	76 08		 jbe	 SHORT $LN13@stbtt__ras

; 3231 :                             // this can happen due to subpixel positioning and some kind of fp rounding error i think
; 3232 :                             z->ey = scan_y_top;

  00322	f3 0f 11 73 1c	 movss	 DWORD PTR [rbx+28], xmm6
  00327	0f 28 ce	 movaps	 xmm1, xmm6
$LN13@stbtt__ras:

; 3233 :                         }
; 3234 :                     }
; 3235 :                     STBTT_assert(z->ey >= scan_y_top); // if we get really unlucky a tiny bit of an edge can be out of bounds

  0032a	0f 2f ce	 comiss	 xmm1, xmm6
  0032d	73 1a		 jae	 SHORT $LN11@stbtt__ras
  0032f	41 b8 a3 0c 00
	00		 mov	 r8d, 3235		; 00000ca3H
  00335	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0033c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@PMJHELI@?$AAz?$AA?9?$AA?$DO?$AAe?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAc?$AAa?$AAn?$AA_?$AAy@
  00343	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN11@stbtt__ras:

; 3236 :                     // insert at front
; 3237 :                     z->next = active;

  00349	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 3238 :                     active = z;

  0034c	48 8b fb	 mov	 rdi, rbx
  0034f	48 89 5c 24 40	 mov	 QWORD PTR active$[rsp], rbx
$LN24@stbtt__ras:

; 3239 :                 }
; 3240 :             }
; 3241 :             ++e;

  00354	f3 0f 10 46 18	 movss	 xmm0, DWORD PTR [rsi+24]
  00359	48 83 c6 14	 add	 rsi, 20
  0035d	44 0f 2f c0	 comiss	 xmm8, xmm0
  00361	0f 83 a1 fe ff
	ff		 jae	 $LL9@stbtt__ras
  00367	4c 8b 64 24 50	 mov	 r12, QWORD PTR result$GSCopy$1$[rsp]
$LN10@stbtt__ras:

; 3242 :         }
; 3243 : 
; 3244 :         // now process all active edges
; 3245 :         if (active)

  0036c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR scanline2$1$[rsp]
  00371	48 85 ff	 test	 rdi, rdi
  00374	74 1b		 je	 SHORT $LN27@stbtt__ras

; 3246 :             stbtt__fill_active_edges_new(scanline, scanline2 + 1, result->w, active, scan_y_top);

  00376	45 8b 04 24	 mov	 r8d, DWORD PTR [r12]
  0037a	48 8d 53 04	 lea	 rdx, QWORD PTR [rbx+4]
  0037e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scanline$1$[rsp]
  00383	4c 8b cf	 mov	 r9, rdi
  00386	f3 0f 11 74 24
	20		 movss	 DWORD PTR [rsp+32], xmm6
  0038c	e8 00 00 00 00	 call	 ?stbtt__fill_active_edges_new@@YAXPEAM0HPEAUstbtt__active_edge@@M@Z ; stbtt__fill_active_edges_new
$LN27@stbtt__ras:

; 3250 :             for (i = 0; i < result->w; ++i) {

  00391	45 33 c0	 xor	 r8d, r8d
  00394	0f 28 cf	 movaps	 xmm1, xmm7
  00397	45 39 04 24	 cmp	 DWORD PTR [r12], r8d
  0039b	7e 5e		 jle	 SHORT $LN116@stbtt__ras

; 3247 : 
; 3248 :         {
; 3249 :             float sum = 0;

  0039d	4c 8b 4c 24 30	 mov	 r9, QWORD PTR scanline$1$[rsp]
  003a2	4c 8b d3	 mov	 r10, rbx
  003a5	4d 2b d1	 sub	 r10, r9
  003a8	41 bb ff 00 00
	00		 mov	 r11d, 255		; 000000ffH
  003ae	66 90		 npad	 2
$LL16@stbtt__ras:

; 3251 :                 float k;
; 3252 :                 int m;
; 3253 :                 sum += scanline2[i];

  003b0	f3 43 0f 58 0c
	0a		 addss	 xmm1, DWORD PTR [r10+r9]

; 3258 :                 result->pixels[j * result->stride + i] = (unsigned char)m;

  003b6	41 8b c5	 mov	 eax, r13d
  003b9	0f 28 c1	 movaps	 xmm0, xmm1
  003bc	f3 41 0f 58 01	 addss	 xmm0, DWORD PTR [r9]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

  003c1	41 0f 54 c3	 andps	 xmm0, xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3255 :                 k = (float)STBTT_fabs(k) * 255 + 0.5f;

  003c5	f3 41 0f 59 c4	 mulss	 xmm0, xmm12
  003ca	f3 41 0f 58 c5	 addss	 xmm0, xmm13

; 3256 :                 m = (int)k;

  003cf	f3 0f 2c d0	 cvttss2si edx, xmm0

; 3257 :                 if (m > 255) m = 255;

  003d3	41 3b d3	 cmp	 edx, r11d
  003d6	41 0f 4f d3	 cmovg	 edx, r11d

; 3258 :                 result->pixels[j * result->stride + i] = (unsigned char)m;

  003da	41 0f af 44 24
	08		 imul	 eax, DWORD PTR [r12+8]
  003e0	49 83 c1 04	 add	 r9, 4
  003e4	41 03 c0	 add	 eax, r8d
  003e7	41 ff c0	 inc	 r8d
  003ea	48 63 c8	 movsxd	 rcx, eax
  003ed	49 8b 44 24 10	 mov	 rax, QWORD PTR [r12+16]
  003f2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  003f5	45 3b 04 24	 cmp	 r8d, DWORD PTR [r12]
  003f9	7c b5		 jl	 SHORT $LL16@stbtt__ras
$LN116@stbtt__ras:

; 3259 :             }
; 3260 :         }
; 3261 :         // advance all the edges
; 3262 :         step = &active;

  003fb	4c 8b 5c 24 30	 mov	 r11, QWORD PTR scanline$1$[rsp]
  00400	48 8d 4c 24 40	 lea	 rcx, QWORD PTR active$[rsp]

; 3263 :         while (*step) {

  00405	48 85 ff	 test	 rdi, rdi
  00408	74 20		 je	 SHORT $LN18@stbtt__ras
  0040a	48 8b c7	 mov	 rax, rdi
  0040d	0f 1f 00	 npad	 3
$LL17@stbtt__ras:

; 3264 :             stbtt__active_edge* z = *step;
; 3265 :             z->fx += z->fdx; // advance to position for current scanline

  00410	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  00415	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [rax+8]
  0041a	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0

; 3266 :             step = &((*step)->next); // advance through list

  0041f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00422	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00425	48 85 c0	 test	 rax, rax
  00428	75 e6		 jne	 SHORT $LL17@stbtt__ras
$LN18@stbtt__ras:

; 3267 :         }
; 3268 : 
; 3269 :         ++y;

  0042a	8b 54 24 38	 mov	 edx, DWORD PTR y$1$[rsp]

; 3270 :         ++j;

  0042e	41 ff c5	 inc	 r13d
  00431	ff c2		 inc	 edx
  00433	89 54 24 38	 mov	 DWORD PTR y$1$[rsp], edx
  00437	45 3b 6c 24 04	 cmp	 r13d, DWORD PTR [r12+4]
  0043c	0f 8c 0e fd ff
	ff		 jl	 $LL2@stbtt__ras

; 3199 : 
; 3200 :     while (j < result->h) {

  00442	44 0f 28 ac 24
	80 02 00 00	 movaps	 xmm13, XMMWORD PTR [rsp+640]
  0044b	44 0f 28 a4 24
	90 02 00 00	 movaps	 xmm12, XMMWORD PTR [rsp+656]
  00454	44 0f 28 9c 24
	a0 02 00 00	 movaps	 xmm11, XMMWORD PTR [rsp+672]
  0045d	44 0f 28 94 24
	b0 02 00 00	 movaps	 xmm10, XMMWORD PTR [rsp+688]
  00466	44 0f 28 84 24
	d0 02 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+720]
  0046f	0f 28 bc 24 e0
	02 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+736]
  00477	0f 28 b4 24 f0
	02 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+752]
$LN3@stbtt__ras:
  0047f	44 0f 28 8c 24
	c0 02 00 00	 movaps	 xmm9, XMMWORD PTR [rsp+704]

; 2736 :     while (c) {

  00488	4c 8b b4 24 08
	03 00 00	 mov	 r14, QWORD PTR [rsp+776]
  00490	4c 8b ac 24 10
	03 00 00	 mov	 r13, QWORD PTR [rsp+784]
  00498	4c 8b a4 24 18
	03 00 00	 mov	 r12, QWORD PTR [rsp+792]
  004a0	48 8b bc 24 20
	03 00 00	 mov	 rdi, QWORD PTR [rsp+800]
  004a8	48 8b b4 24 28
	03 00 00	 mov	 rsi, QWORD PTR [rsp+808]
  004b0	48 8b ac 24 30
	03 00 00	 mov	 rbp, QWORD PTR [rsp+816]
  004b8	4d 85 ff	 test	 r15, r15
  004bb	74 29		 je	 SHORT $LN72@stbtt__ras
  004bd	0f 1f 00	 npad	 3
$LL71@stbtt__ras:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  004c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2737 :         stbtt__hheap_chunk* n = c->next;

  004c7	49 8b 1f	 mov	 rbx, QWORD PTR [r15]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  004ca	48 85 c0	 test	 rax, rax
  004cd	74 06		 je	 SHORT $LN76@stbtt__ras

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  004cf	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN76@stbtt__ras:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  004d5	49 8b cf	 mov	 rcx, r15
  004d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2739 :         c = n;

  004de	4c 8b fb	 mov	 r15, rbx
  004e1	48 85 db	 test	 rbx, rbx
  004e4	75 da		 jne	 SHORT $LL71@stbtt__ras
$LN72@stbtt__ras:

; 3271 :     }
; 3272 : 
; 3273 :     stbtt__hheap_cleanup(&hh, userdata);
; 3274 : 
; 3275 :     if (scanline != scanline_data)

  004e6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR scanline$1$[rsp]
  004eb	48 8d 44 24 60	 lea	 rax, QWORD PTR scanline_data$[rsp]
  004f0	4c 8b bc 24 00
	03 00 00	 mov	 r15, QWORD PTR [rsp+768]
  004f8	48 8b 9c 24 58
	03 00 00	 mov	 rbx, QWORD PTR [rsp+856]
  00500	48 3b c8	 cmp	 rcx, rax
  00503	74 1d		 je	 SHORT $LN86@stbtt__ras
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00505	48 85 c9	 test	 rcx, rcx
  00508	74 12		 je	 SHORT $LN84@stbtt__ras

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0050a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00511	48 85 c0	 test	 rax, rax
  00514	74 06		 je	 SHORT $LN84@stbtt__ras

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00516	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN84@stbtt__ras:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0051c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN86@stbtt__ras:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3277 : }

  00522	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0052a	48 33 cc	 xor	 rcx, rsp
  0052d	e8 00 00 00 00	 call	 __security_check_cookie
  00532	48 81 c4 38 03
	00 00		 add	 rsp, 824		; 00000338H
  00539	c3		 ret	 0
?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z ENDP ; stbtt__rasterize_sorted_edges
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
t$1 = 0
__$ArrayPad$ = 24
p$ = 48
n$ = 56
?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_ins_sort

; 3286 :     int i, j;
; 3287 :     for (i = 1; i < n; ++i) {

  00000	83 fa 01	 cmp	 edx, 1
  00003	0f 8e b7 00 00
	00		 jle	 $LN19@stbtt__sor
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 18	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3285 : {

  0001c	4c 8b d9	 mov	 r11, rcx
  0001f	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00024	41 b8 01 00 00
	00		 mov	 r8d, 1
  0002a	4c 8d 49 14	 lea	 r9, QWORD PTR [rcx+20]
  0002e	44 8d 52 ff	 lea	 r10d, DWORD PTR [rdx-1]
  00032	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL4@stbtt__sor:

; 3288 :         stbtt__edge t = p[i], * a = &t;

  00040	41 8b 59 10	 mov	 ebx, DWORD PTR [r9+16]

; 3289 :         j = i;

  00044	49 8b d0	 mov	 rdx, r8
  00047	41 0f 10 11	 movups	 xmm2, XMMWORD PTR [r9]
  0004b	0f 11 14 24	 movups	 XMMWORD PTR t$1[rsp], xmm2

; 3290 :         while (j > 0) {

  0004f	4d 85 c0	 test	 r8, r8
  00052	7e 49		 jle	 SHORT $LN2@stbtt__sor
  00054	f3 0f 10 4c 24
	04		 movss	 xmm1, DWORD PTR t$1[rsp+4]
  0005a	49 8d 49 ec	 lea	 rcx, QWORD PTR [r9-20]
  0005e	66 90		 npad	 2
$LL5@stbtt__sor:

; 3291 :             stbtt__edge* b = &p[j - 1];
; 3292 :             int c = STBTT__COMPARE(a, b);

  00060	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [rcx+4]
  00065	33 c0		 xor	 eax, eax
  00067	0f 2f c1	 comiss	 xmm0, xmm1
  0006a	0f 97 c0	 seta	 al

; 3293 :             if (!c) break;

  0006d	85 c0		 test	 eax, eax
  0006f	74 19		 je	 SHORT $LN12@stbtt__sor

; 3294 :             p[j] = p[j - 1];

  00071	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  00074	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]

; 3295 :             --j;

  00077	48 ff ca	 dec	 rdx
  0007a	0f 11 41 14	 movups	 XMMWORD PTR [rcx+20], xmm0
  0007e	89 41 24	 mov	 DWORD PTR [rcx+36], eax
  00081	48 83 e9 14	 sub	 rcx, 20
  00085	48 85 d2	 test	 rdx, rdx
  00088	7f d6		 jg	 SHORT $LL5@stbtt__sor
$LN12@stbtt__sor:

; 3296 :         }
; 3297 :         if (i != j)

  0008a	4c 3b c2	 cmp	 r8, rdx
  0008d	74 0e		 je	 SHORT $LN2@stbtt__sor

; 3298 :             p[j] = t;

  0008f	48 8d 04 92	 lea	 rax, QWORD PTR [rdx+rdx*4]
  00093	41 0f 11 14 83	 movups	 XMMWORD PTR [r11+rax*4], xmm2
  00098	41 89 5c 83 10	 mov	 DWORD PTR [r11+rax*4+16], ebx
$LN2@stbtt__sor:

; 3286 :     int i, j;
; 3287 :     for (i = 1; i < n; ++i) {

  0009d	49 ff c0	 inc	 r8
  000a0	49 83 c1 14	 add	 r9, 20
  000a4	49 83 ea 01	 sub	 r10, 1
  000a8	75 96		 jne	 SHORT $LL4@stbtt__sor
  000aa	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 3299 :     }
; 3300 : }

  000af	48 8b 4c 24 18	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b4	48 33 cc	 xor	 rcx, rsp
  000b7	e8 00 00 00 00	 call	 __security_check_cookie
  000bc	48 83 c4 28	 add	 rsp, 40			; 00000028H
$LN19@stbtt__sor:
  000c0	c3		 ret	 0
?stbtt__sort_edges_ins_sort@@YAXPEAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_ins_sort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
p$ = 64
n$ = 72
?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_quicksort

; 3304 :     /* threshold for transitioning to insertion sort */
; 3305 :     while (n > 12) {

  00000	83 fa 0c	 cmp	 edx, 12
  00003	0f 8e c8 01 00
	00		 jle	 $LN41@stbtt__sor
  00009	55		 push	 rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 3303 : {

  00014	8b ea		 mov	 ebp, edx
  00016	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0001b	48 8b f1	 mov	 rsi, rcx
  0001e	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
  00023	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@stbtt__sor:

; 3306 :         stbtt__edge t;
; 3307 :         int c01, c12, c, m, i, j;
; 3308 : 
; 3309 :         /* compute median of three */
; 3310 :         m = n >> 1;
; 3311 :         c01 = STBTT__COMPARE(&p[0], &p[m]);

  00030	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [rsi+4]

; 3312 :         c12 = STBTT__COMPARE(&p[m], &p[n - 1]);

  00035	8d 7d ff	 lea	 edi, DWORD PTR [rbp-1]
  00038	33 d2		 xor	 edx, edx
  0003a	8b c5		 mov	 eax, ebp
  0003c	48 d1 e8	 shr	 rax, 1
  0003f	4c 8b fe	 mov	 r15, rsi
  00042	44 8b cd	 mov	 r9d, ebp
  00045	4c 8b f6	 mov	 r14, rsi
  00048	49 ff c9	 dec	 r9
  0004b	4c 8d 04 80	 lea	 r8, QWORD PTR [rax+rax*4]
  0004f	f3 42 0f 10 44
	86 04		 movss	 xmm0, DWORD PTR [rsi+r8*4+4]
  00056	4b 8d 04 89	 lea	 rax, QWORD PTR [r9+r9*4]
  0005a	f3 0f 10 4c 86
	04		 movss	 xmm1, DWORD PTR [rsi+rax*4+4]
  00060	0f 2f c8	 comiss	 xmm1, xmm0
  00063	0f 97 c2	 seta	 dl
  00066	33 c0		 xor	 eax, eax
  00068	0f 2f c2	 comiss	 xmm0, xmm2
  0006b	0f 97 c0	 seta	 al

; 3313 :         /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
; 3314 :         if (c01 != c12) {

  0006e	3b c2		 cmp	 eax, edx
  00070	74 39		 je	 SHORT $LN13@stbtt__sor

; 3315 :             /* otherwise, we'll need to swap something else to middle */
; 3316 :             int z;
; 3317 :             c = STBTT__COMPARE(&p[0], &p[n - 1]);
; 3318 :             /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
; 3319 :             /* 0<mid && mid>n:  0>n => 0; 0<n => n */
; 3320 :             z = (c == c12) ? 0 : n - 1;
; 3321 :             t = p[z];
; 3322 :             p[z] = p[m];

  00072	42 0f 10 04 86	 movups	 xmm0, XMMWORD PTR [rsi+r8*4]
  00077	33 c9		 xor	 ecx, ecx
  00079	0f 2f ca	 comiss	 xmm1, xmm2
  0007c	0f 97 c1	 seta	 cl
  0007f	33 c0		 xor	 eax, eax
  00081	3b ca		 cmp	 ecx, edx
  00083	0f 45 c7	 cmovne	 eax, edi
  00086	48 98		 cdqe
  00088	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  0008c	0f 10 0c 8e	 movups	 xmm1, XMMWORD PTR [rsi+rcx*4]
  00090	8b 54 8e 10	 mov	 edx, DWORD PTR [rsi+rcx*4+16]
  00094	0f 11 04 8e	 movups	 XMMWORD PTR [rsi+rcx*4], xmm0
  00098	42 8b 44 86 10	 mov	 eax, DWORD PTR [rsi+r8*4+16]
  0009d	89 44 8e 10	 mov	 DWORD PTR [rsi+rcx*4+16], eax

; 3323 :             p[m] = t;

  000a1	42 0f 11 0c 86	 movups	 XMMWORD PTR [rsi+r8*4], xmm1
  000a6	42 89 54 86 10	 mov	 DWORD PTR [rsi+r8*4+16], edx
$LN13@stbtt__sor:

; 3324 :         }
; 3325 :         /* now p[m] is the median-of-three */
; 3326 :         /* swap it to the beginning so it won't move around */
; 3327 :         t = p[0];
; 3328 :         p[0] = p[m];

  000ab	42 0f 10 04 86	 movups	 xmm0, XMMWORD PTR [rsi+r8*4]
  000b0	8b 4e 10	 mov	 ecx, DWORD PTR [rsi+16]

; 3329 :         p[m] = t;
; 3330 : 
; 3331 :         /* partition loop */
; 3332 :         i = 1;

  000b3	41 bb 01 00 00
	00		 mov	 r11d, 1
  000b9	0f 10 0e	 movups	 xmm1, XMMWORD PTR [rsi]
  000bc	45 8b d3	 mov	 r10d, r11d
  000bf	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0
  000c2	42 8b 44 86 10	 mov	 eax, DWORD PTR [rsi+r8*4+16]
  000c7	89 46 10	 mov	 DWORD PTR [rsi+16], eax
  000ca	42 0f 11 0c 86	 movups	 XMMWORD PTR [rsi+r8*4], xmm1
  000cf	42 89 4c 86 10	 mov	 DWORD PTR [rsi+r8*4+16], ecx
  000d4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@stbtt__sor:

; 3338 :                 if (!STBTT__COMPARE(&p[i], &p[0])) break;

  000e0	f3 0f 10 4e 04	 movss	 xmm1, DWORD PTR [rsi+4]
  000e5	4a 8d 0c 95 01
	00 00 00	 lea	 rcx, QWORD PTR [r10*4+1]
  000ed	49 03 ca	 add	 rcx, r10
  000f0	0f 2f 0c 8e	 comiss	 xmm1, DWORD PTR [rsi+rcx*4]
  000f4	48 8d 0c 8e	 lea	 rcx, QWORD PTR [rsi+rcx*4]
  000f8	76 15		 jbe	 SHORT $LN28@stbtt__sor
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL9@stbtt__sor:

; 3333 :         j = n - 1;
; 3334 :         for (;;) {
; 3335 :             /* handling of equality is crucial here */
; 3336 :             /* for sentinels & efficiency with duplicates */
; 3337 :             for (;; ++i) {

  00100	41 ff c3	 inc	 r11d
  00103	48 8d 49 14	 lea	 rcx, QWORD PTR [rcx+20]
  00107	49 ff c2	 inc	 r10

; 3338 :                 if (!STBTT__COMPARE(&p[i], &p[0])) break;

  0010a	0f 2f 09	 comiss	 xmm1, DWORD PTR [rcx]
  0010d	77 f1		 ja	 SHORT $LL9@stbtt__sor
$LN28@stbtt__sor:

; 3339 :             }
; 3340 :             for (;; --j) {
; 3341 :                 if (!STBTT__COMPARE(&p[0], &p[j])) break;

  0010f	4a 8d 0c 8d 01
	00 00 00	 lea	 rcx, QWORD PTR [r9*4+1]
  00117	49 03 c9	 add	 rcx, r9
  0011a	f3 0f 10 04 8e	 movss	 xmm0, DWORD PTR [rsi+rcx*4]
  0011f	48 8d 0c 8e	 lea	 rcx, QWORD PTR [rsi+rcx*4]
  00123	0f 2f c1	 comiss	 xmm0, xmm1
  00126	76 1b		 jbe	 SHORT $LN29@stbtt__sor
  00128	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL12@stbtt__sor:
  00130	f3 0f 10 41 ec	 movss	 xmm0, DWORD PTR [rcx-20]
  00135	48 8d 49 ec	 lea	 rcx, QWORD PTR [rcx-20]
  00139	ff cf		 dec	 edi
  0013b	49 ff c9	 dec	 r9
  0013e	0f 2f c1	 comiss	 xmm0, xmm1
  00141	77 ed		 ja	 SHORT $LL12@stbtt__sor
$LN29@stbtt__sor:

; 3342 :             }
; 3343 :             /* make sure we haven't crossed */
; 3344 :             if (i >= j) break;

  00143	4d 3b d1	 cmp	 r10, r9
  00146	7d 3a		 jge	 SHORT $LN30@stbtt__sor

; 3345 :             t = p[i];
; 3346 :             p[i] = p[j];

  00148	4b 8d 0c 89	 lea	 rcx, QWORD PTR [r9+r9*4]

; 3347 :             p[j] = t;
; 3348 : 
; 3349 :             ++i;

  0014c	41 ff c3	 inc	 r11d
  0014f	0f 10 04 8e	 movups	 xmm0, XMMWORD PTR [rsi+rcx*4]
  00153	4b 8d 14 92	 lea	 rdx, QWORD PTR [r10+r10*4]

; 3350 :             --j;

  00157	ff cf		 dec	 edi
  00159	0f 10 0c 96	 movups	 xmm1, XMMWORD PTR [rsi+rdx*4]
  0015d	44 8b 44 96 10	 mov	 r8d, DWORD PTR [rsi+rdx*4+16]
  00162	49 ff c2	 inc	 r10
  00165	0f 11 04 96	 movups	 XMMWORD PTR [rsi+rdx*4], xmm0
  00169	8b 44 8e 10	 mov	 eax, DWORD PTR [rsi+rcx*4+16]
  0016d	49 ff c9	 dec	 r9
  00170	89 44 96 10	 mov	 DWORD PTR [rsi+rdx*4+16], eax
  00174	0f 11 0c 8e	 movups	 XMMWORD PTR [rsi+rcx*4], xmm1
  00178	44 89 44 8e 10	 mov	 DWORD PTR [rsi+rcx*4+16], r8d
  0017d	e9 5e ff ff ff	 jmp	 $LL4@stbtt__sor
$LN30@stbtt__sor:

; 3351 :         }
; 3352 :         /* recurse on smaller side, iterate on larger */
; 3353 :         if (j < (n - i)) {

  00182	41 2b eb	 sub	 ebp, r11d
  00185	49 63 c3	 movsxd	 rax, r11d
  00188	3b fd		 cmp	 edi, ebp
  0018a	8b dd		 mov	 ebx, ebp
  0018c	8b d7		 mov	 edx, edi
  0018e	0f 4d d3	 cmovge	 edx, ebx
  00191	0f 4d ef	 cmovge	 ebp, edi
  00194	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00198	48 8d 34 8e	 lea	 rsi, QWORD PTR [rsi+rcx*4]
  0019c	4c 0f 4d f6	 cmovge	 r14, rsi
  001a0	49 8b ce	 mov	 rcx, r14
  001a3	e8 00 00 00 00	 call	 ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort
  001a8	3b fb		 cmp	 edi, ebx
  001aa	49 0f 4d f7	 cmovge	 rsi, r15
  001ae	83 fd 0c	 cmp	 ebp, 12
  001b1	0f 8f 79 fe ff
	ff		 jg	 $LL2@stbtt__sor

; 3304 :     /* threshold for transitioning to insertion sort */
; 3305 :     while (n > 12) {

  001b7	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  001bc	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]
  001c1	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  001c6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 3354 :             stbtt__sort_edges_quicksort(p, j);
; 3355 :             p = p + i;
; 3356 :             n = n - i;
; 3357 :         }
; 3358 :         else {
; 3359 :             stbtt__sort_edges_quicksort(p + i, n - i);
; 3360 :             n = j;
; 3361 :         }
; 3362 :     }
; 3363 : }

  001cb	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001cf	5e		 pop	 rsi
  001d0	5d		 pop	 rbp
$LN41@stbtt__sor:
  001d1	c3		 ret	 0
?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_quicksort
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
t$1 = 32
__$ArrayPad$ = 56
p$ = 80
n$ = 88
?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z PROC	; stbtt__sort_edges

; 3366 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00019	48 63 da	 movsxd	 rbx, edx
  0001c	48 8b f9	 mov	 rdi, rcx

; 3367 :     stbtt__sort_edges_quicksort(p, n);

  0001f	8b d3		 mov	 edx, ebx
  00021	e8 00 00 00 00	 call	 ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3287 :     for (i = 1; i < n; ++i) {

  00026	48 83 fb 01	 cmp	 rbx, 1
  0002a	7e 7c		 jle	 SHORT $LN5@stbtt__sor
  0002c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00032	4c 8d 4f 14	 lea	 r9, QWORD PTR [rdi+20]
  00036	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL6@stbtt__sor:

; 3288 :         stbtt__edge t = p[i], * a = &t;

  00040	41 0f 10 11	 movups	 xmm2, XMMWORD PTR [r9]
  00044	45 8b 59 10	 mov	 r11d, DWORD PTR [r9+16]
  00048	49 8d 49 ec	 lea	 rcx, QWORD PTR [r9-20]

; 3289 :         j = i;

  0004c	49 8b d0	 mov	 rdx, r8
  0004f	0f 11 54 24 20	 movups	 XMMWORD PTR t$1[rsp], xmm2
  00054	f3 0f 10 4c 24
	24		 movss	 xmm1, DWORD PTR t$1[rsp+4]
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL7@stbtt__sor:

; 3290 :         while (j > 0) {
; 3291 :             stbtt__edge* b = &p[j - 1];
; 3292 :             int c = STBTT__COMPARE(a, b);

  00060	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [rcx+4]
  00065	33 c0		 xor	 eax, eax
  00067	0f 2f c1	 comiss	 xmm0, xmm1
  0006a	0f 97 c0	 seta	 al

; 3293 :             if (!c) break;

  0006d	85 c0		 test	 eax, eax
  0006f	74 19		 je	 SHORT $LN14@stbtt__sor

; 3294 :             p[j] = p[j - 1];

  00071	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  00074	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]

; 3295 :             --j;

  00077	48 ff ca	 dec	 rdx
  0007a	0f 11 41 14	 movups	 XMMWORD PTR [rcx+20], xmm0
  0007e	89 41 24	 mov	 DWORD PTR [rcx+36], eax
  00081	48 83 e9 14	 sub	 rcx, 20
  00085	48 85 d2	 test	 rdx, rdx
  00088	7f d6		 jg	 SHORT $LL7@stbtt__sor
$LN14@stbtt__sor:

; 3296 :         }
; 3297 :         if (i != j)

  0008a	4c 3b c2	 cmp	 r8, rdx
  0008d	74 0d		 je	 SHORT $LN4@stbtt__sor

; 3298 :             p[j] = t;

  0008f	48 8d 04 92	 lea	 rax, QWORD PTR [rdx+rdx*4]
  00093	0f 11 14 87	 movups	 XMMWORD PTR [rdi+rax*4], xmm2
  00097	44 89 5c 87 10	 mov	 DWORD PTR [rdi+rax*4+16], r11d
$LN4@stbtt__sor:

; 3287 :     for (i = 1; i < n; ++i) {

  0009c	49 ff c0	 inc	 r8
  0009f	49 83 c1 14	 add	 r9, 20
  000a3	4c 3b c3	 cmp	 r8, rbx
  000a6	7c 98		 jl	 SHORT $LL6@stbtt__sor
$LN5@stbtt__sor:

; 3368 :     stbtt__sort_edges_ins_sort(p, n);
; 3369 : }

  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ad	48 33 cc	 xor	 rcx, rsp
  000b0	e8 00 00 00 00	 call	 __security_check_cookie
  000b5	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000ba	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
?stbtt__sort_edges@@YAXPEAUstbtt__edge@@H@Z ENDP	; stbtt__sort_edges
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
pts$1$ = 64
result$GSCopy$1$ = 72
t$1 = 80
__$ArrayPad$ = 104
result$ = 192
pts$ = 200
wcount$ = 208
windings$ = 216
scale_x$ = 224
scale_y$ = 232
shift_x$ = 240
shift_y$ = 248
off_x$ = 256
off_y$ = 264
invert$dead$ = 272
userdata$dead$ = 280
?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z PROC ; stbtt__rasterize

; 3377 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 56		 push	 r14
  00006	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000d	0f 29 74 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm6
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3378 :     float y_scale_inv = invert ? -scale_y : scale_y;

  00021	f3 0f 10 b4 24
	e8 00 00 00	 movss	 xmm6, DWORD PTR scale_y$[rsp]
  0002a	4c 8b f1	 mov	 r14, rcx
  0002d	0f 57 35 00 00
	00 00		 xorps	 xmm6, DWORD PTR __xmm@80000000800000008000000080000000

; 3385 : #else
; 3386 : #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
; 3387 : #endif
; 3388 :     // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
; 3389 : 
; 3390 :     // now we have to blow out the windings into explicit edge lists
; 3391 :     n = 0;

  00034	45 33 d2	 xor	 r10d, r10d
  00037	48 89 4c 24 48	 mov	 QWORD PTR result$GSCopy$1$[rsp], rcx
  0003c	49 8b d8	 mov	 rbx, r8
  0003f	33 c9		 xor	 ecx, ecx
  00041	41 8b f9	 mov	 edi, r9d
  00044	48 89 54 24 40	 mov	 QWORD PTR pts$1$[rsp], rdx

; 3392 :     for (i = 0; i < windings; ++i)

  00049	45 85 c9	 test	 r9d, r9d
  0004c	7e 58		 jle	 SHORT $LN57@stbtt__ras
  0004e	83 ff 08	 cmp	 edi, 8
  00051	72 53		 jb	 SHORT $LN57@stbtt__ras

; 3379 :     stbtt__edge* e;
; 3380 :     int n, i, j, k, m;
; 3381 : #if STBTT_RASTERIZER_VERSION == 1
; 3382 :     int vsubsample = result->h < 8 ? 15 : 5;
; 3383 : #elif STBTT_RASTERIZER_VERSION == 2
; 3384 :     int vsubsample = 1;

  00053	48 63 d7	 movsxd	 rdx, edi
  00056	0f 57 d2	 xorps	 xmm2, xmm2
  00059	48 83 e2 f8	 and	 rdx, -8
  0005d	0f 57 c9	 xorps	 xmm1, xmm1

; 3392 :     for (i = 0; i < windings; ++i)

  00060	33 c0		 xor	 eax, eax
$LL4@stbtt__ras:

; 3393 :         n += wcount[i];

  00062	f3 41 0f 6f 04
	80		 movdqu	 xmm0, XMMWORD PTR [r8+rax*4]
  00068	83 c1 08	 add	 ecx, 8
  0006b	66 0f fe d0	 paddd	 xmm2, xmm0
  0006f	f3 41 0f 6f 44
	80 10		 movdqu	 xmm0, XMMWORD PTR [r8+rax*4+16]
  00076	48 83 c0 08	 add	 rax, 8
  0007a	66 0f fe c8	 paddd	 xmm1, xmm0
  0007e	48 3b c2	 cmp	 rax, rdx
  00081	7c df		 jl	 SHORT $LL4@stbtt__ras

; 3379 :     stbtt__edge* e;
; 3380 :     int n, i, j, k, m;
; 3381 : #if STBTT_RASTERIZER_VERSION == 1
; 3382 :     int vsubsample = result->h < 8 ? 15 : 5;
; 3383 : #elif STBTT_RASTERIZER_VERSION == 2
; 3384 :     int vsubsample = 1;

  00083	66 0f fe ca	 paddd	 xmm1, xmm2
  00087	66 0f 6f c1	 movdqa	 xmm0, xmm1
  0008b	66 0f 73 d8 08	 psrldq	 xmm0, 8
  00090	66 0f fe c8	 paddd	 xmm1, xmm0
  00094	66 0f 6f c1	 movdqa	 xmm0, xmm1
  00098	66 0f 73 d8 04	 psrldq	 xmm0, 4
  0009d	66 0f fe c8	 paddd	 xmm1, xmm0
  000a1	66 41 0f 7e ca	 movd	 r10d, xmm1
$LN57@stbtt__ras:
  000a6	33 d2		 xor	 edx, edx
  000a8	48 63 c9	 movsxd	 rcx, ecx
  000ab	45 33 c0	 xor	 r8d, r8d

; 3392 :     for (i = 0; i < windings; ++i)

  000ae	4c 63 cf	 movsxd	 r9, edi
  000b1	49 3b c9	 cmp	 rcx, r9
  000b4	7d 3b		 jge	 SHORT $LN65@stbtt__ras
  000b6	49 8b c1	 mov	 rax, r9
  000b9	48 2b c1	 sub	 rax, rcx
  000bc	48 83 f8 02	 cmp	 rax, 2
  000c0	7c 24		 jl	 SHORT $LN77@stbtt__ras
  000c2	4d 8d 59 ff	 lea	 r11, QWORD PTR [r9-1]
  000c6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL68@stbtt__ras:

; 3393 :         n += wcount[i];

  000d0	03 14 8b	 add	 edx, DWORD PTR [rbx+rcx*4]
  000d3	44 03 44 8b 04	 add	 r8d, DWORD PTR [rbx+rcx*4+4]
  000d8	48 83 c1 02	 add	 rcx, 2
  000dc	49 3b cb	 cmp	 rcx, r11
  000df	7c ef		 jl	 SHORT $LL68@stbtt__ras

; 3392 :     for (i = 0; i < windings; ++i)

  000e1	49 3b c9	 cmp	 rcx, r9
  000e4	7d 04		 jge	 SHORT $LN67@stbtt__ras
$LN77@stbtt__ras:

; 3393 :         n += wcount[i];

  000e6	44 03 14 8b	 add	 r10d, DWORD PTR [rbx+rcx*4]
$LN67@stbtt__ras:
  000ea	41 8d 04 10	 lea	 eax, DWORD PTR [r8+rdx]
  000ee	44 03 d0	 add	 r10d, eax
$LN65@stbtt__ras:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  000f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000f8	48 85 c0	 test	 rax, rax
  000fb	74 06		 je	 SHORT $LN20@stbtt__ras

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  000fd	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN20@stbtt__ras:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3395 :     e = (stbtt__edge*)STBTT_malloc(sizeof(*e) * (n + 1), userdata); // add an extra one as a sentinel

  00103	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  00107	48 63 c8	 movsxd	 rcx, eax
  0010a	48 8d 0c 89	 lea	 rcx, QWORD PTR [rcx+rcx*4]
  0010e	48 c1 e1 02	 shl	 rcx, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00118	48 8b e8	 mov	 rbp, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3396 :     if (e == 0) return;

  0011b	48 85 c0	 test	 rax, rax
  0011e	0f 84 44 02 00
	00		 je	 $LN41@stbtt__ras

; 3397 :     n = 0;

  00124	48 89 b4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rsi
  0012c	4c 89 a4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r12
  00134	45 33 e4	 xor	 r12d, r12d
  00137	4c 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r15

; 3398 : 
; 3399 :     m = 0;

  0013f	45 33 ff	 xor	 r15d, r15d

; 3400 :     for (i = 0; i < windings; ++i) {

  00142	41 8d 74 24 01	 lea	 esi, QWORD PTR [r12+1]
  00147	85 ff		 test	 edi, edi
  00149	0f 8e 34 01 00
	00		 jle	 $LN6@stbtt__ras
  0014f	f3 0f 10 94 24
	f8 00 00 00	 movss	 xmm2, DWORD PTR shift_y$[rsp]
  00158	45 33 f6	 xor	 r14d, r14d
  0015b	f3 0f 10 9c 24
	f0 00 00 00	 movss	 xmm3, DWORD PTR shift_x$[rsp]
  00164	f3 0f 10 a4 24
	e0 00 00 00	 movss	 xmm4, DWORD PTR scale_x$[rsp]
  0016d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pts$1$[rsp]
  00172	4c 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], r13
  0017a	4c 8b ef	 mov	 r13, rdi
  0017d	0f 1f 00	 npad	 3
$LL7@stbtt__ras:

; 3401 :         stbtt__point* p = pts + m;

  00180	49 63 c7	 movsxd	 rax, r15d

; 3404 :         for (k = 0; k < wcount[i]; j = k++) {

  00183	45 33 db	 xor	 r11d, r11d
  00186	33 d2		 xor	 edx, edx
  00188	4c 8d 14 c1	 lea	 r10, QWORD PTR [rcx+rax*8]
  0018c	8b 03		 mov	 eax, DWORD PTR [rbx]
  0018e	44 03 f8	 add	 r15d, eax
  00191	85 c0		 test	 eax, eax
  00193	0f 8e d0 00 00
	00		 jle	 $LN5@stbtt__ras

; 3402 :         m += wcount[i];
; 3403 :         j = wcount[i] - 1;

  00199	ff c8		 dec	 eax
  0019b	4d 8d 42 04	 lea	 r8, QWORD PTR [r10+4]
  0019f	48 63 c8	 movsxd	 rcx, eax
  001a2	4b 8d 04 b6	 lea	 rax, QWORD PTR [r14+r14*4]
  001a6	4c 8d 0c 85 10
	00 00 00	 lea	 r9, QWORD PTR [rax*4+16]
  001ae	4c 03 cd	 add	 r9, rbp
  001b1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL10@stbtt__ras:

; 3405 :             int a = k, b = j;
; 3406 :             // skip the edge if horizontal
; 3407 :             if (p[j].y == p[k].y)

  001c0	f3 41 0f 10 44
	ca 04		 movss	 xmm0, DWORD PTR [r10+rcx*8+4]
  001c7	48 8b fa	 mov	 rdi, rdx
  001ca	41 0f 2e 00	 ucomiss xmm0, DWORD PTR [r8]
  001ce	7a 02		 jp	 SHORT $LN78@stbtt__ras
  001d0	74 7c		 je	 SHORT $LN8@stbtt__ras
$LN78@stbtt__ras:

; 3408 :                 continue;
; 3409 :             // add edge from j to k to the list
; 3410 :             e[n].invert = 0;
; 3411 :             if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {

  001d2	33 c0		 xor	 eax, eax
  001d4	41 c7 01 00 00
	00 00		 mov	 DWORD PTR [r9], 0
  001db	f3 41 0f 10 44
	ca 04		 movss	 xmm0, DWORD PTR [r10+rcx*8+4]
  001e2	41 0f 2f 00	 comiss	 xmm0, DWORD PTR [r8]
  001e6	0f 97 c0	 seta	 al
  001e9	85 c0		 test	 eax, eax
  001eb	74 09		 je	 SHORT $LN13@stbtt__ras

; 3412 :                 e[n].invert = 1;
; 3413 :                 a = j, b = k;

  001ed	48 8b f9	 mov	 rdi, rcx
  001f0	41 89 31	 mov	 DWORD PTR [r9], esi
  001f3	48 8b ca	 mov	 rcx, rdx
$LN13@stbtt__ras:

; 3414 :             }
; 3415 :             e[n].x0 = p[a].x * scale_x + shift_x;

  001f6	0f 28 c4	 movaps	 xmm0, xmm4

; 3416 :             e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;

  001f9	0f 28 ce	 movaps	 xmm1, xmm6
  001fc	f3 41 0f 59 04
	fa		 mulss	 xmm0, DWORD PTR [r10+rdi*8]

; 3417 :             e[n].x1 = p[b].x * scale_x + shift_x;
; 3418 :             e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
; 3419 :             ++n;

  00202	41 ff c4	 inc	 r12d
  00205	49 ff c6	 inc	 r14
  00208	f3 0f 58 c3	 addss	 xmm0, xmm3
  0020c	f3 41 0f 11 41
	f0		 movss	 DWORD PTR [r9-16], xmm0
  00212	0f 28 c4	 movaps	 xmm0, xmm4
  00215	f3 41 0f 59 4c
	fa 04		 mulss	 xmm1, DWORD PTR [r10+rdi*8+4]
  0021c	f3 0f 58 ca	 addss	 xmm1, xmm2
  00220	f3 41 0f 11 49
	f4		 movss	 DWORD PTR [r9-12], xmm1
  00226	0f 28 ce	 movaps	 xmm1, xmm6
  00229	f3 41 0f 59 04
	ca		 mulss	 xmm0, DWORD PTR [r10+rcx*8]
  0022f	f3 0f 58 c3	 addss	 xmm0, xmm3
  00233	f3 41 0f 11 41
	f8		 movss	 DWORD PTR [r9-8], xmm0
  00239	f3 41 0f 59 4c
	ca 04		 mulss	 xmm1, DWORD PTR [r10+rcx*8+4]
  00240	f3 0f 58 ca	 addss	 xmm1, xmm2
  00244	f3 41 0f 11 49
	fc		 movss	 DWORD PTR [r9-4], xmm1
  0024a	49 83 c1 14	 add	 r9, 20
$LN8@stbtt__ras:

; 3404 :         for (k = 0; k < wcount[i]; j = k++) {

  0024e	48 8b ca	 mov	 rcx, rdx
  00251	41 ff c3	 inc	 r11d
  00254	48 ff c2	 inc	 rdx
  00257	49 83 c0 08	 add	 r8, 8
  0025b	44 3b 1b	 cmp	 r11d, DWORD PTR [rbx]
  0025e	0f 8c 5c ff ff
	ff		 jl	 $LL10@stbtt__ras
  00264	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pts$1$[rsp]
$LN5@stbtt__ras:

; 3400 :     for (i = 0; i < windings; ++i) {

  00269	48 83 c3 04	 add	 rbx, 4
  0026d	4c 2b ee	 sub	 r13, rsi
  00270	0f 85 0a ff ff
	ff		 jne	 $LL7@stbtt__ras
  00276	4c 8b 74 24 48	 mov	 r14, QWORD PTR result$GSCopy$1$[rsp]
  0027b	4c 8b ac 24 88
	00 00 00	 mov	 r13, QWORD PTR [rsp+136]
$LN6@stbtt__ras:

; 3367 :     stbtt__sort_edges_quicksort(p, n);

  00283	41 8b d4	 mov	 edx, r12d
  00286	48 8b cd	 mov	 rcx, rbp
  00289	e8 00 00 00 00	 call	 ?stbtt__sort_edges_quicksort@@YAXPEAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 3287 :     for (i = 1; i < n; ++i) {

  0028e	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR [rsp+128]
  00296	4d 63 dc	 movsxd	 r11, r12d
  00299	4c 3b de	 cmp	 r11, rsi
  0029c	7e 7b		 jle	 SHORT $LN30@stbtt__ras
  0029e	4c 8d 4d 14	 lea	 r9, QWORD PTR [rbp+20]
  002a2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL31@stbtt__ras:

; 3288 :         stbtt__edge t = p[i], * a = &t;

  002b0	41 0f 10 11	 movups	 xmm2, XMMWORD PTR [r9]
  002b4	45 8b 51 10	 mov	 r10d, DWORD PTR [r9+16]
  002b8	49 8d 49 ec	 lea	 rcx, QWORD PTR [r9-20]

; 3289 :         j = i;

  002bc	48 8b d6	 mov	 rdx, rsi
  002bf	0f 11 54 24 50	 movups	 XMMWORD PTR t$1[rsp], xmm2
  002c4	f3 0f 10 4c 24
	54		 movss	 xmm1, DWORD PTR t$1[rsp+4]
  002ca	66 0f 1f 44 00
	00		 npad	 6
$LL32@stbtt__ras:

; 3290 :         while (j > 0) {
; 3291 :             stbtt__edge* b = &p[j - 1];
; 3292 :             int c = STBTT__COMPARE(a, b);

  002d0	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [rcx+4]
  002d5	33 c0		 xor	 eax, eax
  002d7	0f 2f c1	 comiss	 xmm0, xmm1
  002da	0f 97 c0	 seta	 al

; 3293 :             if (!c) break;

  002dd	85 c0		 test	 eax, eax
  002df	74 19		 je	 SHORT $LN50@stbtt__ras

; 3294 :             p[j] = p[j - 1];

  002e1	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]
  002e4	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]

; 3295 :             --j;

  002e7	48 ff ca	 dec	 rdx
  002ea	0f 11 41 14	 movups	 XMMWORD PTR [rcx+20], xmm0
  002ee	89 41 24	 mov	 DWORD PTR [rcx+36], eax
  002f1	48 83 e9 14	 sub	 rcx, 20
  002f5	48 85 d2	 test	 rdx, rdx
  002f8	7f d6		 jg	 SHORT $LL32@stbtt__ras
$LN50@stbtt__ras:

; 3296 :         }
; 3297 :         if (i != j)

  002fa	48 3b f2	 cmp	 rsi, rdx
  002fd	74 0e		 je	 SHORT $LN29@stbtt__ras

; 3298 :             p[j] = t;

  002ff	48 8d 04 92	 lea	 rax, QWORD PTR [rdx+rdx*4]
  00303	0f 11 54 85 00	 movups	 XMMWORD PTR [rbp+rax*4], xmm2
  00308	44 89 54 85 10	 mov	 DWORD PTR [rbp+rax*4+16], r10d
$LN29@stbtt__ras:

; 3287 :     for (i = 1; i < n; ++i) {

  0030d	48 ff c6	 inc	 rsi
  00310	49 83 c1 14	 add	 r9, 20
  00314	49 3b f3	 cmp	 rsi, r11
  00317	7c 97		 jl	 SHORT $LL31@stbtt__ras
$LN30@stbtt__ras:

; 3420 :         }
; 3421 :     }
; 3422 : 
; 3423 :     // now sort the edges by their highest point (should snap to integer, and then by x)
; 3424 :     //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
; 3425 :     stbtt__sort_edges(e, n);
; 3426 : 
; 3427 :     // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
; 3428 :     stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

  00319	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR off_y$[rsp]
  00320	45 8b c4	 mov	 r8d, r12d
  00323	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00327	48 8b d5	 mov	 rdx, rbp
  0032a	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR off_x$[rsp]
  00331	49 8b ce	 mov	 rcx, r14
  00334	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00338	e8 00 00 00 00	 call	 ?stbtt__rasterize_sorted_edges@@YAXPEAUstbtt__bitmap@@PEAUstbtt__edge@@HHHHPEAX@Z ; stbtt__rasterize_sorted_edges
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0033d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00344	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR [rsp+144]
  0034c	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+200]
  00354	48 85 c0	 test	 rax, rax
  00357	74 06		 je	 SHORT $LN39@stbtt__ras

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00359	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN39@stbtt__ras:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0035f	48 8b cd	 mov	 rcx, rbp
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN41@stbtt__ras:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3431 : }

  00368	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0036d	48 33 cc	 xor	 rcx, rsp
  00370	e8 00 00 00 00	 call	 __security_check_cookie
  00375	0f 28 74 24 70	 movaps	 xmm6, XMMWORD PTR [rsp+112]
  0037a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00381	41 5e		 pop	 r14
  00383	5f		 pop	 rdi
  00384	5d		 pop	 rbp
  00385	5b		 pop	 rbx
  00386	c3		 ret	 0
?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ENDP ; stbtt__rasterize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
points$ = 8
n$ = 16
x$ = 24
y$ = 32
?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z PROC	; stbtt__add_point

; 3435 :     if (!points) return; // during first pass, it's unallocated

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 0e		 je	 SHORT $LN1@stbtt__add

; 3436 :     points[n].x = x;

  00005	48 63 c2	 movsxd	 rax, edx
  00008	f3 0f 11 14 c1	 movss	 DWORD PTR [rcx+rax*8], xmm2

; 3437 :     points[n].y = y;

  0000d	f3 0f 11 5c c1
	04		 movss	 DWORD PTR [rcx+rax*8+4], xmm3
$LN1@stbtt__add:

; 3438 : }

  00013	c3		 ret	 0
?stbtt__add_point@@YAXPEAUstbtt__point@@HMM@Z ENDP	; stbtt__add_point
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
points$ = 224
num_points$ = 232
x0$ = 240
y0$ = 248
x1$ = 256
y1$ = 264
x2$ = 272
y2$ = 280
objspace_flatness_squared$ = 288
n$ = 296
?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z PROC ; stbtt__tesselate_curve

; 3442 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 3443 :     // midpoint
; 3444 :     float mx = (x0 + 2 * x1 + x2) / 4;
; 3445 :     float my = (y0 + 2 * y1 + y2) / 4;
; 3446 :     // versus directly drawn line
; 3447 :     float dx = (x0 + x2) / 2 - mx;
; 3448 :     float dy = (y0 + y2) / 2 - my;
; 3449 :     if (n > 16) // 65536 segments on one curve better be enough!

  00013	8b 9c 24 28 01
	00 00		 mov	 ebx, DWORD PTR n$[rsp]
  0001a	0f 28 ca	 movaps	 xmm1, xmm2
  0001d	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  00021	0f 28 c3	 movaps	 xmm0, xmm3
  00024	f3 0f 10 b4 24
	10 01 00 00	 movss	 xmm6, DWORD PTR x2$[rsp]
  0002d	48 8b f2	 mov	 rsi, rdx
  00030	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  00034	f3 0f 58 ce	 addss	 xmm1, xmm6
  00038	f3 0f 10 bc 24
	18 01 00 00	 movss	 xmm7, DWORD PTR y2$[rsp]
  00041	48 8b f9	 mov	 rdi, rcx
  00044	44 0f 29 48 b8	 movaps	 XMMWORD PTR [rax-72], xmm9
  00049	f3 0f 58 c7	 addss	 xmm0, xmm7
  0004d	44 0f 29 50 a8	 movaps	 XMMWORD PTR [rax-88], xmm10
  00052	44 0f 29 58 98	 movaps	 XMMWORD PTR [rax-104], xmm11
  00057	f3 44 0f 10 9c
	24 00 01 00 00	 movss	 xmm11, DWORD PTR x1$[rsp]
  00061	44 0f 29 60 88	 movaps	 XMMWORD PTR [rax-120], xmm12
  00066	45 0f 28 cb	 movaps	 xmm9, xmm11
  0006a	f3 44 0f 10 a4
	24 08 01 00 00	 movss	 xmm12, DWORD PTR y1$[rsp]
  00074	f3 45 0f 58 cb	 addss	 xmm9, xmm11
  00079	44 0f 29 6c 24
	50		 movaps	 XMMWORD PTR [rsp+80], xmm13
  0007f	45 0f 28 d4	 movaps	 xmm10, xmm12
  00083	f3 44 0f 10 2d
	00 00 00 00	 movss	 xmm13, DWORD PTR __real@3f000000
  0008c	f3 45 0f 58 d4	 addss	 xmm10, xmm12
  00091	f3 41 0f 59 cd	 mulss	 xmm1, xmm13
  00096	f3 41 0f 59 c5	 mulss	 xmm0, xmm13
  0009b	f3 44 0f 58 ca	 addss	 xmm9, xmm2
  000a0	f3 44 0f 58 d3	 addss	 xmm10, xmm3
  000a5	f3 44 0f 58 ce	 addss	 xmm9, xmm6
  000aa	f3 44 0f 58 d7	 addss	 xmm10, xmm7
  000af	f3 44 0f 59 0d
	00 00 00 00	 mulss	 xmm9, DWORD PTR __real@3e800000
  000b8	f3 44 0f 59 15
	00 00 00 00	 mulss	 xmm10, DWORD PTR __real@3e800000
  000c1	f3 41 0f 5c c9	 subss	 xmm1, xmm9
  000c6	f3 41 0f 5c c2	 subss	 xmm0, xmm10
  000cb	83 fb 10	 cmp	 ebx, 16
  000ce	0f 8f da 00 00
	00		 jg	 $LN9@stbtt__tes

; 3450 :         return 1;
; 3451 :     if (dx * dx + dy * dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA

  000d4	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000d8	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000dc	44 0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm8
  000e1	f3 44 0f 10 84
	24 20 01 00 00	 movss	 xmm8, DWORD PTR objspace_flatness_squared$[rsp]
  000eb	f3 0f 58 c1	 addss	 xmm0, xmm1
  000ef	41 0f 2f c0	 comiss	 xmm0, xmm8
  000f3	0f 86 94 00 00
	00		 jbe	 $LN3@stbtt__tes

; 3452 :         stbtt__tesselate_curve(points, num_points, x0, y0, (x0 + x1) / 2.0f, (y0 + y1) / 2.0f, mx, my, objspace_flatness_squared, n + 1);

  000f9	0f 28 cb	 movaps	 xmm1, xmm3
  000fc	0f 28 c2	 movaps	 xmm0, xmm2
  000ff	f3 41 0f 58 cc	 addss	 xmm1, xmm12
  00104	ff c3		 inc	 ebx
  00106	89 5c 24 48	 mov	 DWORD PTR [rsp+72], ebx
  0010a	f3 41 0f 58 c3	 addss	 xmm0, xmm11
  0010f	f3 44 0f 11 44
	24 40		 movss	 DWORD PTR [rsp+64], xmm8
  00116	f3 44 0f 11 54
	24 38		 movss	 DWORD PTR [rsp+56], xmm10
  0011d	f3 44 0f 11 4c
	24 30		 movss	 DWORD PTR [rsp+48], xmm9
  00124	f3 41 0f 59 cd	 mulss	 xmm1, xmm13
  00129	f3 41 0f 59 c5	 mulss	 xmm0, xmm13
  0012e	f3 0f 11 4c 24
	28		 movss	 DWORD PTR [rsp+40], xmm1
  00134	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0013a	e8 00 00 00 00	 call	 ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3453 :         stbtt__tesselate_curve(points, num_points, mx, my, (x1 + x2) / 2.0f, (y1 + y2) / 2.0f, x2, y2, objspace_flatness_squared, n + 1);

  0013f	89 5c 24 48	 mov	 DWORD PTR [rsp+72], ebx
  00143	f3 44 0f 58 e7	 addss	 xmm12, xmm7
  00148	f3 44 0f 11 44
	24 40		 movss	 DWORD PTR [rsp+64], xmm8
  0014f	f3 44 0f 58 de	 addss	 xmm11, xmm6
  00154	f3 0f 11 7c 24
	38		 movss	 DWORD PTR [rsp+56], xmm7
  0015a	41 0f 28 da	 movaps	 xmm3, xmm10
  0015e	f3 0f 11 74 24
	30		 movss	 DWORD PTR [rsp+48], xmm6
  00164	41 0f 28 d1	 movaps	 xmm2, xmm9
  00168	48 8b d6	 mov	 rdx, rsi
  0016b	48 8b cf	 mov	 rcx, rdi
  0016e	f3 45 0f 59 e5	 mulss	 xmm12, xmm13
  00173	f3 45 0f 59 dd	 mulss	 xmm11, xmm13
  00178	f3 44 0f 11 64
	24 28		 movss	 DWORD PTR [rsp+40], xmm12
  0017f	f3 44 0f 11 5c
	24 20		 movss	 DWORD PTR [rsp+32], xmm11
  00186	e8 00 00 00 00	 call	 ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3454 :     }

  0018b	eb 18		 jmp	 SHORT $LN11@stbtt__tes
$LN3@stbtt__tes:

; 3455 :     else {
; 3456 :         stbtt__add_point(points, *num_points, x2, y2);

  0018d	48 63 0a	 movsxd	 rcx, DWORD PTR [rdx]

; 3435 :     if (!points) return; // during first pass, it's unallocated

  00190	48 85 ff	 test	 rdi, rdi
  00193	74 0b		 je	 SHORT $LN6@stbtt__tes

; 3436 :     points[n].x = x;

  00195	f3 0f 11 34 cf	 movss	 DWORD PTR [rdi+rcx*8], xmm6

; 3437 :     points[n].y = y;

  0019a	f3 0f 11 7c cf
	04		 movss	 DWORD PTR [rdi+rcx*8+4], xmm7
$LN6@stbtt__tes:

; 3457 :         *num_points = *num_points + 1;

  001a0	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  001a3	89 02		 mov	 DWORD PTR [rdx], eax
$LN11@stbtt__tes:
  001a5	44 0f 28 84 24
	a0 00 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+160]
$LN9@stbtt__tes:

; 3458 :     }
; 3459 :     return 1;
; 3460 : }

  001ae	4c 8d 9c 24 d0
	00 00 00	 lea	 r11, QWORD PTR [rsp+208]
  001b6	b8 01 00 00 00	 mov	 eax, 1
  001bb	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001bf	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  001c3	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  001c8	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  001cd	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  001d2	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  001d7	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  001dc	45 0f 28 63 90	 movaps	 xmm12, XMMWORD PTR [r11-112]
  001e1	45 0f 28 6b 80	 movaps	 xmm13, XMMWORD PTR [r11-128]
  001e6	49 8b e3	 mov	 rsp, r11
  001e9	5f		 pop	 rdi
  001ea	c3		 ret	 0
?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ENDP ; stbtt__tesselate_curve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
points$ = 272
num_points$ = 280
x0$ = 288
y0$ = 296
x1$ = 304
y1$ = 312
x2$ = 320
y2$ = 328
x3$ = 336
y3$ = 344
objspace_flatness_squared$ = 352
n$ = 360
?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z PROC ; stbtt__tesselate_cubic

; 3463 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	f3 0f 11 58 20	 movss	 DWORD PTR [rax+32], xmm3
  00010	f3 0f 11 50 18	 movss	 DWORD PTR [rax+24], xmm2
  00015	57		 push	 rdi
  00016	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H

; 3464 :     // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
; 3465 :     float dx0 = x1 - x0;
; 3466 :     float dy0 = y1 - y0;
; 3467 :     float dx1 = x2 - x1;

  0001d	f3 0f 10 a4 24
	40 01 00 00	 movss	 xmm4, DWORD PTR x2$[rsp]
  00026	0f 28 eb	 movaps	 xmm5, xmm3

; 3468 :     float dy1 = y2 - y1;
; 3469 :     float dx2 = x3 - x2;

  00029	f3 0f 10 9c 24
	50 01 00 00	 movss	 xmm3, DWORD PTR x3$[rsp]
  00032	0f 28 c4	 movaps	 xmm0, xmm4
  00035	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  00039	48 8b f2	 mov	 rsi, rdx
  0003c	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  00040	0f 28 f2	 movaps	 xmm6, xmm2
  00043	f3 0f 10 94 24
	48 01 00 00	 movss	 xmm2, DWORD PTR y2$[rsp]
  0004c	48 8b f9	 mov	 rdi, rcx
  0004f	44 0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm8
  00054	0f 28 ca	 movaps	 xmm1, xmm2
  00057	44 0f 29 48 b8	 movaps	 XMMWORD PTR [rax-72], xmm9
  0005c	44 0f 29 50 a8	 movaps	 XMMWORD PTR [rax-88], xmm10
  00061	44 0f 29 58 98	 movaps	 XMMWORD PTR [rax-104], xmm11

; 3470 :     float dy2 = y3 - y2;
; 3471 :     float dx = x3 - x0;

  00066	44 0f 28 db	 movaps	 xmm11, xmm3
  0006a	44 0f 29 60 88	 movaps	 XMMWORD PTR [rax-120], xmm12
  0006f	f3 44 0f 5c de	 subss	 xmm11, xmm6
  00074	44 0f 29 74 24
	70		 movaps	 XMMWORD PTR [rsp+112], xmm14
  0007a	44 0f 28 e3	 movaps	 xmm12, xmm3
  0007e	f3 44 0f 10 b4
	24 30 01 00 00	 movss	 xmm14, DWORD PTR x1$[rsp]
  00088	f3 44 0f 5c e4	 subss	 xmm12, xmm4
  0008d	f3 0f 10 a4 24
	58 01 00 00	 movss	 xmm4, DWORD PTR y3$[rsp]
  00096	f3 41 0f 5c c6	 subss	 xmm0, xmm14
  0009b	44 0f 29 7c 24
	60		 movaps	 XMMWORD PTR [rsp+96], xmm15
  000a1	45 0f 28 d6	 movaps	 xmm10, xmm14
  000a5	f3 44 0f 10 bc
	24 38 01 00 00	 movss	 xmm15, DWORD PTR y1$[rsp]
  000af	f3 44 0f 5c d6	 subss	 xmm10, xmm6
  000b4	f3 41 0f 5c cf	 subss	 xmm1, xmm15
  000b9	41 0f 28 ff	 movaps	 xmm7, xmm15
  000bd	44 0f 28 cc	 movaps	 xmm9, xmm4
  000c1	f3 0f 5c fd	 subss	 xmm7, xmm5

; 3472 :     float dy = y3 - y0;
; 3473 :     float longlen = (float)(STBTT_sqrt(dx0 * dx0 + dy0 * dy0) + STBTT_sqrt(dx1 * dx1 + dy1 * dy1) + STBTT_sqrt(dx2 * dx2 + dy2 * dy2));

  000c5	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000c9	f3 44 0f 5c ca	 subss	 xmm9, xmm2
  000ce	44 0f 28 c4	 movaps	 xmm8, xmm4
  000d2	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000d6	f3 44 0f 5c c5	 subss	 xmm8, xmm5
  000db	f3 0f 58 c8	 addss	 xmm1, xmm0
  000df	0f 57 c0	 xorps	 xmm0, xmm0
  000e2	0f 2e c1	 ucomiss xmm0, xmm1
  000e5	77 09		 ja	 SHORT $LN29@stbtt__tes
  000e7	0f 57 f6	 xorps	 xmm6, xmm6
  000ea	f3 0f 51 f1	 sqrtss	 xmm6, xmm1
  000ee	eb 0b		 jmp	 SHORT $LN30@stbtt__tes
$LN29@stbtt__tes:
  000f0	0f 28 c1	 movaps	 xmm0, xmm1
  000f3	e8 00 00 00 00	 call	 sqrtf
  000f8	0f 28 f0	 movaps	 xmm6, xmm0
$LN30@stbtt__tes:
  000fb	f3 0f 59 ff	 mulss	 xmm7, xmm7
  000ff	0f 57 c0	 xorps	 xmm0, xmm0
  00102	f3 45 0f 59 d2	 mulss	 xmm10, xmm10
  00107	f3 41 0f 58 fa	 addss	 xmm7, xmm10
  0010c	0f 2e c7	 ucomiss xmm0, xmm7
  0010f	77 09		 ja	 SHORT $LN27@stbtt__tes
  00111	0f 57 c0	 xorps	 xmm0, xmm0
  00114	f3 0f 51 c7	 sqrtss	 xmm0, xmm7
  00118	eb 08		 jmp	 SHORT $LN28@stbtt__tes
$LN27@stbtt__tes:
  0011a	0f 28 c7	 movaps	 xmm0, xmm7
  0011d	e8 00 00 00 00	 call	 sqrtf
$LN28@stbtt__tes:
  00122	f3 45 0f 59 c9	 mulss	 xmm9, xmm9
  00127	f3 0f 58 f0	 addss	 xmm6, xmm0
  0012b	f3 45 0f 59 e4	 mulss	 xmm12, xmm12
  00130	0f 57 c0	 xorps	 xmm0, xmm0
  00133	f3 45 0f 58 cc	 addss	 xmm9, xmm12
  00138	41 0f 2e c1	 ucomiss xmm0, xmm9
  0013c	77 0a		 ja	 SHORT $LN25@stbtt__tes
  0013e	0f 57 c0	 xorps	 xmm0, xmm0
  00141	f3 41 0f 51 c1	 sqrtss	 xmm0, xmm9
  00146	eb 09		 jmp	 SHORT $LN26@stbtt__tes
$LN25@stbtt__tes:
  00148	41 0f 28 c1	 movaps	 xmm0, xmm9
  0014c	e8 00 00 00 00	 call	 sqrtf
$LN26@stbtt__tes:

; 3474 :     float shortlen = (float)STBTT_sqrt(dx * dx + dy * dy);

  00151	f3 45 0f 59 c0	 mulss	 xmm8, xmm8
  00156	f3 0f 58 f0	 addss	 xmm6, xmm0
  0015a	f3 45 0f 59 db	 mulss	 xmm11, xmm11
  0015f	0f 57 c0	 xorps	 xmm0, xmm0
  00162	f3 45 0f 58 c3	 addss	 xmm8, xmm11
  00167	41 0f 2e c0	 ucomiss xmm0, xmm8
  0016b	77 0a		 ja	 SHORT $LN23@stbtt__tes
  0016d	0f 57 c0	 xorps	 xmm0, xmm0
  00170	f3 41 0f 51 c0	 sqrtss	 xmm0, xmm8
  00175	eb 09		 jmp	 SHORT $LN24@stbtt__tes
$LN23@stbtt__tes:
  00177	41 0f 28 c0	 movaps	 xmm0, xmm8
  0017b	e8 00 00 00 00	 call	 sqrtf
$LN24@stbtt__tes:

; 3475 :     float flatness_squared = longlen * longlen - shortlen * shortlen;
; 3476 : 
; 3477 :     if (n > 16) // 65536 segments on one curve better be enough!

  00180	8b 9c 24 68 01
	00 00		 mov	 ebx, DWORD PTR n$[rsp]
  00187	f3 0f 59 f6	 mulss	 xmm6, xmm6
  0018b	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0018f	f3 0f 5c f0	 subss	 xmm6, xmm0
  00193	83 fb 10	 cmp	 ebx, 16
  00196	0f 8f bc 02 00
	00		 jg	 $LN4@stbtt__tes
  0019c	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@3f000000
  001a5	44 0f 29 ac 24
	80 00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm13
  001ae	f3 44 0f 10 ac
	24 60 01 00 00	 movss	 xmm13, DWORD PTR objspace_flatness_squared$[rsp]
  001b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL9@stbtt__tes:

; 3479 : 
; 3480 :     if (flatness_squared > objspace_flatness_squared) {

  001c0	41 0f 2f f5	 comiss	 xmm6, xmm13
  001c4	0f 86 5b 02 00
	00		 jbe	 $LN3@stbtt__tes

; 3481 :         float x01 = (x0 + x1) / 2;
; 3482 :         float y01 = (y0 + y1) / 2;
; 3483 :         float x12 = (x1 + x2) / 2;
; 3484 :         float y12 = (y1 + y2) / 2;

  001ca	f3 44 0f 10 a4
	24 48 01 00 00	 movss	 xmm12, DWORD PTR y2$[rsp]

; 3485 :         float x23 = (x2 + x3) / 2;
; 3486 :         float y23 = (y2 + y3) / 2;
; 3487 : 
; 3488 :         float xa = (x01 + x12) / 2;
; 3489 :         float ya = (y01 + y12) / 2;
; 3490 :         float xb = (x12 + x23) / 2;
; 3491 :         float yb = (y12 + y23) / 2;
; 3492 : 
; 3493 :         float mx = (xa + xb) / 2;
; 3494 :         float my = (ya + yb) / 2;
; 3495 : 
; 3496 :         stbtt__tesselate_cubic(points, num_points, x0, y0, x01, y01, xa, ya, mx, my, objspace_flatness_squared, n + 1);

  001d4	ff c3		 inc	 ebx
  001d6	f3 44 0f 10 8c
	24 40 01 00 00	 movss	 xmm9, DWORD PTR x2$[rsp]
  001e0	48 8b d6	 mov	 rdx, rsi
  001e3	f3 44 0f 10 94
	24 28 01 00 00	 movss	 xmm10, DWORD PTR y0$[rsp]
  001ed	48 8b cf	 mov	 rcx, rdi
  001f0	f3 44 0f 10 9c
	24 20 01 00 00	 movss	 xmm11, DWORD PTR x0$[rsp]
  001fa	41 0f 28 e2	 movaps	 xmm4, xmm10
  001fe	f3 41 0f 58 e7	 addss	 xmm4, xmm15
  00203	89 5c 24 58	 mov	 DWORD PTR [rsp+88], ebx
  00207	f3 45 0f 58 fc	 addss	 xmm15, xmm12
  0020c	f3 44 0f 11 6c
	24 50		 movss	 DWORD PTR [rsp+80], xmm13
  00213	f3 44 0f 58 a4
	24 58 01 00 00	 addss	 xmm12, DWORD PTR y3$[rsp]
  0021d	41 0f 28 eb	 movaps	 xmm5, xmm11
  00221	f3 41 0f 58 ee	 addss	 xmm5, xmm14
  00226	f3 45 0f 58 f1	 addss	 xmm14, xmm9
  0022b	f3 41 0f 59 e0	 mulss	 xmm4, xmm8
  00230	f3 44 0f 58 8c
	24 50 01 00 00	 addss	 xmm9, DWORD PTR x3$[rsp]
  0023a	f3 45 0f 59 f8	 mulss	 xmm15, xmm8
  0023f	f3 45 0f 59 f0	 mulss	 xmm14, xmm8
  00244	41 0f 28 cf	 movaps	 xmm1, xmm15
  00248	f3 41 0f 59 e8	 mulss	 xmm5, xmm8
  0024d	0f 28 d1	 movaps	 xmm2, xmm1
  00250	f3 45 0f 59 e0	 mulss	 xmm12, xmm8
  00255	41 0f 28 c6	 movaps	 xmm0, xmm14
  00259	f3 45 0f 59 c8	 mulss	 xmm9, xmm8
  0025e	0f 28 d8	 movaps	 xmm3, xmm0
  00261	f3 0f 58 d4	 addss	 xmm2, xmm4
  00265	f3 0f 58 dd	 addss	 xmm3, xmm5
  00269	f3 44 0f 11 a4
	24 48 01 00 00	 movss	 DWORD PTR y2$[rsp], xmm12
  00273	45 0f 28 fc	 movaps	 xmm15, xmm12
  00277	f3 44 0f 11 8c
	24 40 01 00 00	 movss	 DWORD PTR x2$[rsp], xmm9
  00281	f3 44 0f 58 f9	 addss	 xmm15, xmm1
  00286	45 0f 28 f1	 movaps	 xmm14, xmm9
  0028a	f3 44 0f 58 f0	 addss	 xmm14, xmm0
  0028f	f3 41 0f 59 d0	 mulss	 xmm2, xmm8
  00294	f3 41 0f 59 d8	 mulss	 xmm3, xmm8
  00299	f3 45 0f 59 f8	 mulss	 xmm15, xmm8
  0029e	f3 45 0f 59 f0	 mulss	 xmm14, xmm8
  002a3	41 0f 28 f7	 movaps	 xmm6, xmm15
  002a7	f3 0f 58 f2	 addss	 xmm6, xmm2
  002ab	41 0f 28 fe	 movaps	 xmm7, xmm14
  002af	f3 0f 58 fb	 addss	 xmm7, xmm3
  002b3	f3 41 0f 59 f0	 mulss	 xmm6, xmm8
  002b8	f3 41 0f 59 f8	 mulss	 xmm7, xmm8
  002bd	f3 0f 11 74 24
	48		 movss	 DWORD PTR [rsp+72], xmm6
  002c3	f3 0f 11 7c 24
	40		 movss	 DWORD PTR [rsp+64], xmm7
  002c9	f3 0f 11 54 24
	38		 movss	 DWORD PTR [rsp+56], xmm2
  002cf	41 0f 28 d3	 movaps	 xmm2, xmm11
  002d3	f3 0f 11 5c 24
	30		 movss	 DWORD PTR [rsp+48], xmm3
  002d9	41 0f 28 da	 movaps	 xmm3, xmm10
  002dd	f3 0f 11 64 24
	28		 movss	 DWORD PTR [rsp+40], xmm4
  002e3	f3 0f 11 6c 24
	20		 movss	 DWORD PTR [rsp+32], xmm5
  002e9	e8 00 00 00 00	 call	 ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic
  002ee	f3 0f 10 94 24
	50 01 00 00	 movss	 xmm2, DWORD PTR x3$[rsp]
  002f7	41 0f 28 c1	 movaps	 xmm0, xmm9
  002fb	f3 0f 10 9c 24
	58 01 00 00	 movss	 xmm3, DWORD PTR y3$[rsp]
  00304	f3 41 0f 5c c6	 subss	 xmm0, xmm14
  00309	41 0f 28 cc	 movaps	 xmm1, xmm12

; 3497 :         stbtt__tesselate_cubic(points, num_points, mx, my, xb, yb, x23, y23, x3, y3, objspace_flatness_squared, n + 1);

  0030d	f3 0f 11 bc 24
	20 01 00 00	 movss	 DWORD PTR x0$[rsp], xmm7
  00316	f3 41 0f 5c cf	 subss	 xmm1, xmm15
  0031b	f3 0f 11 b4 24
	28 01 00 00	 movss	 DWORD PTR y0$[rsp], xmm6
  00324	44 0f 28 da	 movaps	 xmm11, xmm2
  00328	45 0f 28 d6	 movaps	 xmm10, xmm14
  0032c	f3 45 0f 5c d9	 subss	 xmm11, xmm9
  00331	45 0f 28 c7	 movaps	 xmm8, xmm15
  00335	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00339	f3 44 0f 5c d7	 subss	 xmm10, xmm7
  0033e	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00342	44 0f 28 cb	 movaps	 xmm9, xmm3
  00346	f3 44 0f 5c c6	 subss	 xmm8, xmm6
  0034b	f3 45 0f 5c cc	 subss	 xmm9, xmm12
  00350	44 0f 28 e2	 movaps	 xmm12, xmm2
  00354	f3 0f 58 c8	 addss	 xmm1, xmm0
  00358	0f 57 c0	 xorps	 xmm0, xmm0
  0035b	f3 44 0f 5c e7	 subss	 xmm12, xmm7
  00360	0f 28 fb	 movaps	 xmm7, xmm3
  00363	f3 0f 5c fe	 subss	 xmm7, xmm6
  00367	0f 2e c1	 ucomiss xmm0, xmm1
  0036a	77 09		 ja	 SHORT $LN21@stbtt__tes

; 3472 :     float dy = y3 - y0;
; 3473 :     float longlen = (float)(STBTT_sqrt(dx0 * dx0 + dy0 * dy0) + STBTT_sqrt(dx1 * dx1 + dy1 * dy1) + STBTT_sqrt(dx2 * dx2 + dy2 * dy2));

  0036c	0f 57 f6	 xorps	 xmm6, xmm6
  0036f	f3 0f 51 f1	 sqrtss	 xmm6, xmm1
  00373	eb 0b		 jmp	 SHORT $LN22@stbtt__tes
$LN21@stbtt__tes:
  00375	0f 28 c1	 movaps	 xmm0, xmm1
  00378	e8 00 00 00 00	 call	 sqrtf
  0037d	0f 28 f0	 movaps	 xmm6, xmm0
$LN22@stbtt__tes:
  00380	f3 45 0f 59 c0	 mulss	 xmm8, xmm8
  00385	0f 57 c0	 xorps	 xmm0, xmm0
  00388	f3 45 0f 59 d2	 mulss	 xmm10, xmm10
  0038d	f3 45 0f 58 c2	 addss	 xmm8, xmm10
  00392	41 0f 2e c0	 ucomiss xmm0, xmm8
  00396	77 0a		 ja	 SHORT $LN19@stbtt__tes
  00398	0f 57 c0	 xorps	 xmm0, xmm0
  0039b	f3 41 0f 51 c0	 sqrtss	 xmm0, xmm8
  003a0	eb 09		 jmp	 SHORT $LN20@stbtt__tes
$LN19@stbtt__tes:
  003a2	41 0f 28 c0	 movaps	 xmm0, xmm8
  003a6	e8 00 00 00 00	 call	 sqrtf
$LN20@stbtt__tes:
  003ab	f3 45 0f 59 c9	 mulss	 xmm9, xmm9
  003b0	f3 0f 58 f0	 addss	 xmm6, xmm0
  003b4	f3 45 0f 59 db	 mulss	 xmm11, xmm11
  003b9	0f 57 c0	 xorps	 xmm0, xmm0
  003bc	f3 45 0f 58 cb	 addss	 xmm9, xmm11
  003c1	41 0f 2e c1	 ucomiss xmm0, xmm9
  003c5	77 0a		 ja	 SHORT $LN17@stbtt__tes
  003c7	0f 57 c0	 xorps	 xmm0, xmm0
  003ca	f3 41 0f 51 c1	 sqrtss	 xmm0, xmm9
  003cf	eb 09		 jmp	 SHORT $LN18@stbtt__tes
$LN17@stbtt__tes:
  003d1	41 0f 28 c1	 movaps	 xmm0, xmm9
  003d5	e8 00 00 00 00	 call	 sqrtf
$LN18@stbtt__tes:

; 3474 :     float shortlen = (float)STBTT_sqrt(dx * dx + dy * dy);

  003da	f3 0f 59 ff	 mulss	 xmm7, xmm7
  003de	f3 0f 58 f0	 addss	 xmm6, xmm0
  003e2	f3 45 0f 59 e4	 mulss	 xmm12, xmm12
  003e7	0f 57 c0	 xorps	 xmm0, xmm0
  003ea	f3 41 0f 58 fc	 addss	 xmm7, xmm12
  003ef	0f 2e c7	 ucomiss xmm0, xmm7
  003f2	77 09		 ja	 SHORT $LN15@stbtt__tes
  003f4	0f 57 c0	 xorps	 xmm0, xmm0
  003f7	f3 0f 51 c7	 sqrtss	 xmm0, xmm7
  003fb	eb 08		 jmp	 SHORT $LN16@stbtt__tes
$LN15@stbtt__tes:
  003fd	0f 28 c7	 movaps	 xmm0, xmm7
  00400	e8 00 00 00 00	 call	 sqrtf
$LN16@stbtt__tes:

; 3475 :     float flatness_squared = longlen * longlen - shortlen * shortlen;
; 3476 : 
; 3477 :     if (n > 16) // 65536 segments on one curve better be enough!

  00405	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@3f000000
  0040e	f3 0f 59 f6	 mulss	 xmm6, xmm6
  00412	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00416	f3 0f 5c f0	 subss	 xmm6, xmm0
  0041a	83 fb 10	 cmp	 ebx, 16
  0041d	0f 8e 9d fd ff
	ff		 jle	 $LL9@stbtt__tes

; 3478 :         return;

  00423	eb 2a		 jmp	 SHORT $LN31@stbtt__tes
$LN3@stbtt__tes:

; 3498 :     }
; 3499 :     else {
; 3500 :         stbtt__add_point(points, *num_points, x3, y3);

  00425	48 63 0e	 movsxd	 rcx, DWORD PTR [rsi]

; 3435 :     if (!points) return; // during first pass, it's unallocated

  00428	48 85 ff	 test	 rdi, rdi
  0042b	74 1d		 je	 SHORT $LN6@stbtt__tes

; 3436 :     points[n].x = x;

  0042d	f3 0f 10 94 24
	50 01 00 00	 movss	 xmm2, DWORD PTR x3$[rsp]
  00436	f3 0f 11 14 cf	 movss	 DWORD PTR [rdi+rcx*8], xmm2

; 3437 :     points[n].y = y;

  0043b	f3 0f 10 94 24
	58 01 00 00	 movss	 xmm2, DWORD PTR y3$[rsp]
  00444	f3 0f 11 54 cf
	04		 movss	 DWORD PTR [rdi+rcx*8+4], xmm2
$LN6@stbtt__tes:

; 3501 :         *num_points = *num_points + 1;

  0044a	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  0044d	89 06		 mov	 DWORD PTR [rsi], eax
$LN31@stbtt__tes:
  0044f	44 0f 28 ac 24
	80 00 00 00	 movaps	 xmm13, XMMWORD PTR [rsp+128]
$LN4@stbtt__tes:

; 3502 :     }
; 3503 : }

  00458	44 0f 28 74 24
	70		 movaps	 xmm14, XMMWORD PTR [rsp+112]
  0045e	4c 8d 9c 24 00
	01 00 00	 lea	 r11, QWORD PTR [rsp+256]
  00466	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0046a	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0046e	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00473	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  00478	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  0047d	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  00482	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  00487	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  0048c	45 0f 28 63 90	 movaps	 xmm12, XMMWORD PTR [r11-112]
  00491	44 0f 28 7c 24
	60		 movaps	 xmm15, XMMWORD PTR [rsp+96]
  00497	49 8b e3	 mov	 rsp, r11
  0049a	5f		 pop	 rdi
  0049b	c3		 ret	 0
?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ENDP ; stbtt__tesselate_cubic
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
vertices$ = 240
num_points$ = 248
num_verts$ = 248
objspace_flatness$ = 256
contour_lengths$ = 264
num_contours$ = 272
tv1074 = 280
userdata$dead$ = 280
?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z PROC ; stbtt_FlattenCurves

; 3507 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 3508 :     stbtt__point* points = 0;

  0001c	45 33 ed	 xor	 r13d, r13d
  0001f	44 0f 29 54 24
	60		 movaps	 XMMWORD PTR [rsp+96], xmm10

; 3509 :     int num_points = 0;
; 3510 : 
; 3511 :     float objspace_flatness_squared = objspace_flatness * objspace_flatness;
; 3512 :     int i, n = 0, start = 0, pass;
; 3513 : 
; 3514 :     // count how many "moves" there are to get the contour count
; 3515 :     for (i = 0; i < num_verts; ++i)

  00025	4c 63 fa	 movsxd	 r15, edx
  00028	44 0f 28 d2	 movaps	 xmm10, xmm2
  0002c	f3 45 0f 59 d2	 mulss	 xmm10, xmm10
  00031	4d 8b e1	 mov	 r12, r9
  00034	4c 89 bc 24 18
	01 00 00	 mov	 QWORD PTR tv1074[rsp], r15
  0003c	48 8b d9	 mov	 rbx, rcx
  0003f	41 8b f5	 mov	 esi, r13d
  00042	41 8b fd	 mov	 edi, r13d
  00045	45 8b c5	 mov	 r8d, r13d
  00048	45 8b f5	 mov	 r14d, r13d
  0004b	85 d2		 test	 edx, edx
  0004d	7e 29		 jle	 SHORT $LN3@stbtt_Flat
  0004f	48 8d 51 0c	 lea	 rdx, QWORD PTR [rcx+12]
  00053	49 8b cf	 mov	 rcx, r15
  00056	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL68@stbtt_Flat:
  00060	80 3a 01	 cmp	 BYTE PTR [rdx], 1
  00063	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  00067	48 8d 52 0e	 lea	 rdx, QWORD PTR [rdx+14]
  0006b	41 0f 45 c0	 cmovne	 eax, r8d
  0006f	44 8b c0	 mov	 r8d, eax
  00072	48 83 e9 01	 sub	 rcx, 1
  00076	75 e8		 jne	 SHORT $LL68@stbtt_Flat
$LN3@stbtt_Flat:

; 3516 :         if (vertices[i].type == STBTT_vmove)
; 3517 :             ++n;
; 3518 : 
; 3519 :     *num_contours = n;

  00078	48 8b ac 24 10
	01 00 00	 mov	 rbp, QWORD PTR num_contours$[rsp]
  00080	44 89 45 00	 mov	 DWORD PTR [rbp], r8d

; 3520 :     if (n == 0) return 0;

  00084	45 85 c0	 test	 r8d, r8d
  00087	74 2c		 je	 SHORT $LN84@stbtt_Flat
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00089	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00090	48 85 c0	 test	 rax, rax
  00093	74 06		 je	 SHORT $LN26@stbtt_Flat

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00095	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN26@stbtt_Flat:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3522 :     *contour_lengths = (int*)STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

  0009b	49 63 c8	 movsxd	 rcx, r8d
  0009e	48 c1 e1 02	 shl	 rcx, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3522 :     *contour_lengths = (int*)STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

  000a8	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 3523 : 
; 3524 :     if (*contour_lengths == 0) {

  000ac	48 85 c0	 test	 rax, rax
  000af	75 0b		 jne	 SHORT $LN15@stbtt_Flat

; 3525 :         *num_contours = 0;

  000b1	44 89 6d 00	 mov	 DWORD PTR [rbp], r13d
$LN84@stbtt_Flat:

; 3581 : }

  000b5	33 c0		 xor	 eax, eax
  000b7	e9 c5 02 00 00	 jmp	 $LN1@stbtt_Flat
$LN15@stbtt_Flat:
  000bc	0f 29 b4 24 a0
	00 00 00	 movaps	 XMMWORD PTR [rsp+160], xmm6
  000c4	0f 29 bc 24 90
	00 00 00	 movaps	 XMMWORD PTR [rsp+144], xmm7
  000cc	44 0f 29 84 24
	80 00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm8
  000d5	44 0f 29 4c 24
	70		 movaps	 XMMWORD PTR [rsp+112], xmm9
  000db	0f 1f 44 00 00	 npad	 5
$LL7@stbtt_Flat:
  000e0	45 0f 57 c0	 xorps	 xmm8, xmm8
  000e4	45 0f 57 c9	 xorps	 xmm9, xmm9

; 3526 :         return 0;
; 3527 :     }
; 3528 : 
; 3529 :     // make two passes through the points so we don't need to realloc
; 3530 :     for (pass = 0; pass < 2; ++pass) {
; 3531 :         float x = 0, y = 0;
; 3532 :         if (pass == 1) {

  000e8	41 83 fd 01	 cmp	 r13d, 1
  000ec	75 2b		 jne	 SHORT $LN17@stbtt_Flat
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  000ee	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3533 :             points = (stbtt__point*)STBTT_malloc(num_points * sizeof(points[0]), userdata);

  000f5	48 63 cf	 movsxd	 rcx, edi
  000f8	48 c1 e1 03	 shl	 rcx, 3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  000fc	48 85 c0	 test	 rax, rax
  000ff	74 06		 je	 SHORT $LN33@stbtt_Flat

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00101	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN33@stbtt_Flat:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0010d	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3534 :             if (points == NULL) goto error;

  00110	48 85 c0	 test	 rax, rax
  00113	0f 84 89 02 00
	00		 je	 $error$86
$LN17@stbtt_Flat:

; 3535 :         }
; 3536 :         num_points = 0;

  00119	33 ff		 xor	 edi, edi
  0011b	89 bc 24 f8 00
	00 00		 mov	 DWORD PTR num_points$[rsp], edi

; 3537 :         n = -1;

  00122	48 8d 6f ff	 lea	 rbp, QWORD PTR [rdi-1]

; 3538 :         for (i = 0; i < num_verts; ++i) {

  00126	4d 85 ff	 test	 r15, r15
  00129	0f 8e 17 02 00
	00		 jle	 $LN9@stbtt_Flat

; 3535 :         }
; 3536 :         num_points = 0;

  0012f	48 83 c3 0a	 add	 rbx, 10
$LL10@stbtt_Flat:

; 3539 :             switch (vertices[i].type) {

  00133	0f b6 4b 02	 movzx	 ecx, BYTE PTR [rbx+2]
  00137	83 e9 01	 sub	 ecx, 1
  0013a	0f 84 9a 01 00
	00		 je	 $LN19@stbtt_Flat
  00140	83 e9 01	 sub	 ecx, 1
  00143	0f 84 56 01 00
	00		 je	 $LN21@stbtt_Flat
  00149	83 e9 01	 sub	 ecx, 1
  0014c	0f 84 bb 00 00
	00		 je	 $LN22@stbtt_Flat
  00152	83 f9 01	 cmp	 ecx, 1
  00155	0f 85 cd 01 00
	00		 jne	 $LN8@stbtt_Flat

; 3561 :             case STBTT_vcubic:
; 3562 :                 stbtt__tesselate_cubic(points, &num_points, x, y,

  0015b	0f bf 43 f8	 movsx	 eax, WORD PTR [rbx-8]
  0015f	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR num_points$[rsp]
  00167	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR [rsp+88], 0
  0016f	41 0f 28 d9	 movaps	 xmm3, xmm9
  00173	f3 44 0f 11 54
	24 50		 movss	 DWORD PTR [rsp+80], xmm10
  0017a	41 0f 28 d0	 movaps	 xmm2, xmm8
  0017e	48 8b ce	 mov	 rcx, rsi
  00181	66 0f 6e f8	 movd	 xmm7, eax
  00185	0f bf 43 f6	 movsx	 eax, WORD PTR [rbx-10]
  00189	0f 5b ff	 cvtdq2ps xmm7, xmm7
  0018c	66 0f 6e f0	 movd	 xmm6, eax
  00190	0f bf 03	 movsx	 eax, WORD PTR [rbx]
  00193	f3 0f 11 7c 24
	48		 movss	 DWORD PTR [rsp+72], xmm7
  00199	0f 5b f6	 cvtdq2ps xmm6, xmm6
  0019c	66 0f 6e e8	 movd	 xmm5, eax
  001a0	0f bf 43 fe	 movsx	 eax, WORD PTR [rbx-2]
  001a4	f3 0f 11 74 24
	40		 movss	 DWORD PTR [rsp+64], xmm6
  001aa	0f 5b ed	 cvtdq2ps xmm5, xmm5
  001ad	66 0f 6e e0	 movd	 xmm4, eax
  001b1	0f bf 43 fc	 movsx	 eax, WORD PTR [rbx-4]
  001b5	f3 0f 11 6c 24
	38		 movss	 DWORD PTR [rsp+56], xmm5
  001bb	0f 5b e4	 cvtdq2ps xmm4, xmm4
  001be	66 0f 6e c8	 movd	 xmm1, eax
  001c2	0f bf 43 fa	 movsx	 eax, WORD PTR [rbx-6]
  001c6	f3 0f 11 64 24
	30		 movss	 DWORD PTR [rsp+48], xmm4
  001cc	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001cf	66 0f 6e c0	 movd	 xmm0, eax
  001d3	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001d6	f3 0f 11 4c 24
	28		 movss	 DWORD PTR [rsp+40], xmm1
  001dc	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  001e2	e8 00 00 00 00	 call	 ?stbtt__tesselate_cubic@@YAXPEAUstbtt__point@@PEAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic

; 3563 :                     vertices[i].cx, vertices[i].cy,
; 3564 :                     vertices[i].cx1, vertices[i].cy1,
; 3565 :                     vertices[i].x, vertices[i].y,
; 3566 :                     objspace_flatness_squared, 0);
; 3567 :                 x = vertices[i].x, y = vertices[i].y;

  001e7	0f bf 43 f6	 movsx	 eax, WORD PTR [rbx-10]
  001eb	8b bc 24 f8 00
	00 00		 mov	 edi, DWORD PTR num_points$[rsp]
  001f2	66 44 0f 6e c0	 movd	 xmm8, eax
  001f7	0f bf 43 f8	 movsx	 eax, WORD PTR [rbx-8]
  001fb	45 0f 5b c0	 cvtdq2ps xmm8, xmm8
  001ff	66 44 0f 6e c8	 movd	 xmm9, eax
  00204	45 0f 5b c9	 cvtdq2ps xmm9, xmm9
  00208	e9 1b 01 00 00	 jmp	 $LN8@stbtt_Flat
$LN22@stbtt_Flat:

; 3554 :             case STBTT_vcurve:
; 3555 :                 stbtt__tesselate_curve(points, &num_points, x, y,

  0020d	0f bf 43 f8	 movsx	 eax, WORD PTR [rbx-8]
  00211	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR num_points$[rsp]
  00219	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR [rsp+72], 0
  00221	48 8b ce	 mov	 rcx, rsi
  00224	f3 44 0f 11 54
	24 40		 movss	 DWORD PTR [rsp+64], xmm10
  0022b	66 0f 6e d8	 movd	 xmm3, eax
  0022f	0f bf 43 f6	 movsx	 eax, WORD PTR [rbx-10]
  00233	0f 5b db	 cvtdq2ps xmm3, xmm3
  00236	66 0f 6e d0	 movd	 xmm2, eax
  0023a	0f bf 43 fc	 movsx	 eax, WORD PTR [rbx-4]
  0023e	f3 0f 11 5c 24
	38		 movss	 DWORD PTR [rsp+56], xmm3
  00244	41 0f 28 d9	 movaps	 xmm3, xmm9
  00248	0f 5b d2	 cvtdq2ps xmm2, xmm2
  0024b	66 0f 6e c8	 movd	 xmm1, eax
  0024f	0f bf 43 fa	 movsx	 eax, WORD PTR [rbx-6]
  00253	f3 0f 11 54 24
	30		 movss	 DWORD PTR [rsp+48], xmm2
  00259	41 0f 28 d0	 movaps	 xmm2, xmm8
  0025d	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00260	66 0f 6e c0	 movd	 xmm0, eax
  00264	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00267	f3 0f 11 4c 24
	28		 movss	 DWORD PTR [rsp+40], xmm1
  0026d	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00273	e8 00 00 00 00	 call	 ?stbtt__tesselate_curve@@YAHPEAUstbtt__point@@PEAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3556 :                     vertices[i].cx, vertices[i].cy,
; 3557 :                     vertices[i].x, vertices[i].y,
; 3558 :                     objspace_flatness_squared, 0);
; 3559 :                 x = vertices[i].x, y = vertices[i].y;

  00278	0f bf 43 f8	 movsx	 eax, WORD PTR [rbx-8]
  0027c	44 0f bf 43 f6	 movsx	 r8d, WORD PTR [rbx-10]

; 3560 :                 break;

  00281	8b bc 24 f8 00
	00 00		 mov	 edi, DWORD PTR num_points$[rsp]
  00288	66 44 0f 6e c8	 movd	 xmm9, eax
  0028d	66 45 0f 6e c0	 movd	 xmm8, r8d
  00292	45 0f 5b c9	 cvtdq2ps xmm9, xmm9
  00296	45 0f 5b c0	 cvtdq2ps xmm8, xmm8
  0029a	e9 89 00 00 00	 jmp	 $LN8@stbtt_Flat
$LN21@stbtt_Flat:

; 3548 :                 stbtt__add_point(points, num_points++, x, y);
; 3549 :                 break;
; 3550 :             case STBTT_vline:
; 3551 :                 x = vertices[i].x, y = vertices[i].y;

  0029f	0f bf 43 f6	 movsx	 eax, WORD PTR [rbx-10]
  002a3	66 44 0f 6e c0	 movd	 xmm8, eax
  002a8	0f bf 43 f8	 movsx	 eax, WORD PTR [rbx-8]
  002ac	45 0f 5b c0	 cvtdq2ps xmm8, xmm8
  002b0	66 44 0f 6e c8	 movd	 xmm9, eax

; 3552 :                 stbtt__add_point(points, num_points++, x, y);

  002b5	48 63 c7	 movsxd	 rax, edi
  002b8	45 0f 5b c9	 cvtdq2ps xmm9, xmm9
  002bc	8d 78 01	 lea	 edi, DWORD PTR [rax+1]
  002bf	89 bc 24 f8 00
	00 00		 mov	 DWORD PTR num_points$[rsp], edi

; 3435 :     if (!points) return; // during first pass, it's unallocated

  002c6	48 85 f6	 test	 rsi, rsi
  002c9	74 5d		 je	 SHORT $LN8@stbtt_Flat

; 3436 :     points[n].x = x;

  002cb	f3 44 0f 11 04
	c6		 movss	 DWORD PTR [rsi+rax*8], xmm8

; 3437 :     points[n].y = y;

  002d1	f3 44 0f 11 4c
	c6 04		 movss	 DWORD PTR [rsi+rax*8+4], xmm9

; 3553 :                 break;

  002d8	eb 4e		 jmp	 SHORT $LN8@stbtt_Flat
$LN19@stbtt_Flat:

; 3540 :             case STBTT_vmove:
; 3541 :                 // start the next contour
; 3542 :                 if (n >= 0)

  002da	48 85 ed	 test	 rbp, rbp
  002dd	78 0c		 js	 SHORT $LN78@stbtt_Flat

; 3543 :                     (*contour_lengths)[n] = num_points - start;

  002df	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  002e3	8b cf		 mov	 ecx, edi
  002e5	41 2b ce	 sub	 ecx, r14d
  002e8	89 0c a8	 mov	 DWORD PTR [rax+rbp*4], ecx
$LN78@stbtt_Flat:

; 3544 :                 ++n;
; 3545 :                 start = num_points;
; 3546 : 
; 3547 :                 x = vertices[i].x, y = vertices[i].y;

  002eb	0f bf 43 f6	 movsx	 eax, WORD PTR [rbx-10]
  002ef	48 ff c5	 inc	 rbp
  002f2	4c 63 f7	 movsxd	 r14, edi
  002f5	66 44 0f 6e c0	 movd	 xmm8, eax
  002fa	0f bf 43 f8	 movsx	 eax, WORD PTR [rbx-8]
  002fe	41 8d 7e 01	 lea	 edi, DWORD PTR [r14+1]
  00302	89 bc 24 f8 00
	00 00		 mov	 DWORD PTR num_points$[rsp], edi
  00309	45 0f 5b c0	 cvtdq2ps xmm8, xmm8
  0030d	66 44 0f 6e c8	 movd	 xmm9, eax
  00312	45 0f 5b c9	 cvtdq2ps xmm9, xmm9

; 3435 :     if (!points) return; // during first pass, it's unallocated

  00316	48 85 f6	 test	 rsi, rsi
  00319	74 0d		 je	 SHORT $LN8@stbtt_Flat

; 3436 :     points[n].x = x;

  0031b	f3 46 0f 11 04
	f6		 movss	 DWORD PTR [rsi+r14*8], xmm8

; 3437 :     points[n].y = y;

  00321	f3 46 0f 11 4c
	f6 04		 movss	 DWORD PTR [rsi+r14*8+4], xmm9
$LN8@stbtt_Flat:

; 3538 :         for (i = 0; i < num_verts; ++i) {

  00328	48 83 c3 0e	 add	 rbx, 14
  0032c	49 83 ef 01	 sub	 r15, 1
  00330	0f 85 fd fd ff
	ff		 jne	 $LL10@stbtt_Flat
  00336	4c 8b bc 24 18
	01 00 00	 mov	 r15, QWORD PTR tv1074[rsp]
  0033e	48 8b 9c 24 f0
	00 00 00	 mov	 rbx, QWORD PTR vertices$[rsp]
$LN9@stbtt_Flat:

; 3568 :                 break;
; 3569 :             }
; 3570 :         }
; 3571 :         (*contour_lengths)[n] = num_points - start;

  00346	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0034a	8b cf		 mov	 ecx, edi
  0034c	41 2b ce	 sub	 ecx, r14d
  0034f	41 ff c5	 inc	 r13d
  00352	89 0c a8	 mov	 DWORD PTR [rax+rbp*4], ecx
  00355	41 83 fd 02	 cmp	 r13d, 2
  00359	0f 8c 81 fd ff
	ff		 jl	 $LL7@stbtt_Flat

; 3572 :     }
; 3573 : 
; 3574 :     return points;

  0035f	48 8b c6	 mov	 rax, rsi
$LN83@stbtt_Flat:
  00362	44 0f 28 84 24
	80 00 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+128]
  0036b	0f 28 bc 24 90
	00 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+144]
  00373	0f 28 b4 24 a0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+160]
  0037b	44 0f 28 4c 24
	70		 movaps	 xmm9, XMMWORD PTR [rsp+112]
$LN1@stbtt_Flat:

; 3581 : }

  00381	48 8b 9c 24 00
	01 00 00	 mov	 rbx, QWORD PTR [rsp+256]
  00389	44 0f 28 54 24
	60		 movaps	 xmm10, XMMWORD PTR [rsp+96]
  0038f	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00396	41 5f		 pop	 r15
  00398	41 5e		 pop	 r14
  0039a	41 5d		 pop	 r13
  0039c	41 5c		 pop	 r12
  0039e	5f		 pop	 rdi
  0039f	5e		 pop	 rsi
  003a0	5d		 pop	 rbp
  003a1	c3		 ret	 0
$error$86:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  003a2	33 c9		 xor	 ecx, ecx
  003a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3577 :     STBTT_free(*contour_lengths, userdata);

  003aa	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  003ae	48 85 c9	 test	 rcx, rcx
  003b1	74 12		 je	 SHORT $LN55@stbtt_Flat

; 3610 :         if (ImGuiContext* ctx = GImGui)

  003b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  003ba	48 85 c0	 test	 rax, rax
  003bd	74 06		 je	 SHORT $LN55@stbtt_Flat

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  003bf	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN55@stbtt_Flat:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  003c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3579 :     *num_contours = 0;

  003cb	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR num_contours$[rsp]
  003d3	45 33 ed	 xor	 r13d, r13d
  003d6	4d 89 2c 24	 mov	 QWORD PTR [r12], r13
  003da	44 89 28	 mov	 DWORD PTR [rax], r13d

; 3580 :     return NULL;

  003dd	33 c0		 xor	 eax, eax
  003df	eb 81		 jmp	 SHORT $LN83@stbtt_Flat
?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ENDP ; stbtt_FlattenCurves
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
result$ = 144
winding_count$ = 152
flatness_in_pixels$ = 152
vertices$ = 160
num_verts$ = 168
scale_x$ = 176
scale_y$ = 184
shift_x$ = 192
shift_y$ = 200
x_off$ = 208
y_off$ = 216
invert$dead$ = 224
userdata$dead$ = 232
winding_lengths$ = 232
stbtt_Rasterize PROC

; 3584 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 73 08	 mov	 QWORD PTR [r11+8], rsi
  00007	57		 push	 rdi
  00008	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 3585 :     float scale = scale_x > scale_y ? scale_y : scale_x;
; 3586 :     int winding_count = 0;

  0000f	33 c0		 xor	 eax, eax
  00011	0f 29 74 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm6
  00016	f3 0f 10 b4 24
	b8 00 00 00	 movss	 xmm6, DWORD PTR scale_y$[rsp]
  0001f	41 8b d1	 mov	 edx, r9d
  00022	0f 28 c6	 movaps	 xmm0, xmm6
  00025	0f 29 7c 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm7
  0002a	f3 0f 10 bc 24
	b0 00 00 00	 movss	 xmm7, DWORD PTR scale_x$[rsp]

; 3587 :     int* winding_lengths = NULL;
; 3588 :     stbtt__point* windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);

  00033	4d 8d 4b 60	 lea	 r9, QWORD PTR [r11+96]
  00037	f3 0f 5d c7	 minss	 xmm0, xmm7
  0003b	41 89 43 10	 mov	 DWORD PTR [r11+16], eax
  0003f	49 89 43 60	 mov	 QWORD PTR [r11+96], rax
  00043	48 8b f1	 mov	 rsi, rcx
  00046	49 8d 43 10	 lea	 rax, QWORD PTR [r11+16]
  0004a	49 8b c8	 mov	 rcx, r8
  0004d	49 89 43 98	 mov	 QWORD PTR [r11-104], rax
  00051	f3 0f 5e c8	 divss	 xmm1, xmm0
  00055	0f 28 d1	 movaps	 xmm2, xmm1
  00058	e8 00 00 00 00	 call	 ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ; stbtt_FlattenCurves
  0005d	48 8b f8	 mov	 rdi, rax

; 3589 :     if (windings) {

  00060	48 85 c0	 test	 rax, rax
  00063	0f 84 a1 00 00
	00		 je	 $LN18@stbtt_Rast

; 3590 :         stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);

  00069	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR y_off$[rsp]
  00070	48 8b d0	 mov	 rdx, rax
  00073	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR shift_y$[rsp]
  0007c	f3 0f 10 8c 24
	c0 00 00 00	 movss	 xmm1, DWORD PTR shift_x$[rsp]
  00085	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR winding_count$[rsp]
  0008d	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR winding_lengths$[rsp]
  00095	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00099	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR x_off$[rsp]
  000a0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000a4	48 8b ce	 mov	 rcx, rsi
  000a7	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  000ad	f3 0f 11 4c 24
	30		 movss	 DWORD PTR [rsp+48], xmm1
  000b3	f3 0f 11 74 24
	28		 movss	 DWORD PTR [rsp+40], xmm6
  000b9	f3 0f 11 7c 24
	20		 movss	 DWORD PTR [rsp+32], xmm7
  000bf	e8 00 00 00 00	 call	 ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ; stbtt__rasterize
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  000c4	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR winding_lengths$[rsp], 0
  000cd	74 12		 je	 SHORT $LN8@stbtt_Rast

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000d6	48 85 c0	 test	 rax, rax
  000d9	74 06		 je	 SHORT $LN8@stbtt_Rast

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000db	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN8@stbtt_Rast:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000e1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR winding_lengths$[rsp]
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000f6	48 85 c0	 test	 rax, rax
  000f9	74 06		 je	 SHORT $LN16@stbtt_Rast

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000fb	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN16@stbtt_Rast:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00101	48 8b cf	 mov	 rcx, rdi
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN18@stbtt_Rast:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3594 : }

  0010a	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR [rsp+144]
  00112	0f 28 74 24 70	 movaps	 xmm6, XMMWORD PTR [rsp+112]
  00117	0f 28 7c 24 60	 movaps	 xmm7, XMMWORD PTR [rsp+96]
  0011c	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00123	5f		 pop	 rdi
  00124	c3		 ret	 0
stbtt_Rasterize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
gbm$ = 96
c$1 = 120
winding_lengths$2 = 304
vertices$ = 304
info$ = 304
output$ = 312
num_verts$1$ = 320
out_w$ = 320
out_h$ = 328
winding_count$3 = 336
out_stride$ = 336
scale_x$ = 344
scale_y$ = 352
shift_x$ = 360
shift_y$ = 368
glyph$ = 376
stbtt_MakeGlyphBitmapSubpixel PROC

; 3647 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  0000b	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  0000f	48 8b f9	 mov	 rdi, rcx
  00012	48 89 68 f0	 mov	 QWORD PTR [rax-16], rbp
  00016	48 89 70 e8	 mov	 QWORD PTR [rax-24], rsi

; 3648 :     int ix0, iy0;
; 3649 :     stbtt_vertex* vertices;
; 3650 :     int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

  0001a	8b b4 24 78 01
	00 00		 mov	 esi, DWORD PTR glyph$[rsp]
  00021	4c 89 60 e0	 mov	 QWORD PTR [rax-32], r12
  00025	45 8b e0	 mov	 r12d, r8d
  00028	4c 89 68 d8	 mov	 QWORD PTR [rax-40], r13
  0002c	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  00030	4c 89 70 d0	 mov	 QWORD PTR [rax-48], r14
  00034	4c 8b ea	 mov	 r13, rdx
  00037	4c 89 78 c8	 mov	 QWORD PTR [rax-56], r15
  0003b	8b d6		 mov	 edx, esi
  0003d	0f 29 70 b8	 movaps	 XMMWORD PTR [rax-72], xmm6
  00041	45 8b f9	 mov	 r15d, r9d
  00044	0f 29 78 a8	 movaps	 XMMWORD PTR [rax-88], xmm7
  00048	44 0f 29 40 98	 movaps	 XMMWORD PTR [rax-104], xmm8
  0004d	44 0f 29 48 88	 movaps	 XMMWORD PTR [rax-120], xmm9
  00052	e8 00 00 00 00	 call	 stbtt_GetGlyphShape

; 1599 :     if (info->cff.size) {

  00057	f3 44 0f 10 8c
	24 70 01 00 00	 movss	 xmm9, DWORD PTR shift_y$[rsp]
  00061	33 db		 xor	 ebx, ebx
  00063	8b d6		 mov	 edx, esi
  00065	f3 44 0f 10 84
	24 68 01 00 00	 movss	 xmm8, DWORD PTR shift_x$[rsp]
  0006f	48 8b cf	 mov	 rcx, rdi
  00072	f3 0f 10 bc 24
	60 01 00 00	 movss	 xmm7, DWORD PTR scale_y$[rsp]
  0007b	f3 0f 10 b4 24
	58 01 00 00	 movss	 xmm6, DWORD PTR scale_x$[rsp]

; 3648 :     int ix0, iy0;
; 3649 :     stbtt_vertex* vertices;
; 3650 :     int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

  00084	89 84 24 40 01
	00 00		 mov	 DWORD PTR num_verts$1$[rsp], eax

; 1599 :     if (info->cff.size) {

  0008b	39 5f 4c	 cmp	 DWORD PTR [rdi+76], ebx
  0008e	74 53		 je	 SHORT $LN17@stbtt_Make
  00090	0f 57 c0	 xorps	 xmm0, xmm0

; 2281 :     stbtt__csctx c = STBTT__CSCTX_INIT(1);

  00093	48 c7 44 24 78
	01 00 00 00	 mov	 QWORD PTR c$1[rsp], 1
  0009c	0f 57 c9	 xorps	 xmm1, xmm1
  0009f	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR c$1[rsp+40], rbx

; 2282 :     int r = stbtt__run_charstring(info, glyph_index, &c);

  000a7	4c 8d 44 24 78	 lea	 r8, QWORD PTR c$1[rsp]
  000ac	89 9c 24 a8 00
	00 00		 mov	 DWORD PTR c$1[rsp+48], ebx
  000b3	0f 11 84 24 80
	00 00 00	 movups	 XMMWORD PTR c$1[rsp+8], xmm0
  000bb	f3 0f 7f 8c 24
	90 00 00 00	 movdqu	 XMMWORD PTR c$1[rsp+24], xmm1
  000c4	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring

; 2283 :     if (x0)  *x0 = r ? c.min_x : 0;

  000c9	85 c0		 test	 eax, eax
  000cb	44 8b d3	 mov	 r10d, ebx

; 2284 :     if (y0)  *y0 = r ? c.min_y : 0;
; 2285 :     if (x1)  *x1 = r ? c.max_x : 0;
; 2286 :     if (y1)  *y1 = r ? c.max_y : 0;

  000ce	8b cb		 mov	 ecx, ebx
  000d0	44 0f 45 94 24
	90 00 00 00	 cmovne	 r10d, DWORD PTR c$1[rsp+24]
  000d9	0f 45 8c 24 9c
	00 00 00	 cmovne	 ecx, DWORD PTR c$1[rsp+36]

; 1601 :     }

  000e1	eb 4d		 jmp	 SHORT $LN5@stbtt_Make
$LN17@stbtt_Make:

; 1602 :     else {
; 1603 :         int g = stbtt__GetGlyfOffset(info, glyph_index);

  000e3	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1604 :         if (g < 0) return 0;

  000e8	85 c0		 test	 eax, eax
  000ea	0f 88 b2 00 00
	00		 js	 $LN81@stbtt_Make

; 1605 : 
; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  000f0	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000f4	41 bb 00 01 00
	00		 mov	 r11d, 256		; 00000100H

; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  000fa	4c 63 c8	 movsxd	 r9, eax

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000fd	41 0f bf c3	 movsx	 eax, r11w
  00101	41 0f bf cb	 movsx	 ecx, r11w
  00105	43 0f b6 54 08
	02		 movzx	 edx, BYTE PTR [r8+r9+2]
  0010b	0f af d0	 imul	 edx, eax
  0010e	43 0f b6 44 08
	03		 movzx	 eax, BYTE PTR [r8+r9+3]
  00114	66 03 d0	 add	 dx, ax
  00117	43 0f b6 44 08
	09		 movzx	 eax, BYTE PTR [r8+r9+9]

; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  0011d	44 0f bf d2	 movsx	 r10d, dx

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00121	43 0f b6 54 08
	08		 movzx	 edx, BYTE PTR [r8+r9+8]
  00127	0f af d1	 imul	 edx, ecx
  0012a	66 03 d0	 add	 dx, ax

; 1609 :         if (y1) *y1 = ttSHORT(info->data + g + 8);

  0012d	0f bf ca	 movsx	 ecx, dx
$LN5@stbtt_Make:
  00130	66 41 0f 6e ca	 movd	 xmm1, r10d
  00135	0f 57 db	 xorps	 xmm3, xmm3

; 2667 :         if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);

  00138	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0013b	f3 0f 59 ce	 mulss	 xmm1, xmm6
  0013f	f3 41 0f 58 c8	 addss	 xmm1, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00144	0f 2f cb	 comiss	 xmm1, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2667 :         if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);

  00147	f3 0f 2c c1	 cvttss2si eax, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  0014b	73 10		 jae	 SHORT $LN79@stbtt_Make
  0014d	66 0f 6e c0	 movd	 xmm0, eax
  00151	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00154	0f 2e c1	 ucomiss xmm0, xmm1
  00157	7a 02		 jp	 SHORT $LN83@stbtt_Make
  00159	74 02		 je	 SHORT $LN79@stbtt_Make
$LN83@stbtt_Make:
  0015b	ff c8		 dec	 eax
$LN79@stbtt_Make:
  0015d	66 0f 6e c0	 movd	 xmm0, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  00161	41 0f 28 d1	 movaps	 xmm2, xmm9
  00165	66 0f 6e c9	 movd	 xmm1, ecx
  00169	0f 5b c9	 cvtdq2ps xmm1, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  0016c	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  0016f	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00173	f3 44 0f 2c f0	 cvttss2si r14d, xmm0
  00178	f3 0f 5c d1	 subss	 xmm2, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  0017c	0f 2f d3	 comiss	 xmm2, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  0017f	f3 0f 2c c2	 cvttss2si eax, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00183	73 10		 jae	 SHORT $LN80@stbtt_Make
  00185	66 0f 6e c0	 movd	 xmm0, eax
  00189	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0018c	0f 2e c2	 ucomiss xmm0, xmm2
  0018f	7a 02		 jp	 SHORT $LN82@stbtt_Make
  00191	74 02		 je	 SHORT $LN80@stbtt_Make
$LN82@stbtt_Make:
  00193	ff c8		 dec	 eax
$LN80@stbtt_Make:
  00195	66 0f 6e c0	 movd	 xmm0, eax
  00199	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  0019c	f3 0f 2c e8	 cvttss2si ebp, xmm0
  001a0	eb 05		 jmp	 SHORT $LN12@stbtt_Make
$LN81@stbtt_Make:

; 2287 :     return r ? c.num_vertices : 0;
; 2288 : }
; 2289 : 
; 2290 : STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo* info, int glyph_index, stbtt_vertex** pvertices)
; 2291 : {
; 2292 :     if (!info->cff.size)
; 2293 :         return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
; 2294 :     else
; 2295 :         return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
; 2296 : }
; 2297 : 
; 2298 : STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo* info, int glyph_index, int* advanceWidth, int* leftSideBearing)
; 2299 : {
; 2300 :     stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data + info->hhea + 34);
; 2301 :     if (glyph_index < numOfLongHorMetrics) {
; 2302 :         if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * glyph_index);
; 2303 :         if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4 * glyph_index + 2);
; 2304 :     }
; 2305 :     else {
; 2306 :         if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * (numOfLongHorMetrics - 1));
; 2307 :         if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4 * numOfLongHorMetrics + 2 * (glyph_index - numOfLongHorMetrics));
; 2308 :     }
; 2309 : }
; 2310 : 
; 2311 : static int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo* info, int glyph1, int glyph2)
; 2312 : {
; 2313 :     stbtt_uint8* data = info->data + info->kern;
; 2314 :     stbtt_uint32 needle, straw;
; 2315 :     int l, r, m;
; 2316 : 
; 2317 :     // we only look at the first table. it must be 'horizontal' and format 0.
; 2318 :     if (!info->kern)
; 2319 :         return 0;
; 2320 :     if (ttUSHORT(data + 2) < 1) // number of tables, need at least 1
; 2321 :         return 0;
; 2322 :     if (ttUSHORT(data + 8) != 1) // horizontal flag must be set in format
; 2323 :         return 0;
; 2324 : 
; 2325 :     l = 0;
; 2326 :     r = ttUSHORT(data + 10) - 1;
; 2327 :     needle = glyph1 << 16 | glyph2;
; 2328 :     while (l <= r) {
; 2329 :         m = (l + r) >> 1;
; 2330 :         straw = ttULONG(data + 18 + (m * 6)); // note: unaligned read
; 2331 :         if (needle < straw)
; 2332 :             r = m - 1;
; 2333 :         else if (needle > straw)
; 2334 :             l = m + 1;
; 2335 :         else
; 2336 :             return ttSHORT(data + 22 + (m * 6));
; 2337 :     }
; 2338 :     return 0;
; 2339 : }
; 2340 : 
; 2341 : static stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8* coverageTable, int glyph)
; 2342 : {
; 2343 :     stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
; 2344 :     switch (coverageFormat) {
; 2345 :     case 1: {
; 2346 :         stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);
; 2347 : 
; 2348 :         // Binary search.
; 2349 :         stbtt_int32 l = 0, r = glyphCount - 1, m;
; 2350 :         int straw, needle = glyph;
; 2351 :         while (l <= r) {
; 2352 :             stbtt_uint8* glyphArray = coverageTable + 4;
; 2353 :             stbtt_uint16 glyphID;
; 2354 :             m = (l + r) >> 1;
; 2355 :             glyphID = ttUSHORT(glyphArray + 2 * m);
; 2356 :             straw = glyphID;
; 2357 :             if (needle < straw)
; 2358 :                 r = m - 1;
; 2359 :             else if (needle > straw)
; 2360 :                 l = m + 1;
; 2361 :             else {
; 2362 :                 return m;
; 2363 :             }
; 2364 :         }
; 2365 :     } break;
; 2366 : 
; 2367 :     case 2: {
; 2368 :         stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
; 2369 :         stbtt_uint8* rangeArray = coverageTable + 4;
; 2370 : 
; 2371 :         // Binary search.
; 2372 :         stbtt_int32 l = 0, r = rangeCount - 1, m;
; 2373 :         int strawStart, strawEnd, needle = glyph;
; 2374 :         while (l <= r) {
; 2375 :             stbtt_uint8* rangeRecord;
; 2376 :             m = (l + r) >> 1;
; 2377 :             rangeRecord = rangeArray + 6 * m;
; 2378 :             strawStart = ttUSHORT(rangeRecord);
; 2379 :             strawEnd = ttUSHORT(rangeRecord + 2);
; 2380 :             if (needle < strawStart)
; 2381 :                 r = m - 1;
; 2382 :             else if (needle > strawEnd)
; 2383 :                 l = m + 1;
; 2384 :             else {
; 2385 :                 stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
; 2386 :                 return startCoverageIndex + glyph - strawStart;
; 2387 :             }
; 2388 :         }
; 2389 :     } break;
; 2390 : 
; 2391 :     default: {
; 2392 :         // There are no other cases.
; 2393 :         STBTT_assert(0);
; 2394 :     } break;
; 2395 :     }
; 2396 : 
; 2397 :     return -1;
; 2398 : }
; 2399 : 
; 2400 : static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8* classDefTable, int glyph)
; 2401 : {
; 2402 :     stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
; 2403 :     switch (classDefFormat)
; 2404 :     {
; 2405 :     case 1: {
; 2406 :         stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
; 2407 :         stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
; 2408 :         stbtt_uint8* classDef1ValueArray = classDefTable + 6;
; 2409 : 
; 2410 :         if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
; 2411 :             return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));
; 2412 : 
; 2413 :         // [DEAR IMGUI] Commented to fix static analyzer warning
; 2414 :         //classDefTable = classDef1ValueArray + 2 * glyphCount;
; 2415 :     } break;
; 2416 : 
; 2417 :     case 2: {
; 2418 :         stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
; 2419 :         stbtt_uint8* classRangeRecords = classDefTable + 4;
; 2420 : 
; 2421 :         // Binary search.
; 2422 :         stbtt_int32 l = 0, r = classRangeCount - 1, m;
; 2423 :         int strawStart, strawEnd, needle = glyph;
; 2424 :         while (l <= r) {
; 2425 :             stbtt_uint8* classRangeRecord;
; 2426 :             m = (l + r) >> 1;
; 2427 :             classRangeRecord = classRangeRecords + 6 * m;
; 2428 :             strawStart = ttUSHORT(classRangeRecord);
; 2429 :             strawEnd = ttUSHORT(classRangeRecord + 2);
; 2430 :             if (needle < strawStart)
; 2431 :                 r = m - 1;
; 2432 :             else if (needle > strawEnd)
; 2433 :                 l = m + 1;
; 2434 :             else
; 2435 :                 return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
; 2436 :         }
; 2437 : 
; 2438 :         // [DEAR IMGUI] Commented to fix static analyzer warning
; 2439 :         //classDefTable = classRangeRecords + 6 * classRangeCount;
; 2440 :     } break;
; 2441 : 
; 2442 :     default: {
; 2443 :         // There are no other cases.
; 2444 :         STBTT_assert(0);
; 2445 :     } break;
; 2446 :     }
; 2447 : 
; 2448 :     return -1;
; 2449 : }
; 2450 : 
; 2451 : // Define to STBTT_assert(x) if you want to break on unimplemented formats.
; 2452 : #define STBTT_GPOS_TODO_assert(x)
; 2453 : 
; 2454 : static stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo* info, int glyph1, int glyph2)
; 2455 : {
; 2456 :     stbtt_uint16 lookupListOffset;
; 2457 :     stbtt_uint8* lookupList;
; 2458 :     stbtt_uint16 lookupCount;
; 2459 :     stbtt_uint8* data;
; 2460 :     stbtt_int32 i;
; 2461 : 
; 2462 :     if (!info->gpos) return 0;
; 2463 : 
; 2464 :     data = info->data + info->gpos;
; 2465 : 
; 2466 :     if (ttUSHORT(data + 0) != 1) return 0; // Major version 1
; 2467 :     if (ttUSHORT(data + 2) != 0) return 0; // Minor version 0
; 2468 : 
; 2469 :     lookupListOffset = ttUSHORT(data + 8);
; 2470 :     lookupList = data + lookupListOffset;
; 2471 :     lookupCount = ttUSHORT(lookupList);
; 2472 : 
; 2473 :     for (i = 0; i < lookupCount; ++i) {
; 2474 :         stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
; 2475 :         stbtt_uint8* lookupTable = lookupList + lookupOffset;
; 2476 : 
; 2477 :         stbtt_uint16 lookupType = ttUSHORT(lookupTable);
; 2478 :         stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
; 2479 :         stbtt_uint8* subTableOffsets = lookupTable + 6;
; 2480 :         switch (lookupType) {
; 2481 :         case 2: { // Pair Adjustment Positioning Subtable
; 2482 :             stbtt_int32 sti;
; 2483 :             for (sti = 0; sti < subTableCount; sti++) {
; 2484 :                 stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
; 2485 :                 stbtt_uint8* table = lookupTable + subtableOffset;
; 2486 :                 stbtt_uint16 posFormat = ttUSHORT(table);
; 2487 :                 stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
; 2488 :                 stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
; 2489 :                 if (coverageIndex == -1) continue;
; 2490 : 
; 2491 :                 switch (posFormat) {
; 2492 :                 case 1: {
; 2493 :                     stbtt_int32 l, r, m;
; 2494 :                     int straw, needle;
; 2495 :                     stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
; 2496 :                     stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
; 2497 :                     stbtt_int32 valueRecordPairSizeInBytes = 2;
; 2498 :                     stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
; 2499 :                     stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
; 2500 :                     stbtt_uint8* pairValueTable = table + pairPosOffset;
; 2501 :                     stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
; 2502 :                     stbtt_uint8* pairValueArray = pairValueTable + 2;
; 2503 :                     // TODO: Support more formats.
; 2504 :                     STBTT_GPOS_TODO_assert(valueFormat1 == 4);
; 2505 :                     if (valueFormat1 != 4) return 0;
; 2506 :                     STBTT_GPOS_TODO_assert(valueFormat2 == 0);
; 2507 :                     if (valueFormat2 != 0) return 0;
; 2508 : 
; 2509 :                     STBTT_assert(coverageIndex < pairSetCount);
; 2510 :                     STBTT__NOTUSED(pairSetCount);
; 2511 : 
; 2512 :                     needle = glyph2;
; 2513 :                     r = pairValueCount - 1;
; 2514 :                     l = 0;
; 2515 : 
; 2516 :                     // Binary search.
; 2517 :                     while (l <= r) {
; 2518 :                         stbtt_uint16 secondGlyph;
; 2519 :                         stbtt_uint8* pairValue;
; 2520 :                         m = (l + r) >> 1;
; 2521 :                         pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
; 2522 :                         secondGlyph = ttUSHORT(pairValue);
; 2523 :                         straw = secondGlyph;
; 2524 :                         if (needle < straw)
; 2525 :                             r = m - 1;
; 2526 :                         else if (needle > straw)
; 2527 :                             l = m + 1;
; 2528 :                         else {
; 2529 :                             stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
; 2530 :                             return xAdvance;
; 2531 :                         }
; 2532 :                     }
; 2533 :                 } break;
; 2534 : 
; 2535 :                 case 2: {
; 2536 :                     stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
; 2537 :                     stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
; 2538 : 
; 2539 :                     stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
; 2540 :                     stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
; 2541 :                     int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
; 2542 :                     int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);
; 2543 : 
; 2544 :                     stbtt_uint16 class1Count = ttUSHORT(table + 12);
; 2545 :                     stbtt_uint16 class2Count = ttUSHORT(table + 14);
; 2546 :                     STBTT_assert(glyph1class < class1Count);
; 2547 :                     STBTT_assert(glyph2class < class2Count);
; 2548 : 
; 2549 :                     // TODO: Support more formats.
; 2550 :                     STBTT_GPOS_TODO_assert(valueFormat1 == 4);
; 2551 :                     if (valueFormat1 != 4) return 0;
; 2552 :                     STBTT_GPOS_TODO_assert(valueFormat2 == 0);
; 2553 :                     if (valueFormat2 != 0) return 0;
; 2554 : 
; 2555 :                     if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {
; 2556 :                         stbtt_uint8* class1Records = table + 16;
; 2557 :                         stbtt_uint8* class2Records = class1Records + 2 * (glyph1class * class2Count);
; 2558 :                         stbtt_int16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);
; 2559 :                         return xAdvance;
; 2560 :                     }
; 2561 :                 } break;
; 2562 : 
; 2563 :                 default: {
; 2564 :                     // There are no other cases.
; 2565 :                     STBTT_assert(0);
; 2566 :                     break;
; 2567 :                 } // [DEAR IMGUI] removed ;
; 2568 :                 }
; 2569 :             }
; 2570 :             break;
; 2571 :         } // [DEAR IMGUI] removed ;
; 2572 : 
; 2573 :         default:
; 2574 :             // TODO: Implement other stuff.
; 2575 :             break;
; 2576 :         }
; 2577 :     }
; 2578 : 
; 2579 :     return 0;
; 2580 : }
; 2581 : 
; 2582 : STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo* info, int g1, int g2)
; 2583 : {
; 2584 :     int xAdvance = 0;
; 2585 : 
; 2586 :     if (info->gpos)
; 2587 :         xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);
; 2588 : 
; 2589 :     if (info->kern)
; 2590 :         xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);
; 2591 : 
; 2592 :     return xAdvance;
; 2593 : }
; 2594 : 
; 2595 : STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo* info, int ch1, int ch2)
; 2596 : {
; 2597 :     if (!info->kern && !info->gpos) // if no kerning table, don't waste time looking up both codepoint->glyphs
; 2598 :         return 0;
; 2599 :     return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info, ch1), stbtt_FindGlyphIndex(info, ch2));
; 2600 : }
; 2601 : 
; 2602 : STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo* info, int codepoint, int* advanceWidth, int* leftSideBearing)
; 2603 : {
; 2604 :     stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info, codepoint), advanceWidth, leftSideBearing);
; 2605 : }
; 2606 : 
; 2607 : STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo* info, int* ascent, int* descent, int* lineGap)
; 2608 : {
; 2609 :     if (ascent) *ascent = ttSHORT(info->data + info->hhea + 4);
; 2610 :     if (descent) *descent = ttSHORT(info->data + info->hhea + 6);
; 2611 :     if (lineGap) *lineGap = ttSHORT(info->data + info->hhea + 8);
; 2612 : }
; 2613 : 
; 2614 : STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo* info, int* typoAscent, int* typoDescent, int* typoLineGap)
; 2615 : {
; 2616 :     int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
; 2617 :     if (!tab)
; 2618 :         return 0;
; 2619 :     if (typoAscent) *typoAscent = ttSHORT(info->data + tab + 68);
; 2620 :     if (typoDescent) *typoDescent = ttSHORT(info->data + tab + 70);
; 2621 :     if (typoLineGap) *typoLineGap = ttSHORT(info->data + tab + 72);
; 2622 :     return 1;
; 2623 : }
; 2624 : 
; 2625 : STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo* info, int* x0, int* y0, int* x1, int* y1)
; 2626 : {
; 2627 :     *x0 = ttSHORT(info->data + info->head + 36);
; 2628 :     *y0 = ttSHORT(info->data + info->head + 38);
; 2629 :     *x1 = ttSHORT(info->data + info->head + 40);
; 2630 :     *y1 = ttSHORT(info->data + info->head + 42);
; 2631 : }
; 2632 : 
; 2633 : STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo* info, float height)
; 2634 : {
; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
; 2636 :     return (float)height / fheight;
; 2637 : }
; 2638 : 
; 2639 : STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo* info, float pixels)
; 2640 : {
; 2641 :     int unitsPerEm = ttUSHORT(info->data + info->head + 18);
; 2642 :     return pixels / unitsPerEm;
; 2643 : }
; 2644 : 
; 2645 : STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo* info, stbtt_vertex* v)
; 2646 : {
; 2647 :     STBTT_free(v, info->userdata);
; 2648 : }
; 2649 : 
; 2650 : //////////////////////////////////////////////////////////////////////////////
; 2651 : //
; 2652 : // antialiasing software rasterizer
; 2653 : //
; 2654 : 
; 2655 : STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo* font, int glyph, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1)
; 2656 : {
; 2657 :     int x0 = 0, y0 = 0, x1, y1; // =0 suppresses compiler warning
; 2658 :     if (!stbtt_GetGlyphBox(font, glyph, &x0, &y0, &x1, &y1)) {
; 2659 :         // e.g. space character
; 2660 :         if (ix0) *ix0 = 0;

  001a2	44 8b f3	 mov	 r14d, ebx

; 2661 :         if (iy0) *iy0 = 0;

  001a5	8b eb		 mov	 ebp, ebx
$LN12@stbtt_Make:

; 3651 :     stbtt__bitmap gbm;
; 3652 : 
; 3653 :     stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0, &iy0, 0, 0);
; 3654 :     gbm.pixels = output;
; 3655 :     gbm.w = out_w;
; 3656 :     gbm.h = out_h;
; 3657 :     gbm.stride = out_stride;

  001a7	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR out_stride$[rsp]
  001ae	45 85 e4	 test	 r12d, r12d
  001b1	48 8b bc 24 30
	01 00 00	 mov	 rdi, QWORD PTR vertices$[rsp]
  001b9	4c 89 6c 24 70	 mov	 QWORD PTR gbm$[rsp+16], r13
  001be	4c 8b ac 24 00
	01 00 00	 mov	 r13, QWORD PTR [rsp+256]
  001c6	44 89 64 24 60	 mov	 DWORD PTR gbm$[rsp], r12d
  001cb	4c 8b a4 24 08
	01 00 00	 mov	 r12, QWORD PTR [rsp+264]
  001d3	89 44 24 68	 mov	 DWORD PTR gbm$[rsp+8], eax
  001d7	44 89 7c 24 64	 mov	 DWORD PTR gbm$[rsp+4], r15d

; 3658 : 
; 3659 :     if (gbm.w && gbm.h)

  001dc	0f 84 d5 00 00
	00		 je	 $LN64@stbtt_Make
  001e2	45 85 ff	 test	 r15d, r15d
  001e5	0f 84 cc 00 00
	00		 je	 $LN64@stbtt_Make

; 3588 :     stbtt__point* windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);

  001eb	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3eb33333
  001f3	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR winding_count$3[rsp]
  001fb	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR num_verts$1$[rsp]
  00202	4c 8d 8c 24 30
	01 00 00	 lea	 r9, QWORD PTR winding_lengths$2[rsp]
  0020a	0f 28 c7	 movaps	 xmm0, xmm7
  0020d	89 9c 24 50 01
	00 00		 mov	 DWORD PTR winding_count$3[rsp], ebx
  00214	f3 0f 5d c6	 minss	 xmm0, xmm6
  00218	48 89 9c 24 30
	01 00 00	 mov	 QWORD PTR winding_lengths$2[rsp], rbx
  00220	48 8b cf	 mov	 rcx, rdi
  00223	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00228	f3 0f 5e d0	 divss	 xmm2, xmm0
  0022c	e8 00 00 00 00	 call	 ?stbtt_FlattenCurves@@YAPEAUstbtt__point@@PEAUstbtt_vertex@@HMPEAPEAHPEAHPEAX@Z ; stbtt_FlattenCurves
  00231	48 8b f0	 mov	 rsi, rax

; 3589 :     if (windings) {

  00234	48 85 c0	 test	 rax, rax
  00237	74 7e		 je	 SHORT $LN64@stbtt_Make

; 3590 :         stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);

  00239	48 8b 9c 24 30
	01 00 00	 mov	 rbx, QWORD PTR winding_lengths$2[rsp]
  00241	48 8d 4c 24 60	 lea	 rcx, QWORD PTR gbm$[rsp]
  00246	44 8b 8c 24 50
	01 00 00	 mov	 r9d, DWORD PTR winding_count$3[rsp]
  0024e	4c 8b c3	 mov	 r8, rbx
  00251	89 6c 24 48	 mov	 DWORD PTR [rsp+72], ebp
  00255	48 8b d0	 mov	 rdx, rax
  00258	44 89 74 24 40	 mov	 DWORD PTR [rsp+64], r14d
  0025d	f3 44 0f 11 4c
	24 38		 movss	 DWORD PTR [rsp+56], xmm9
  00264	f3 44 0f 11 44
	24 30		 movss	 DWORD PTR [rsp+48], xmm8
  0026b	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  00271	f3 0f 11 74 24
	20		 movss	 DWORD PTR [rsp+32], xmm6
  00277	e8 00 00 00 00	 call	 ?stbtt__rasterize@@YAXPEAUstbtt__bitmap@@PEAUstbtt__point@@PEAHHMMMMHHHPEAX@Z ; stbtt__rasterize
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  0027c	48 85 db	 test	 rbx, rbx
  0027f	74 12		 je	 SHORT $LN54@stbtt_Make

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00281	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00288	48 85 c0	 test	 rax, rax
  0028b	74 06		 je	 SHORT $LN54@stbtt_Make

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0028d	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN54@stbtt_Make:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00293	48 8b cb	 mov	 rcx, rbx
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0029c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  002a3	48 85 c0	 test	 rax, rax
  002a6	74 06		 je	 SHORT $LN62@stbtt_Make

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  002a8	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN62@stbtt_Make:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  002ae	48 8b ce	 mov	 rcx, rsi
  002b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN64@stbtt_Make:
  002b7	44 0f 28 8c 24
	b0 00 00 00	 movaps	 xmm9, XMMWORD PTR [rsp+176]

; 3609 :     if (ptr)

  002c0	44 0f 28 84 24
	c0 00 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+192]
  002c9	0f 28 bc 24 d0
	00 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+208]
  002d1	0f 28 b4 24 e0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+224]
  002d9	4c 8b bc 24 f0
	00 00 00	 mov	 r15, QWORD PTR [rsp+240]
  002e1	4c 8b b4 24 f8
	00 00 00	 mov	 r14, QWORD PTR [rsp+248]
  002e9	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR [rsp+272]
  002f1	48 8b ac 24 18
	01 00 00	 mov	 rbp, QWORD PTR [rsp+280]
  002f9	48 8b 9c 24 38
	01 00 00	 mov	 rbx, QWORD PTR [rsp+312]
  00301	48 85 ff	 test	 rdi, rdi
  00304	74 12		 je	 SHORT $LN70@stbtt_Make

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00306	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0030d	48 85 c0	 test	 rax, rax
  00310	74 06		 je	 SHORT $LN70@stbtt_Make

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00312	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN70@stbtt_Make:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00318	48 8b cf	 mov	 rcx, rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3663 : }

  0031b	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  00322	5f		 pop	 rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00323	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
stbtt_MakeGlyphBitmapSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
spc$ = 64
pixels$dead$ = 72
pw$ = 80
ph$dead$ = 88
stride_in_bytes$dead$ = 96
padding$ = 104
alloc_context$dead$ = 112
stbtt_PackBegin PROC

; 3846 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3846 : {

  00021	41 8b e8	 mov	 ebp, r8d
  00024	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00027	48 85 c0	 test	 rax, rax
  0002a	74 06		 je	 SHORT $LN9@stbtt_Pack

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  0002c	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN9@stbtt_Pack:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00032	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3848 :     int            num_nodes = pw - padding;

  0003d	44 8b 74 24 68	 mov	 r14d, DWORD PTR padding$[rsp]
  00042	8b fd		 mov	 edi, ebp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3848 :     int            num_nodes = pw - padding;

  0004b	41 2b fe	 sub	 edi, r14d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0004e	48 8b f0	 mov	 rsi, rax

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00051	48 85 c9	 test	 rcx, rcx
  00054	74 06		 je	 SHORT $LN16@stbtt_Pack

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00056	ff 81 ec 00 00
	00		 inc	 DWORD PTR [rcx+236]
$LN16@stbtt_Pack:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3849 :     stbrp_node* nodes = (stbrp_node*)STBTT_malloc(sizeof(*nodes) * num_nodes, alloc_context);

  0005c	48 63 cf	 movsxd	 rcx, edi
  0005f	48 c1 e1 04	 shl	 rcx, 4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00069	48 8b c8	 mov	 rcx, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3851 :     if (context == NULL || nodes == NULL) {

  0006c	48 85 f6	 test	 rsi, rsi
  0006f	74 6d		 je	 SHORT $LN26@stbtt_Pack
  00071	48 85 c0	 test	 rax, rax
  00074	74 51		 je	 SHORT $LN3@stbtt_Pack

; 3855 :     }
; 3856 : 
; 3857 :     spc->user_allocator_context = alloc_context;

  00076	33 c0		 xor	 eax, eax

; 3858 :     spc->width = pw;
; 3859 :     spc->height = ph;
; 3860 :     spc->pixels = pixels;
; 3861 :     spc->pack_info = context;
; 3862 :     spc->nodes = nodes;

  00078	48 89 4b 38	 mov	 QWORD PTR [rbx+56], rcx
  0007c	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00082	48 89 03	 mov	 QWORD PTR [rbx], rax
  00085	44 89 43 14	 mov	 DWORD PTR [rbx+20], r8d

; 3863 :     spc->padding = padding;
; 3864 :     spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
; 3865 :     spc->h_oversample = 1;
; 3866 :     spc->v_oversample = 1;
; 3867 :     spc->skip_missing = 0;
; 3868 : 
; 3869 :     stbrp_init_target(context, pw - padding, ph - padding, nodes, num_nodes);

  00089	4c 8b c9	 mov	 r9, rcx
  0008c	45 2b c6	 sub	 r8d, r14d
  0008f	89 6b 10	 mov	 DWORD PTR [rbx+16], ebp
  00092	8b d7		 mov	 edx, edi
  00094	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  00098	48 8b ce	 mov	 rcx, rsi
  0009b	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  0009f	44 89 73 1c	 mov	 DWORD PTR [rbx+28], r14d
  000a3	89 6b 18	 mov	 DWORD PTR [rbx+24], ebp
  000a6	c7 43 24 01 00
	00 00		 mov	 DWORD PTR [rbx+36], 1
  000ad	c7 43 28 01 00
	00 00		 mov	 DWORD PTR [rbx+40], 1
  000b4	89 43 20	 mov	 DWORD PTR [rbx+32], eax
  000b7	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  000bb	e8 00 00 00 00	 call	 stbrp_init_target

; 3870 : 
; 3871 :     if (pixels)
; 3872 :         STBTT_memset(pixels, 0, pw * ph); // background of 0 around pixels
; 3873 : 
; 3874 :     return 1;

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	eb 36		 jmp	 SHORT $LN1@stbtt_Pack
$LN3@stbtt_Pack:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000ce	48 85 c0	 test	 rax, rax
  000d1	74 06		 je	 SHORT $LN24@stbtt_Pack

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000d3	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN24@stbtt_Pack:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000d9	48 8b ce	 mov	 rcx, rsi
  000dc	eb 17		 jmp	 SHORT $LN32@stbtt_Pack
$LN26@stbtt_Pack:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3853 :         if (nodes != NULL) STBTT_free(nodes, alloc_context);

  000de	48 85 c9	 test	 rcx, rcx
  000e1	74 18		 je	 SHORT $LN34@stbtt_Pack
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000ea	48 85 c0	 test	 rax, rax
  000ed	74 06		 je	 SHORT $LN32@stbtt_Pack

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000ef	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN32@stbtt_Pack:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3854 :         return 0;

  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN34@stbtt_Pack:
  000fb	33 c0		 xor	 eax, eax
$LN1@stbtt_Pack:

; 3875 : }

  000fd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00102	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00107	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0010c	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00111	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00115	41 5e		 pop	 r14
  00117	c3		 ret	 0
stbtt_PackBegin ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
spc$ = 48
stbtt_PackEnd PROC

; 3878 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 3879 :     STBTT_free(spc->nodes, spc->user_allocator_context);

  00009	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 12		 je	 SHORT $LN5@stbtt_Pack

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00019	48 85 c0	 test	 rax, rax
  0001c	74 06		 je	 SHORT $LN5@stbtt_Pack

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0001e	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN5@stbtt_Pack:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3880 :     STBTT_free(spc->pack_info, spc->user_allocator_context);

  0002a	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  0002e	48 85 c9	 test	 rcx, rcx
  00031	74 12		 je	 SHORT $LN13@stbtt_Pack

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 06		 je	 SHORT $LN13@stbtt_Pack

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0003f	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN13@stbtt_Pack:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3881 : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0004a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
stbtt_PackEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
w$1$ = 32
tv713 = 40
buffer$ = 48
__$ArrayPad$ = 56
pixels$ = 112
w$ = 120
h$ = 128
stride_in_bytes$ = 136
kernel_width$ = 144
?stbtt__h_prefilter@@YAXPEAEHHHI@Z PROC			; stbtt__h_prefilter

; 3901 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001d	44 8b a4 24 90
	00 00 00	 mov	 r12d, DWORD PTR kernel_width$[rsp]

; 3902 :     unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 3903 :     int safe_w = w - kernel_width;

  00025	8b c2		 mov	 eax, edx
  00027	41 2b c4	 sub	 eax, r12d
  0002a	89 54 24 20	 mov	 DWORD PTR w$1$[rsp], edx

; 3904 :     int j;
; 3905 :     STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze

  0002e	49 c7 43 c8 00
	00 00 00	 mov	 QWORD PTR [r11-56], 0
  00036	8b ea		 mov	 ebp, edx

; 3943 :         default:
; 3944 :             for (i = 0; i <= safe_w; ++i) {

  00038	4c 63 f0	 movsxd	 r14, eax
  0003b	4c 8b f9	 mov	 r15, rcx
  0003e	45 85 c0	 test	 r8d, r8d
  00041	0f 8e 6c 02 00
	00		 jle	 $LN3@stbtt__h_p

; 3901 : {

  00047	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  0004b	41 8b cc	 mov	 ecx, r12d
  0004e	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  00052	49 89 7b 20	 mov	 QWORD PTR [r11+32], rdi
  00056	49 63 c1	 movsxd	 rax, r9d
  00059	4d 89 6b d8	 mov	 QWORD PTR [r11-40], r13
  0005d	45 8b e8	 mov	 r13d, r8d
  00060	48 89 44 24 28	 mov	 QWORD PTR tv713[rsp], rax
  00065	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@stbtt__h_p:

; 3907 :         int i;
; 3908 :         unsigned int total;
; 3909 :         STBTT_memset(buffer, 0, kernel_width);

  00070	4c 8b c1	 mov	 r8, rcx
  00073	33 d2		 xor	 edx, edx
  00075	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0007a	e8 00 00 00 00	 call	 memset

; 3910 : 
; 3911 :         total = 0;
; 3912 : 
; 3913 :         // make kernel_width a constant in common cases so compiler can optimize out the divide
; 3914 :         switch (kernel_width) {

  0007f	41 8b c4	 mov	 eax, r12d
  00082	33 db		 xor	 ebx, ebx
  00084	83 e8 02	 sub	 eax, 2
  00087	0f 84 5f 01 00
	00		 je	 $LN28@stbtt__h_p
  0008d	83 e8 01	 sub	 eax, 1
  00090	0f 84 07 01 00
	00		 je	 $LN29@stbtt__h_p
  00096	83 e8 01	 sub	 eax, 1
  00099	0f 84 b1 00 00
	00		 je	 $LN30@stbtt__h_p
  0009f	33 c9		 xor	 ecx, ecx
  000a1	83 f8 01	 cmp	 eax, 1
  000a4	74 58		 je	 SHORT $LN31@stbtt__h_p

; 3943 :         default:
; 3944 :             for (i = 0; i <= safe_w; ++i) {

  000a6	4d 85 f6	 test	 r14, r14
  000a9	0f 88 86 01 00
	00		 js	 $LN8@stbtt__h_p
  000af	4d 8b cf	 mov	 r9, r15
  000b2	4d 8d 56 01	 lea	 r10, QWORD PTR [r14+1]
  000b6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL21@stbtt__h_p:

; 3945 :                 total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  000c0	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  000c4	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  000c8	48 63 c1	 movsxd	 rax, ecx
  000cb	41 8b d0	 mov	 edx, r8d
  000ce	83 e0 07	 and	 eax, 7
  000d1	0f b6 44 04 30	 movzx	 eax, BYTE PTR buffer$[rsp+rax]
  000d6	2b d0		 sub	 edx, eax

; 3946 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];

  000d8	41 8d 04 0c	 lea	 eax, DWORD PTR [r12+rcx]
  000dc	83 e0 07	 and	 eax, 7
  000df	03 da		 add	 ebx, edx

; 3947 :                 pixels[i] = (unsigned char)(total / kernel_width);

  000e1	33 d2		 xor	 edx, edx
  000e3	ff c1		 inc	 ecx
  000e5	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b
  000ea	8b c3		 mov	 eax, ebx
  000ec	41 f7 f4	 div	 r12d
  000ef	41 88 41 ff	 mov	 BYTE PTR [r9-1], al
  000f3	49 83 ea 01	 sub	 r10, 1
  000f7	75 c7		 jne	 SHORT $LL21@stbtt__h_p

; 3943 :         default:
; 3944 :             for (i = 0; i <= safe_w; ++i) {

  000f9	e9 37 01 00 00	 jmp	 $LN8@stbtt__h_p
$LN31@stbtt__h_p:

; 3936 :         case 5:
; 3937 :             for (i = 0; i <= safe_w; ++i) {

  000fe	4d 85 f6	 test	 r14, r14
  00101	0f 88 2e 01 00
	00		 js	 $LN8@stbtt__h_p
  00107	4d 8b cf	 mov	 r9, r15
  0010a	4d 8d 56 01	 lea	 r10, QWORD PTR [r14+1]
  0010e	66 90		 npad	 2
$LL18@stbtt__h_p:

; 3938 :                 total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  00110	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00114	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00118	48 63 c1	 movsxd	 rax, ecx
  0011b	41 8b d0	 mov	 edx, r8d
  0011e	83 e0 07	 and	 eax, 7
  00121	0f b6 44 04 30	 movzx	 eax, BYTE PTR buffer$[rsp+rax]
  00126	2b d0		 sub	 edx, eax

; 3939 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];

  00128	8d 41 fd	 lea	 eax, DWORD PTR [rcx-3]
  0012b	83 e0 07	 and	 eax, 7
  0012e	03 da		 add	 ebx, edx
  00130	ff c1		 inc	 ecx
  00132	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b

; 3940 :                 pixels[i] = (unsigned char)(total / 5);

  00137	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0013c	f7 e3		 mul	 ebx
  0013e	c1 ea 02	 shr	 edx, 2
  00141	41 88 51 ff	 mov	 BYTE PTR [r9-1], dl
  00145	49 83 ea 01	 sub	 r10, 1
  00149	75 c5		 jne	 SHORT $LL18@stbtt__h_p

; 3941 :             }
; 3942 :             break;

  0014b	e9 e5 00 00 00	 jmp	 $LN8@stbtt__h_p
$LN30@stbtt__h_p:

; 3929 :         case 4:
; 3930 :             for (i = 0; i <= safe_w; ++i) {

  00150	33 c9		 xor	 ecx, ecx
  00152	4d 85 f6	 test	 r14, r14
  00155	0f 88 da 00 00
	00		 js	 $LN8@stbtt__h_p
  0015b	4d 8b cf	 mov	 r9, r15
  0015e	4d 8d 56 01	 lea	 r10, QWORD PTR [r14+1]
$LL15@stbtt__h_p:

; 3931 :                 total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  00162	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00166	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  0016a	48 63 c1	 movsxd	 rax, ecx
  0016d	41 8b d0	 mov	 edx, r8d
  00170	83 e0 07	 and	 eax, 7
  00173	0f b6 44 04 30	 movzx	 eax, BYTE PTR buffer$[rsp+rax]
  00178	2b d0		 sub	 edx, eax

; 3932 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];

  0017a	8d 41 fc	 lea	 eax, DWORD PTR [rcx-4]
  0017d	83 e0 07	 and	 eax, 7
  00180	03 da		 add	 ebx, edx
  00182	ff c1		 inc	 ecx
  00184	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b

; 3933 :                 pixels[i] = (unsigned char)(total / 4);

  00189	8b c3		 mov	 eax, ebx
  0018b	c1 e8 02	 shr	 eax, 2
  0018e	41 88 41 ff	 mov	 BYTE PTR [r9-1], al
  00192	49 83 ea 01	 sub	 r10, 1
  00196	75 ca		 jne	 SHORT $LL15@stbtt__h_p

; 3934 :             }
; 3935 :             break;

  00198	e9 98 00 00 00	 jmp	 $LN8@stbtt__h_p
$LN29@stbtt__h_p:

; 3920 :             }
; 3921 :             break;
; 3922 :         case 3:
; 3923 :             for (i = 0; i <= safe_w; ++i) {

  0019d	33 c9		 xor	 ecx, ecx
  0019f	4d 85 f6	 test	 r14, r14
  001a2	0f 88 8d 00 00
	00		 js	 $LN8@stbtt__h_p
  001a8	4d 8b cf	 mov	 r9, r15
  001ab	4d 8d 56 01	 lea	 r10, QWORD PTR [r14+1]
  001af	90		 npad	 1
$LL12@stbtt__h_p:

; 3924 :                 total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  001b0	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  001b4	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  001b8	48 63 c1	 movsxd	 rax, ecx
  001bb	41 8b d0	 mov	 edx, r8d
  001be	83 e0 07	 and	 eax, 7
  001c1	0f b6 44 04 30	 movzx	 eax, BYTE PTR buffer$[rsp+rax]
  001c6	2b d0		 sub	 edx, eax

; 3925 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];

  001c8	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  001cb	83 e0 07	 and	 eax, 7
  001ce	03 da		 add	 ebx, edx
  001d0	ff c1		 inc	 ecx
  001d2	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b

; 3926 :                 pixels[i] = (unsigned char)(total / 3);

  001d7	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001dc	f7 e3		 mul	 ebx
  001de	d1 ea		 shr	 edx, 1
  001e0	41 88 51 ff	 mov	 BYTE PTR [r9-1], dl
  001e4	49 83 ea 01	 sub	 r10, 1
  001e8	75 c6		 jne	 SHORT $LL12@stbtt__h_p

; 3927 :             }
; 3928 :             break;

  001ea	eb 49		 jmp	 SHORT $LN8@stbtt__h_p
$LN28@stbtt__h_p:

; 3915 :         case 2:
; 3916 :             for (i = 0; i <= safe_w; ++i) {

  001ec	33 c9		 xor	 ecx, ecx
  001ee	4d 85 f6	 test	 r14, r14
  001f1	78 42		 js	 SHORT $LN8@stbtt__h_p
  001f3	4d 8b cf	 mov	 r9, r15
  001f6	4d 8d 56 01	 lea	 r10, QWORD PTR [r14+1]
  001fa	66 0f 1f 44 00
	00		 npad	 6
$LL9@stbtt__h_p:

; 3917 :                 total += pixels[i] - buffer[i & STBTT__OVER_MASK];

  00200	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00204	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00208	48 63 c1	 movsxd	 rax, ecx
  0020b	41 8b d0	 mov	 edx, r8d
  0020e	83 e0 07	 and	 eax, 7
  00211	0f b6 44 04 30	 movzx	 eax, BYTE PTR buffer$[rsp+rax]
  00216	2b d0		 sub	 edx, eax

; 3918 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];

  00218	8d 41 02	 lea	 eax, DWORD PTR [rcx+2]
  0021b	83 e0 07	 and	 eax, 7
  0021e	03 da		 add	 ebx, edx
  00220	ff c1		 inc	 ecx
  00222	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b

; 3919 :                 pixels[i] = (unsigned char)(total / 2);

  00227	8b c3		 mov	 eax, ebx
  00229	d1 e8		 shr	 eax, 1
  0022b	41 88 41 ff	 mov	 BYTE PTR [r9-1], al
  0022f	49 83 ea 01	 sub	 r10, 1
  00233	75 cb		 jne	 SHORT $LL9@stbtt__h_p
$LN8@stbtt__h_p:

; 3948 :             }
; 3949 :             break;
; 3950 :         }
; 3951 : 
; 3952 :         for (; i < w; ++i) {

  00235	3b cd		 cmp	 ecx, ebp
  00237	7d 4e		 jge	 SHORT $LN23@stbtt__h_p
  00239	48 63 f1	 movsxd	 rsi, ecx
  0023c	2b e9		 sub	 ebp, ecx
  0023e	4a 8d 3c 3e	 lea	 rdi, QWORD PTR [rsi+r15]
$LL24@stbtt__h_p:

; 3953 :             STBTT_assert(pixels[i] == 0);

  00242	80 3f 00	 cmp	 BYTE PTR [rdi], 0
  00245	74 1a		 je	 SHORT $LN25@stbtt__h_p
  00247	41 b8 71 0f 00
	00		 mov	 r8d, 3953		; 00000f71H
  0024d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00254	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@BDJAMAMF@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
  0025b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN25@stbtt__h_p:

; 3954 :             total -= buffer[i & STBTT__OVER_MASK];

  00261	48 8b c6	 mov	 rax, rsi

; 3955 :             pixels[i] = (unsigned char)(total / kernel_width);

  00264	33 d2		 xor	 edx, edx
  00266	83 e0 07	 and	 eax, 7
  00269	48 ff c6	 inc	 rsi
  0026c	0f b6 44 04 30	 movzx	 eax, BYTE PTR buffer$[rsp+rax]
  00271	2b d8		 sub	 ebx, eax
  00273	8b c3		 mov	 eax, ebx
  00275	41 f7 f4	 div	 r12d
  00278	88 07		 mov	 BYTE PTR [rdi], al
  0027a	48 ff c7	 inc	 rdi
  0027d	48 83 ed 01	 sub	 rbp, 1
  00281	75 bf		 jne	 SHORT $LL24@stbtt__h_p
  00283	8b 6c 24 20	 mov	 ebp, DWORD PTR w$1$[rsp]
$LN23@stbtt__h_p:

; 3956 :         }
; 3957 : 
; 3958 :         pixels += stride_in_bytes;

  00287	4c 03 7c 24 28	 add	 r15, QWORD PTR tv713[rsp]
  0028c	49 8b cc	 mov	 rcx, r12
  0028f	49 83 ed 01	 sub	 r13, 1
  00293	0f 85 d7 fd ff
	ff		 jne	 $LL4@stbtt__h_p

; 3906 :     for (j = 0; j < h; ++j) {

  00299	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
  0029e	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]
  002a6	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  002ae	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
$LN3@stbtt__h_p:

; 3959 :     }
; 3960 : }

  002b3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b8	48 33 cc	 xor	 rcx, rsp
  002bb	e8 00 00 00 00	 call	 __security_check_cookie
  002c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002c4	41 5f		 pop	 r15
  002c6	41 5e		 pop	 r14
  002c8	41 5c		 pop	 r12
  002ca	5d		 pop	 rbp
  002cb	c3		 ret	 0
?stbtt__h_prefilter@@YAXPEAEHHHI@Z ENDP			; stbtt__h_prefilter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
kernel_width$GSCopy$1$ = 32
h$1$ = 36
tv876 = 40
buffer$ = 48
__$ArrayPad$ = 56
pixels$ = 128
w$ = 136
h$ = 144
stride_in_bytes$ = 152
kernel_width$ = 160
?stbtt__v_prefilter@@YAXPEAEHHHI@Z PROC			; stbtt__v_prefilter

; 3963 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001e	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR kernel_width$[rsp]

; 3964 :     unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 3965 :     int safe_h = h - kernel_width;

  00025	41 8b f0	 mov	 esi, r8d
  00028	2b f7		 sub	 esi, edi
  0002a	4d 63 e1	 movsxd	 r12, r9d
  0002d	44 89 44 24 24	 mov	 DWORD PTR h$1$[rsp], r8d
  00032	45 8b f8	 mov	 r15d, r8d
  00035	89 7c 24 20	 mov	 DWORD PTR kernel_width$GSCopy$1$[rsp], edi
  00039	4c 8b f1	 mov	 r14, rcx

; 3966 :     int j;
; 3967 :     STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze

  0003c	49 c7 43 b8 00
	00 00 00	 mov	 QWORD PTR [r11-72], 0

; 3968 :     for (j = 0; j < w; ++j) {

  00044	85 d2		 test	 edx, edx
  00046	0f 8e 6c 02 00
	00		 jle	 $LN3@stbtt__v_p

; 3963 : {

  0004c	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00050	8b c7		 mov	 eax, edi
  00052	49 89 6b d0	 mov	 QWORD PTR [r11-48], rbp
  00056	8b ea		 mov	 ebp, edx
  00058	48 89 6c 24 28	 mov	 QWORD PTR tv876[rsp], rbp
  0005d	4d 89 6b c8	 mov	 QWORD PTR [r11-56], r13
$LL4@stbtt__v_p:

; 3969 :         int i;
; 3970 :         unsigned int total;
; 3971 :         STBTT_memset(buffer, 0, kernel_width);

  00061	4c 8b c0	 mov	 r8, rax
  00064	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00069	33 d2		 xor	 edx, edx
  0006b	e8 00 00 00 00	 call	 memset

; 3972 : 
; 3973 :         total = 0;
; 3974 : 
; 3975 :         // make kernel_width a constant in common cases so compiler can optimize out the divide
; 3976 :         switch (kernel_width) {

  00070	8b c7		 mov	 eax, edi
  00072	33 db		 xor	 ebx, ebx
  00074	83 e8 02	 sub	 eax, 2
  00077	0f 84 5f 01 00
	00		 je	 $LN28@stbtt__v_p
  0007d	83 e8 01	 sub	 eax, 1
  00080	0f 84 05 01 00
	00		 je	 $LN29@stbtt__v_p
  00086	83 e8 01	 sub	 eax, 1
  00089	0f 84 b1 00 00
	00		 je	 $LN30@stbtt__v_p
  0008f	33 c9		 xor	 ecx, ecx
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 56		 je	 SHORT $LN31@stbtt__v_p

; 4005 :         default:
; 4006 :             for (i = 0; i <= safe_h; ++i) {

  00096	85 f6		 test	 esi, esi
  00098	0f 88 87 01 00
	00		 js	 $LN8@stbtt__v_p
  0009e	45 33 d2	 xor	 r10d, r10d
  000a1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL21@stbtt__v_p:

; 4007 :                 total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  000b0	8b c1		 mov	 eax, ecx
  000b2	4d 63 ca	 movsxd	 r9, r10d
  000b5	83 e0 07	 and	 eax, 7
  000b8	45 03 d4	 add	 r10d, r12d
  000bb	47 0f b6 04 31	 movzx	 r8d, BYTE PTR [r9+r14]
  000c0	0f b6 54 04 30	 movzx	 edx, BYTE PTR buffer$[rsp+rax]
  000c5	41 8b c0	 mov	 eax, r8d
  000c8	2b c2		 sub	 eax, edx

; 4008 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];
; 4009 :                 pixels[i * stride_in_bytes] = (unsigned char)(total / kernel_width);

  000ca	33 d2		 xor	 edx, edx
  000cc	03 d8		 add	 ebx, eax
  000ce	8d 04 0f	 lea	 eax, DWORD PTR [rdi+rcx]
  000d1	83 e0 07	 and	 eax, 7
  000d4	ff c1		 inc	 ecx
  000d6	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b
  000db	8b c3		 mov	 eax, ebx
  000dd	f7 f7		 div	 edi
  000df	43 88 04 31	 mov	 BYTE PTR [r9+r14], al
  000e3	3b ce		 cmp	 ecx, esi
  000e5	7e c9		 jle	 SHORT $LL21@stbtt__v_p

; 4005 :         default:
; 4006 :             for (i = 0; i <= safe_h; ++i) {

  000e7	e9 39 01 00 00	 jmp	 $LN8@stbtt__v_p
$LN31@stbtt__v_p:

; 3998 :         case 5:
; 3999 :             for (i = 0; i <= safe_h; ++i) {

  000ec	85 f6		 test	 esi, esi
  000ee	0f 88 31 01 00
	00		 js	 $LN8@stbtt__v_p
  000f4	45 33 d2	 xor	 r10d, r10d
  000f7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@stbtt__v_p:

; 4000 :                 total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  00100	8b c1		 mov	 eax, ecx
  00102	4d 63 ca	 movsxd	 r9, r10d
  00105	83 e0 07	 and	 eax, 7
  00108	45 03 d4	 add	 r10d, r12d
  0010b	47 0f b6 04 31	 movzx	 r8d, BYTE PTR [r9+r14]
  00110	0f b6 54 04 30	 movzx	 edx, BYTE PTR buffer$[rsp+rax]
  00115	41 8b c0	 mov	 eax, r8d
  00118	2b c2		 sub	 eax, edx
  0011a	03 d8		 add	 ebx, eax

; 4001 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];

  0011c	8d 41 fd	 lea	 eax, DWORD PTR [rcx-3]
  0011f	83 e0 07	 and	 eax, 7
  00122	ff c1		 inc	 ecx
  00124	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b

; 4002 :                 pixels[i * stride_in_bytes] = (unsigned char)(total / 5);

  00129	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0012e	f7 e3		 mul	 ebx
  00130	c1 ea 02	 shr	 edx, 2
  00133	43 88 14 31	 mov	 BYTE PTR [r9+r14], dl
  00137	3b ce		 cmp	 ecx, esi
  00139	7e c5		 jle	 SHORT $LL18@stbtt__v_p

; 4003 :             }
; 4004 :             break;

  0013b	e9 e5 00 00 00	 jmp	 $LN8@stbtt__v_p
$LN30@stbtt__v_p:

; 3991 :         case 4:
; 3992 :             for (i = 0; i <= safe_h; ++i) {

  00140	33 c9		 xor	 ecx, ecx
  00142	85 f6		 test	 esi, esi
  00144	0f 88 db 00 00
	00		 js	 $LN8@stbtt__v_p
  0014a	45 33 d2	 xor	 r10d, r10d
  0014d	0f 1f 00	 npad	 3
$LL15@stbtt__v_p:

; 3993 :                 total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  00150	8b c1		 mov	 eax, ecx
  00152	4d 63 ca	 movsxd	 r9, r10d
  00155	83 e0 07	 and	 eax, 7
  00158	45 03 d4	 add	 r10d, r12d
  0015b	47 0f b6 04 31	 movzx	 r8d, BYTE PTR [r9+r14]
  00160	0f b6 54 04 30	 movzx	 edx, BYTE PTR buffer$[rsp+rax]
  00165	41 8b c0	 mov	 eax, r8d
  00168	2b c2		 sub	 eax, edx
  0016a	03 d8		 add	 ebx, eax

; 3994 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];

  0016c	8d 41 fc	 lea	 eax, DWORD PTR [rcx-4]
  0016f	83 e0 07	 and	 eax, 7
  00172	ff c1		 inc	 ecx
  00174	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b

; 3995 :                 pixels[i * stride_in_bytes] = (unsigned char)(total / 4);

  00179	8b c3		 mov	 eax, ebx
  0017b	c1 e8 02	 shr	 eax, 2
  0017e	43 88 04 31	 mov	 BYTE PTR [r9+r14], al
  00182	3b ce		 cmp	 ecx, esi
  00184	7e ca		 jle	 SHORT $LL15@stbtt__v_p

; 3996 :             }
; 3997 :             break;

  00186	e9 9a 00 00 00	 jmp	 $LN8@stbtt__v_p
$LN29@stbtt__v_p:

; 3982 :             }
; 3983 :             break;
; 3984 :         case 3:
; 3985 :             for (i = 0; i <= safe_h; ++i) {

  0018b	33 c9		 xor	 ecx, ecx
  0018d	85 f6		 test	 esi, esi
  0018f	0f 88 90 00 00
	00		 js	 $LN8@stbtt__v_p
  00195	45 33 d2	 xor	 r10d, r10d
  00198	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL12@stbtt__v_p:

; 3986 :                 total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  001a0	8b c1		 mov	 eax, ecx
  001a2	4d 63 ca	 movsxd	 r9, r10d
  001a5	83 e0 07	 and	 eax, 7
  001a8	45 03 d4	 add	 r10d, r12d
  001ab	47 0f b6 04 31	 movzx	 r8d, BYTE PTR [r9+r14]
  001b0	0f b6 54 04 30	 movzx	 edx, BYTE PTR buffer$[rsp+rax]
  001b5	41 8b c0	 mov	 eax, r8d
  001b8	2b c2		 sub	 eax, edx
  001ba	03 d8		 add	 ebx, eax

; 3987 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];

  001bc	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  001bf	83 e0 07	 and	 eax, 7
  001c2	ff c1		 inc	 ecx
  001c4	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b

; 3988 :                 pixels[i * stride_in_bytes] = (unsigned char)(total / 3);

  001c9	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001ce	f7 e3		 mul	 ebx
  001d0	d1 ea		 shr	 edx, 1
  001d2	43 88 14 31	 mov	 BYTE PTR [r9+r14], dl
  001d6	3b ce		 cmp	 ecx, esi
  001d8	7e c6		 jle	 SHORT $LL12@stbtt__v_p

; 3989 :             }
; 3990 :             break;

  001da	eb 49		 jmp	 SHORT $LN8@stbtt__v_p
$LN28@stbtt__v_p:

; 3977 :         case 2:
; 3978 :             for (i = 0; i <= safe_h; ++i) {

  001dc	33 c9		 xor	 ecx, ecx
  001de	85 f6		 test	 esi, esi
  001e0	78 43		 js	 SHORT $LN8@stbtt__v_p
  001e2	45 33 d2	 xor	 r10d, r10d
  001e5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL9@stbtt__v_p:

; 3979 :                 total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

  001f0	8b c1		 mov	 eax, ecx
  001f2	4d 63 ca	 movsxd	 r9, r10d
  001f5	83 e0 07	 and	 eax, 7
  001f8	45 03 d4	 add	 r10d, r12d
  001fb	47 0f b6 04 31	 movzx	 r8d, BYTE PTR [r9+r14]
  00200	0f b6 54 04 30	 movzx	 edx, BYTE PTR buffer$[rsp+rax]
  00205	41 8b c0	 mov	 eax, r8d
  00208	2b c2		 sub	 eax, edx
  0020a	03 d8		 add	 ebx, eax

; 3980 :                 buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];

  0020c	8d 41 02	 lea	 eax, DWORD PTR [rcx+2]
  0020f	83 e0 07	 and	 eax, 7
  00212	ff c1		 inc	 ecx
  00214	44 88 44 04 30	 mov	 BYTE PTR buffer$[rsp+rax], r8b

; 3981 :                 pixels[i * stride_in_bytes] = (unsigned char)(total / 2);

  00219	8b c3		 mov	 eax, ebx
  0021b	d1 e8		 shr	 eax, 1
  0021d	43 88 04 31	 mov	 BYTE PTR [r9+r14], al
  00221	3b ce		 cmp	 ecx, esi
  00223	7e cb		 jle	 SHORT $LL9@stbtt__v_p
$LN8@stbtt__v_p:

; 4010 :             }
; 4011 :             break;
; 4012 :         }
; 4013 : 
; 4014 :         for (; i < h; ++i) {

  00225	41 3b cf	 cmp	 ecx, r15d
  00228	7d 68		 jge	 SHORT $LN23@stbtt__v_p
  0022a	41 8b c4	 mov	 eax, r12d
  0022d	48 63 e9	 movsxd	 rbp, ecx
  00230	0f af c1	 imul	 eax, ecx
  00233	48 63 f8	 movsxd	 rdi, eax
  00236	49 03 fe	 add	 rdi, r14
  00239	44 2b f9	 sub	 r15d, ecx
  0023c	8b 4c 24 20	 mov	 ecx, DWORD PTR kernel_width$GSCopy$1$[rsp]
$LL24@stbtt__v_p:

; 4015 :             STBTT_assert(pixels[i * stride_in_bytes] == 0);

  00240	80 3f 00	 cmp	 BYTE PTR [rdi], 0
  00243	74 1e		 je	 SHORT $LN25@stbtt__v_p
  00245	41 b8 af 0f 00
	00		 mov	 r8d, 4015		; 00000fafH
  0024b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@DIJHBPFC@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@IGKGDOM@?$AAp?$AAi?$AAx?$AAe?$AAl?$AAs?$AA?$FL?$AAi?$AA?5?$AA?$CK?$AA?5?$AAs?$AAt?$AAr?$AAi@
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0025f	8b 4c 24 20	 mov	 ecx, DWORD PTR kernel_width$GSCopy$1$[rsp]
$LN25@stbtt__v_p:

; 4016 :             total -= buffer[i & STBTT__OVER_MASK];

  00263	48 8b c5	 mov	 rax, rbp

; 4017 :             pixels[i * stride_in_bytes] = (unsigned char)(total / kernel_width);

  00266	33 d2		 xor	 edx, edx
  00268	83 e0 07	 and	 eax, 7
  0026b	48 ff c5	 inc	 rbp
  0026e	0f b6 44 04 30	 movzx	 eax, BYTE PTR buffer$[rsp+rax]
  00273	2b d8		 sub	 ebx, eax
  00275	8b c3		 mov	 eax, ebx
  00277	f7 f1		 div	 ecx
  00279	88 07		 mov	 BYTE PTR [rdi], al
  0027b	49 03 fc	 add	 rdi, r12
  0027e	49 83 ef 01	 sub	 r15, 1
  00282	75 bc		 jne	 SHORT $LL24@stbtt__v_p
  00284	8b 7c 24 20	 mov	 edi, DWORD PTR kernel_width$GSCopy$1$[rsp]
  00288	48 8b 6c 24 28	 mov	 rbp, QWORD PTR tv876[rsp]
  0028d	44 8b 7c 24 24	 mov	 r15d, DWORD PTR h$1$[rsp]
$LN23@stbtt__v_p:

; 4018 :         }
; 4019 : 
; 4020 :         pixels += 1;

  00292	49 ff c6	 inc	 r14
  00295	8b c7		 mov	 eax, edi
  00297	48 83 ed 01	 sub	 rbp, 1
  0029b	48 89 6c 24 28	 mov	 QWORD PTR tv876[rsp], rbp
  002a0	0f 85 bb fd ff
	ff		 jne	 $LL4@stbtt__v_p

; 3968 :     for (j = 0; j < w; ++j) {

  002a6	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
  002ab	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  002b0	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
$LN3@stbtt__v_p:

; 4021 :     }
; 4022 : }

  002b8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002bd	48 33 cc	 xor	 rcx, rsp
  002c0	e8 00 00 00 00	 call	 __security_check_cookie
  002c5	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002c9	41 5f		 pop	 r15
  002cb	41 5e		 pop	 r14
  002cd	41 5c		 pop	 r12
  002cf	5f		 pop	 rdi
  002d0	5e		 pop	 rsi
  002d1	c3		 ret	 0
?stbtt__v_prefilter@@YAXPEAEHHHI@Z ENDP			; stbtt__v_prefilter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
oversample$ = 8
?stbtt__oversample_shift@@YAMH@Z PROC			; stbtt__oversample_shift

; 4026 :     if (!oversample)

  00000	85 c9		 test	 ecx, ecx
  00002	75 04		 jne	 SHORT $LN2@stbtt__ove
  00004	0f 57 c0	 xorps	 xmm0, xmm0

; 4034 : }

  00007	c3		 ret	 0
$LN2@stbtt__ove:

; 4027 :         return 0.0f;
; 4028 : 
; 4029 :     // The prefilter is a box filter of width "oversample",
; 4030 :     // which shifts phase by (oversample - 1)/2 pixels in
; 4031 :     // oversampled space. We want to shift in the opposite
; 4032 :     // direction to counter this.
; 4033 :     return (float)-(oversample - 1) / (2.0f * (float)oversample);

  00008	b8 01 00 00 00	 mov	 eax, 1
  0000d	66 0f 6e c9	 movd	 xmm1, ecx
  00011	2b c1		 sub	 eax, ecx
  00013	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00016	66 0f 6e c0	 movd	 xmm0, eax
  0001a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0001d	f3 0f 58 c9	 addss	 xmm1, xmm1
  00021	f3 0f 5e c1	 divss	 xmm0, xmm1

; 4034 : }

  00025	c3		 ret	 0
?stbtt__oversample_shift@@YAMH@Z ENDP			; stbtt__oversample_shift
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
j$1$ = 80
tv2096 = 84
old_h_over$1$ = 88
old_v_over$1$ = 92
tv2071 = 96
c$1 = 104
glyph$1$ = 352
spc$ = 352
info$ = 360
ranges$ = 368
return_value$1$ = 376
num_ranges$dead$ = 376
rects$ = 384
stbtt_PackFontRangesRenderIntoRects PROC

; 4095 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	44 89 48 20	 mov	 DWORD PTR [rax+32], r9d
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	41 54		 push	 r12
  0000c	41 57		 push	 r15
  0000e	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00015	44 0f 29 40 98	 movaps	 XMMWORD PTR [rax-104], xmm8
  0001a	4d 8b f8	 mov	 r15, r8
  0001d	44 0f 29 48 88	 movaps	 XMMWORD PTR [rax-120], xmm9

; 4096 :     int i, j, k, return_value = 1;

  00022	41 b8 01 00 00
	00		 mov	 r8d, 1
  00028	44 0f 29 a0 58
	ff ff ff	 movaps	 XMMWORD PTR [rax-168], xmm12
  00030	45 0f 57 c9	 xorps	 xmm9, xmm9
  00034	44 0f 29 a8 48
	ff ff ff	 movaps	 XMMWORD PTR [rax-184], xmm13
  0003c	48 8b f2	 mov	 rsi, rdx

; 4097 : 
; 4098 :     // save current values
; 4099 :     int old_h_over = spc->h_oversample;

  0003f	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]
  00042	48 8b f9	 mov	 rdi, rcx

; 4100 :     int old_v_over = spc->v_oversample;
; 4101 : 
; 4102 :     k = 0;
; 4103 :     for (i = 0; i < num_ranges; ++i) {
; 4104 :         float fh = ranges[i].font_size;

  00045	f3 45 0f 10 07	 movss	 xmm8, DWORD PTR [r15]

; 4105 :         float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

  0004a	41 bc 00 01 00
	00		 mov	 r12d, 256		; 00000100H
  00050	45 0f 2f c1	 comiss	 xmm8, xmm9
  00054	89 44 24 58	 mov	 DWORD PTR old_h_over$1$[rsp], eax
  00058	8b 41 28	 mov	 eax, DWORD PTR [rcx+40]
  0005b	44 89 84 24 78
	01 00 00	 mov	 DWORD PTR return_value$1$[rsp], r8d
  00063	89 44 24 5c	 mov	 DWORD PTR old_v_over$1$[rsp], eax
  00067	76 4c		 jbe	 SHORT $LN13@stbtt_Pack

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  00069	4c 63 5a 24	 movsxd	 r11, DWORD PTR [rdx+36]
  0006d	4c 8b 52 08	 mov	 r10, QWORD PTR [rdx+8]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00071	41 0f bf cc	 movsx	 ecx, r12w
  00075	47 0f b6 44 13
	07		 movzx	 r8d, BYTE PTR [r11+r10+7]
  0007b	43 0f b6 54 13
	06		 movzx	 edx, BYTE PTR [r11+r10+6]
  00081	43 0f b6 44 13
	04		 movzx	 eax, BYTE PTR [r11+r10+4]
  00087	0f af d1	 imul	 edx, ecx
  0008a	41 0f bf cc	 movsx	 ecx, r12w
  0008e	0f af c1	 imul	 eax, ecx
  00091	66 44 03 c2	 add	 r8w, dx

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  00095	45 0f bf c8	 movsx	 r9d, r8w

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00099	47 0f b6 44 13
	05		 movzx	 r8d, BYTE PTR [r11+r10+5]
  0009f	66 41 03 c0	 add	 ax, r8w

; 4105 :         float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

  000a3	44 8b 84 24 78
	01 00 00	 mov	 r8d, DWORD PTR return_value$1$[rsp]

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  000ab	98		 cwde
  000ac	41 2b c1	 sub	 eax, r9d
  000af	66 0f 6e c0	 movd	 xmm0, eax

; 4105 :         float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

  000b3	eb 23		 jmp	 SHORT $LN116@stbtt_Pack
$LN13@stbtt_Pack:

; 2641 :     int unitsPerEm = ttUSHORT(info->data + info->head + 18);

  000b5	48 63 52 1c	 movsxd	 rdx, DWORD PTR [rdx+28]
  000b9	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]

; 4105 :         float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

  000bd	44 0f 57 05 00
	00 00 00	 xorps	 xmm8, DWORD PTR __xmm@80000000800000008000000080000000

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  000c5	0f b6 4c 02 12	 movzx	 ecx, BYTE PTR [rdx+rax+18]
  000ca	0f b6 44 02 13	 movzx	 eax, BYTE PTR [rdx+rax+19]
  000cf	c1 e1 08	 shl	 ecx, 8
  000d2	03 c8		 add	 ecx, eax
  000d4	66 0f 6e c1	 movd	 xmm0, ecx
$LN116@stbtt_Pack:

; 4106 :         float recip_h, recip_v, sub_x, sub_y;
; 4107 :         spc->h_oversample = ranges[i].h_oversample;

  000d8	41 0f b6 57 20	 movzx	 edx, BYTE PTR [r15+32]

; 4108 :         spc->v_oversample = ranges[i].v_oversample;
; 4109 :         recip_h = 1.0f / spc->h_oversample;

  000dd	f3 44 0f 10 25
	00 00 00 00	 movss	 xmm12, DWORD PTR __real@3f800000
  000e6	89 57 24	 mov	 DWORD PTR [rdi+36], edx
  000e9	45 0f 28 ec	 movaps	 xmm13, xmm12
  000ed	41 0f b6 4f 21	 movzx	 ecx, BYTE PTR [r15+33]
  000f2	44 0f 29 9c 24
	c0 00 00 00	 movaps	 XMMWORD PTR [rsp+192], xmm11
  000fb	89 4f 28	 mov	 DWORD PTR [rdi+40], ecx
  000fe	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00101	f3 44 0f 5e c0	 divss	 xmm8, xmm0
  00106	0f 57 c0	 xorps	 xmm0, xmm0
  00109	f3 48 0f 2a c2	 cvtsi2ss xmm0, rdx
  0010e	f3 44 0f 5e e8	 divss	 xmm13, xmm0
  00113	0f 57 c0	 xorps	 xmm0, xmm0

; 4110 :         recip_v = 1.0f / spc->v_oversample;

  00116	f3 48 0f 2a c1	 cvtsi2ss xmm0, rcx
  0011b	f3 44 0f 5e e0	 divss	 xmm12, xmm0

; 4026 :     if (!oversample)

  00120	85 d2		 test	 edx, edx
  00122	75 06		 jne	 SHORT $LN28@stbtt_Pack
  00124	45 0f 57 db	 xorps	 xmm11, xmm11

; 4027 :         return 0.0f;

  00128	eb 20		 jmp	 SHORT $LN27@stbtt_Pack
$LN28@stbtt_Pack:

; 4028 : 
; 4029 :     // The prefilter is a box filter of width "oversample",
; 4030 :     // which shifts phase by (oversample - 1)/2 pixels in
; 4031 :     // oversampled space. We want to shift in the opposite
; 4032 :     // direction to counter this.
; 4033 :     return (float)-(oversample - 1) / (2.0f * (float)oversample);

  0012a	b8 01 00 00 00	 mov	 eax, 1
  0012f	66 0f 6e c2	 movd	 xmm0, edx
  00133	2b c2		 sub	 eax, edx
  00135	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00138	66 44 0f 6e d8	 movd	 xmm11, eax
  0013d	45 0f 5b db	 cvtdq2ps xmm11, xmm11
  00141	f3 0f 58 c0	 addss	 xmm0, xmm0
  00145	f3 44 0f 5e d8	 divss	 xmm11, xmm0
$LN27@stbtt_Pack:
  0014a	44 0f 29 94 24
	d0 00 00 00	 movaps	 XMMWORD PTR [rsp+208], xmm10

; 4026 :     if (!oversample)

  00153	85 c9		 test	 ecx, ecx
  00155	75 06		 jne	 SHORT $LN31@stbtt_Pack
  00157	45 0f 57 d2	 xorps	 xmm10, xmm10

; 4027 :         return 0.0f;

  0015b	eb 20		 jmp	 SHORT $LN30@stbtt_Pack
$LN31@stbtt_Pack:

; 4028 : 
; 4029 :     // The prefilter is a box filter of width "oversample",
; 4030 :     // which shifts phase by (oversample - 1)/2 pixels in
; 4031 :     // oversampled space. We want to shift in the opposite
; 4032 :     // direction to counter this.
; 4033 :     return (float)-(oversample - 1) / (2.0f * (float)oversample);

  0015d	b8 01 00 00 00	 mov	 eax, 1
  00162	66 0f 6e c1	 movd	 xmm0, ecx
  00166	2b c1		 sub	 eax, ecx
  00168	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0016b	66 44 0f 6e d0	 movd	 xmm10, eax
  00170	45 0f 5b d2	 cvtdq2ps xmm10, xmm10
  00174	f3 0f 58 c0	 addss	 xmm0, xmm0
  00178	f3 44 0f 5e d0	 divss	 xmm10, xmm0
$LN30@stbtt_Pack:

; 4111 :         sub_x = stbtt__oversample_shift(spc->h_oversample);
; 4112 :         sub_y = stbtt__oversample_shift(spc->v_oversample);
; 4113 :         for (j = 0; j < ranges[i].num_chars; ++j) {

  0017d	33 ed		 xor	 ebp, ebp
  0017f	8b cd		 mov	 ecx, ebp
  00181	89 4c 24 50	 mov	 DWORD PTR j$1$[rsp], ecx
  00185	41 39 6f 10	 cmp	 DWORD PTR [r15+16], ebp
  00189	0f 8e 61 04 00
	00		 jle	 $LN2@stbtt_Pack
  0018f	48 89 9c 24 68
	01 00 00	 mov	 QWORD PTR [rsp+360], rbx
  00197	8b d5		 mov	 edx, ebp
  00199	48 8b 9c 24 80
	01 00 00	 mov	 rbx, QWORD PTR rects$[rsp]
  001a1	4c 89 b4 24 20
	01 00 00	 mov	 QWORD PTR [rsp+288], r14
  001a9	48 83 c3 08	 add	 rbx, 8
  001ad	4c 89 ac 24 28
	01 00 00	 mov	 QWORD PTR [rsp+296], r13
  001b5	44 8b f5	 mov	 r14d, ebp
  001b8	0f 29 b4 24 10
	01 00 00	 movaps	 XMMWORD PTR [rsp+272], xmm6
  001c0	0f 29 bc 24 00
	01 00 00	 movaps	 XMMWORD PTR [rsp+256], xmm7
  001c8	48 89 54 24 60	 mov	 QWORD PTR tv2071[rsp], rdx
  001cd	0f 1f 00	 npad	 3
$LL7@stbtt_Pack:

; 4114 :             stbrp_rect* r = &rects[k];
; 4115 :             if (r->was_packed && r->w != 0 && r->h != 0) {

  001d0	83 7b 04 00	 cmp	 DWORD PTR [rbx+4], 0
  001d4	0f 84 c3 03 00
	00		 je	 $LN8@stbtt_Pack
  001da	66 83 7b fc 00	 cmp	 WORD PTR [rbx-4], 0
  001df	0f 84 b8 03 00
	00		 je	 $LN8@stbtt_Pack
  001e5	66 83 7b fe 00	 cmp	 WORD PTR [rbx-2], 0
  001ea	0f 84 ad 03 00
	00		 je	 $LN8@stbtt_Pack

; 4116 :                 stbtt_packedchar* bc = &ranges[i].chardata_for_range[j];
; 4117 :                 int advance, lsb, x0, y0, x1, y1;
; 4118 :                 int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];

  001f0	49 8b 47 08	 mov	 rax, QWORD PTR [r15+8]
  001f4	4d 8b 6f 18	 mov	 r13, QWORD PTR [r15+24]
  001f8	48 85 c0	 test	 rax, rax
  001fb	75 08		 jne	 SHORT $LN15@stbtt_Pack
  001fd	41 8b 57 04	 mov	 edx, DWORD PTR [r15+4]
  00201	03 d1		 add	 edx, ecx
  00203	eb 03		 jmp	 SHORT $LN16@stbtt_Pack
$LN15@stbtt_Pack:
  00205	8b 14 02	 mov	 edx, DWORD PTR [rdx+rax]
$LN16@stbtt_Pack:

; 4119 :                 int glyph = stbtt_FindGlyphIndex(info, codepoint);

  00208	48 8b ce	 mov	 rcx, rsi
  0020b	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  00210	44 8b c8	 mov	 r9d, eax
  00213	89 84 24 60 01
	00 00		 mov	 DWORD PTR glyph$1$[rsp], eax

; 4120 :                 stbrp_coord pad = (stbrp_coord)spc->padding;

  0021a	0f b7 47 1c	 movzx	 eax, WORD PTR [rdi+28]

; 4121 : 
; 4122 :                 // pad on left and top
; 4123 :                 r->x += pad;

  0021e	66 01 03	 add	 WORD PTR [rbx], ax

; 4124 :                 r->y += pad;

  00221	66 01 43 02	 add	 WORD PTR [rbx+2], ax

; 4125 :                 r->w -= pad;

  00225	66 29 43 fc	 sub	 WORD PTR [rbx-4], ax

; 4126 :                 r->h -= pad;

  00229	66 29 43 fe	 sub	 WORD PTR [rbx-2], ax

; 2300 :     stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data + info->hhea + 34);

  0022d	48 63 46 24	 movsxd	 rax, DWORD PTR [rsi+36]
  00231	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]

; 1270 : static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00235	42 0f b6 4c 00
	22		 movzx	 ecx, BYTE PTR [rax+r8+34]
  0023b	42 0f b6 54 00
	23		 movzx	 edx, BYTE PTR [rax+r8+35]

; 2301 :     if (glyph_index < numOfLongHorMetrics) {

  00241	8b c1		 mov	 eax, ecx
  00243	c1 e0 08	 shl	 eax, 8
  00246	03 c2		 add	 eax, edx
  00248	44 3b c8	 cmp	 r9d, eax
  0024b	7d 29		 jge	 SHORT $LN34@stbtt_Pack

; 2302 :         if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * glyph_index);

  0024d	48 63 56 28	 movsxd	 rdx, DWORD PTR [rsi+40]
  00251	42 8d 04 8d 00
	00 00 00	 lea	 eax, DWORD PTR [r9*4]
  00259	48 98		 cdqe
  0025b	49 03 c0	 add	 rax, r8

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  0025e	41 0f bf cc	 movsx	 ecx, r12w
  00262	44 0f b6 04 02	 movzx	 r8d, BYTE PTR [rdx+rax]
  00267	0f b6 44 02 01	 movzx	 eax, BYTE PTR [rdx+rax+1]
  0026c	44 0f af c1	 imul	 r8d, ecx
  00270	66 44 03 c0	 add	 r8w, ax

; 2304 :     }

  00274	eb 30		 jmp	 SHORT $LN104@stbtt_Pack
$LN34@stbtt_Pack:

; 2305 :     else {
; 2306 :         if (advanceWidth)     *advanceWidth = ttSHORT(info->data + info->hmtx + 4 * (numOfLongHorMetrics - 1));

  00276	48 63 46 28	 movsxd	 rax, DWORD PTR [rsi+40]
  0027a	4c 8b c9	 mov	 r9, rcx
  0027d	49 c1 e1 08	 shl	 r9, 8
  00281	4c 03 c0	 add	 r8, rax
  00284	4c 03 ca	 add	 r9, rdx

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00287	41 0f bf cc	 movsx	 ecx, r12w
  0028b	43 0f b6 54 88
	fc		 movzx	 edx, BYTE PTR [r8+r9*4-4]
  00291	47 0f b6 44 88
	fd		 movzx	 r8d, BYTE PTR [r8+r9*4-3]
  00297	44 8b 8c 24 60
	01 00 00	 mov	 r9d, DWORD PTR glyph$1$[rsp]
  0029f	0f af d1	 imul	 edx, ecx
  002a2	66 44 03 c2	 add	 r8w, dx
$LN104@stbtt_Pack:

; 1599 :     if (info->cff.size) {

  002a6	83 7e 4c 00	 cmp	 DWORD PTR [rsi+76], 0
  002aa	0f 57 ff	 xorps	 xmm7, xmm7

; 4127 :                 stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
; 4128 :                 stbtt_GetGlyphBitmapBox(info, glyph,

  002ad	41 0f bf c0	 movsx	 eax, r8w
  002b1	0f 57 f6	 xorps	 xmm6, xmm6
  002b4	89 44 24 54	 mov	 DWORD PTR tv2096[rsp], eax

; 1599 :     if (info->cff.size) {

  002b8	41 8b d1	 mov	 edx, r9d

; 4127 :                 stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
; 4128 :                 stbtt_GetGlyphBitmapBox(info, glyph,

  002bb	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]

; 1599 :     if (info->cff.size) {

  002be	48 8b ce	 mov	 rcx, rsi

; 4127 :                 stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
; 4128 :                 stbtt_GetGlyphBitmapBox(info, glyph,

  002c1	f3 48 0f 2a f8	 cvtsi2ss xmm7, rax
  002c6	8b 47 24	 mov	 eax, DWORD PTR [rdi+36]
  002c9	f3 48 0f 2a f0	 cvtsi2ss xmm6, rax
  002ce	f3 41 0f 59 f8	 mulss	 xmm7, xmm8
  002d3	f3 41 0f 59 f0	 mulss	 xmm6, xmm8

; 1599 :     if (info->cff.size) {

  002d8	74 50		 je	 SHORT $LN66@stbtt_Pack
  002da	0f 57 c0	 xorps	 xmm0, xmm0

; 2281 :     stbtt__csctx c = STBTT__CSCTX_INIT(1);

  002dd	48 c7 44 24 68
	01 00 00 00	 mov	 QWORD PTR c$1[rsp], 1
  002e6	0f 57 c9	 xorps	 xmm1, xmm1
  002e9	48 89 ac 24 90
	00 00 00	 mov	 QWORD PTR c$1[rsp+40], rbp

; 2282 :     int r = stbtt__run_charstring(info, glyph_index, &c);

  002f1	4c 8d 44 24 68	 lea	 r8, QWORD PTR c$1[rsp]
  002f6	89 ac 24 98 00
	00 00		 mov	 DWORD PTR c$1[rsp+48], ebp
  002fd	0f 11 44 24 70	 movups	 XMMWORD PTR c$1[rsp+8], xmm0
  00302	f3 0f 7f 8c 24
	80 00 00 00	 movdqu	 XMMWORD PTR c$1[rsp+24], xmm1
  0030b	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring

; 2283 :     if (x0)  *x0 = r ? c.min_x : 0;

  00310	85 c0		 test	 eax, eax
  00312	44 8b c5	 mov	 r8d, ebp

; 2284 :     if (y0)  *y0 = r ? c.min_y : 0;
; 2285 :     if (x1)  *x1 = r ? c.max_x : 0;
; 2286 :     if (y1)  *y1 = r ? c.max_y : 0;

  00315	8b cd		 mov	 ecx, ebp
  00317	44 0f 45 84 24
	80 00 00 00	 cmovne	 r8d, DWORD PTR c$1[rsp+24]
  00320	0f 45 8c 24 8c
	00 00 00	 cmovne	 ecx, DWORD PTR c$1[rsp+36]

; 1601 :     }

  00328	eb 4c		 jmp	 SHORT $LN72@stbtt_Pack
$LN66@stbtt_Pack:

; 1602 :     else {
; 1603 :         int g = stbtt__GetGlyfOffset(info, glyph_index);

  0032a	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1604 :         if (g < 0) return 0;

  0032f	85 c0		 test	 eax, eax
  00331	79 08		 jns	 SHORT $LN68@stbtt_Pack

; 2664 :     }

  00333	44 8b e5	 mov	 r12d, ebp
  00336	e9 aa 00 00 00	 jmp	 $LN61@stbtt_Pack
$LN68@stbtt_Pack:

; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  0033b	4c 8b 4e 08	 mov	 r9, QWORD PTR [rsi+8]
  0033f	4c 63 d0	 movsxd	 r10, eax

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00342	41 0f bf cc	 movsx	 ecx, r12w
  00346	47 0f b6 44 0a
	03		 movzx	 r8d, BYTE PTR [r10+r9+3]
  0034c	43 0f b6 54 0a
	02		 movzx	 edx, BYTE PTR [r10+r9+2]
  00352	43 0f b6 44 0a
	09		 movzx	 eax, BYTE PTR [r10+r9+9]
  00358	0f af d1	 imul	 edx, ecx
  0035b	41 0f bf cc	 movsx	 ecx, r12w
  0035f	66 44 03 c2	 add	 r8w, dx
  00363	43 0f b6 54 0a
	08		 movzx	 edx, BYTE PTR [r10+r9+8]
  00369	0f af d1	 imul	 edx, ecx

; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  0036c	45 0f bf c0	 movsx	 r8d, r8w

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00370	66 03 d0	 add	 dx, ax

; 1609 :         if (y1) *y1 = ttSHORT(info->data + g + 8);

  00373	0f bf ca	 movsx	 ecx, dx
$LN72@stbtt_Pack:
  00376	66 41 0f 6e c8	 movd	 xmm1, r8d

; 2667 :         if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);

  0037b	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0037e	f3 0f 59 ce	 mulss	 xmm1, xmm6
  00382	f3 41 0f 58 c9	 addss	 xmm1, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00387	41 0f 2f c9	 comiss	 xmm1, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2667 :         if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);

  0038b	f3 0f 2c c1	 cvttss2si eax, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  0038f	73 10		 jae	 SHORT $LN109@stbtt_Pack
  00391	66 0f 6e c0	 movd	 xmm0, eax
  00395	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00398	0f 2e c1	 ucomiss xmm0, xmm1
  0039b	7a 02		 jp	 SHORT $LN115@stbtt_Pack
  0039d	74 02		 je	 SHORT $LN109@stbtt_Pack
$LN115@stbtt_Pack:
  0039f	ff c8		 dec	 eax
$LN109@stbtt_Pack:
  003a1	66 0f 6e c0	 movd	 xmm0, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  003a5	41 0f 28 d1	 movaps	 xmm2, xmm9
  003a9	66 0f 6e c9	 movd	 xmm1, ecx
  003ad	0f 5b c9	 cvtdq2ps xmm1, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  003b0	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  003b3	f3 0f 59 cf	 mulss	 xmm1, xmm7
  003b7	f3 44 0f 2c e0	 cvttss2si r12d, xmm0
  003bc	f3 0f 5c d1	 subss	 xmm2, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  003c0	41 0f 2f d1	 comiss	 xmm2, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  003c4	f3 0f 2c c2	 cvttss2si eax, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  003c8	73 10		 jae	 SHORT $LN110@stbtt_Pack
  003ca	66 0f 6e c0	 movd	 xmm0, eax
  003ce	0f 5b c0	 cvtdq2ps xmm0, xmm0
  003d1	0f 2e c2	 ucomiss xmm0, xmm2
  003d4	7a 02		 jp	 SHORT $LN114@stbtt_Pack
  003d6	74 02		 je	 SHORT $LN110@stbtt_Pack
$LN114@stbtt_Pack:
  003d8	ff c8		 dec	 eax
$LN110@stbtt_Pack:
  003da	66 0f 6e c0	 movd	 xmm0, eax
  003de	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  003e1	f3 0f 2c e8	 cvttss2si ebp, xmm0
$LN61@stbtt_Pack:

; 4129 :                     scale * spc->h_oversample,
; 4130 :                     scale * spc->v_oversample,
; 4131 :                     &x0, &y0, &x1, &y1);
; 4132 :                 stbtt_MakeGlyphBitmapSubpixel(info,

  003e5	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  003e8	0f 57 c9	 xorps	 xmm1, xmm1
  003eb	8b 4f 24	 mov	 ecx, DWORD PTR [rdi+36]
  003ee	0f 57 c0	 xorps	 xmm0, xmm0
  003f1	44 8b 57 18	 mov	 r10d, DWORD PTR [rdi+24]
  003f5	44 0f b7 4b fe	 movzx	 r9d, WORD PTR [rbx-2]
  003fa	44 0f b7 43 fc	 movzx	 r8d, WORD PTR [rbx-4]
  003ff	44 2b c8	 sub	 r9d, eax
  00402	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  00407	0f b7 43 02	 movzx	 eax, WORD PTR [rbx+2]
  0040b	44 2b c1	 sub	 r8d, ecx
  0040e	41 ff c1	 inc	 r9d
  00411	41 ff c0	 inc	 r8d
  00414	41 0f af c2	 imul	 eax, r10d
  00418	f3 48 0f 2a c1	 cvtsi2ss xmm0, rcx
  0041d	48 8b ce	 mov	 rcx, rsi
  00420	48 63 d0	 movsxd	 rdx, eax
  00423	f3 41 0f 59 c8	 mulss	 xmm1, xmm8
  00428	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  0042b	48 03 d0	 add	 rdx, rax
  0042e	f3 41 0f 59 c0	 mulss	 xmm0, xmm8
  00433	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR glyph$1$[rsp]
  0043a	48 03 57 30	 add	 rdx, QWORD PTR [rdi+48]
  0043e	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00442	f3 44 0f 11 4c
	24 40		 movss	 DWORD PTR [rsp+64], xmm9
  00449	f3 44 0f 11 4c
	24 38		 movss	 DWORD PTR [rsp+56], xmm9
  00450	f3 0f 11 4c 24
	30		 movss	 DWORD PTR [rsp+48], xmm1
  00456	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0045c	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  00461	e8 00 00 00 00	 call	 stbtt_MakeGlyphBitmapSubpixel

; 4133 :                     spc->pixels + r->x + r->y * spc->stride_in_bytes,
; 4134 :                     r->w - spc->h_oversample + 1,
; 4135 :                     r->h - spc->v_oversample + 1,
; 4136 :                     spc->stride_in_bytes,
; 4137 :                     scale * spc->h_oversample,
; 4138 :                     scale * spc->v_oversample,
; 4139 :                     0, 0,
; 4140 :                     glyph);
; 4141 : 
; 4142 :                 if (spc->h_oversample > 1)

  00466	44 8b 57 24	 mov	 r10d, DWORD PTR [rdi+36]
  0046a	41 83 fa 01	 cmp	 r10d, 1
  0046e	76 2c		 jbe	 SHORT $LN10@stbtt_Pack

; 4143 :                     stbtt__h_prefilter(spc->pixels + r->x + r->y * spc->stride_in_bytes,

  00470	0f b7 43 02	 movzx	 eax, WORD PTR [rbx+2]
  00474	44 8b 4f 18	 mov	 r9d, DWORD PTR [rdi+24]
  00478	44 0f b7 43 fe	 movzx	 r8d, WORD PTR [rbx-2]
  0047d	0f b7 53 fc	 movzx	 edx, WORD PTR [rbx-4]
  00481	41 0f af c1	 imul	 eax, r9d
  00485	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  0048a	48 63 c8	 movsxd	 rcx, eax
  0048d	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00490	48 03 c8	 add	 rcx, rax
  00493	48 03 4f 30	 add	 rcx, QWORD PTR [rdi+48]
  00497	e8 00 00 00 00	 call	 ?stbtt__h_prefilter@@YAXPEAEHHHI@Z ; stbtt__h_prefilter
$LN10@stbtt_Pack:

; 4144 :                         r->w, r->h, spc->stride_in_bytes,
; 4145 :                         spc->h_oversample);
; 4146 : 
; 4147 :                 if (spc->v_oversample > 1)

  0049c	44 8b 57 28	 mov	 r10d, DWORD PTR [rdi+40]
  004a0	41 83 fa 01	 cmp	 r10d, 1
  004a4	76 2c		 jbe	 SHORT $LN11@stbtt_Pack

; 4148 :                     stbtt__v_prefilter(spc->pixels + r->x + r->y * spc->stride_in_bytes,

  004a6	0f b7 43 02	 movzx	 eax, WORD PTR [rbx+2]
  004aa	44 8b 4f 18	 mov	 r9d, DWORD PTR [rdi+24]
  004ae	44 0f b7 43 fe	 movzx	 r8d, WORD PTR [rbx-2]
  004b3	0f b7 53 fc	 movzx	 edx, WORD PTR [rbx-4]
  004b7	41 0f af c1	 imul	 eax, r9d
  004bb	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  004c0	48 63 c8	 movsxd	 rcx, eax
  004c3	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  004c6	48 03 c8	 add	 rcx, rax
  004c9	48 03 4f 30	 add	 rcx, QWORD PTR [rdi+48]
  004cd	e8 00 00 00 00	 call	 ?stbtt__v_prefilter@@YAXPEAEHHHI@Z ; stbtt__v_prefilter
$LN11@stbtt_Pack:

; 4149 :                         r->w, r->h, spc->stride_in_bytes,
; 4150 :                         spc->v_oversample);
; 4151 : 
; 4152 :                 bc->x0 = (stbtt_int16)r->x;

  004d2	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  004d5	66 0f 6e 44 24
	54		 movd	 xmm0, DWORD PTR tv2096[rsp]

; 4153 :                 bc->y0 = (stbtt_int16)r->y;
; 4154 :                 bc->x1 = (stbtt_int16)(r->x + r->w);
; 4155 :                 bc->y1 = (stbtt_int16)(r->y + r->h);
; 4156 :                 bc->xadvance = scale * advance;
; 4157 :                 bc->xoff = (float)x0 * recip_h + sub_x;
; 4158 :                 bc->yoff = (float)y0 * recip_v + sub_y;
; 4159 :                 bc->xoff2 = (x0 + r->w) * recip_h + sub_x;
; 4160 :                 bc->yoff2 = (y0 + r->h) * recip_v + sub_y;
; 4161 :             }

  004db	8b 4c 24 50	 mov	 ecx, DWORD PTR j$1$[rsp]
  004df	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv2071[rsp]
  004e4	44 8b 84 24 78
	01 00 00	 mov	 r8d, DWORD PTR return_value$1$[rsp]
  004ec	0f 5b c0	 cvtdq2ps xmm0, xmm0
  004ef	66 43 89 04 2e	 mov	 WORD PTR [r14+r13], ax
  004f4	0f b7 43 02	 movzx	 eax, WORD PTR [rbx+2]
  004f8	66 43 89 44 2e
	02		 mov	 WORD PTR [r14+r13+2], ax
  004fe	0f b7 43 fc	 movzx	 eax, WORD PTR [rbx-4]
  00502	66 03 03	 add	 ax, WORD PTR [rbx]
  00505	f3 41 0f 59 c0	 mulss	 xmm0, xmm8
  0050a	66 43 89 44 2e
	04		 mov	 WORD PTR [r14+r13+4], ax
  00510	0f b7 43 02	 movzx	 eax, WORD PTR [rbx+2]
  00514	66 03 43 fe	 add	 ax, WORD PTR [rbx-2]
  00518	f3 43 0f 11 44
	2e 10		 movss	 DWORD PTR [r14+r13+16], xmm0
  0051f	66 43 89 44 2e
	06		 mov	 WORD PTR [r14+r13+6], ax
  00525	66 0f 6e c5	 movd	 xmm0, ebp
  00529	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0052c	66 41 0f 6e cc	 movd	 xmm1, r12d
  00531	f3 41 0f 59 c4	 mulss	 xmm0, xmm12
  00536	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00539	f3 41 0f 58 c2	 addss	 xmm0, xmm10
  0053e	f3 41 0f 59 cd	 mulss	 xmm1, xmm13
  00543	f3 43 0f 11 44
	2e 0c		 movss	 DWORD PTR [r14+r13+12], xmm0
  0054a	f3 41 0f 58 cb	 addss	 xmm1, xmm11
  0054f	f3 43 0f 11 4c
	2e 08		 movss	 DWORD PTR [r14+r13+8], xmm1
  00556	0f b7 43 fc	 movzx	 eax, WORD PTR [rbx-4]
  0055a	41 03 c4	 add	 eax, r12d
  0055d	41 bc 00 01 00
	00		 mov	 r12d, 256		; 00000100H
  00563	66 0f 6e c0	 movd	 xmm0, eax
  00567	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0056a	f3 41 0f 59 c5	 mulss	 xmm0, xmm13
  0056f	f3 41 0f 58 c3	 addss	 xmm0, xmm11
  00574	f3 43 0f 11 44
	2e 14		 movss	 DWORD PTR [r14+r13+20], xmm0
  0057b	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  0057f	03 c5		 add	 eax, ebp
  00581	33 ed		 xor	 ebp, ebp
  00583	66 0f 6e c0	 movd	 xmm0, eax
  00587	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0058a	f3 41 0f 59 c4	 mulss	 xmm0, xmm12
  0058f	f3 41 0f 58 c2	 addss	 xmm0, xmm10
  00594	f3 43 0f 11 44
	2e 18		 movss	 DWORD PTR [r14+r13+24], xmm0
  0059b	eb 0a		 jmp	 SHORT $LN9@stbtt_Pack
$LN8@stbtt_Pack:

; 4162 :             else {
; 4163 :                 return_value = 0; // if any fail, report failure

  0059d	44 8b c5	 mov	 r8d, ebp
  005a0	89 ac 24 78 01
	00 00		 mov	 DWORD PTR return_value$1$[rsp], ebp
$LN9@stbtt_Pack:

; 4111 :         sub_x = stbtt__oversample_shift(spc->h_oversample);
; 4112 :         sub_y = stbtt__oversample_shift(spc->v_oversample);
; 4113 :         for (j = 0; j < ranges[i].num_chars; ++j) {

  005a7	ff c1		 inc	 ecx
  005a9	48 83 c2 04	 add	 rdx, 4

; 4164 :             }
; 4165 : 
; 4166 :             ++k;

  005ad	48 83 c3 10	 add	 rbx, 16
  005b1	89 4c 24 50	 mov	 DWORD PTR j$1$[rsp], ecx
  005b5	49 83 c6 1c	 add	 r14, 28
  005b9	48 89 54 24 60	 mov	 QWORD PTR tv2071[rsp], rdx
  005be	41 3b 4f 10	 cmp	 ecx, DWORD PTR [r15+16]
  005c2	0f 8c 08 fc ff
	ff		 jl	 $LL7@stbtt_Pack

; 4111 :         sub_x = stbtt__oversample_shift(spc->h_oversample);
; 4112 :         sub_y = stbtt__oversample_shift(spc->v_oversample);
; 4113 :         for (j = 0; j < ranges[i].num_chars; ++j) {

  005c8	0f 28 bc 24 00
	01 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+256]
  005d0	0f 28 b4 24 10
	01 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+272]
  005d8	4c 8b b4 24 20
	01 00 00	 mov	 r14, QWORD PTR [rsp+288]
  005e0	4c 8b ac 24 28
	01 00 00	 mov	 r13, QWORD PTR [rsp+296]
  005e8	48 8b 9c 24 68
	01 00 00	 mov	 rbx, QWORD PTR [rsp+360]
$LN2@stbtt_Pack:

; 4167 :         }
; 4168 :     }
; 4169 : 
; 4170 :     // restore original values
; 4171 :     spc->h_oversample = old_h_over;

  005f0	8b 44 24 58	 mov	 eax, DWORD PTR old_h_over$1$[rsp]

; 4172 :     spc->v_oversample = old_v_over;
; 4173 : 
; 4174 :     return return_value;
; 4175 : }

  005f4	4c 8d 9c 24 30
	01 00 00	 lea	 r11, QWORD PTR [rsp+304]
  005fc	44 0f 28 9c 24
	c0 00 00 00	 movaps	 xmm11, XMMWORD PTR [rsp+192]
  00605	44 0f 28 94 24
	d0 00 00 00	 movaps	 xmm10, XMMWORD PTR [rsp+208]
  0060e	45 0f 28 43 c0	 movaps	 xmm8, XMMWORD PTR [r11-64]
  00613	45 0f 28 4b b0	 movaps	 xmm9, XMMWORD PTR [r11-80]
  00618	45 0f 28 63 80	 movaps	 xmm12, XMMWORD PTR [r11-128]
  0061d	45 0f 28 ab 70
	ff ff ff	 movaps	 xmm13, XMMWORD PTR [r11-144]
  00625	89 47 24	 mov	 DWORD PTR [rdi+36], eax
  00628	8b 44 24 5c	 mov	 eax, DWORD PTR old_v_over$1$[rsp]
  0062c	89 47 28	 mov	 DWORD PTR [rdi+40], eax
  0062f	41 8b c0	 mov	 eax, r8d
  00632	49 8b e3	 mov	 rsp, r11
  00635	41 5f		 pop	 r15
  00637	41 5c		 pop	 r12
  00639	5f		 pop	 rdi
  0063a	5e		 pop	 rsi
  0063b	5d		 pop	 rbp
  0063c	c3		 ret	 0
stbtt_PackFontRangesRenderIntoRects ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
chardata$ = 8
pw$ = 16
ph$ = 24
char_index$ = 32
xpos$ = 40
ypos$ = 48
q$ = 56
align_to_integer$dead$ = 64
stbtt_GetPackedQuad PROC

; 4245 :     float ipw = 1.0f / pw, iph = 1.0f / ph;

  00000	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00008	66 0f 6e c2	 movd	 xmm0, edx
  0000c	0f 28 d3	 movaps	 xmm2, xmm3

; 4246 :     const stbtt_packedchar* b = chardata + char_index;
; 4247 : 
; 4248 :     if (align_to_integer) {
; 4249 :         float x = (float)STBTT_ifloor((*xpos + b->xoff) + 0.5f);
; 4250 :         float y = (float)STBTT_ifloor((*ypos + b->yoff) + 0.5f);
; 4251 :         q->x0 = x;
; 4252 :         q->y0 = y;
; 4253 :         q->x1 = x + b->xoff2 - b->xoff;
; 4254 :         q->y1 = y + b->yoff2 - b->yoff;
; 4255 :     }
; 4256 :     else {
; 4257 :         q->x0 = *xpos + b->xoff;

  0000f	48 8b 54 24 28	 mov	 rdx, QWORD PTR xpos$[rsp]
  00014	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00017	49 63 c1	 movsxd	 rax, r9d
  0001a	f3 0f 5e d0	 divss	 xmm2, xmm0
  0001e	66 41 0f 6e c0	 movd	 xmm0, r8d
  00023	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00026	4c 6b c0 1c	 imul	 r8, rax, 28
  0002a	f3 0f 5e d8	 divss	 xmm3, xmm0

; 4258 :         q->y0 = *ypos + b->yoff;

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR ypos$[rsp]
  00033	4c 03 c1	 add	 r8, rcx
  00036	48 8b 4c 24 38	 mov	 rcx, QWORD PTR q$[rsp]
  0003b	f3 41 0f 10 40
	08		 movss	 xmm0, DWORD PTR [r8+8]
  00041	f3 0f 58 02	 addss	 xmm0, DWORD PTR [rdx]
  00045	f3 0f 11 01	 movss	 DWORD PTR [rcx], xmm0
  00049	f3 41 0f 10 40
	0c		 movss	 xmm0, DWORD PTR [r8+12]
  0004f	f3 0f 58 00	 addss	 xmm0, DWORD PTR [rax]
  00053	f3 0f 11 41 04	 movss	 DWORD PTR [rcx+4], xmm0

; 4259 :         q->x1 = *xpos + b->xoff2;

  00058	f3 41 0f 10 40
	14		 movss	 xmm0, DWORD PTR [r8+20]
  0005e	f3 0f 58 02	 addss	 xmm0, DWORD PTR [rdx]
  00062	f3 0f 11 41 10	 movss	 DWORD PTR [rcx+16], xmm0

; 4260 :         q->y1 = *ypos + b->yoff2;

  00067	f3 41 0f 10 48
	18		 movss	 xmm1, DWORD PTR [r8+24]
  0006d	f3 0f 58 08	 addss	 xmm1, DWORD PTR [rax]

; 4261 :     }
; 4262 : 
; 4263 :     q->s0 = b->x0 * ipw;

  00071	f3 0f 11 49 14	 movss	 DWORD PTR [rcx+20], xmm1
  00076	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  0007a	66 0f 6e c0	 movd	 xmm0, eax
  0007e	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00081	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00085	f3 0f 11 41 08	 movss	 DWORD PTR [rcx+8], xmm0

; 4264 :     q->t0 = b->y0 * iph;

  0008a	41 0f b7 40 02	 movzx	 eax, WORD PTR [r8+2]
  0008f	66 0f 6e c8	 movd	 xmm1, eax
  00093	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00096	f3 0f 59 cb	 mulss	 xmm1, xmm3
  0009a	f3 0f 11 49 0c	 movss	 DWORD PTR [rcx+12], xmm1

; 4265 :     q->s1 = b->x1 * ipw;

  0009f	41 0f b7 40 04	 movzx	 eax, WORD PTR [r8+4]
  000a4	66 0f 6e c0	 movd	 xmm0, eax
  000a8	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000ab	f3 0f 59 c2	 mulss	 xmm0, xmm2
  000af	f3 0f 11 41 18	 movss	 DWORD PTR [rcx+24], xmm0

; 4266 :     q->t1 = b->y1 * iph;

  000b4	41 0f b7 40 06	 movzx	 eax, WORD PTR [r8+6]
  000b9	66 0f 6e c8	 movd	 xmm1, eax
  000bd	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000c0	f3 0f 59 cb	 mulss	 xmm1, xmm3
  000c4	f3 0f 11 49 1c	 movss	 DWORD PTR [rcx+28], xmm1

; 4267 : 
; 4268 :     *xpos += b->xadvance;

  000c9	f3 41 0f 10 40
	10		 movss	 xmm0, DWORD PTR [r8+16]
  000cf	f3 0f 58 02	 addss	 xmm0, DWORD PTR [rdx]
  000d3	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 4269 : }

  000d7	c3		 ret	 0
stbtt_GetPackedQuad ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
data$ = 8
index$ = 16
stbtt_GetFontOffsetForIndex PROC

; 4843 :     return stbtt_GetFontOffsetForIndex_internal((unsigned char*)data, index);

  00000	e9 00 00 00 00	 jmp	 ?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ; stbtt_GetFontOffsetForIndex_internal
stbtt_GetFontOffsetForIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
_TEXT	SEGMENT
info$ = 8
data$ = 16
offset$ = 24
stbtt_InitFont PROC

; 4853 :     return stbtt_InitFont_internal(info, (unsigned char*)data, offset);

  00000	e9 00 00 00 00	 jmp	 ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ; stbtt_InitFont_internal
stbtt_InitFont ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?_OnChangedClipRect@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_OnChangedClipRect

; 511  : {

$LN10:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 512  :     // If current command is used with different settings we need to add a new command
; 513  :     IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
; 514  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  0000f	48 63 01	 movsxd	 rax, DWORD PTR [rcx]
  00012	48 8b f9	 mov	 rdi, rcx
  00015	48 6b d8 38	 imul	 rbx, rax, 56		; 00000038H
  00019	48 03 59 08	 add	 rbx, QWORD PTR [rcx+8]

; 515  :     if (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &_CmdHeader.ClipRect, sizeof(ImVec4)) != 0)

  0001d	8b 4b e8	 mov	 ecx, DWORD PTR [rbx-24]
  00020	85 c9		 test	 ecx, ecx
  00022	74 31		 je	 SHORT $LN6@OnChangedC
  00024	48 8b 43 c8	 mov	 rax, QWORD PTR [rbx-56]
  00028	48 3b 87 88 00
	00 00		 cmp	 rax, QWORD PTR [rdi+136]
  0002f	75 0d		 jne	 SHORT $LN7@OnChangedC
  00031	48 8b 43 d0	 mov	 rax, QWORD PTR [rbx-48]
  00035	48 3b 87 90 00
	00 00		 cmp	 rax, QWORD PTR [rdi+144]
  0003c	74 17		 je	 SHORT $LN6@OnChangedC
$LN7@OnChangedC:

; 516  :     {
; 517  :         AddDrawCmd();

  0003e	48 8b cf	 mov	 rcx, rdi

; 531  : }

  00041	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00046	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi

; 516  :     {
; 517  :         AddDrawCmd();

  00050	e9 00 00 00 00	 jmp	 ?AddDrawCmd@ImDrawList@@QEAAXXZ ; ImDrawList::AddDrawCmd
$LN6@OnChangedC:

; 518  :         return;
; 519  :     }
; 520  :     IM_ASSERT(curr_cmd->UserCallback == NULL);

  00055	48 83 7b f0 00	 cmp	 QWORD PTR [rbx-16], 0
  0005a	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0005f	74 1d		 je	 SHORT $LN5@OnChangedC
  00061	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@FGNNAPCK@?$AAc?$AAu?$AAr?$AAr?$AA_?$AAc?$AAm?$AAd?$AA?9?$AA?$DO?$AAU?$AAs?$AAe?$AAr?$AAC@
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007b	8b 4b e8	 mov	 ecx, DWORD PTR [rbx-24]
$LN5@OnChangedC:

; 521  : 
; 522  :     // Try to merge with previous command if it matches, else use current command
; 523  :     ImDrawCmd* prev_cmd = curr_cmd - 1;
; 524  :     if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)

  0007e	85 c9		 test	 ecx, ecx
  00080	75 39		 jne	 SHORT $LN3@OnChangedC
  00082	83 3f 01	 cmp	 DWORD PTR [rdi], 1
  00085	7e 34		 jle	 SHORT $LN3@OnChangedC
  00087	44 8d 41 1c	 lea	 r8d, QWORD PTR [rcx+28]
  0008b	48 8d 8f 88 00
	00 00		 lea	 rcx, QWORD PTR [rdi+136]
  00092	48 8d 53 90	 lea	 rdx, QWORD PTR [rbx-112]
  00096	e8 00 00 00 00	 call	 memcmp
  0009b	85 c0		 test	 eax, eax
  0009d	75 1c		 jne	 SHORT $LN3@OnChangedC
  0009f	8b 43 b0	 mov	 eax, DWORD PTR [rbx-80]
  000a2	03 43 ac	 add	 eax, DWORD PTR [rbx-84]
  000a5	3b 43 e4	 cmp	 eax, DWORD PTR [rbx-28]
  000a8	75 11		 jne	 SHORT $LN3@OnChangedC
  000aa	48 83 7b b8 00	 cmp	 QWORD PTR [rbx-72], 0
  000af	75 0a		 jne	 SHORT $LN3@OnChangedC

; 525  :     {
; 526  :         CmdBuffer.pop_back();

  000b1	48 8b cf	 mov	 rcx, rdi
  000b4	e8 00 00 00 00	 call	 ?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ; ImVector<ImDrawCmd>::pop_back

; 527  :         return;

  000b9	eb 0b		 jmp	 SHORT $LN8@OnChangedC
$LN3@OnChangedC:

; 528  :     }
; 529  : 
; 530  :     curr_cmd->ClipRect = _CmdHeader.ClipRect;

  000bb	0f 10 87 88 00
	00 00		 movups	 xmm0, XMMWORD PTR [rdi+136]
  000c2	0f 11 43 c8	 movups	 XMMWORD PTR [rbx-56], xmm0
$LN8@OnChangedC:

; 531  : }

  000c6	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000cb	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d0	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
?_OnChangedClipRect@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_OnChangedClipRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?_OnChangedTextureID@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_OnChangedTextureID

; 534  : {

$LN10:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 535  :     // If current command is used with different settings we need to add a new command
; 536  :     IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
; 537  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  0000a	48 63 01	 movsxd	 rax, DWORD PTR [rcx]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 6b f8 38	 imul	 rdi, rax, 56		; 00000038H
  00014	48 03 79 08	 add	 rdi, QWORD PTR [rcx+8]

; 538  :     if (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != _CmdHeader.TextureId)

  00018	8b 4f e8	 mov	 ecx, DWORD PTR [rdi-24]
  0001b	85 c9		 test	 ecx, ecx
  0001d	74 1f		 je	 SHORT $LN7@OnChangedT
  0001f	48 8b 83 98 00
	00 00		 mov	 rax, QWORD PTR [rbx+152]
  00026	48 39 47 d8	 cmp	 QWORD PTR [rdi-40], rax
  0002a	74 12		 je	 SHORT $LN7@OnChangedT

; 539  :     {
; 540  :         AddDrawCmd();

  0002c	48 8b cb	 mov	 rcx, rbx

; 554  : }

  0002f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi

; 539  :     {
; 540  :         AddDrawCmd();

  00039	e9 00 00 00 00	 jmp	 ?AddDrawCmd@ImDrawList@@QEAAXXZ ; ImDrawList::AddDrawCmd
$LN7@OnChangedT:

; 541  :         return;
; 542  :     }
; 543  :     IM_ASSERT(curr_cmd->UserCallback == NULL);

  0003e	48 83 7f f0 00	 cmp	 QWORD PTR [rdi-16], 0
  00043	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00048	74 1d		 je	 SHORT $LN5@OnChangedT
  0004a	41 b8 1f 02 00
	00		 mov	 r8d, 543		; 0000021fH
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@FGNNAPCK@?$AAc?$AAu?$AAr?$AAr?$AA_?$AAc?$AAm?$AAd?$AA?9?$AA?$DO?$AAU?$AAs?$AAe?$AAr?$AAC@
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00064	8b 4f e8	 mov	 ecx, DWORD PTR [rdi-24]
$LN5@OnChangedT:

; 544  : 
; 545  :     // Try to merge with previous command if it matches, else use current command
; 546  :     ImDrawCmd* prev_cmd = curr_cmd - 1;
; 547  :     if (curr_cmd->ElemCount == 0 && CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&_CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd->UserCallback == NULL)

  00067	85 c9		 test	 ecx, ecx
  00069	75 48		 jne	 SHORT $LN3@OnChangedT
  0006b	83 3b 01	 cmp	 DWORD PTR [rbx], 1
  0006e	7e 43		 jle	 SHORT $LN3@OnChangedT
  00070	48 8d 8b 88 00
	00 00		 lea	 rcx, QWORD PTR [rbx+136]
  00077	41 b8 1c 00 00
	00		 mov	 r8d, 28
  0007d	48 8d 57 90	 lea	 rdx, QWORD PTR [rdi-112]
  00081	e8 00 00 00 00	 call	 memcmp
  00086	85 c0		 test	 eax, eax
  00088	75 29		 jne	 SHORT $LN3@OnChangedT
  0008a	8b 47 b0	 mov	 eax, DWORD PTR [rdi-80]
  0008d	03 47 ac	 add	 eax, DWORD PTR [rdi-84]
  00090	3b 47 e4	 cmp	 eax, DWORD PTR [rdi-28]
  00093	75 1e		 jne	 SHORT $LN3@OnChangedT
  00095	48 83 7f b8 00	 cmp	 QWORD PTR [rdi-72], 0
  0009a	75 17		 jne	 SHORT $LN3@OnChangedT

; 548  :     {
; 549  :         CmdBuffer.pop_back();

  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 554  : }

  000a4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5f		 pop	 rdi

; 548  :     {
; 549  :         CmdBuffer.pop_back();

  000ae	e9 00 00 00 00	 jmp	 ?pop_back@?$ImVector@UImDrawCmd@@@@QEAAXXZ ; ImVector<ImDrawCmd>::pop_back
$LN3@OnChangedT:

; 550  :         return;
; 551  :     }
; 552  : 
; 553  :     curr_cmd->TextureId = _CmdHeader.TextureId;

  000b3	48 8b 83 98 00
	00 00		 mov	 rax, QWORD PTR [rbx+152]
  000ba	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 554  : }

  000bf	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c4	48 89 47 d8	 mov	 QWORD PTR [rdi-40], rax
  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
?_OnChangedTextureID@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_OnChangedTextureID
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ PROC		; ImDrawList::_OnChangedVtxOffset

; 557  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 558  :     // We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.
; 559  :     _VtxCurrentIdx = 0;
; 560  :     IM_ASSERT_PARANOID(CmdBuffer.Size > 0);
; 561  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  0000a	48 63 01	 movsxd	 rax, DWORD PTR [rcx]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 6b f8 38	 imul	 rdi, rax, 56		; 00000038H
  00014	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [rcx+52], 0
  0001b	48 03 79 08	 add	 rdi, QWORD PTR [rcx+8]

; 562  :     //IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
; 563  :     if (curr_cmd->ElemCount != 0)

  0001f	83 7f e8 00	 cmp	 DWORD PTR [rdi-24], 0
  00023	74 0f		 je	 SHORT $LN2@OnChangedV

; 570  : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi

; 564  :     {
; 565  :         AddDrawCmd();

  0002f	e9 00 00 00 00	 jmp	 ?AddDrawCmd@ImDrawList@@QEAAXXZ ; ImDrawList::AddDrawCmd
$LN2@OnChangedV:

; 566  :         return;
; 567  :     }
; 568  :     IM_ASSERT(curr_cmd->UserCallback == NULL);

  00034	48 83 7f f0 00	 cmp	 QWORD PTR [rdi-16], 0
  00039	74 1a		 je	 SHORT $LN4@OnChangedV
  0003b	41 b8 38 02 00
	00		 mov	 r8d, 568		; 00000238H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@FGNNAPCK@?$AAc?$AAu?$AAr?$AAr?$AA_?$AAc?$AAm?$AAd?$AA?9?$AA?$DO?$AAU?$AAs?$AAe?$AAr?$AAC@
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@OnChangedV:

; 569  :     curr_cmd->VtxOffset = _CmdHeader.VtxOffset;

  00055	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [rbx+160]

; 570  : }

  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	89 47 e0	 mov	 DWORD PTR [rdi-32], eax
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ ENDP		; ImDrawList::_OnChangedVtxOffset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
idx_count$ = 72
vtx_count$ = 80
?PrimReserve@ImDrawList@@QEAAXHH@Z PROC			; ImDrawList::PrimReserve

; 632  : {

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 633  :     // Large mesh support (when enabled)
; 634  :     IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0);
; 635  :     if (sizeof(ImDrawIdx) == 2 && (_VtxCurrentIdx + vtx_count >= (1 << 16)) && (Flags & ImDrawListFlags_AllowVtxOffset))

  00018	44 8b 49 34	 mov	 r9d, DWORD PTR [rcx+52]
  0001c	41 8b f0	 mov	 esi, r8d
  0001f	45 03 c8	 add	 r9d, r8d
  00022	8b ea		 mov	 ebp, edx
  00024	48 8b d9	 mov	 rbx, rcx
  00027	41 81 f9 00 00
	01 00		 cmp	 r9d, 65536		; 00010000H
  0002e	72 58		 jb	 SHORT $LN4@PrimReserv
  00030	f6 41 30 08	 test	 BYTE PTR [rcx+48], 8
  00034	74 52		 je	 SHORT $LN4@PrimReserv

; 561  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  00036	48 63 01	 movsxd	 rax, DWORD PTR [rcx]

; 636  :     {
; 637  :         // FIXME: In theory we should be testing that vtx_count <64k here.
; 638  :         // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
; 639  :         // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
; 640  :         _CmdHeader.VtxOffset = VtxBuffer.Size;

  00039	8b 51 20	 mov	 edx, DWORD PTR [rcx+32]

; 561  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  0003c	48 6b f8 38	 imul	 rdi, rax, 56		; 00000038H

; 636  :     {
; 637  :         // FIXME: In theory we should be testing that vtx_count <64k here.
; 638  :         // In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
; 639  :         // to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
; 640  :         _CmdHeader.VtxOffset = VtxBuffer.Size;

  00040	89 91 a0 00 00
	00		 mov	 DWORD PTR [rcx+160], edx

; 561  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  00046	48 03 79 08	 add	 rdi, QWORD PTR [rcx+8]
  0004a	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [rcx+52], 0

; 562  :     //IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
; 563  :     if (curr_cmd->ElemCount != 0)

  00051	83 7f e8 00	 cmp	 DWORD PTR [rdi-24], 0
  00055	74 07		 je	 SHORT $LN5@PrimReserv

; 564  :     {
; 565  :         AddDrawCmd();

  00057	e8 00 00 00 00	 call	 ?AddDrawCmd@ImDrawList@@QEAAXXZ ; ImDrawList::AddDrawCmd

; 566  :         return;

  0005c	eb 2a		 jmp	 SHORT $LN4@PrimReserv
$LN5@PrimReserv:

; 567  :     }
; 568  :     IM_ASSERT(curr_cmd->UserCallback == NULL);

  0005e	48 83 7f f0 00	 cmp	 QWORD PTR [rdi-16], 0
  00063	74 20		 je	 SHORT $LN7@PrimReserv
  00065	41 b8 38 02 00
	00		 mov	 r8d, 568		; 00000238H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@FGNNAPCK@?$AAc?$AAu?$AAr?$AAr?$AA_?$AAc?$AAm?$AAd?$AA?9?$AA?$DO?$AAU?$AAs?$AAe?$AAr?$AAC@
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007f	8b 93 a0 00 00
	00		 mov	 edx, DWORD PTR [rbx+160]
$LN7@PrimReserv:

; 569  :     curr_cmd->VtxOffset = _CmdHeader.VtxOffset;

  00085	89 57 e0	 mov	 DWORD PTR [rdi-32], edx
$LN4@PrimReserv:

; 644  :     ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  00088	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0008b	bf 08 00 00 00	 mov	 edi, 8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 644  :     ImDrawCmd* draw_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  00090	48 6b c8 38	 imul	 rcx, rax, 56		; 00000038H
  00094	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 645  :     draw_cmd->ElemCount += idx_count;

  00098	01 6c 01 e8	 add	 DWORD PTR [rcx+rax-24], ebp

; 646  : 
; 647  :     int vtx_buffer_old_size = VtxBuffer.Size;

  0009c	4c 63 7b 20	 movsxd	 r15, DWORD PTR [rbx+32]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000a0	8b 4b 24	 mov	 ecx, DWORD PTR [rbx+36]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 648  :     VtxBuffer.resize(vtx_buffer_old_size + vtx_count);

  000a3	41 03 f7	 add	 esi, r15d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000a6	3b f1		 cmp	 esi, ecx
  000a8	7e 21		 jle	 SHORT $LN9@PrimReserv

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000aa	85 c9		 test	 ecx, ecx
  000ac	74 0b		 je	 SHORT $LN13@PrimReserv
  000ae	8b c1		 mov	 eax, ecx
  000b0	99		 cdq
  000b1	2b c2		 sub	 eax, edx
  000b3	d1 f8		 sar	 eax, 1
  000b5	03 c1		 add	 eax, ecx
  000b7	eb 02		 jmp	 SHORT $LN14@PrimReserv
$LN13@PrimReserv:
  000b9	8b c7		 mov	 eax, edi
$LN14@PrimReserv:
  000bb	3b c6		 cmp	 eax, esi

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000bd	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000c1	8b d6		 mov	 edx, esi
  000c3	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000c6	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::reserve
$LN9@PrimReserv:
  000cb	89 73 20	 mov	 DWORD PTR [rbx+32], esi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 649  :     _VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

  000ce	4b 8d 0c bf	 lea	 rcx, QWORD PTR [r15+r15*4]
  000d2	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]

; 650  : 
; 651  :     int idx_buffer_old_size = IdxBuffer.Size;

  000d6	4c 63 7b 10	 movsxd	 r15, DWORD PTR [rbx+16]
  000da	48 8d 0c 88	 lea	 rcx, QWORD PTR [rax+rcx*4]
  000de	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx

; 652  :     IdxBuffer.resize(idx_buffer_old_size + idx_count);

  000e2	41 8d 34 2f	 lea	 esi, DWORD PTR [r15+rbp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000e6	8b 4b 14	 mov	 ecx, DWORD PTR [rbx+20]
  000e9	3b f1		 cmp	 esi, ecx
  000eb	7e 1e		 jle	 SHORT $LN16@PrimReserv

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000ed	85 c9		 test	 ecx, ecx
  000ef	74 0a		 je	 SHORT $LN20@PrimReserv
  000f1	8b c1		 mov	 eax, ecx
  000f3	99		 cdq
  000f4	2b c2		 sub	 eax, edx
  000f6	d1 f8		 sar	 eax, 1
  000f8	8d 3c 01	 lea	 edi, DWORD PTR [rcx+rax]
$LN20@PrimReserv:
  000fb	3b fe		 cmp	 edi, esi

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000fd	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00101	8b d6		 mov	 edx, esi
  00103	0f 4f d7	 cmovg	 edx, edi

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00106	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QEAAXH@Z ; ImVector<unsigned short>::reserve
$LN16@PrimReserv:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 654  : }

  0010b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00110	89 73 10	 mov	 DWORD PTR [rbx+16], esi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 653  :     _IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;

  00113	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 654  : }

  00117	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0011c	4a 8d 0c 78	 lea	 rcx, QWORD PTR [rax+r15*2]
  00120	48 89 4b 50	 mov	 QWORD PTR [rbx+80], rcx
  00124	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00129	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012d	41 5f		 pop	 r15
  0012f	41 5e		 pop	 r14
  00131	5f		 pop	 rdi
  00132	c3		 ret	 0
?PrimReserve@ImDrawList@@QEAAXHH@Z ENDP			; ImDrawList::PrimReserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 32
a$ = 40
c$ = 48
col$ = 56
?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z PROC	; ImDrawList::PrimRect

; 669  : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 10	 sub	 rsp, 16

; 670  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);

  00006	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0000a	48 8b d9	 mov	 rbx, rcx

; 671  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

  0000d	44 0f b7 51 34	 movzx	 r10d, WORD PTR [rcx+52]
  00012	4c 8b da	 mov	 r11, rdx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00015	f3 0f 10 52 04	 movss	 xmm2, DWORD PTR [rdx+4]
  0001a	f3 0f 10 1a	 movss	 xmm3, DWORD PTR [rdx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 670  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);

  0001e	f3 0f 10 28	 movss	 xmm5, DWORD PTR [rax]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00022	f3 41 0f 10 08	 movss	 xmm1, DWORD PTR [r8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 672  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

  00027	41 8d 52 01	 lea	 edx, DWORD PTR [r10+1]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0002b	f3 41 0f 10 60
	04		 movss	 xmm4, DWORD PTR [r8+4]
  00031	0f 29 34 24	 movaps	 XMMWORD PTR [rsp], xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 670  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);

  00035	f3 0f 10 70 04	 movss	 xmm6, DWORD PTR [rax+4]

; 672  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

  0003a	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  0003e	66 44 89 10	 mov	 WORD PTR [rax], r10w
  00042	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  00046	41 8d 4a 02	 lea	 ecx, DWORD PTR [r10+2]
  0004a	66 89 50 02	 mov	 WORD PTR [rax+2], dx
  0004e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00052	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 673  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx + 3);

  00056	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0005a	66 44 89 50 06	 mov	 WORD PTR [rax+6], r10w
  0005f	66 41 83 c2 03	 add	 r10w, 3
  00064	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00068	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  0006c	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00070	66 44 89 50 0a	 mov	 WORD PTR [rax+10], r10w

; 674  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

  00075	f2 41 0f 10 03	 movsd	 xmm0, QWORD PTR [r11]
  0007a	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  0007e	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  00082	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00086	f3 0f 11 68 08	 movss	 DWORD PTR [rax+8], xmm5
  0008b	f3 0f 11 70 0c	 movss	 DWORD PTR [rax+12], xmm6
  00090	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00094	44 89 48 10	 mov	 DWORD PTR [rax+16], r9d

; 675  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

  00098	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  0009c	f3 0f 11 48 14	 movss	 DWORD PTR [rax+20], xmm1
  000a1	f3 0f 11 50 18	 movss	 DWORD PTR [rax+24], xmm2
  000a6	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000aa	f3 0f 11 68 1c	 movss	 DWORD PTR [rax+28], xmm5
  000af	f3 0f 11 70 20	 movss	 DWORD PTR [rax+32], xmm6
  000b4	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000b8	44 89 48 24	 mov	 DWORD PTR [rax+36], r9d

; 676  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

  000bc	f2 41 0f 10 00	 movsd	 xmm0, QWORD PTR [r8]
  000c1	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000c5	f2 0f 11 40 28	 movsd	 QWORD PTR [rax+40], xmm0
  000ca	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000ce	f3 0f 11 68 30	 movss	 DWORD PTR [rax+48], xmm5
  000d3	f3 0f 11 70 34	 movss	 DWORD PTR [rax+52], xmm6
  000d8	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000dc	44 89 48 38	 mov	 DWORD PTR [rax+56], r9d

; 677  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

  000e0	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000e4	f3 0f 11 58 3c	 movss	 DWORD PTR [rax+60], xmm3
  000e9	f3 0f 11 60 40	 movss	 DWORD PTR [rax+64], xmm4
  000ee	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000f2	f3 0f 11 68 44	 movss	 DWORD PTR [rax+68], xmm5
  000f7	f3 0f 11 70 48	 movss	 DWORD PTR [rax+72], xmm6
  000fc	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]

; 678  :     _VtxWritePtr += 4;
; 679  :     _VtxCurrentIdx += 4;
; 680  :     _IdxWritePtr += 6;
; 681  : }

  00100	0f 28 34 24	 movaps	 xmm6, XMMWORD PTR [rsp]
  00104	44 89 48 4c	 mov	 DWORD PTR [rax+76], r9d
  00108	48 83 43 48 50	 add	 QWORD PTR [rbx+72], 80	; 00000050H
  0010d	83 43 34 04	 add	 DWORD PTR [rbx+52], 4
  00111	48 83 43 50 0c	 add	 QWORD PTR [rbx+80], 12
  00116	48 83 c4 10	 add	 rsp, 16
  0011a	5b		 pop	 rbx
  0011b	c3		 ret	 0
?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z ENDP	; ImDrawList::PrimRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 80
a$ = 88
c$ = 96
uv_a$ = 104
uv_c$ = 112
col$ = 120
?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z PROC	; ImDrawList::PrimRectUV

; 684  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 687  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

  00006	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  0000a	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0000d	f3 41 0f 10 59
	04		 movss	 xmm3, DWORD PTR [r9+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 684  : {

  00013	4d 8b d1	 mov	 r10, r9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00016	f3 41 0f 10 20	 movss	 xmm4, DWORD PTR [r8]
  0001b	f3 0f 10 6a 04	 movss	 xmm5, DWORD PTR [rdx+4]
  00020	4c 8b 5c 24 70	 mov	 r11, QWORD PTR uv_c$[rsp]
  00025	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  0002a	f3 41 0f 10 31	 movss	 xmm6, DWORD PTR [r9]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 686  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

  0002f	44 0f b7 49 34	 movzx	 r9d, WORD PTR [rcx+52]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00034	f3 41 0f 10 13	 movss	 xmm2, DWORD PTR [r11]
  00039	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  0003e	f3 41 0f 10 7b
	04		 movss	 xmm7, DWORD PTR [r11+4]
  00044	44 0f 29 44 24
	10		 movaps	 XMMWORD PTR [rsp+16], xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 687  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

  0004a	41 8d 49 01	 lea	 ecx, DWORD PTR [r9+1]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0004e	f3 44 0f 10 02	 movss	 xmm8, DWORD PTR [rdx]
  00053	44 0f 29 0c 24	 movaps	 XMMWORD PTR [rsp], xmm9
  00058	f3 45 0f 10 48
	04		 movss	 xmm9, DWORD PTR [r8+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 687  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);

  0005e	66 44 89 08	 mov	 WORD PTR [rax], r9w
  00062	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00066	66 89 48 02	 mov	 WORD PTR [rax+2], cx
  0006a	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  0006e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00072	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 688  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx + 3);

  00076	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0007a	66 44 89 48 06	 mov	 WORD PTR [rax+6], r9w
  0007f	66 41 83 c1 03	 add	 r9w, 3
  00084	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00088	66 89 48 08	 mov	 WORD PTR [rax+8], cx
  0008c	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]

; 689  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;

  00090	8b 4c 24 78	 mov	 ecx, DWORD PTR col$[rsp]
  00094	66 44 89 48 0a	 mov	 WORD PTR [rax+10], r9w
  00099	f2 0f 10 02	 movsd	 xmm0, QWORD PTR [rdx]
  0009d	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000a1	f2 0f 11 00	 movsd	 QWORD PTR [rax], xmm0
  000a5	f2 41 0f 10 0a	 movsd	 xmm1, QWORD PTR [r10]
  000aa	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000ae	f2 0f 11 48 08	 movsd	 QWORD PTR [rax+8], xmm1
  000b3	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000b7	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 690  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;

  000ba	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000be	f3 0f 11 60 14	 movss	 DWORD PTR [rax+20], xmm4
  000c3	f3 0f 11 68 18	 movss	 DWORD PTR [rax+24], xmm5
  000c8	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000cc	f3 0f 11 50 1c	 movss	 DWORD PTR [rax+28], xmm2
  000d1	f3 0f 11 58 20	 movss	 DWORD PTR [rax+32], xmm3
  000d6	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000da	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 691  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;

  000dd	f2 41 0f 10 00	 movsd	 xmm0, QWORD PTR [r8]
  000e2	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000e6	f2 0f 11 40 28	 movsd	 QWORD PTR [rax+40], xmm0
  000eb	f2 41 0f 10 0b	 movsd	 xmm1, QWORD PTR [r11]
  000f0	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000f4	f2 0f 11 48 30	 movsd	 QWORD PTR [rax+48], xmm1
  000f9	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000fd	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 692  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;

  00100	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00104	f3 44 0f 11 40
	3c		 movss	 DWORD PTR [rax+60], xmm8

; 693  :     _VtxWritePtr += 4;
; 694  :     _VtxCurrentIdx += 4;
; 695  :     _IdxWritePtr += 6;
; 696  : }

  0010a	44 0f 28 44 24
	10		 movaps	 xmm8, XMMWORD PTR [rsp+16]
  00110	f3 44 0f 11 48
	40		 movss	 DWORD PTR [rax+64], xmm9
  00116	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  0011a	44 0f 28 0c 24	 movaps	 xmm9, XMMWORD PTR [rsp]
  0011f	f3 0f 11 70 44	 movss	 DWORD PTR [rax+68], xmm6
  00124	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00129	f3 0f 11 78 48	 movss	 DWORD PTR [rax+72], xmm7
  0012e	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00132	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  00137	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
  0013a	48 83 43 48 50	 add	 QWORD PTR [rbx+72], 80	; 00000050H
  0013f	83 43 34 04	 add	 DWORD PTR [rbx+52], 4
  00143	48 83 43 50 0c	 add	 QWORD PTR [rbx+80], 12
  00148	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0014c	5b		 pop	 rbx
  0014d	c3		 ret	 0
?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ENDP	; ImDrawList::PrimRectUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 96
center$ = 104
extra_max_sample$1$ = 112
radius$ = 112
a_min_sample$ = 120
a_max_sample$ = 128
tv927 = 136
a_step$dead$ = 136
?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z PROC ; ImDrawList::_PathArcToFastEx

; 1059 : {

$LN54:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000c	44 8b b4 24 80
	00 00 00	 mov	 r14d, DWORD PTR a_max_sample$[rsp]
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0001c	41 8b f9	 mov	 edi, r9d
  0001f	0f 28 f2	 movaps	 xmm6, xmm2
  00022	4c 8b ea	 mov	 r13, rdx

; 1060 :     if (radius <= 0.0f)

  00025	0f 2f c6	 comiss	 xmm0, xmm6
  00028	48 8b e9	 mov	 rbp, rcx
  0002b	72 5e		 jb	 SHORT $LN8@PathArcToF
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0002d	8b 49 7c	 mov	 ecx, DWORD PTR [rcx+124]
  00030	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  00033	3b c1		 cmp	 eax, ecx
  00035	75 2e		 jne	 SHORT $LN24@PathArcToF
  00037	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0003b	85 c9		 test	 ecx, ecx
  0003d	74 0b		 je	 SHORT $LN28@PathArcToF
  0003f	8b c1		 mov	 eax, ecx
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx
  00044	d1 f8		 sar	 eax, 1
  00046	03 c1		 add	 eax, ecx
  00048	eb 05		 jmp	 SHORT $LN29@PathArcToF
$LN28@PathArcToF:
  0004a	b8 08 00 00 00	 mov	 eax, 8
$LN29@PathArcToF:
  0004f	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00052	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00056	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0005a	41 8b d0	 mov	 edx, r8d
  0005d	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00062	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN24@PathArcToF:
  00065	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  0006c	48 63 d0	 movsxd	 rdx, eax
  0006f	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  00073	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00077	ff 45 78	 inc	 DWORD PTR [rbp+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1148 : }

  0007a	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0007f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00083	41 5e		 pop	 r14
  00085	41 5d		 pop	 r13
  00087	5f		 pop	 rdi
  00088	5d		 pop	 rbp
  00089	5b		 pop	 rbx
  0008a	c3		 ret	 0
$LN8@PathArcToF:
  0008b	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi

; 1068 :         a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);

  00090	0f 28 ce	 movaps	 xmm1, xmm6
  00093	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00098	4c 89 7c 24 78	 mov	 QWORD PTR [rsp+120], r15
  0009d	e8 00 00 00 00	 call	 ?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z ; ImDrawList::_CalcCircleAutoSegmentCount
  000a2	8b c8		 mov	 ecx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 426  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

  000a4	c6 44 24 70 00	 mov	 BYTE PTR extra_max_sample$1$[rsp], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1068 :         a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / _CalcCircleAutoSegmentCount(radius);

  000a9	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  000ae	99		 cdq
  000af	f7 f9		 idiv	 ecx
  000b1	8b d8		 mov	 ebx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 426  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

  000b3	83 f8 01	 cmp	 eax, 1
  000b6	7d 17		 jge	 SHORT $LN32@PathArcToF
  000b8	41 8b c6	 mov	 eax, r14d
  000bb	be 01 00 00 00	 mov	 esi, 1
  000c0	2b c7		 sub	 eax, edi
  000c2	8b de		 mov	 ebx, esi
  000c4	99		 cdq
  000c5	8b c8		 mov	 ecx, eax
  000c7	33 ca		 xor	 ecx, edx
  000c9	2b ca		 sub	 ecx, edx
  000cb	ff c1		 inc	 ecx
  000cd	eb 48		 jmp	 SHORT $LN12@PathArcToF
$LN32@PathArcToF:
  000cf	b8 0c 00 00 00	 mov	 eax, 12
  000d4	3b d8		 cmp	 ebx, eax
  000d6	0f 4f d8	 cmovg	 ebx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1073 :     const int sample_range = ImAbs(a_max_sample - a_min_sample);

  000d9	41 8b c6	 mov	 eax, r14d
  000dc	2b c7		 sub	 eax, edi

; 1077 :     bool extra_max_sample = false;

  000de	8b f3		 mov	 esi, ebx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 410  : static inline int    ImAbs(int x) { return x < 0 ? -x : x; }

  000e0	99		 cdq
  000e1	44 8b c0	 mov	 r8d, eax
  000e4	44 33 c2	 xor	 r8d, edx
  000e7	44 2b c2	 sub	 r8d, edx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1076 :     int samples = sample_range + 1;

  000ea	41 8d 48 01	 lea	 ecx, DWORD PTR [r8+1]

; 1078 :     if (a_step > 1)

  000ee	83 fb 01	 cmp	 ebx, 1
  000f1	7e 24		 jle	 SHORT $LN12@PathArcToF

; 1079 :     {
; 1080 :         samples = sample_range / a_step + 1;

  000f3	41 8b c0	 mov	 eax, r8d
  000f6	99		 cdq
  000f7	f7 fb		 idiv	 ebx
  000f9	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1081 :         const int overstep = sample_range % a_step;
; 1082 : 
; 1083 :         if (overstep > 0)

  000fc	85 d2		 test	 edx, edx
  000fe	7e 17		 jle	 SHORT $LN12@PathArcToF

; 1084 :         {
; 1085 :             extra_max_sample = true;
; 1086 :             samples++;

  00100	ff c1		 inc	 ecx
  00102	c6 44 24 70 01	 mov	 BYTE PTR extra_max_sample$1$[rsp], 1

; 1087 : 
; 1088 :             // When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
; 1089 :             // distribute first step range evenly between them by reducing first step size.
; 1090 :             if (sample_range > 0)

  00107	45 85 c0	 test	 r8d, r8d
  0010a	7e 0b		 jle	 SHORT $LN12@PathArcToF

; 1091 :                 a_step -= (a_step - overstep) / 2;

  0010c	8b c3		 mov	 eax, ebx
  0010e	2b c2		 sub	 eax, edx
  00110	99		 cdq
  00111	2b c2		 sub	 eax, edx
  00113	d1 f8		 sar	 eax, 1
  00115	2b f0		 sub	 esi, eax
$LN12@PathArcToF:

; 1092 :         }
; 1093 :     }
; 1094 : 
; 1095 :     _Path.resize(_Path.Size + samples);

  00117	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  0011a	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv927[rsp], eax
  00121	44 8d 24 08	 lea	 r12d, DWORD PTR [rax+rcx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00125	8b 4d 7c	 mov	 ecx, DWORD PTR [rbp+124]
  00128	44 3b e1	 cmp	 r12d, ecx
  0012b	7e 2d		 jle	 SHORT $LN37@PathArcToF

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0012d	85 c9		 test	 ecx, ecx
  0012f	74 0b		 je	 SHORT $LN41@PathArcToF
  00131	8b c1		 mov	 eax, ecx
  00133	99		 cdq
  00134	2b c2		 sub	 eax, edx
  00136	d1 f8		 sar	 eax, 1
  00138	03 c1		 add	 eax, ecx
  0013a	eb 05		 jmp	 SHORT $LN42@PathArcToF
$LN41@PathArcToF:
  0013c	b8 08 00 00 00	 mov	 eax, 8
$LN42@PathArcToF:
  00141	41 3b c4	 cmp	 eax, r12d

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00144	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00148	41 8b d4	 mov	 edx, r12d
  0014b	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0014e	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00153	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv927[rsp]
$LN37@PathArcToF:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1098 :     int sample_index = a_min_sample;

  0015a	4c 8b 7c 24 78	 mov	 r15, QWORD PTR [rsp+120]
  0015f	48 63 c8	 movsxd	 rcx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00162	44 89 65 78	 mov	 DWORD PTR [rbp+120], r12d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1096 :     ImVec2* out_ptr = _Path.Data + (_Path.Size - samples);

  00166	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR [rbp+128]

; 1098 :     int sample_index = a_min_sample;

  0016d	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  00172	4c 8d 04 c8	 lea	 r8, QWORD PTR [rax+rcx*8]
  00176	8b cf		 mov	 ecx, edi

; 1099 :     if (sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)

  00178	83 ff 2f	 cmp	 edi, 47			; 0000002fH
  0017b	76 1e		 jbe	 SHORT $LN15@PathArcToF

; 1100 :     {
; 1101 :         sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

  0017d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00182	f7 ef		 imul	 edi
  00184	c1 fa 03	 sar	 edx, 3
  00187	8b c2		 mov	 eax, edx
  00189	c1 e8 1f	 shr	 eax, 31
  0018c	03 d0		 add	 edx, eax
  0018e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00191	c1 e0 04	 shl	 eax, 4
  00194	2b c8		 sub	 ecx, eax

; 1102 :         if (sample_index < 0)

  00196	79 03		 jns	 SHORT $LN15@PathArcToF

; 1103 :             sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

  00198	83 c1 30	 add	 ecx, 48			; 00000030H
$LN15@PathArcToF:

; 1104 :     }
; 1105 : 
; 1106 :     if (a_max_sample >= a_min_sample)

  0019b	48 63 d1	 movsxd	 rdx, ecx
  0019e	4c 63 ce	 movsxd	 r9, esi
  001a1	4c 63 d3	 movsxd	 r10, ebx
  001a4	44 3b f7	 cmp	 r14d, edi
  001a7	7c 67		 jl	 SHORT $LL16@PathArcToF
  001a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@PathArcToF:

; 1107 :     {
; 1108 :         for (int a = a_min_sample; a <= a_max_sample; a += a_step, sample_index += a_step, a_step = a_next_step)
; 1109 :         {
; 1110 :             // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
; 1111 :             if (sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
; 1112 :                 sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
; 1113 : 
; 1114 :             const ImVec2 s = _Data->ArcFastVtx[sample_index];

  001b0	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]
  001b4	48 8d 4a d0	 lea	 rcx, QWORD PTR [rdx-48]
  001b8	48 83 fa 30	 cmp	 rdx, 48			; 00000030H
  001bc	48 0f 4c ca	 cmovl	 rcx, rdx
  001c0	03 fe		 add	 edi, esi
  001c2	8b f3		 mov	 esi, ebx
  001c4	f3 0f 10 44 c8
	30		 movss	 xmm0, DWORD PTR [rax+rcx*8+48]
  001ca	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
  001ce	f3 0f 10 4c c8
	34		 movss	 xmm1, DWORD PTR [rax+rcx*8+52]
  001d4	4d 8b ca	 mov	 r9, r10

; 1115 :             out_ptr->x = center.x + s.x * radius;

  001d7	f3 0f 59 c6	 mulss	 xmm0, xmm6

; 1116 :             out_ptr->y = center.y + s.y * radius;

  001db	f3 0f 59 ce	 mulss	 xmm1, xmm6
  001df	f3 41 0f 58 45
	00		 addss	 xmm0, DWORD PTR [r13]
  001e5	f3 41 0f 11 00	 movss	 DWORD PTR [r8], xmm0
  001ea	f3 41 0f 58 4d
	04		 addss	 xmm1, DWORD PTR [r13+4]
  001f0	f3 41 0f 11 48
	04		 movss	 DWORD PTR [r8+4], xmm1

; 1117 :             out_ptr++;

  001f6	49 83 c0 08	 add	 r8, 8
  001fa	41 3b fe	 cmp	 edi, r14d
  001fd	7e b1		 jle	 SHORT $LL4@PathArcToF

; 1118 :         }
; 1119 :     }

  001ff	eb 5f		 jmp	 SHORT $LN6@PathArcToF
  00201	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL16@PathArcToF:

; 1120 :     else
; 1121 :     {
; 1122 :         for (int a = a_min_sample; a >= a_max_sample; a -= a_step, sample_index -= a_step, a_step = a_next_step)
; 1123 :         {
; 1124 :             // a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
; 1125 :             if (sample_index < 0)
; 1126 :                 sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
; 1127 : 
; 1128 :             const ImVec2 s = _Data->ArcFastVtx[sample_index];

  00210	48 85 d2	 test	 rdx, rdx
  00213	48 8d 42 30	 lea	 rax, QWORD PTR [rdx+48]
  00217	48 0f 49 c2	 cmovns	 rax, rdx
  0021b	2b fe		 sub	 edi, esi
  0021d	48 8b d0	 mov	 rdx, rax
  00220	8b f3		 mov	 esi, ebx
  00222	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]
  00226	f3 0f 10 44 d0
	30		 movss	 xmm0, DWORD PTR [rax+rdx*8+48]
  0022c	f3 0f 10 4c d0
	34		 movss	 xmm1, DWORD PTR [rax+rdx*8+52]
  00232	49 2b d1	 sub	 rdx, r9

; 1129 :             out_ptr->x = center.x + s.x * radius;

  00235	f3 0f 59 c6	 mulss	 xmm0, xmm6
  00239	4d 8b ca	 mov	 r9, r10

; 1130 :             out_ptr->y = center.y + s.y * radius;

  0023c	f3 0f 59 ce	 mulss	 xmm1, xmm6
  00240	f3 41 0f 58 45
	00		 addss	 xmm0, DWORD PTR [r13]
  00246	f3 41 0f 11 00	 movss	 DWORD PTR [r8], xmm0
  0024b	f3 41 0f 58 4d
	04		 addss	 xmm1, DWORD PTR [r13+4]
  00251	f3 41 0f 11 48
	04		 movss	 DWORD PTR [r8+4], xmm1

; 1131 :             out_ptr++;

  00257	49 83 c0 08	 add	 r8, 8
  0025b	41 3b fe	 cmp	 edi, r14d
  0025e	7d b0		 jge	 SHORT $LL16@PathArcToF
$LN6@PathArcToF:

; 1132 :         }
; 1133 :     }
; 1134 : 
; 1135 :     if (extra_max_sample)

  00260	80 7c 24 70 00	 cmp	 BYTE PTR extra_max_sample$1$[rsp], 0
  00265	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0026a	74 55		 je	 SHORT $LN20@PathArcToF

; 1136 :     {
; 1137 :         int normalized_max_sample = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX;

  0026c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00271	41 f7 ee	 imul	 r14d
  00274	c1 fa 03	 sar	 edx, 3
  00277	8b c2		 mov	 eax, edx
  00279	c1 e8 1f	 shr	 eax, 31
  0027c	03 d0		 add	 edx, eax
  0027e	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00281	c1 e0 04	 shl	 eax, 4
  00284	44 2b f0	 sub	 r14d, eax

; 1138 :         if (normalized_max_sample < 0)
; 1139 :             normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX;
; 1140 : 
; 1141 :         const ImVec2 s = _Data->ArcFastVtx[normalized_max_sample];

  00287	41 8d 46 30	 lea	 eax, DWORD PTR [r14+48]
  0028b	41 0f 49 c6	 cmovns	 eax, r14d
  0028f	48 63 c8	 movsxd	 rcx, eax
  00292	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]
  00296	f3 0f 10 44 c8
	30		 movss	 xmm0, DWORD PTR [rax+rcx*8+48]
  0029c	f3 0f 10 4c c8
	34		 movss	 xmm1, DWORD PTR [rax+rcx*8+52]

; 1142 :         out_ptr->x = center.x + s.x * radius;

  002a2	f3 0f 59 c6	 mulss	 xmm0, xmm6

; 1143 :         out_ptr->y = center.y + s.y * radius;

  002a6	f3 0f 59 ce	 mulss	 xmm1, xmm6
  002aa	f3 41 0f 58 45
	00		 addss	 xmm0, DWORD PTR [r13]
  002b0	f3 41 0f 11 00	 movss	 DWORD PTR [r8], xmm0
  002b5	f3 41 0f 58 4d
	04		 addss	 xmm1, DWORD PTR [r13+4]
  002bb	f3 41 0f 11 48
	04		 movss	 DWORD PTR [r8+4], xmm1
$LN20@PathArcToF:

; 1148 : }

  002c1	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  002c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002ca	41 5e		 pop	 r14
  002cc	41 5d		 pop	 r13
  002ce	5f		 pop	 rdi
  002cf	5d		 pop	 rbp
  002d0	5b		 pop	 rbx
  002d1	c3		 ret	 0
?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ENDP ; ImDrawList::_PathArcToFastEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 160
center$ = 168
radius$ = 176
a_min$ = 184
a_max$ = 192
num_segments$ = 200
?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z PROC	; ImDrawList::_PathArcToN

; 1151 : {

$LN30:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 57		 push	 r15
  00005	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000c	8b 41 78	 mov	 eax, DWORD PTR [rcx+120]
  0000f	48 8d 59 78	 lea	 rbx, QWORD PTR [rcx+120]
  00013	0f 29 7c 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm7
  00018	0f 57 c0	 xorps	 xmm0, xmm0
  0001b	0f 28 fa	 movaps	 xmm7, xmm2
  0001e	44 0f 29 4c 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm9

; 1152 :     if (radius <= 0.0f)

  00024	0f 2f c7	 comiss	 xmm0, xmm7
  00027	4c 8b fa	 mov	 r15, rdx
  0002a	44 0f 28 cb	 movaps	 xmm9, xmm3
  0002e	72 49		 jb	 SHORT $LN5@PathArcToN
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00030	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  00033	3b c1		 cmp	 eax, ecx
  00035	75 2d		 jne	 SHORT $LN8@PathArcToN
  00037	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0003b	85 c9		 test	 ecx, ecx
  0003d	74 0c		 je	 SHORT $LN12@PathArcToN
  0003f	8b c1		 mov	 eax, ecx
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx
  00044	d1 f8		 sar	 eax, 1
  00046	8d 34 01	 lea	 esi, DWORD PTR [rcx+rax]
  00049	eb 05		 jmp	 SHORT $LN13@PathArcToN
$LN12@PathArcToN:
  0004b	be 08 00 00 00	 mov	 esi, 8
$LN13@PathArcToN:
  00050	41 3b f0	 cmp	 esi, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00053	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00056	44 0f 4f c6	 cmovg	 r8d, esi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0005a	41 8b d0	 mov	 edx, r8d
  0005d	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00062	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN8@PathArcToN:
  00064	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00068	48 63 d0	 movsxd	 rdx, eax
  0006b	49 8b 07	 mov	 rax, QWORD PTR [r15]
  0006e	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00072	ff 03		 inc	 DWORD PTR [rbx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1155 :         return;

  00074	e9 25 01 00 00	 jmp	 $LN3@PathArcToN
$LN5@PathArcToN:
  00079	48 89 ac 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbp

; 1156 :     }
; 1157 : 
; 1158 :     // Note that we are adding a point at both a_min and a_max.
; 1159 :     // If you are trying to draw a full closed circle you don't want the overlapping points!
; 1160 :     _Path.reserve(_Path.Size + (num_segments + 1));

  00081	48 8b cb	 mov	 rcx, rbx
  00084	4c 89 b4 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r14
  0008c	44 8b b4 24 c8
	00 00 00	 mov	 r14d, DWORD PTR num_segments$[rsp]
  00094	41 8d 56 01	 lea	 edx, DWORD PTR [r14+1]
  00098	03 d0		 add	 edx, eax
  0009a	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  0009f	33 ed		 xor	 ebp, ebp

; 1161 :     for (int i = 0; i <= num_segments; i++)

  000a1	45 85 f6	 test	 r14d, r14d
  000a4	0f 88 e4 00 00
	00		 js	 $LN28@PathArcToN

; 1164 :         _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));

  000aa	48 89 bc 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rdi
  000b2	8d 75 08	 lea	 esi, QWORD PTR [rbp+8]
  000b5	8b 3b		 mov	 edi, DWORD PTR [rbx]
  000b7	0f 29 74 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm6
  000bc	44 0f 29 44 24
	50		 movaps	 XMMWORD PTR [rsp+80], xmm8
  000c2	f3 44 0f 10 84
	24 c0 00 00 00	 movss	 xmm8, DWORD PTR a_max$[rsp]
  000cc	44 0f 29 54 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm10
  000d2	f3 45 0f 5c c1	 subss	 xmm8, xmm9
  000d7	66 45 0f 6e d6	 movd	 xmm10, r14d
  000dc	45 0f 5b d2	 cvtdq2ps xmm10, xmm10
$LL4@PathArcToN:

; 1162 :     {
; 1163 :         const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);

  000e0	0f 57 f6	 xorps	 xmm6, xmm6
  000e3	f3 0f 2a f5	 cvtsi2ss xmm6, ebp
  000e7	f3 41 0f 5e f2	 divss	 xmm6, xmm10
  000ec	f3 41 0f 59 f0	 mulss	 xmm6, xmm8
  000f1	f3 41 0f 58 f1	 addss	 xmm6, xmm9

; 1164 :         _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));

  000f6	0f 28 c6	 movaps	 xmm0, xmm6
  000f9	e8 00 00 00 00	 call	 cosf
  000fe	f3 0f 59 c7	 mulss	 xmm0, xmm7
  00102	f3 41 0f 58 07	 addss	 xmm0, DWORD PTR [r15]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00107	f3 0f 11 44 24
	20		 movss	 DWORD PTR $T1[rsp], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1164 :         _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));

  0010d	0f 28 c6	 movaps	 xmm0, xmm6
  00110	e8 00 00 00 00	 call	 sinf
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00115	44 8b 43 04	 mov	 r8d, DWORD PTR [rbx+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1164 :         _Path.push_back(ImVec2(center.x + ImCos(a) * radius, center.y + ImSin(a) * radius));

  00119	f3 0f 59 c7	 mulss	 xmm0, xmm7
  0011d	f3 41 0f 58 47
	04		 addss	 xmm0, DWORD PTR [r15+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00123	f3 0f 11 44 24
	24		 movss	 DWORD PTR $T1[rsp+4], xmm0

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00129	41 3b f8	 cmp	 edi, r8d
  0012c	75 28		 jne	 SHORT $LN17@PathArcToN
  0012e	8d 4f 01	 lea	 ecx, DWORD PTR [rdi+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00131	45 85 c0	 test	 r8d, r8d
  00134	74 0d		 je	 SHORT $LN21@PathArcToN
  00136	41 8b c0	 mov	 eax, r8d
  00139	99		 cdq
  0013a	2b c2		 sub	 eax, edx
  0013c	d1 f8		 sar	 eax, 1
  0013e	41 03 c0	 add	 eax, r8d
  00141	eb 02		 jmp	 SHORT $LN22@PathArcToN
$LN21@PathArcToN:
  00143	8b c6		 mov	 eax, esi
$LN22@PathArcToN:
  00145	3b c1		 cmp	 eax, ecx
  00147	0f 4f c8	 cmovg	 ecx, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0014a	8b d1		 mov	 edx, ecx
  0014c	48 8b cb	 mov	 rcx, rbx
  0014f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00154	8b 3b		 mov	 edi, DWORD PTR [rbx]
$LN17@PathArcToN:
  00156	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1161 :     for (int i = 0; i <= num_segments; i++)

  0015a	ff c5		 inc	 ebp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0015c	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]
  00161	48 63 d7	 movsxd	 rdx, edi
  00164	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00168	ff 03		 inc	 DWORD PTR [rbx]
  0016a	8b 3b		 mov	 edi, DWORD PTR [rbx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1161 :     for (int i = 0; i <= num_segments; i++)

  0016c	41 3b ee	 cmp	 ebp, r14d
  0016f	0f 8e 6b ff ff
	ff		 jle	 $LL4@PathArcToN
  00175	44 0f 28 54 24
	30		 movaps	 xmm10, XMMWORD PTR [rsp+48]
  0017b	44 0f 28 44 24
	50		 movaps	 xmm8, XMMWORD PTR [rsp+80]
  00181	0f 28 74 24 70	 movaps	 xmm6, XMMWORD PTR [rsp+112]
  00186	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+168]
$LN28@PathArcToN:
  0018e	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+160]
  00196	4c 8b b4 24 b0
	00 00 00	 mov	 r14, QWORD PTR [rsp+176]
$LN3@PathArcToN:

; 1165 :     }
; 1166 : }

  0019e	0f 28 7c 24 60	 movaps	 xmm7, XMMWORD PTR [rsp+96]
  001a3	44 0f 28 4c 24
	40		 movaps	 xmm9, XMMWORD PTR [rsp+64]
  001a9	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  001b0	41 5f		 pop	 r15
  001b2	5e		 pop	 rsi
  001b3	5b		 pop	 rbx
  001b4	c3		 ret	 0
?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z ENDP	; ImDrawList::_PathArcToN
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
flags$ = 48
?FixRectCornerFlags@@YAHH@Z PROC			; FixRectCornerFlags

; 1324 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 1325 : #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
; 1326 :     // Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
; 1327 :     //   ~0   --> ImDrawFlags_RoundCornersAll or 0
; 1328 :     if (flags == ~0)

  00008	83 f9 ff	 cmp	 ecx, -1
  0000b	75 0b		 jne	 SHORT $LN2@FixRectCor

; 1329 :         return ImDrawFlags_RoundCornersAll;

  0000d	b8 f0 00 00 00	 mov	 eax, 240		; 000000f0H

; 1354 : }

  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5b		 pop	 rbx
  00017	c3		 ret	 0
$LN2@FixRectCor:

; 1330 : 
; 1331 :     // Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations)
; 1332 :     //   0x01 --> ImDrawFlags_RoundCornersTopLeft (VALUE 0x01 OVERLAPS ImDrawFlags_Closed but ImDrawFlags_Closed is never valid in this path!)
; 1333 :     //   0x02 --> ImDrawFlags_RoundCornersTopRight
; 1334 :     //   0x03 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight
; 1335 :     //   0x04 --> ImDrawFlags_RoundCornersBotLeft
; 1336 :     //   0x05 --> ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersBotLeft
; 1337 :     //   ...
; 1338 :     //   0x0F --> ImDrawFlags_RoundCornersAll or 0
; 1339 :     // (See all values in ImDrawCornerFlags_)
; 1340 :     if (flags >= 0x01 && flags <= 0x0F)

  00018	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  0001b	83 f8 0e	 cmp	 eax, 14
  0001e	77 0b		 ja	 SHORT $LN3@FixRectCor

; 1341 :         return (flags << 4);

  00020	c1 e3 04	 shl	 ebx, 4
  00023	8b c3		 mov	 eax, ebx

; 1354 : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
$LN3@FixRectCor:

; 1342 : 
; 1343 :     // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
; 1344 : #endif
; 1345 : 
; 1346 :     // If this triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
; 1347 :     // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc...
; 1348 :     IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");

  0002b	f6 c3 0f	 test	 bl, 15
  0002e	74 1a		 je	 SHORT $LN7@FixRectCor
  00030	41 b8 44 05 00
	00		 mov	 r8d, 1348		; 00000544H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JM@GAJOFMMN@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AA0?$AAF?$AA?$CJ?$AA?5@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN7@FixRectCor:

; 1349 : 
; 1350 :     if ((flags & ImDrawFlags_RoundCornersMask_) == 0)
; 1351 :         flags |= ImDrawFlags_RoundCornersAll;
; 1352 : 
; 1353 :     return flags;

  0004a	8b c3		 mov	 eax, ebx
  0004c	8b cb		 mov	 ecx, ebx
  0004e	0d f0 00 00 00	 or	 eax, 240		; 000000f0H
  00053	81 e1 f0 01 00
	00		 and	 ecx, 496		; 000001f0H
  00059	0f 45 c3	 cmovne	 eax, ebx

; 1354 : }

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
?FixRectCornerFlags@@YAHH@Z ENDP			; FixRectCornerFlags
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 144
$T1 = 152
$T2 = 152
$T3 = 152
$T4 = 152
$T5 = 152
$T6 = 152
a$ = 152
b$ = 160
rounding$ = 168
flags$ = 176
?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z PROC	; ImDrawList::PathRect

; 1357 : {

$LN129:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00013	8b 9c 24 b0 00
	00 00		 mov	 ebx, DWORD PTR flags$[rsp]
  0001a	4d 8b f0	 mov	 r14, r8
  0001d	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  00022	0f 28 f3	 movaps	 xmm6, xmm3
  00025	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  0002a	4c 8b fa	 mov	 r15, rdx

; 1328 :     if (flags == ~0)

  0002d	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f800000

; 1357 : {

  00035	48 8b f1	 mov	 rsi, rcx
  00038	44 0f 29 44 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm8
  0003e	8b fb		 mov	 edi, ebx

; 1328 :     if (flags == ~0)

  00040	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@3f000000
  00049	83 fb ff	 cmp	 ebx, -1
  0004c	0f 85 a2 00 00
	00		 jne	 $LN19@PathRect

; 1329 :         return ImDrawFlags_RoundCornersAll;

  00052	bb f0 00 00 00	 mov	 ebx, 240		; 000000f0H
$LN6@PathRect:

; 1359 :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);

  00057	41 0f 28 c8	 movaps	 xmm1, xmm8
$LN7@PathRect:
  0005b	f3 41 0f 10 1f	 movss	 xmm3, DWORD PTR [r15]
  00060	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

  00065	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1359 :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);

  0006d	f3 0f 5c c3	 subss	 xmm0, xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

  00071	0f 54 c2	 andps	 xmm0, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1359 :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);

  00074	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00078	f3 0f 5c c7	 subss	 xmm0, xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 424  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

  0007c	0f 2f c6	 comiss	 xmm0, xmm6
  0007f	77 03		 ja	 SHORT $LN30@PathRect
  00081	0f 28 f0	 movaps	 xmm6, xmm0
$LN30@PathRect:
  00084	8b c3		 mov	 eax, ebx
  00086	25 a0 00 00 00	 and	 eax, 160		; 000000a0H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1360 :     rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);

  0008b	3c a0		 cmp	 al, 160			; 000000a0H
  0008d	8b c3		 mov	 eax, ebx
  0008f	0f 95 c1	 setne	 cl
  00092	83 e0 50	 and	 eax, 80			; 00000050H
  00095	3c 50		 cmp	 al, 80			; 00000050H
  00097	0f 95 c0	 setne	 al
  0009a	84 c8		 test	 cl, al
  0009c	74 04		 je	 SHORT $LN8@PathRect
  0009e	44 0f 28 c7	 movaps	 xmm8, xmm7
$LN8@PathRect:
  000a2	f3 41 0f 10 4f
	04		 movss	 xmm1, DWORD PTR [r15+4]
  000a8	f3 41 0f 10 46
	04		 movss	 xmm0, DWORD PTR [r14+4]
  000ae	f3 0f 5c c1	 subss	 xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\ucrt\corecrt_math.h

; 676  :             return (float)fabs(_X);

  000b2	0f 54 c2	 andps	 xmm0, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1360 :     rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_RoundCornersLeft) == ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_RoundCornersRight) == ImDrawFlags_RoundCornersRight) ? 0.5f : 1.0f) - 1.0f);

  000b5	f3 41 0f 59 c0	 mulss	 xmm0, xmm8
  000ba	f3 0f 5c c7	 subss	 xmm0, xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 424  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

  000be	0f 2f c6	 comiss	 xmm0, xmm6
  000c1	77 03		 ja	 SHORT $LN36@PathRect
  000c3	0f 28 f0	 movaps	 xmm6, xmm0
$LN36@PathRect:
  000c6	0f 57 ff	 xorps	 xmm7, xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1362 :     if (rounding <= 0.0f || (flags & ImDrawFlags_RoundCornersMask_) == ImDrawFlags_RoundCornersNone)

  000c9	0f 2f fe	 comiss	 xmm7, xmm6
  000cc	0f 83 fe 02 00
	00		 jae	 $LN126@PathRect
  000d2	8b c3		 mov	 eax, ebx
  000d4	25 f0 01 00 00	 and	 eax, 496		; 000001f0H
  000d9	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  000de	0f 84 ec 02 00
	00		 je	 $LN126@PathRect

; 1363 :     {
; 1364 :         PathLineTo(a);
; 1365 :         PathLineTo(ImVec2(b.x, a.y));
; 1366 :         PathLineTo(b);
; 1367 :         PathLineTo(ImVec2(a.x, b.y));
; 1368 :     }
; 1369 :     else
; 1370 :     {
; 1371 :         const float rounding_tl = (flags & ImDrawFlags_RoundCornersTopLeft) ? rounding : 0.0f;

  000e4	44 0f 29 4c 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm9
  000ea	f6 c3 10	 test	 bl, 16
  000ed	74 69		 je	 SHORT $LN10@PathRect
  000ef	0f 28 d6	 movaps	 xmm2, xmm6
  000f2	eb 67		 jmp	 SHORT $LN11@PathRect
$LN19@PathRect:

; 1340 :     if (flags >= 0x01 && flags <= 0x0F)

  000f4	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]
  000f7	83 f8 0e	 cmp	 eax, 14
  000fa	77 05		 ja	 SHORT $LN20@PathRect

; 1341 :         return (flags << 4);

  000fc	c1 e3 04	 shl	 ebx, 4
  000ff	eb 31		 jmp	 SHORT $LN18@PathRect
$LN20@PathRect:

; 1342 : 
; 1343 :     // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
; 1344 : #endif
; 1345 : 
; 1346 :     // If this triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
; 1347 :     // Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc...
; 1348 :     IM_ASSERT((flags & 0x0F) == 0 && "Misuse of legacy hardcoded ImDrawCornerFlags values!");

  00101	f6 c3 0f	 test	 bl, 15
  00104	74 1a		 je	 SHORT $LN24@PathRect
  00106	41 b8 44 05 00
	00		 mov	 r8d, 1348		; 00000544H
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JM@GAJOFMMN@?$AA?$CI?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AA0?$AAF?$AA?$CJ?$AA?5@
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN24@PathRect:

; 1349 : 
; 1350 :     if ((flags & ImDrawFlags_RoundCornersMask_) == 0)

  00120	8b cb		 mov	 ecx, ebx

; 1351 :         flags |= ImDrawFlags_RoundCornersAll;
; 1352 : 
; 1353 :     return flags;

  00122	bb f0 00 00 00	 mov	 ebx, 240		; 000000f0H
  00127	0b df		 or	 ebx, edi
  00129	81 e1 f0 01 00
	00		 and	 ecx, 496		; 000001f0H
  0012f	0f 45 df	 cmovne	 ebx, edi
$LN18@PathRect:
  00132	8b c3		 mov	 eax, ebx
  00134	25 c0 00 00 00	 and	 eax, 192		; 000000c0H

; 1359 :     rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_RoundCornersTop) == ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_RoundCornersBottom) == ImDrawFlags_RoundCornersBottom) ? 0.5f : 1.0f) - 1.0f);

  00139	3c c0		 cmp	 al, 192			; 000000c0H
  0013b	8b c3		 mov	 eax, ebx
  0013d	0f 95 c1	 setne	 cl
  00140	83 e0 30	 and	 eax, 48			; 00000030H
  00143	3c 30		 cmp	 al, 48			; 00000030H
  00145	0f 95 c0	 setne	 al
  00148	84 c8		 test	 cl, al
  0014a	0f 84 07 ff ff
	ff		 je	 $LN6@PathRect
  00150	0f 28 cf	 movaps	 xmm1, xmm7
  00153	e9 03 ff ff ff	 jmp	 $LN7@PathRect
$LN10@PathRect:
  00158	0f 57 d2	 xorps	 xmm2, xmm2
$LN11@PathRect:

; 1372 :         const float rounding_tr = (flags & ImDrawFlags_RoundCornersTopRight) ? rounding : 0.0f;

  0015b	f6 c3 20	 test	 bl, 32			; 00000020H
  0015e	74 06		 je	 SHORT $LN12@PathRect
  00160	44 0f 28 c6	 movaps	 xmm8, xmm6
  00164	eb 04		 jmp	 SHORT $LN13@PathRect
$LN12@PathRect:
  00166	45 0f 57 c0	 xorps	 xmm8, xmm8
$LN13@PathRect:

; 1373 :         const float rounding_br = (flags & ImDrawFlags_RoundCornersBottomRight) ? rounding : 0.0f;

  0016a	84 db		 test	 bl, bl
  0016c	79 06		 jns	 SHORT $LN14@PathRect
  0016e	44 0f 28 ce	 movaps	 xmm9, xmm6
  00172	eb 04		 jmp	 SHORT $LN15@PathRect
$LN14@PathRect:
  00174	45 0f 57 c9	 xorps	 xmm9, xmm9
$LN15@PathRect:

; 1374 :         const float rounding_bl = (flags & ImDrawFlags_RoundCornersBottomLeft) ? rounding : 0.0f;

  00178	f6 c3 40	 test	 bl, 64			; 00000040H
  0017b	75 03		 jne	 SHORT $LN17@PathRect
  0017d	0f 57 f6	 xorps	 xmm6, xmm6
$LN17@PathRect:

; 1171 :     if (radius <= 0.0f)

  00180	0f 2f fa	 comiss	 xmm7, xmm2
  00183	bf 08 00 00 00	 mov	 edi, 8

; 1375 :         PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);

  00188	f3 0f 58 da	 addss	 xmm3, xmm2
  0018c	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00190	f3 0f 11 9c 24
	98 00 00 00	 movss	 DWORD PTR $T4[rsp], xmm3
  00199	f3 0f 11 8c 24
	9c 00 00 00	 movss	 DWORD PTR $T4[rsp+4], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1171 :     if (radius <= 0.0f)

  001a2	72 50		 jb	 SHORT $LN80@PathRect
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  001a4	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  001a7	8b 4e 7c	 mov	 ecx, DWORD PTR [rsi+124]
  001aa	3b c1		 cmp	 eax, ecx
  001ac	75 2b		 jne	 SHORT $LN83@PathRect
  001ae	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  001b2	85 c9		 test	 ecx, ecx
  001b4	74 0b		 je	 SHORT $LN87@PathRect
  001b6	8b c1		 mov	 eax, ecx
  001b8	99		 cdq
  001b9	2b c2		 sub	 eax, edx
  001bb	d1 f8		 sar	 eax, 1
  001bd	03 c1		 add	 eax, ecx
  001bf	eb 02		 jmp	 SHORT $LN88@PathRect
$LN87@PathRect:
  001c1	8b c7		 mov	 eax, edi
$LN88@PathRect:
  001c3	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  001c6	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  001ca	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  001ce	41 8b d0	 mov	 edx, r8d
  001d1	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  001d6	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN83@PathRect:
  001d9	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  001e0	48 63 d0	 movsxd	 rdx, eax
  001e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T4[rsp]
  001eb	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  001ef	ff 46 78	 inc	 DWORD PTR [rsi+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1174 :         return;

  001f2	eb 1e		 jmp	 SHORT $LN79@PathRect
$LN80@PathRect:

; 1175 :     }
; 1176 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

  001f4	41 b9 18 00 00
	00		 mov	 r9d, 24
  001fa	c7 44 24 20 24
	00 00 00	 mov	 DWORD PTR [rsp+32], 36	; 00000024H
  00202	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR $T4[rsp]
  0020a	48 8b ce	 mov	 rcx, rsi
  0020d	e8 00 00 00 00	 call	 ?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN79@PathRect:

; 1171 :     if (radius <= 0.0f)

  00212	41 0f 2f f8	 comiss	 xmm7, xmm8

; 1376 :         PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);

  00216	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  0021b	41 0f 28 c8	 movaps	 xmm1, xmm8
  0021f	f3 41 0f 58 4f
	04		 addss	 xmm1, DWORD PTR [r15+4]
  00225	f3 41 0f 5c c0	 subss	 xmm0, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0022a	f3 0f 11 8c 24
	9c 00 00 00	 movss	 DWORD PTR $T3[rsp+4], xmm1
  00233	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR $T3[rsp], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1171 :     if (radius <= 0.0f)

  0023c	72 50		 jb	 SHORT $LN92@PathRect
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0023e	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  00241	8b 4e 7c	 mov	 ecx, DWORD PTR [rsi+124]
  00244	3b c1		 cmp	 eax, ecx
  00246	75 2b		 jne	 SHORT $LN95@PathRect
  00248	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0024c	85 c9		 test	 ecx, ecx
  0024e	74 0b		 je	 SHORT $LN99@PathRect
  00250	8b c1		 mov	 eax, ecx
  00252	99		 cdq
  00253	2b c2		 sub	 eax, edx
  00255	d1 f8		 sar	 eax, 1
  00257	03 c1		 add	 eax, ecx
  00259	eb 02		 jmp	 SHORT $LN100@PathRect
$LN99@PathRect:
  0025b	8b c7		 mov	 eax, edi
$LN100@PathRect:
  0025d	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00260	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00264	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00268	41 8b d0	 mov	 edx, r8d
  0026b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00270	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN95@PathRect:
  00273	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  0027a	48 63 d0	 movsxd	 rdx, eax
  0027d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T3[rsp]
  00285	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00289	ff 46 78	 inc	 DWORD PTR [rsi+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1174 :         return;

  0028c	eb 22		 jmp	 SHORT $LN91@PathRect
$LN92@PathRect:

; 1175 :     }
; 1176 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

  0028e	41 b9 24 00 00
	00		 mov	 r9d, 36			; 00000024H
  00294	c7 44 24 20 30
	00 00 00	 mov	 DWORD PTR [rsp+32], 48	; 00000030H
  0029c	41 0f 28 d0	 movaps	 xmm2, xmm8
  002a0	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR $T3[rsp]
  002a8	48 8b ce	 mov	 rcx, rsi
  002ab	e8 00 00 00 00	 call	 ?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN91@PathRect:

; 1171 :     if (radius <= 0.0f)

  002b0	41 0f 2f f9	 comiss	 xmm7, xmm9

; 1377 :         PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);

  002b4	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  002b9	f3 41 0f 10 4e
	04		 movss	 xmm1, DWORD PTR [r14+4]
  002bf	f3 41 0f 5c c1	 subss	 xmm0, xmm9
  002c4	f3 41 0f 5c c9	 subss	 xmm1, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  002c9	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR $T2[rsp], xmm0
  002d2	f3 0f 11 8c 24
	9c 00 00 00	 movss	 DWORD PTR $T2[rsp+4], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1171 :     if (radius <= 0.0f)

  002db	72 50		 jb	 SHORT $LN104@PathRect
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  002dd	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  002e0	8b 4e 7c	 mov	 ecx, DWORD PTR [rsi+124]
  002e3	3b c1		 cmp	 eax, ecx
  002e5	75 2b		 jne	 SHORT $LN107@PathRect
  002e7	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  002eb	85 c9		 test	 ecx, ecx
  002ed	74 0b		 je	 SHORT $LN111@PathRect
  002ef	8b c1		 mov	 eax, ecx
  002f1	99		 cdq
  002f2	2b c2		 sub	 eax, edx
  002f4	d1 f8		 sar	 eax, 1
  002f6	03 c1		 add	 eax, ecx
  002f8	eb 02		 jmp	 SHORT $LN112@PathRect
$LN111@PathRect:
  002fa	8b c7		 mov	 eax, edi
$LN112@PathRect:
  002fc	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  002ff	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00303	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00307	41 8b d0	 mov	 edx, r8d
  0030a	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  0030f	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN107@PathRect:
  00312	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00319	48 63 d0	 movsxd	 rdx, eax
  0031c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  00324	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00328	ff 46 78	 inc	 DWORD PTR [rsi+120]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1174 :         return;

  0032b	eb 1f		 jmp	 SHORT $LN103@PathRect
$LN104@PathRect:

; 1175 :     }
; 1176 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

  0032d	45 33 c9	 xor	 r9d, r9d
  00330	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR [rsp+32], 12
  00338	41 0f 28 d1	 movaps	 xmm2, xmm9
  0033c	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR $T2[rsp]
  00344	48 8b ce	 mov	 rcx, rsi
  00347	e8 00 00 00 00	 call	 ?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
$LN103@PathRect:

; 1171 :     if (radius <= 0.0f)

  0034c	0f 2f fe	 comiss	 xmm7, xmm6

; 1378 :         PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);

  0034f	f3 41 0f 10 4e
	04		 movss	 xmm1, DWORD PTR [r14+4]
  00355	0f 28 c6	 movaps	 xmm0, xmm6
  00358	f3 41 0f 58 07	 addss	 xmm0, DWORD PTR [r15]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0035d	44 0f 28 4c 24
	30		 movaps	 xmm9, XMMWORD PTR [rsp+48]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1378 :         PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);

  00363	f3 0f 5c ce	 subss	 xmm1, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00367	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR $T1[rsp], xmm0
  00370	f3 0f 11 8c 24
	9c 00 00 00	 movss	 DWORD PTR $T1[rsp+4], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1171 :     if (radius <= 0.0f)

  00379	72 2f		 jb	 SHORT $LN116@PathRect
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0037b	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  0037e	8b 4e 7c	 mov	 ecx, DWORD PTR [rsi+124]
  00381	3b c1		 cmp	 eax, ecx
  00383	0f 85 9a 01 00
	00		 jne	 $LN71@PathRect
  00389	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0038d	85 c9		 test	 ecx, ecx
  0038f	74 0a		 je	 SHORT $LN123@PathRect
  00391	8b c1		 mov	 eax, ecx
  00393	99		 cdq
  00394	2b c2		 sub	 eax, edx
  00396	d1 f8		 sar	 eax, 1
  00398	8d 3c 01	 lea	 edi, DWORD PTR [rcx+rax]
$LN123@PathRect:
  0039b	41 3b f8	 cmp	 edi, r8d
  0039e	44 0f 4f c7	 cmovg	 r8d, edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  003a2	41 8b d0	 mov	 edx, r8d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1174 :         return;

  003a5	e9 6d 01 00 00	 jmp	 $LN127@PathRect
$LN116@PathRect:

; 1175 :     }
; 1176 :     _PathArcToFastEx(center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0);

  003aa	41 b9 0c 00 00
	00		 mov	 r9d, 12
  003b0	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR [rsp+32], 24
  003b8	0f 28 d6	 movaps	 xmm2, xmm6
  003bb	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR $T1[rsp]
  003c3	48 8b ce	 mov	 rcx, rsi
  003c6	e8 00 00 00 00	 call	 ?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z ; ImDrawList::_PathArcToFastEx
  003cb	e9 6c 01 00 00	 jmp	 $LN115@PathRect
$LN126@PathRect:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  003d0	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  003d3	bf 08 00 00 00	 mov	 edi, 8
  003d8	8b 4e 7c	 mov	 ecx, DWORD PTR [rsi+124]
  003db	3b c1		 cmp	 eax, ecx
  003dd	75 2b		 jne	 SHORT $LN40@PathRect
  003df	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  003e3	85 c9		 test	 ecx, ecx
  003e5	74 0b		 je	 SHORT $LN44@PathRect
  003e7	8b c1		 mov	 eax, ecx
  003e9	99		 cdq
  003ea	2b c2		 sub	 eax, edx
  003ec	d1 f8		 sar	 eax, 1
  003ee	03 c1		 add	 eax, ecx
  003f0	eb 02		 jmp	 SHORT $LN45@PathRect
$LN44@PathRect:
  003f2	8b c7		 mov	 eax, edi
$LN45@PathRect:
  003f4	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  003f7	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  003fb	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  003ff	41 8b d0	 mov	 edx, r8d
  00402	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00407	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN40@PathRect:
  0040a	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00411	48 63 d0	 movsxd	 rdx, eax
  00414	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00417	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0041b	ff 46 78	 inc	 DWORD PTR [rsi+120]
  0041e	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00421	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  00426	f3 41 0f 10 4f
	04		 movss	 xmm1, DWORD PTR [r15+4]

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0042c	44 8b 46 7c	 mov	 r8d, DWORD PTR [rsi+124]

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00430	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR $T6[rsp], xmm0
  00439	f3 0f 11 8c 24
	9c 00 00 00	 movss	 DWORD PTR $T6[rsp+4], xmm1

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00442	41 3b c0	 cmp	 eax, r8d
  00445	75 2a		 jne	 SHORT $LN51@PathRect
  00447	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0044a	45 85 c0	 test	 r8d, r8d
  0044d	74 0d		 je	 SHORT $LN55@PathRect
  0044f	41 8b c0	 mov	 eax, r8d
  00452	99		 cdq
  00453	2b c2		 sub	 eax, edx
  00455	d1 f8		 sar	 eax, 1
  00457	41 03 c0	 add	 eax, r8d
  0045a	eb 02		 jmp	 SHORT $LN56@PathRect
$LN55@PathRect:
  0045c	8b c7		 mov	 eax, edi
$LN56@PathRect:
  0045e	3b c1		 cmp	 eax, ecx
  00460	0f 4f c8	 cmovg	 ecx, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00463	8b d1		 mov	 edx, ecx
  00465	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  00469	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  0046e	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN51@PathRect:
  00471	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00478	48 63 d0	 movsxd	 rdx, eax
  0047b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]
  00483	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00487	ff 46 78	 inc	 DWORD PTR [rsi+120]
  0048a	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  0048d	8b 4e 7c	 mov	 ecx, DWORD PTR [rsi+124]
  00490	3b c1		 cmp	 eax, ecx
  00492	75 2b		 jne	 SHORT $LN60@PathRect
  00494	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00498	85 c9		 test	 ecx, ecx
  0049a	74 0b		 je	 SHORT $LN64@PathRect
  0049c	8b c1		 mov	 eax, ecx
  0049e	99		 cdq
  0049f	2b c2		 sub	 eax, edx
  004a1	d1 f8		 sar	 eax, 1
  004a3	03 c1		 add	 eax, ecx
  004a5	eb 02		 jmp	 SHORT $LN65@PathRect
$LN64@PathRect:
  004a7	8b c7		 mov	 eax, edi
$LN65@PathRect:
  004a9	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  004ac	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  004b0	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  004b4	41 8b d0	 mov	 edx, r8d
  004b7	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  004bc	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN60@PathRect:
  004bf	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  004c6	48 63 d0	 movsxd	 rdx, eax
  004c9	49 8b 06	 mov	 rax, QWORD PTR [r14]
  004cc	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  004d0	ff 46 78	 inc	 DWORD PTR [rsi+120]
  004d3	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  004d6	f3 41 0f 10 07	 movss	 xmm0, DWORD PTR [r15]
  004db	f3 41 0f 10 4e
	04		 movss	 xmm1, DWORD PTR [r14+4]

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  004e1	44 8b 46 7c	 mov	 r8d, DWORD PTR [rsi+124]

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  004e5	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR $T5[rsp], xmm0
  004ee	f3 0f 11 8c 24
	9c 00 00 00	 movss	 DWORD PTR $T5[rsp+4], xmm1

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  004f7	41 3b c0	 cmp	 eax, r8d
  004fa	75 27		 jne	 SHORT $LN71@PathRect
  004fc	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  004ff	45 85 c0	 test	 r8d, r8d
  00502	74 0c		 je	 SHORT $LN75@PathRect
  00504	41 8b c0	 mov	 eax, r8d
  00507	99		 cdq
  00508	2b c2		 sub	 eax, edx
  0050a	d1 f8		 sar	 eax, 1
  0050c	41 8d 3c 00	 lea	 edi, DWORD PTR [r8+rax]
$LN75@PathRect:
  00510	3b f9		 cmp	 edi, ecx
  00512	0f 4f cf	 cmovg	 ecx, edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00515	8b d1		 mov	 edx, ecx
$LN127@PathRect:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1380 : }

  00517	48 8d 4e 78	 lea	 rcx, QWORD PTR [rsi+120]
  0051b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00520	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
$LN71@PathRect:
  00523	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  0052a	48 63 d0	 movsxd	 rdx, eax
  0052d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]
  00535	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00539	ff 46 78	 inc	 DWORD PTR [rsi+120]
$LN115@PathRect:
  0053c	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  00541	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00546	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0054a	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  0054e	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  00553	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  00558	49 8b e3	 mov	 rsp, r11
  0055b	41 5f		 pop	 r15
  0055d	41 5e		 pop	 r14
  0055f	5f		 pop	 rdi
  00560	c3		 ret	 0
?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z ENDP	; ImDrawList::PathRect
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 80
p1$ = 88
p2$ = 96
p3$ = 104
p4$ = 112
col$ = 120
thickness$ = 128
?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z PROC	; ImDrawList::AddQuad

; 1437 : {

$LN43:
  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 56		 push	 r14
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1438 :     if ((col & IM_COL32_A_MASK) == 0)

  0000e	f7 44 24 78 00
	00 00 ff	 test	 DWORD PTR col$[rsp], -16777216 ; ff000000H
  00016	4d 8b e1	 mov	 r12, r9
  00019	4d 8b f0	 mov	 r14, r8
  0001c	48 8b f2	 mov	 rsi, rdx
  0001f	48 8b e9	 mov	 rbp, rcx
  00022	0f 84 78 01 00
	00		 je	 $LN1@AddQuad
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00028	8b 41 78	 mov	 eax, DWORD PTR [rcx+120]
  0002b	44 8b 49 7c	 mov	 r9d, DWORD PTR [rcx+124]

; 2567 :     inline    void  PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }

  0002f	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00034	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00039	bf 08 00 00 00	 mov	 edi, 8
  0003e	41 3b c1	 cmp	 eax, r9d
  00041	75 2a		 jne	 SHORT $LN7@AddQuad
  00043	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00046	45 85 c9	 test	 r9d, r9d
  00049	74 0d		 je	 SHORT $LN11@AddQuad
  0004b	41 8b c1	 mov	 eax, r9d
  0004e	99		 cdq
  0004f	2b c2		 sub	 eax, edx
  00051	d1 f8		 sar	 eax, 1
  00053	41 03 c1	 add	 eax, r9d
  00056	eb 02		 jmp	 SHORT $LN12@AddQuad
$LN11@AddQuad:
  00058	8b c7		 mov	 eax, edi
$LN12@AddQuad:
  0005a	3b c1		 cmp	 eax, ecx
  0005c	0f 4f c8	 cmovg	 ecx, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0005f	8b d1		 mov	 edx, ecx
  00061	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]
  00065	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  0006a	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN7@AddQuad:
  0006d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  00074	48 63 d0	 movsxd	 rdx, eax
  00077	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0007a	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0007e	ff 45 78	 inc	 DWORD PTR [rbp+120]
  00081	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  00084	8b 4d 7c	 mov	 ecx, DWORD PTR [rbp+124]
  00087	3b c1		 cmp	 eax, ecx
  00089	75 2b		 jne	 SHORT $LN16@AddQuad
  0008b	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0008f	85 c9		 test	 ecx, ecx
  00091	74 0b		 je	 SHORT $LN20@AddQuad
  00093	8b c1		 mov	 eax, ecx
  00095	99		 cdq
  00096	2b c2		 sub	 eax, edx
  00098	d1 f8		 sar	 eax, 1
  0009a	03 c1		 add	 eax, ecx
  0009c	eb 02		 jmp	 SHORT $LN21@AddQuad
$LN20@AddQuad:
  0009e	8b c7		 mov	 eax, edi
$LN21@AddQuad:
  000a0	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000a3	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000a7	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000ab	41 8b d0	 mov	 edx, r8d
  000ae	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  000b3	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN16@AddQuad:
  000b6	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  000bd	48 63 d0	 movsxd	 rdx, eax
  000c0	49 8b 06	 mov	 rax, QWORD PTR [r14]
  000c3	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  000c7	ff 45 78	 inc	 DWORD PTR [rbp+120]
  000ca	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  000cd	8b 4d 7c	 mov	 ecx, DWORD PTR [rbp+124]
  000d0	3b c1		 cmp	 eax, ecx
  000d2	75 2b		 jne	 SHORT $LN25@AddQuad
  000d4	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000d8	85 c9		 test	 ecx, ecx
  000da	74 0b		 je	 SHORT $LN29@AddQuad
  000dc	8b c1		 mov	 eax, ecx
  000de	99		 cdq
  000df	2b c2		 sub	 eax, edx
  000e1	d1 f8		 sar	 eax, 1
  000e3	03 c1		 add	 eax, ecx
  000e5	eb 02		 jmp	 SHORT $LN30@AddQuad
$LN29@AddQuad:
  000e7	8b c7		 mov	 eax, edi
$LN30@AddQuad:
  000e9	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000ec	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000f0	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000f4	41 8b d0	 mov	 edx, r8d
  000f7	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  000fc	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN25@AddQuad:
  000ff	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  00106	48 63 d0	 movsxd	 rdx, eax
  00109	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0010d	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00111	ff 45 78	 inc	 DWORD PTR [rbp+120]
  00114	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  00117	44 8b 45 7c	 mov	 r8d, DWORD PTR [rbp+124]
  0011b	41 3b c0	 cmp	 eax, r8d
  0011e	75 27		 jne	 SHORT $LN34@AddQuad
  00120	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00123	45 85 c0	 test	 r8d, r8d
  00126	74 0c		 je	 SHORT $LN38@AddQuad
  00128	41 8b c0	 mov	 eax, r8d
  0012b	99		 cdq
  0012c	2b c2		 sub	 eax, edx
  0012e	d1 f8		 sar	 eax, 1
  00130	41 8d 3c 00	 lea	 edi, DWORD PTR [r8+rax]
$LN38@AddQuad:
  00134	3b f9		 cmp	 edi, ecx
  00136	0f 4f cf	 cmovg	 ecx, edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00139	8b d1		 mov	 edx, ecx
  0013b	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]
  0013f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00144	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN34@AddQuad:
  00147	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR [rbp+128]

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  0014e	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR thickness$[rsp]
  00157	44 8b 4c 24 78	 mov	 r9d, DWORD PTR col$[rsp]

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0015c	4c 63 c0	 movsxd	 r8, eax
  0015f	48 8b 44 24 70	 mov	 rax, QWORD PTR p4$[rsp]

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  00164	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0016a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00172	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00175	4a 89 0c c2	 mov	 QWORD PTR [rdx+r8*8], rcx

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  00179	48 8b cd	 mov	 rcx, rbp

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0017c	ff 45 78	 inc	 DWORD PTR [rbp+120]

; 2570 :     inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }

  0017f	44 8b 45 78	 mov	 r8d, DWORD PTR [rbp+120]
  00183	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR [rbp+128]
  0018a	e8 00 00 00 00	 call	 ?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z ; ImDrawList::AddPolyline
  0018f	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00194	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00199	c7 45 78 00 00
	00 00		 mov	 DWORD PTR [rbp+120], 0
$LN1@AddQuad:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1446 : }

  001a0	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  001a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a9	41 5e		 pop	 r14
  001ab	41 5c		 pop	 r12
  001ad	5e		 pop	 rsi
  001ae	c3		 ret	 0
?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z ENDP	; ImDrawList::AddQuad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
p1$ = 72
p2$ = 80
p3$ = 88
p4$ = 96
col$ = 104
?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z PROC	; ImDrawList::AddQuadFilled

; 1449 : {

$LN43:
  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 56		 push	 r14
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1450 :     if ((col & IM_COL32_A_MASK) == 0)

  0000e	f7 44 24 68 00
	00 00 ff	 test	 DWORD PTR col$[rsp], -16777216 ; ff000000H
  00016	4d 8b e1	 mov	 r12, r9
  00019	4d 8b f0	 mov	 r14, r8
  0001c	48 8b f2	 mov	 rsi, rdx
  0001f	48 8b e9	 mov	 rbp, rcx
  00022	0f 84 61 01 00
	00		 je	 $LN1@AddQuadFil
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00028	8b 41 78	 mov	 eax, DWORD PTR [rcx+120]
  0002b	44 8b 49 7c	 mov	 r9d, DWORD PTR [rcx+124]

; 2567 :     inline    void  PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }

  0002f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00034	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00039	bf 08 00 00 00	 mov	 edi, 8
  0003e	41 3b c1	 cmp	 eax, r9d
  00041	75 2a		 jne	 SHORT $LN7@AddQuadFil
  00043	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00046	45 85 c9	 test	 r9d, r9d
  00049	74 0d		 je	 SHORT $LN11@AddQuadFil
  0004b	41 8b c1	 mov	 eax, r9d
  0004e	99		 cdq
  0004f	2b c2		 sub	 eax, edx
  00051	d1 f8		 sar	 eax, 1
  00053	41 03 c1	 add	 eax, r9d
  00056	eb 02		 jmp	 SHORT $LN12@AddQuadFil
$LN11@AddQuadFil:
  00058	8b c7		 mov	 eax, edi
$LN12@AddQuadFil:
  0005a	3b c1		 cmp	 eax, ecx
  0005c	0f 4f c8	 cmovg	 ecx, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0005f	8b d1		 mov	 edx, ecx
  00061	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]
  00065	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  0006a	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN7@AddQuadFil:
  0006d	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  00074	48 63 d0	 movsxd	 rdx, eax
  00077	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0007a	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0007e	ff 45 78	 inc	 DWORD PTR [rbp+120]
  00081	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  00084	8b 4d 7c	 mov	 ecx, DWORD PTR [rbp+124]
  00087	3b c1		 cmp	 eax, ecx
  00089	75 2b		 jne	 SHORT $LN16@AddQuadFil
  0008b	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0008f	85 c9		 test	 ecx, ecx
  00091	74 0b		 je	 SHORT $LN20@AddQuadFil
  00093	8b c1		 mov	 eax, ecx
  00095	99		 cdq
  00096	2b c2		 sub	 eax, edx
  00098	d1 f8		 sar	 eax, 1
  0009a	03 c1		 add	 eax, ecx
  0009c	eb 02		 jmp	 SHORT $LN21@AddQuadFil
$LN20@AddQuadFil:
  0009e	8b c7		 mov	 eax, edi
$LN21@AddQuadFil:
  000a0	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000a3	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000a7	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000ab	41 8b d0	 mov	 edx, r8d
  000ae	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  000b3	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN16@AddQuadFil:
  000b6	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  000bd	48 63 d0	 movsxd	 rdx, eax
  000c0	49 8b 06	 mov	 rax, QWORD PTR [r14]
  000c3	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  000c7	ff 45 78	 inc	 DWORD PTR [rbp+120]
  000ca	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  000cd	8b 4d 7c	 mov	 ecx, DWORD PTR [rbp+124]
  000d0	3b c1		 cmp	 eax, ecx
  000d2	75 2b		 jne	 SHORT $LN25@AddQuadFil
  000d4	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000d8	85 c9		 test	 ecx, ecx
  000da	74 0b		 je	 SHORT $LN29@AddQuadFil
  000dc	8b c1		 mov	 eax, ecx
  000de	99		 cdq
  000df	2b c2		 sub	 eax, edx
  000e1	d1 f8		 sar	 eax, 1
  000e3	03 c1		 add	 eax, ecx
  000e5	eb 02		 jmp	 SHORT $LN30@AddQuadFil
$LN29@AddQuadFil:
  000e7	8b c7		 mov	 eax, edi
$LN30@AddQuadFil:
  000e9	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000ec	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000f0	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000f4	41 8b d0	 mov	 edx, r8d
  000f7	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  000fc	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN25@AddQuadFil:
  000ff	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  00106	48 63 d0	 movsxd	 rdx, eax
  00109	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0010d	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00111	ff 45 78	 inc	 DWORD PTR [rbp+120]
  00114	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
  00117	44 8b 45 7c	 mov	 r8d, DWORD PTR [rbp+124]
  0011b	41 3b c0	 cmp	 eax, r8d
  0011e	75 27		 jne	 SHORT $LN34@AddQuadFil
  00120	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00123	45 85 c0	 test	 r8d, r8d
  00126	74 0c		 je	 SHORT $LN38@AddQuadFil
  00128	41 8b c0	 mov	 eax, r8d
  0012b	99		 cdq
  0012c	2b c2		 sub	 eax, edx
  0012e	d1 f8		 sar	 eax, 1
  00130	41 8d 3c 00	 lea	 edi, DWORD PTR [r8+rax]
$LN38@AddQuadFil:
  00134	3b f9		 cmp	 edi, ecx
  00136	0f 4f cf	 cmovg	 ecx, edi

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00139	8b d1		 mov	 edx, ecx
  0013b	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]
  0013f	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec2@@@@QEAAXH@Z ; ImVector<ImVec2>::reserve
  00144	8b 45 78	 mov	 eax, DWORD PTR [rbp+120]
$LN34@AddQuadFil:
  00147	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR [rbp+128]

; 2569 :     inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  0014e	44 8b 4c 24 68	 mov	 r9d, DWORD PTR col$[rsp]

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00153	4c 63 c0	 movsxd	 r8, eax
  00156	48 8b 44 24 60	 mov	 rax, QWORD PTR p4$[rsp]
  0015b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0015e	4a 89 0c c2	 mov	 QWORD PTR [rdx+r8*8], rcx

; 2569 :     inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  00162	48 8b cd	 mov	 rcx, rbp

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00165	ff 45 78	 inc	 DWORD PTR [rbp+120]

; 2569 :     inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  // Note: Anti-aliased filling requires points to be in clockwise order.

  00168	44 8b 45 78	 mov	 r8d, DWORD PTR [rbp+120]
  0016c	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR [rbp+128]
  00173	e8 00 00 00 00	 call	 ?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z ; ImDrawList::AddConvexPolyFilled
  00178	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0017d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00182	c7 45 78 00 00
	00 00		 mov	 DWORD PTR [rbp+120], 0
$LN1@AddQuadFil:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1458 : }

  00189	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0018e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00192	41 5e		 pop	 r14
  00194	41 5c		 pop	 r12
  00196	5e		 pop	 rsi
  00197	c3		 ret	 0
?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ENDP	; ImDrawList::AddQuadFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 80
user_texture_id$ = 88
p_min$ = 96
p_max$ = 104
uv_min$ = 112
uv_max$ = 120
col$ = 128
?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z PROC	; ImDrawList::AddImage

; 1611 : {

$LN7:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1612 :     if ((col & IM_COL32_A_MASK) == 0)

  00013	8b ac 24 80 00
	00 00		 mov	 ebp, DWORD PTR col$[rsp]
  0001a	4d 8b f1	 mov	 r14, r9
  0001d	4d 8b f8	 mov	 r15, r8
  00020	48 8b fa	 mov	 rdi, rdx
  00023	48 8b d9	 mov	 rbx, rcx
  00026	f7 c5 00 00 00
	ff		 test	 ebp, -16777216		; ff000000H
  0002c	74 5a		 je	 SHORT $LN4@AddImage

; 1613 :         return;
; 1614 : 
; 1615 :     const bool push_texture_id = user_texture_id != _CmdHeader.TextureId;

  0002e	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00033	48 8b b1 98 00
	00 00		 mov	 rsi, QWORD PTR [rcx+152]

; 1616 :     if (push_texture_id)

  0003a	48 3b d6	 cmp	 rdx, rsi
  0003d	74 05		 je	 SHORT $LN3@AddImage

; 1617 :         PushTextureID(user_texture_id);

  0003f	e8 00 00 00 00	 call	 ?PushTextureID@ImDrawList@@QEAAXPEAX@Z ; ImDrawList::PushTextureID
$LN3@AddImage:

; 1618 : 
; 1619 :     PrimReserve(6, 4);

  00044	ba 06 00 00 00	 mov	 edx, 6
  00049	48 8b cb	 mov	 rcx, rbx
  0004c	44 8d 42 fe	 lea	 r8d, QWORD PTR [rdx-2]
  00050	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve

; 1620 :     PrimRectUV(p_min, p_max, uv_min, uv_max, col);

  00055	48 8b 44 24 78	 mov	 rax, QWORD PTR uv_max$[rsp]
  0005a	4d 8b c6	 mov	 r8, r14
  0005d	4c 8b 4c 24 70	 mov	 r9, QWORD PTR uv_min$[rsp]
  00062	49 8b d7	 mov	 rdx, r15
  00065	89 6c 24 28	 mov	 DWORD PTR [rsp+40], ebp
  00069	48 8b cb	 mov	 rcx, rbx
  0006c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00071	e8 00 00 00 00	 call	 ?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z ; ImDrawList::PrimRectUV

; 1621 : 
; 1622 :     if (push_texture_id)

  00076	48 3b fe	 cmp	 rdi, rsi
  00079	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0007e	74 08		 je	 SHORT $LN4@AddImage

; 1623 :         PopTextureID();

  00080	48 8b cb	 mov	 rcx, rbx
  00083	e8 00 00 00 00	 call	 ?PopTextureID@ImDrawList@@QEAAXXZ ; ImDrawList::PopTextureID
$LN4@AddImage:

; 1624 : }

  00088	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0008d	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	41 5f		 pop	 r15
  00098	41 5e		 pop	 r14
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z ENDP	; ImDrawList::AddImage
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv1710 = 32
tv1708 = 40
$T1 = 48
i$1$ = 144
this$ = 144
draw_list$ = 152
new_cmd_buffer_count$1$ = 160
new_idx_buffer_count$1$ = 168
?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z PROC	; ImDrawListSplitter::Merge

; 1720 : {

$LN104:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  00007	41 54		 push	 r12
  00009	41 57		 push	 r15
  0000b	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1721 :     // Note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
; 1722 :     if (_Count <= 1)

  0000f	83 79 04 01	 cmp	 DWORD PTR [rcx+4], 1
  00013	4c 8b e2	 mov	 r12, rdx
  00016	4c 8b f9	 mov	 r15, rcx
  00019	0f 8e e3 04 00
	00		 jle	 $LN1@Merge

; 1723 :         return;
; 1724 : 
; 1725 :     SetCurrentChannel(draw_list, 0);

  0001f	48 89 58 e8	 mov	 QWORD PTR [rax-24], rbx
  00023	45 33 c0	 xor	 r8d, r8d
  00026	48 89 68 e0	 mov	 QWORD PTR [rax-32], rbp
  0002a	48 89 70 d8	 mov	 QWORD PTR [rax-40], rsi
  0002e	48 89 78 d0	 mov	 QWORD PTR [rax-48], rdi
  00032	4c 89 68 c8	 mov	 QWORD PTR [rax-56], r13
  00036	4c 89 70 c0	 mov	 QWORD PTR [rax-64], r14
  0003a	e8 00 00 00 00	 call	 ?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ; ImDrawListSplitter::SetCurrentChannel

; 466  :     if (CmdBuffer.Size == 0)

  0003f	4d 63 04 24	 movsxd	 r8, DWORD PTR [r12]
  00043	41 8b c0	 mov	 eax, r8d
  00046	45 85 c0	 test	 r8d, r8d
  00049	74 41		 je	 SHORT $LN30@Merge

; 467  :         return;
; 468  :     ImDrawCmd* curr_cmd = &CmdBuffer.Data[CmdBuffer.Size - 1];

  0004b	49 6b d0 38	 imul	 rdx, r8, 56		; 00000038H
  0004f	49 03 54 24 08	 add	 rdx, QWORD PTR [r12+8]

; 469  :     if (curr_cmd->ElemCount == 0 && curr_cmd->UserCallback == NULL)

  00054	83 7a e8 00	 cmp	 DWORD PTR [rdx-24], 0
  00058	75 32		 jne	 SHORT $LN30@Merge
  0005a	48 83 7a f0 00	 cmp	 QWORD PTR [rdx-16], 0
  0005f	75 2b		 jne	 SHORT $LN30@Merge
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1815 :     inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

  00061	45 85 c0	 test	 r8d, r8d
  00064	7f 1e		 jg	 SHORT $LN34@Merge
  00066	41 b8 17 07 00
	00		 mov	 r8d, 1815		; 00000717H
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00080	45 8b 04 24	 mov	 r8d, DWORD PTR [r12]
$LN34@Merge:
  00084	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00088	41 89 04 24	 mov	 DWORD PTR [r12], eax
$LN30@Merge:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1731 :     ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;

  0008c	41 8b 4f 04	 mov	 ecx, DWORD PTR [r15+4]
  00090	33 f6		 xor	 esi, esi
  00092	33 ed		 xor	 ebp, ebp
  00094	89 b4 24 a0 00
	00 00		 mov	 DWORD PTR new_cmd_buffer_count$1$[rsp], esi
  0009b	89 ac 24 a8 00
	00 00		 mov	 DWORD PTR new_idx_buffer_count$1$[rsp], ebp
  000a2	85 c9		 test	 ecx, ecx
  000a4	7e 20		 jle	 SHORT $LN24@Merge
  000a6	85 c0		 test	 eax, eax
  000a8	7e 1c		 jle	 SHORT $LN24@Merge
  000aa	49 8b cc	 mov	 rcx, r12
  000ad	e8 00 00 00 00	 call	 ?back@?$ImVector@UImDrawCmd@@@@QEAAAEAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
  000b2	41 8b 4f 04	 mov	 ecx, DWORD PTR [r15+4]
  000b6	4c 8b f0	 mov	 r14, rax

; 1732 :     int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;

  000b9	48 85 c0	 test	 rax, rax
  000bc	74 0b		 je	 SHORT $LN97@Merge
  000be	8b 78 20	 mov	 edi, DWORD PTR [rax+32]
  000c1	03 78 1c	 add	 edi, DWORD PTR [rax+28]
  000c4	eb 05		 jmp	 SHORT $LN27@Merge
$LN24@Merge:

; 1731 :     ImDrawCmd* last_cmd = (_Count > 0 && draw_list->CmdBuffer.Size > 0) ? &draw_list->CmdBuffer.back() : NULL;

  000c6	45 33 f6	 xor	 r14d, r14d
$LN97@Merge:

; 1732 :     int idx_offset = last_cmd ? last_cmd->IdxOffset + last_cmd->ElemCount : 0;

  000c9	33 ff		 xor	 edi, edi
$LN27@Merge:

; 1733 :     for (int i = 1; i < _Count; i++)

  000cb	41 bd 01 00 00
	00		 mov	 r13d, 1
  000d1	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d6	44 89 ac 24 90
	00 00 00	 mov	 DWORD PTR i$1$[rsp], r13d
  000de	48 89 54 24 28	 mov	 QWORD PTR tv1708[rsp], rdx
  000e3	41 3b cd	 cmp	 ecx, r13d
  000e6	0f 8e 18 02 00
	00		 jle	 $LN3@Merge
  000ec	41 8b c5	 mov	 eax, r13d
  000ef	48 89 54 24 20	 mov	 QWORD PTR tv1710[rsp], rdx
  000f4	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  000f9	44 8b d2	 mov	 r10d, edx
  000fc	49 bc 25 49 92
	24 49 92 24 49	 mov	 r12, 5270498306774157605 ; 4924924924924925H
$LL4@Merge:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00106	48 85 c0	 test	 rax, rax
  00109	78 06		 js	 SHORT $LN37@Merge
  0010b	45 3b 6f 08	 cmp	 r13d, DWORD PTR [r15+8]
  0010f	7c 1f		 jl	 SHORT $LN38@Merge
$LN37@Merge:
  00111	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0012b	4c 8b 54 24 20	 mov	 r10, QWORD PTR tv1710[rsp]
$LN38@Merge:
  00130	49 8b 5f 10	 mov	 rbx, QWORD PTR [r15+16]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1736 :         if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()

  00134	4a 63 34 13	 movsxd	 rsi, DWORD PTR [rbx+r10]
  00138	85 f6		 test	 esi, esi
  0013a	7e 2a		 jle	 SHORT $LN12@Merge
  0013c	4e 8b 44 13 08	 mov	 r8, QWORD PTR [rbx+r10+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00141	48 8b ce	 mov	 rcx, rsi
  00144	48 6b c6 38	 imul	 rax, rsi, 56		; 00000038H
  00148	48 8b d6	 mov	 rdx, rsi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1736 :         if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()

  0014b	42 83 7c 00 e8
	00		 cmp	 DWORD PTR [rax+r8-24], 0
  00151	75 13		 jne	 SHORT $LN12@Merge
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00153	48 6b c2 38	 imul	 rax, rdx, 56		; 00000038H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1736 :         if (ch._CmdBuffer.Size > 0 && ch._CmdBuffer.back().ElemCount == 0 && ch._CmdBuffer.back().UserCallback == NULL) // Equivalent of PopUnusedDrawCmd()

  00157	4a 83 7c 00 f0
	00		 cmp	 QWORD PTR [rax+r8-16], 0
  0015d	75 07		 jne	 SHORT $LN12@Merge
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1815 :     inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

  0015f	8d 71 ff	 lea	 esi, DWORD PTR [rcx-1]
  00162	42 89 34 13	 mov	 DWORD PTR [rbx+r10], esi
$LN12@Merge:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1739 :         if (ch._CmdBuffer.Size > 0 && last_cmd != NULL)

  00166	8b ee		 mov	 ebp, esi
  00168	85 f6		 test	 esi, esi
  0016a	0f 8e 3e 01 00
	00		 jle	 $LN89@Merge
  00170	4d 85 f6	 test	 r14, r14
  00173	0f 84 cd 00 00
	00		 je	 $LN14@Merge

; 1740 :         {
; 1741 :             // Do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.
; 1742 :             // Manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter.
; 1743 :             ImDrawCmd* next_cmd = &ch._CmdBuffer[0];

  00179	4e 8b 6c 13 08	 mov	 r13, QWORD PTR [rbx+r10+8]

; 1744 :             if (ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL)

  0017e	41 b8 1c 00 00
	00		 mov	 r8d, 28
  00184	49 8b d5	 mov	 rdx, r13
  00187	49 8b ce	 mov	 rcx, r14
  0018a	e8 00 00 00 00	 call	 memcmp
  0018f	85 c0		 test	 eax, eax
  00191	0f 85 a2 00 00
	00		 jne	 $LN101@Merge
  00197	49 83 7e 28 00	 cmp	 QWORD PTR [r14+40], 0
  0019c	0f 85 97 00 00
	00		 jne	 $LN101@Merge
  001a2	49 83 7d 28 00	 cmp	 QWORD PTR [r13+40], 0
  001a7	0f 85 8c 00 00
	00		 jne	 $LN101@Merge

; 1745 :             {
; 1746 :                 // Merge previous channel last draw command with current channel first draw command if matching.
; 1747 :                 last_cmd->ElemCount += next_cmd->ElemCount;
; 1748 :                 idx_offset += next_cmd->ElemCount;
; 1749 :                 ch._CmdBuffer.erase(ch._CmdBuffer.Data); // FIXME-OPT: Improve for multiple merges.

  001ad	48 8b 6c 24 20	 mov	 rbp, QWORD PTR tv1710[rsp]
  001b2	41 8b 45 20	 mov	 eax, DWORD PTR [r13+32]
  001b6	41 01 46 20	 add	 DWORD PTR [r14+32], eax
  001ba	41 03 7d 20	 add	 edi, DWORD PTR [r13+32]
  001be	48 8b 74 2b 08	 mov	 rsi, QWORD PTR [rbx+rbp+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1817 :     inline T* erase(const T* it) { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

  001c3	4c 63 04 2b	 movsxd	 r8, DWORD PTR [rbx+rbp]
  001c7	4c 8b ce	 mov	 r9, rsi
  001ca	49 6b c8 38	 imul	 rcx, r8, 56		; 00000038H
  001ce	48 03 ce	 add	 rcx, rsi
  001d1	48 3b f1	 cmp	 rsi, rcx
  001d4	72 23		 jb	 SHORT $LN55@Merge
  001d6	41 b8 19 07 00
	00		 mov	 r8d, 1817		; 00000719H
  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@NPHOAPAC@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f0	4c 8b 4c 2b 08	 mov	 r9, QWORD PTR [rbx+rbp+8]
  001f5	44 8b 04 2b	 mov	 r8d, DWORD PTR [rbx+rbp]
$LN55@Merge:
  001f9	49 2b f1	 sub	 rsi, r9
  001fc	49 8b c4	 mov	 rax, r12
  001ff	48 f7 ee	 imul	 rsi
  00202	48 c1 fa 04	 sar	 rdx, 4
  00206	48 8b c2	 mov	 rax, rdx
  00209	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0020d	48 03 d0	 add	 rdx, rax
  00210	49 63 c0	 movsxd	 rax, r8d
  00213	48 6b ca 38	 imul	 rcx, rdx, 56		; 00000038H
  00217	48 2b c2	 sub	 rax, rdx
  0021a	4c 6b c0 38	 imul	 r8, rax, 56		; 00000038H
  0021e	49 03 c9	 add	 rcx, r9
  00221	49 83 e8 38	 sub	 r8, 56			; 00000038H
  00225	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00229	e8 00 00 00 00	 call	 memmove
  0022e	ff 0c 2b	 dec	 DWORD PTR [rbx+rbp]
  00231	4c 8b d5	 mov	 r10, rbp
  00234	8b 2c 2b	 mov	 ebp, DWORD PTR [rbx+rbp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1744 :             if (ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd->UserCallback == NULL && next_cmd->UserCallback == NULL)

  00237	eb 05		 jmp	 SHORT $LN102@Merge
$LN101@Merge:

; 1750 :             }
; 1751 :         }
; 1752 :         if (ch._CmdBuffer.Size > 0)

  00239	4c 8b 54 24 20	 mov	 r10, QWORD PTR tv1710[rsp]
$LN102@Merge:
  0023e	44 8b ac 24 90
	00 00 00	 mov	 r13d, DWORD PTR i$1$[rsp]
$LN14@Merge:
  00246	85 ed		 test	 ebp, ebp
  00248	7e 64		 jle	 SHORT $LN89@Merge

; 1753 :             last_cmd = &ch._CmdBuffer.back();

  0024a	8b b4 24 a0 00
	00 00		 mov	 esi, DWORD PTR new_cmd_buffer_count$1$[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00251	8d 45 ff	 lea	 eax, DWORD PTR [rbp-1]
  00254	4e 8b 4c 13 08	 mov	 r9, QWORD PTR [rbx+r10+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1753 :             last_cmd = &ch._CmdBuffer.back();

  00259	03 f5		 add	 esi, ebp
  0025b	8b ac 24 a8 00
	00 00		 mov	 ebp, DWORD PTR new_idx_buffer_count$1$[rsp]

; 1754 :         new_cmd_buffer_count += ch._CmdBuffer.Size;

  00262	33 d2		 xor	 edx, edx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00264	48 63 c8	 movsxd	 rcx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1754 :         new_cmd_buffer_count += ch._CmdBuffer.Size;

  00267	45 33 c0	 xor	 r8d, r8d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  0026a	4c 6b f1 38	 imul	 r14, rcx, 56		; 00000038H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1753 :             last_cmd = &ch._CmdBuffer.back();

  0026e	89 b4 24 a0 00
	00 00		 mov	 DWORD PTR new_cmd_buffer_count$1$[rsp], esi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00275	4d 03 f1	 add	 r14, r9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1753 :             last_cmd = &ch._CmdBuffer.back();

  00278	42 03 6c 13 10	 add	 ebp, DWORD PTR [rbx+r10+16]
  0027d	89 ac 24 a8 00
	00 00		 mov	 DWORD PTR new_idx_buffer_count$1$[rsp], ebp
  00284	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL7@Merge:

; 1755 :         new_idx_buffer_count += ch._IdxBuffer.Size;
; 1756 :         for (int cmd_n = 0; cmd_n < ch._CmdBuffer.Size; cmd_n++)
; 1757 :         {
; 1758 :             ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset;

  00290	42 89 7c 0a 1c	 mov	 DWORD PTR [rdx+r9+28], edi
  00295	48 8d 52 38	 lea	 rdx, QWORD PTR [rdx+56]

; 1759 :             idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount;

  00299	4e 8b 4c 13 08	 mov	 r9, QWORD PTR [rbx+r10+8]
  0029e	41 ff c0	 inc	 r8d
  002a1	42 03 7c 0a e8	 add	 edi, DWORD PTR [rdx+r9-24]
  002a6	46 3b 04 13	 cmp	 r8d, DWORD PTR [rbx+r10]
  002aa	7c e4		 jl	 SHORT $LL7@Merge
  002ac	eb 23		 jmp	 SHORT $LN2@Merge
$LN89@Merge:
  002ae	8b b4 24 a0 00
	00 00		 mov	 esi, DWORD PTR new_cmd_buffer_count$1$[rsp]
  002b5	03 f5		 add	 esi, ebp
  002b7	8b ac 24 a8 00
	00 00		 mov	 ebp, DWORD PTR new_idx_buffer_count$1$[rsp]
  002be	42 03 6c 13 10	 add	 ebp, DWORD PTR [rbx+r10+16]
  002c3	89 ac 24 a8 00
	00 00		 mov	 DWORD PTR new_idx_buffer_count$1$[rsp], ebp
  002ca	89 b4 24 a0 00
	00 00		 mov	 DWORD PTR new_cmd_buffer_count$1$[rsp], esi
$LN2@Merge:

; 1733 :     for (int i = 1; i < _Count; i++)

  002d1	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  002d6	41 ff c5	 inc	 r13d
  002d9	48 ff c0	 inc	 rax
  002dc	44 89 ac 24 90
	00 00 00	 mov	 DWORD PTR i$1$[rsp], r13d
  002e4	49 83 c2 20	 add	 r10, 32			; 00000020H
  002e8	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  002ed	4c 89 54 24 20	 mov	 QWORD PTR tv1710[rsp], r10
  002f2	45 3b 6f 04	 cmp	 r13d, DWORD PTR [r15+4]
  002f6	0f 8c 0a fe ff
	ff		 jl	 $LL4@Merge
  002fc	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR draw_list$[rsp]
$LN3@Merge:

; 1762 :     draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);

  00304	41 8b 1c 24	 mov	 ebx, DWORD PTR [r12]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00308	bf 08 00 00 00	 mov	 edi, 8
  0030d	41 8b 4c 24 04	 mov	 ecx, DWORD PTR [r12+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1762 :     draw_list->CmdBuffer.resize(draw_list->CmdBuffer.Size + new_cmd_buffer_count);

  00312	03 de		 add	 ebx, esi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00314	3b d9		 cmp	 ebx, ecx
  00316	7e 20		 jle	 SHORT $LN60@Merge

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00318	85 c9		 test	 ecx, ecx
  0031a	74 0b		 je	 SHORT $LN64@Merge
  0031c	8b c1		 mov	 eax, ecx
  0031e	99		 cdq
  0031f	2b c2		 sub	 eax, edx
  00321	d1 f8		 sar	 eax, 1
  00323	03 c1		 add	 eax, ecx
  00325	eb 02		 jmp	 SHORT $LN65@Merge
$LN64@Merge:
  00327	8b c7		 mov	 eax, edi
$LN65@Merge:
  00329	3b c3		 cmp	 eax, ebx
  0032b	8b d3		 mov	 edx, ebx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0032d	49 8b cc	 mov	 rcx, r12

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00330	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00333	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
$LN60@Merge:
  00338	41 89 1c 24	 mov	 DWORD PTR [r12], ebx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1763 :     draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);

  0033c	41 8b 74 24 10	 mov	 esi, DWORD PTR [r12+16]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00341	41 8b 4c 24 14	 mov	 ecx, DWORD PTR [r12+20]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1763 :     draw_list->IdxBuffer.resize(draw_list->IdxBuffer.Size + new_idx_buffer_count);

  00346	03 f5		 add	 esi, ebp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00348	3b f1		 cmp	 esi, ecx
  0034a	7e 23		 jle	 SHORT $LN67@Merge

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0034c	85 c9		 test	 ecx, ecx
  0034e	74 0a		 je	 SHORT $LN71@Merge
  00350	8b c1		 mov	 eax, ecx
  00352	99		 cdq
  00353	2b c2		 sub	 eax, edx
  00355	d1 f8		 sar	 eax, 1
  00357	8d 3c 01	 lea	 edi, DWORD PTR [rcx+rax]
$LN71@Merge:
  0035a	3b fe		 cmp	 edi, esi

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0035c	49 8d 4c 24 10	 lea	 rcx, QWORD PTR [r12+16]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00361	8b d6		 mov	 edx, esi
  00363	0f 4f d7	 cmovg	 edx, edi

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00366	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QEAAXH@Z ; ImVector<unsigned short>::reserve
  0036b	41 8b 1c 24	 mov	 ebx, DWORD PTR [r12]
$LN67@Merge:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1766 :     ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;

  0036f	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR new_cmd_buffer_count$1$[rsp]

; 1768 :     for (int i = 1; i < _Count; i++)

  00377	8b d3		 mov	 edx, ebx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00379	41 89 74 24 10	 mov	 DWORD PTR [r12+16], esi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1766 :     ImDrawCmd* cmd_write = draw_list->CmdBuffer.Data + draw_list->CmdBuffer.Size - new_cmd_buffer_count;

  0037e	48 63 cb	 movsxd	 rcx, ebx
  00381	48 2b c8	 sub	 rcx, rax

; 1767 :     ImDrawIdx* idx_write = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size - new_idx_buffer_count;

  00384	48 63 c5	 movsxd	 rax, ebp
  00387	4c 6b f1 38	 imul	 r14, rcx, 56		; 00000038H
  0038b	48 63 ce	 movsxd	 rcx, esi

; 1768 :     for (int i = 1; i < _Count; i++)

  0038e	be 01 00 00 00	 mov	 esi, 1
  00393	4d 03 74 24 08	 add	 r14, QWORD PTR [r12+8]
  00398	48 2b c8	 sub	 rcx, rax
  0039b	49 8b 44 24 18	 mov	 rax, QWORD PTR [r12+24]
  003a0	4c 8d 2c 48	 lea	 r13, QWORD PTR [rax+rcx*2]
  003a4	41 39 77 04	 cmp	 DWORD PTR [r15+4], esi
  003a8	0f 8e 84 00 00
	00		 jle	 $LN9@Merge
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1817 :     inline T* erase(const T* it) { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

  003ae	8b ee		 mov	 ebp, esi
$LL10@Merge:

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  003b0	48 85 ed	 test	 rbp, rbp
  003b3	78 06		 js	 SHORT $LN75@Merge
  003b5	41 3b 77 08	 cmp	 esi, DWORD PTR [r15+8]
  003b9	7c 1a		 jl	 SHORT $LN76@Merge
$LN75@Merge:
  003bb	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  003c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  003c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  003cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN76@Merge:
  003d5	48 8b 7c 24 28	 mov	 rdi, QWORD PTR tv1708[rsp]
  003da	49 03 7f 10	 add	 rdi, QWORD PTR [r15+16]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1771 :         if (int sz = ch._CmdBuffer.Size) { memcpy(cmd_write, ch._CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }

  003de	48 63 07	 movsxd	 rax, DWORD PTR [rdi]
  003e1	85 c0		 test	 eax, eax
  003e3	74 16		 je	 SHORT $LN16@Merge
  003e5	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  003e9	49 8b ce	 mov	 rcx, r14
  003ec	48 6b d8 38	 imul	 rbx, rax, 56		; 00000038H
  003f0	4c 8b c3	 mov	 r8, rbx
  003f3	e8 00 00 00 00	 call	 memcpy
  003f8	4c 03 f3	 add	 r14, rbx
$LN16@Merge:

; 1772 :         if (int sz = ch._IdxBuffer.Size) { memcpy(idx_write, ch._IdxBuffer.Data, sz * sizeof(ImDrawIdx)); idx_write += sz; }

  003fb	48 63 47 10	 movsxd	 rax, DWORD PTR [rdi+16]
  003ff	85 c0		 test	 eax, eax
  00401	74 18		 je	 SHORT $LN8@Merge
  00403	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00407	48 8b d8	 mov	 rbx, rax
  0040a	48 03 db	 add	 rbx, rbx
  0040d	49 8b cd	 mov	 rcx, r13
  00410	4c 8b c3	 mov	 r8, rbx
  00413	e8 00 00 00 00	 call	 memcpy
  00418	4c 03 eb	 add	 r13, rbx
$LN8@Merge:

; 1768 :     for (int i = 1; i < _Count; i++)

  0041b	48 83 44 24 28
	20		 add	 QWORD PTR tv1708[rsp], 32 ; 00000020H
  00421	ff c6		 inc	 esi
  00423	48 ff c5	 inc	 rbp
  00426	41 3b 77 04	 cmp	 esi, DWORD PTR [r15+4]
  0042a	7c 84		 jl	 SHORT $LL10@Merge
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1817 :     inline T* erase(const T* it) { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

  0042c	41 8b 1c 24	 mov	 ebx, DWORD PTR [r12]
  00430	8b d3		 mov	 edx, ebx
$LN9@Merge:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1774 :     draw_list->_IdxWritePtr = idx_write;

  00432	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  00437	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0043c	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00441	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00446	4d 89 6c 24 50	 mov	 QWORD PTR [r12+80], r13
  0044b	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]

; 1777 :     if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)

  00450	85 db		 test	 ebx, ebx
  00452	74 36		 je	 SHORT $LN19@Merge
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00454	7f 20		 jg	 SHORT $LN79@Merge
  00456	41 b8 0b 07 00
	00		 mov	 r8d, 1803		; 0000070bH
  0045c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00463	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  0046a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00470	41 8b 1c 24	 mov	 ebx, DWORD PTR [r12]
  00474	8b d3		 mov	 edx, ebx
$LN79@Merge:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1777 :     if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)

  00476	4d 8b 44 24 08	 mov	 r8, QWORD PTR [r12+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  0047b	48 63 c3	 movsxd	 rax, ebx
  0047e	48 6b c8 38	 imul	 rcx, rax, 56		; 00000038H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1777 :     if (draw_list->CmdBuffer.Size == 0 || draw_list->CmdBuffer.back().UserCallback != NULL)

  00482	4a 83 7c 01 f0
	00		 cmp	 QWORD PTR [rcx+r8-16], 0
  00488	74 11		 je	 SHORT $LN18@Merge
$LN19@Merge:

; 1778 :         draw_list->AddDrawCmd();

  0048a	49 8b cc	 mov	 rcx, r12
  0048d	e8 00 00 00 00	 call	 ?AddDrawCmd@ImDrawList@@QEAAXXZ ; ImDrawList::AddDrawCmd
  00492	41 8b 14 24	 mov	 edx, DWORD PTR [r12]
  00496	4d 8b 44 24 08	 mov	 r8, QWORD PTR [r12+8]
$LN18@Merge:

; 1779 : 
; 1780 :     // If current command is used with different settings we need to add a new command
; 1781 :     ImDrawCmd* curr_cmd = &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];
; 1782 :     if (curr_cmd->ElemCount == 0)

  0049b	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  004a0	48 63 c2	 movsxd	 rax, edx
  004a3	49 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR [r12+136]
  004ab	48 6b c8 38	 imul	 rcx, rax, 56		; 00000038H
  004af	48 83 c1 c8	 add	 rcx, -56		; ffffffffffffffc8H
  004b3	49 03 c8	 add	 rcx, r8
  004b6	83 79 20 00	 cmp	 DWORD PTR [rcx+32], 0
  004ba	75 27		 jne	 SHORT $LN20@Merge

; 1783 :         ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset

  004bc	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  004bf	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  004c2	f2 0f 10 4a 10	 movsd	 xmm1, QWORD PTR [rdx+16]
  004c7	f2 0f 11 49 10	 movsd	 QWORD PTR [rcx+16], xmm1
  004cc	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  004cf	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 1786 : 
; 1787 :     _Count = 1;

  004d2	41 c7 47 04 01
	00 00 00	 mov	 DWORD PTR [r15+4], 1

; 1788 : }

  004da	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004de	41 5f		 pop	 r15
  004e0	41 5c		 pop	 r12
  004e2	c3		 ret	 0
$LN20@Merge:

; 1784 :     else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)

  004e3	41 b8 1c 00 00
	00		 mov	 r8d, 28
  004e9	e8 00 00 00 00	 call	 memcmp
  004ee	85 c0		 test	 eax, eax
  004f0	74 08		 je	 SHORT $LN22@Merge

; 1785 :         draw_list->AddDrawCmd();

  004f2	49 8b cc	 mov	 rcx, r12
  004f5	e8 00 00 00 00	 call	 ?AddDrawCmd@ImDrawList@@QEAAXXZ ; ImDrawList::AddDrawCmd
$LN22@Merge:

; 1786 : 
; 1787 :     _Count = 1;

  004fa	41 c7 47 04 01
	00 00 00	 mov	 DWORD PTR [r15+4], 1
$LN1@Merge:

; 1788 : }

  00502	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00506	41 5f		 pop	 r15
  00508	41 5c		 pop	 r12
  0050a	c3		 ret	 0
?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z ENDP	; ImDrawListSplitter::Merge
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
draw_list$ = 56
idx$ = 64
?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z PROC ; ImDrawListSplitter::SetCurrentChannel

; 1791 : {

$LN16:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 63 f8	 movsxd	 rdi, r8d
  00012	48 8b da	 mov	 rbx, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 1792 :     IM_ASSERT(idx >= 0 && idx < _Count);

  00018	45 85 c0	 test	 r8d, r8d
  0001b	78 05		 js	 SHORT $LN9@SetCurrent
  0001d	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00020	7c 1a		 jl	 SHORT $LN10@SetCurrent
$LN9@SetCurrent:
  00022	41 b8 00 07 00
	00		 mov	 r8d, 1792		; 00000700H
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@ILGGLBID@?$AAi?$AAd?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AAd?$AAx@
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN10@SetCurrent:

; 1793 :     if (_Current == idx)

  0003c	48 63 06	 movsxd	 rax, DWORD PTR [rsi]
  0003f	3b c7		 cmp	 eax, edi
  00041	0f 84 b9 00 00
	00		 je	 $LN7@SetCurrent

; 1794 :         return;
; 1795 : 
; 1796 :     // Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
; 1797 :     memcpy(&_Channels.Data[_Current]._CmdBuffer, &draw_list->CmdBuffer, sizeof(draw_list->CmdBuffer));

  00047	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  00051	48 c1 e1 05	 shl	 rcx, 5
  00055	0f 11 04 01	 movups	 XMMWORD PTR [rcx+rax], xmm0

; 1798 :     memcpy(&_Channels.Data[_Current]._IdxBuffer, &draw_list->IdxBuffer, sizeof(draw_list->IdxBuffer));

  00059	48 63 0e	 movsxd	 rcx, DWORD PTR [rsi]
  0005c	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  00060	0f 10 43 10	 movups	 xmm0, XMMWORD PTR [rbx+16]
  00064	48 c1 e1 05	 shl	 rcx, 5
  00068	0f 11 44 01 10	 movups	 XMMWORD PTR [rcx+rax+16], xmm0

; 1799 :     _Current = idx;
; 1800 :     memcpy(&draw_list->CmdBuffer, &_Channels.Data[idx]._CmdBuffer, sizeof(draw_list->CmdBuffer));

  0006d	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  00071	48 8b cf	 mov	 rcx, rdi
  00074	89 3e		 mov	 DWORD PTR [rsi], edi
  00076	48 c1 e1 05	 shl	 rcx, 5
  0007a	0f 10 04 08	 movups	 xmm0, XMMWORD PTR [rax+rcx]
  0007e	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0

; 1801 :     memcpy(&draw_list->IdxBuffer, &_Channels.Data[idx]._IdxBuffer, sizeof(draw_list->IdxBuffer));

  00081	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  00085	0f 10 44 08 10	 movups	 xmm0, XMMWORD PTR [rax+rcx+16]
  0008a	0f 11 43 10	 movups	 XMMWORD PTR [rbx+16], xmm0

; 1802 :     draw_list->_IdxWritePtr = draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size;

  0008e	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00092	48 63 4b 10	 movsxd	 rcx, DWORD PTR [rbx+16]
  00096	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]

; 1803 : 
; 1804 :     // If current command is used with different settings we need to add a new command
; 1805 :     ImDrawCmd* curr_cmd = (draw_list->CmdBuffer.Size == 0) ? NULL : &draw_list->CmdBuffer.Data[draw_list->CmdBuffer.Size - 1];

  0009a	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  0009d	48 89 4b 50	 mov	 QWORD PTR [rbx+80], rcx
  000a1	85 c0		 test	 eax, eax
  000a3	74 53		 je	 SHORT $LN14@SetCurrent
  000a5	48 6b c8 38	 imul	 rcx, rax, 56		; 00000038H
  000a9	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000ad	48 83 c0 c8	 add	 rax, -56		; ffffffffffffffc8H
  000b1	48 03 c8	 add	 rcx, rax

; 1806 :     if (curr_cmd == NULL)

  000b4	74 42		 je	 SHORT $LN14@SetCurrent

; 1807 :         draw_list->AddDrawCmd();
; 1808 :     else if (curr_cmd->ElemCount == 0)

  000b6	83 79 20 00	 cmp	 DWORD PTR [rcx+32], 0
  000ba	48 8d 93 88 00
	00 00		 lea	 rdx, QWORD PTR [rbx+136]
  000c1	75 26		 jne	 SHORT $LN5@SetCurrent

; 1809 :         ImDrawCmd_HeaderCopy(curr_cmd, &draw_list->_CmdHeader); // Copy ClipRect, TextureId, VtxOffset

  000c3	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  000c6	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  000c9	f2 0f 10 4a 10	 movsd	 xmm1, QWORD PTR [rdx+16]
  000ce	f2 0f 11 49 10	 movsd	 QWORD PTR [rcx+16], xmm1
  000d3	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  000d6	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 1812 : }

  000d9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000de	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000e3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e7	5f		 pop	 rdi
  000e8	c3		 ret	 0
$LN5@SetCurrent:

; 1810 :     else if (ImDrawCmd_HeaderCompare(curr_cmd, &draw_list->_CmdHeader) != 0)

  000e9	41 b8 1c 00 00
	00		 mov	 r8d, 28
  000ef	e8 00 00 00 00	 call	 memcmp
  000f4	85 c0		 test	 eax, eax
  000f6	74 08		 je	 SHORT $LN7@SetCurrent
$LN14@SetCurrent:

; 1811 :         draw_list->AddDrawCmd();

  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 ?AddDrawCmd@ImDrawList@@QEAAXXZ ; ImDrawList::AddDrawCmd
$LN7@SetCurrent:

; 1812 : }

  00100	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00105	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z ENDP ; ImDrawListSplitter::SetCurrentChannel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
??0ImFontConfig@@QEAA@XZ PROC				; ImFontConfig::ImFontConfig

; 1911 : {

  00000	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 252  :     ImVec2() { x = y = 0.0f; }

  00003	33 c0		 xor	 eax, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1912 :     memset(this, 0, sizeof(*this));

  00005	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00008	0f 11 41 10	 movups	 XMMWORD PTR [rcx+16], xmm0
  0000c	0f 11 41 20	 movups	 XMMWORD PTR [rcx+32], xmm0
  00010	0f 11 41 30	 movups	 XMMWORD PTR [rcx+48], xmm0
  00014	0f 11 41 40	 movups	 XMMWORD PTR [rcx+64], xmm0
  00018	0f 11 41 50	 movups	 XMMWORD PTR [rcx+80], xmm0
  0001c	0f 11 41 60	 movups	 XMMWORD PTR [rcx+96], xmm0
  00020	0f 11 41 70	 movups	 XMMWORD PTR [rcx+112], xmm0
  00024	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 1913 :     FontDataOwnedByAtlas = true;
; 1914 :     OversampleH = 3; // FIXME: 2 may be a better default?
; 1915 :     OversampleV = 1;
; 1916 :     GlyphMaxAdvanceX = FLT_MAX;
; 1917 :     RasterizerMultiply = 1.0f;
; 1918 :     EllipsisChar = (ImWchar)-1;

  0002b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00030	66 89 41 54	 mov	 WORD PTR [rcx+84], ax

; 1919 : }

  00034	48 8b c1	 mov	 rax, rcx
  00037	c6 41 0c 01	 mov	 BYTE PTR [rcx+12], 1
  0003b	c7 41 18 03 00
	00 00		 mov	 DWORD PTR [rcx+24], 3
  00042	c7 41 1c 01 00
	00 00		 mov	 DWORD PTR [rcx+28], 1
  00049	c7 41 44 ff ff
	7f 7f		 mov	 DWORD PTR [rcx+68], 2139095039 ; 7f7fffffH
  00050	c7 41 50 00 00
	80 3f		 mov	 DWORD PTR [rcx+80], 1065353216 ; 3f800000H
  00057	c3		 ret	 0
??0ImFontConfig@@QEAA@XZ ENDP				; ImFontConfig::ImFontConfig
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?ClearInputData@ImFontAtlas@@QEAAXXZ PROC		; ImFontAtlas::ClearInputData

; 1989 : {

$LN95:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1990 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0000a	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00016	74 1a		 je	 SHORT $LN12@ClearInput
  00018	41 b8 c6 07 00
	00		 mov	 r8d, 1990		; 000007c6H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN12@ClearInput:

; 1991 :     for (int i = 0; i < ConfigData.Size; i++)

  00032	8b 43 68	 mov	 eax, DWORD PTR [rbx+104]
  00035	33 ed		 xor	 ebp, ebp
  00037	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0003c	8b fd		 mov	 edi, ebp
  0003e	85 c0		 test	 eax, eax
  00040	0f 8e 03 01 00
	00		 jle	 $LN3@ClearInput
  00046	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  0004b	8b f5		 mov	 esi, ebp
  0004d	44 8b f5	 mov	 r14d, ebp
  00050	8b c8		 mov	 ecx, eax
$LL4@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00052	48 85 f6	 test	 rsi, rsi
  00055	78 04		 js	 SHORT $LN15@ClearInput
  00057	3b f8		 cmp	 edi, eax
  00059	7c 1d		 jl	 SHORT $LN16@ClearInput
$LN15@ClearInput:
  0005b	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00075	8b 4b 68	 mov	 ecx, DWORD PTR [rbx+104]
$LN16@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1992 :         if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)

  00078	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  0007c	49 39 2c 06	 cmp	 QWORD PTR [r14+rax], rbp
  00080	0f 84 a5 00 00
	00		 je	 $LN2@ClearInput
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00086	48 85 f6	 test	 rsi, rsi
  00089	78 04		 js	 SHORT $LN81@ClearInput
  0008b	3b f9		 cmp	 edi, ecx
  0008d	7c 21		 jl	 SHORT $LN87@ClearInput
$LN81@ClearInput:
  0008f	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a9	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  000ad	8b 4b 68	 mov	 ecx, DWORD PTR [rbx+104]
$LN87@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1992 :         if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)

  000b0	41 38 6c 06 0c	 cmp	 BYTE PTR [r14+rax+12], bpl
  000b5	74 74		 je	 SHORT $LN2@ClearInput
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  000b7	48 85 f6	 test	 rsi, rsi
  000ba	78 04		 js	 SHORT $LN82@ClearInput
  000bc	3b f9		 cmp	 edi, ecx
  000be	7c 1e		 jl	 SHORT $LN88@ClearInput
$LN82@ClearInput:
  000c0	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000da	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
$LN88@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1994 :             IM_FREE(ConfigData[i].FontData);

  000de	49 8b 0c 06	 mov	 rcx, QWORD PTR [r14+rax]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  000e2	48 85 c9	 test	 rcx, rcx
  000e5	74 12		 je	 SHORT $LN27@ClearInput

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000ee	48 85 c0	 test	 rax, rax
  000f1	74 06		 je	 SHORT $LN27@ClearInput

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000f3	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN27@ClearInput:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  000ff	48 85 f6	 test	 rsi, rsi
  00102	78 05		 js	 SHORT $LN35@ClearInput
  00104	3b 7b 68	 cmp	 edi, DWORD PTR [rbx+104]
  00107	7c 1a		 jl	 SHORT $LN36@ClearInput
$LN35@ClearInput:
  00109	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN36@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 1995 :             ConfigData[i].FontData = NULL;

  00123	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  00127	49 89 2c 06	 mov	 QWORD PTR [r14+rax], rbp
$LN2@ClearInput:

; 1991 :     for (int i = 0; i < ConfigData.Size; i++)

  0012b	8b 43 68	 mov	 eax, DWORD PTR [rbx+104]
  0012e	ff c7		 inc	 edi
  00130	48 ff c6	 inc	 rsi
  00133	49 81 c6 88 00
	00 00		 add	 r14, 136		; 00000088H
  0013a	8b c8		 mov	 ecx, eax
  0013c	3b f8		 cmp	 edi, eax
  0013e	0f 8c 0e ff ff
	ff		 jl	 $LL4@ClearInput
  00144	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
$LN3@ClearInput:

; 1996 :         }
; 1997 : 
; 1998 :     // When clearing this we lose access to the font name and other information used to build the font.
; 1999 :     for (int i = 0; i < Fonts.Size; i++)

  00149	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  0014c	8b fd		 mov	 edi, ebp
  0014e	85 c0		 test	 eax, eax
  00150	0f 8e fb 00 00
	00		 jle	 $LN6@ClearInput
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00156	48 8b f5	 mov	 rsi, rbp
  00159	8b c8		 mov	 ecx, eax
  0015b	0f 1f 44 00 00	 npad	 5
$LL7@ClearInput:
  00160	48 85 f6	 test	 rsi, rsi
  00163	78 04		 js	 SHORT $LN39@ClearInput
  00165	3b f8		 cmp	 edi, eax
  00167	7c 1d		 jl	 SHORT $LN40@ClearInput
$LN39@ClearInput:
  00169	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0016f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00183	8b 4b 48	 mov	 ecx, DWORD PTR [rbx+72]
$LN40@ClearInput:
  00186	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2000 :         if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)

  0018a	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  0018e	48 8b 04 f2	 mov	 rax, QWORD PTR [rdx+rsi*8]
  00192	4c 39 40 48	 cmp	 QWORD PTR [rax+72], r8
  00196	0f 82 a3 00 00
	00		 jb	 $LN5@ClearInput
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  0019c	48 85 f6	 test	 rsi, rsi
  0019f	78 04		 js	 SHORT $LN83@ClearInput
  001a1	3b f9		 cmp	 edi, ecx
  001a3	7c 22		 jl	 SHORT $LN89@ClearInput
$LN83@ClearInput:
  001a5	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  001ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001bf	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
  001c3	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
$LN89@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2000 :         if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)

  001c7	48 63 43 68	 movsxd	 rax, DWORD PTR [rbx+104]
  001cb	48 69 c8 88 00
	00 00		 imul	 rcx, rax, 136		; 00000088H
  001d2	48 8b 04 f2	 mov	 rax, QWORD PTR [rdx+rsi*8]
  001d6	49 03 c8	 add	 rcx, r8
  001d9	48 39 48 48	 cmp	 QWORD PTR [rax+72], rcx
  001dd	73 60		 jae	 SHORT $LN5@ClearInput
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  001df	48 85 f6	 test	 rsi, rsi
  001e2	78 05		 js	 SHORT $LN90@ClearInput
  001e4	3b 7b 48	 cmp	 edi, DWORD PTR [rbx+72]
  001e7	7c 1e		 jl	 SHORT $LN91@ClearInput
$LN90@ClearInput:
  001e9	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00203	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
$LN91@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2002 :             Fonts[i]->ConfigData = NULL;

  00207	48 8b 04 f2	 mov	 rax, QWORD PTR [rdx+rsi*8]
  0020b	48 89 68 48	 mov	 QWORD PTR [rax+72], rbp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  0020f	48 85 f6	 test	 rsi, rsi
  00212	78 05		 js	 SHORT $LN92@ClearInput
  00214	3b 7b 48	 cmp	 edi, DWORD PTR [rbx+72]
  00217	7c 1a		 jl	 SHORT $LN52@ClearInput
$LN92@ClearInput:
  00219	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0021f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0022d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN52@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2003 :             Fonts[i]->ConfigDataCount = 0;

  00233	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00237	48 8b 0c f0	 mov	 rcx, QWORD PTR [rax+rsi*8]
  0023b	66 89 69 50	 mov	 WORD PTR [rcx+80], bp
$LN5@ClearInput:

; 1996 :         }
; 1997 : 
; 1998 :     // When clearing this we lose access to the font name and other information used to build the font.
; 1999 :     for (int i = 0; i < Fonts.Size; i++)

  0023f	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  00242	ff c7		 inc	 edi
  00244	48 ff c6	 inc	 rsi
  00247	8b c8		 mov	 ecx, eax
  00249	3b f8		 cmp	 edi, eax
  0024b	0f 8c 0f ff ff
	ff		 jl	 $LL7@ClearInput
$LN6@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00251	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00255	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0025a	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0025f	48 85 c9	 test	 rcx, rcx
  00262	74 20		 je	 SHORT $LN54@ClearInput
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00264	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0026b	48 89 6b 68	 mov	 QWORD PTR [rbx+104], rbp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0026f	48 85 c0	 test	 rax, rax
  00272	74 06		 je	 SHORT $LN58@ClearInput

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00274	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN58@ClearInput:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00280	48 89 6b 70	 mov	 QWORD PTR [rbx+112], rbp
$LN54@ClearInput:
  00284	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00288	48 85 c9	 test	 rcx, rcx
  0028b	74 20		 je	 SHORT $LN93@ClearInput
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0028d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00294	48 89 6b 58	 mov	 QWORD PTR [rbx+88], rbp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00298	48 85 c0	 test	 rax, rax
  0029b	74 06		 je	 SHORT $LN69@ClearInput

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0029d	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN69@ClearInput:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  002a9	48 89 6b 60	 mov	 QWORD PTR [rbx+96], rbp
$LN93@ClearInput:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2009 : }

  002ad	48 c7 83 84 04
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rbx+1156], -1
  002b8	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  002bd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002c1	5d		 pop	 rbp
  002c2	c3		 ret	 0
?ClearInputData@ImFontAtlas@@QEAAXXZ ENDP		; ImFontAtlas::ClearInputData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?ClearTexData@ImFontAtlas@@QEAAXXZ PROC			; ImFontAtlas::ClearTexData

; 2012 : {

$LN24:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2013 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00006	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	74 1a		 je	 SHORT $LN6@ClearTexDa
  0000f	41 b8 dd 07 00
	00		 mov	 r8d, 2013		; 000007ddH
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN6@ClearTexDa:

; 2014 :     if (TexPixelsAlpha8)

  00029	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0002d	48 85 c9	 test	 rcx, rcx
  00030	74 18		 je	 SHORT $LN11@ClearTexDa
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00039	48 85 c0	 test	 rax, rax
  0003c	74 06		 je	 SHORT $LN9@ClearTexDa

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0003e	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN9@ClearTexDa:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN11@ClearTexDa:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2016 :     if (TexPixelsRGBA32)

  0004a	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  0004e	48 85 c9	 test	 rcx, rcx
  00051	74 18		 je	 SHORT $LN19@ClearTexDa
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00053	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0005a	48 85 c0	 test	 rax, rax
  0005d	74 06		 je	 SHORT $LN17@ClearTexDa

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0005f	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN17@ClearTexDa:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN19@ClearTexDa:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2018 :     TexPixelsAlpha8 = NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 2019 :     TexPixelsRGBA32 = NULL;

  00071	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 2020 :     TexPixelsUseColors = false;

  00075	88 43 1a	 mov	 BYTE PTR [rbx+26], al

; 2021 :     // Important: we leave TexReady untouched
; 2022 : }

  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5b		 pop	 rbx
  0007d	c3		 ret	 0
?ClearTexData@ImFontAtlas@@QEAAXXZ ENDP			; ImFontAtlas::ClearTexData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?ClearFonts@ImFontAtlas@@QEAAXXZ PROC			; ImFontAtlas::ClearFonts

; 2025 : {

$LN81:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	48 8b f9	 mov	 rdi, rcx

; 2026 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00018	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  0001c	74 1a		 je	 SHORT $LN4@ClearFonts
  0001e	41 b8 ea 07 00
	00		 mov	 r8d, 2026		; 000007eaH
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@ClearFonts:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1786 :     inline void         clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

  00038	33 f6		 xor	 esi, esi
  0003a	39 77 48	 cmp	 DWORD PTR [rdi+72], esi
  0003d	0f 8e b7 00 00
	00		 jle	 $LN7@ClearFonts
  00043	45 33 f6	 xor	 r14d, r14d
  00046	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL8@ClearFonts:
  00050	48 8b 47 50	 mov	 rax, QWORD PTR [rdi+80]
  00054	49 8b 1c 06	 mov	 rbx, QWORD PTR [r14+rax]

; 1753 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

  00058	48 85 db	 test	 rbx, rbx
  0005b	0f 84 8a 00 00
	00		 je	 $LN6@ClearFonts
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3125 :     ClearOutputData();

  00061	48 8b cb	 mov	 rcx, rbx
  00064	e8 00 00 00 00	 call	 ?ClearOutputData@ImFont@@QEAAXXZ ; ImFont::ClearOutputData
  00069	90		 npad	 1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0006a	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  0006e	48 85 c9	 test	 rcx, rcx
  00071	74 19		 je	 SHORT $LN27@ClearFonts
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00073	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0007a	48 85 c0	 test	 rax, rax
  0007d	74 06		 je	 SHORT $LN25@ClearFonts

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0007f	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN25@ClearFonts:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0008b	90		 npad	 1
$LN27@ClearFonts:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0008c	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00090	48 85 c9	 test	 rcx, rcx
  00093	74 19		 je	 SHORT $LN39@ClearFonts
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00095	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0009c	48 85 c0	 test	 rax, rax
  0009f	74 06		 je	 SHORT $LN37@ClearFonts

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000a1	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN37@ClearFonts:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000ad	90		 npad	 1
$LN39@ClearFonts:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  000ae	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000b2	48 85 c9	 test	 rcx, rcx
  000b5	74 19		 je	 SHORT $LN51@ClearFonts
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000be	48 85 c0	 test	 rax, rax
  000c1	74 06		 je	 SHORT $LN49@ClearFonts

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000c3	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN49@ClearFonts:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000cf	90		 npad	 1
$LN51@ClearFonts:

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000d0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000d7	48 85 c0	 test	 rax, rax
  000da	74 06		 je	 SHORT $LN57@ClearFonts

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000dc	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN57@ClearFonts:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000e2	48 8b cb	 mov	 rcx, rbx
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@ClearFonts:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1786 :     inline void         clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

  000eb	ff c6		 inc	 esi
  000ed	49 83 c6 08	 add	 r14, 8
  000f1	3b 77 48	 cmp	 esi, DWORD PTR [rdi+72]
  000f4	0f 8c 56 ff ff
	ff		 jl	 $LL8@ClearFonts
$LN7@ClearFonts:

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000fa	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  000fe	48 85 c9	 test	 rcx, rcx
  00101	74 28		 je	 SHORT $LN78@ClearFonts
  00103	48 c7 47 48 00
	00 00 00	 mov	 QWORD PTR [rdi+72], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0010b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00112	48 85 c0	 test	 rax, rax
  00115	74 06		 je	 SHORT $LN68@ClearFonts

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00117	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN68@ClearFonts:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00123	48 c7 47 50 00
	00 00 00	 mov	 QWORD PTR [rdi+80], 0
$LN78@ClearFonts:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2029 : }

  0012b	c6 47 19 00	 mov	 BYTE PTR [rdi+25], 0
  0012f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00134	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00139	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0013e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00142	41 5e		 pop	 r14
  00144	c3		 ret	 0
?ClearFonts@ImFontAtlas@@QEAAXXZ ENDP			; ImFontAtlas::ClearFonts
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?Clear@ImFontAtlas@@QEAAXXZ PROC			; ImFontAtlas::Clear

; 2032 : {

$LN83:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	48 8b f9	 mov	 rdi, rcx

; 2033 :     ClearInputData();

  00018	e8 00 00 00 00	 call	 ?ClearInputData@ImFontAtlas@@QEAAXXZ ; ImFontAtlas::ClearInputData

; 2034 :     ClearTexData();

  0001d	48 8b cf	 mov	 rcx, rdi
  00020	e8 00 00 00 00	 call	 ?ClearTexData@ImFontAtlas@@QEAAXXZ ; ImFontAtlas::ClearTexData

; 2026 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00025	80 7f 18 00	 cmp	 BYTE PTR [rdi+24], 0
  00029	74 1a		 je	 SHORT $LN6@Clear
  0002b	41 b8 ea 07 00
	00		 mov	 r8d, 2026		; 000007eaH
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN6@Clear:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1786 :     inline void         clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

  00045	33 f6		 xor	 esi, esi
  00047	39 77 48	 cmp	 DWORD PTR [rdi+72], esi
  0004a	0f 8e ad 00 00
	00		 jle	 $LN9@Clear
  00050	45 33 f6	 xor	 r14d, r14d
$LL10@Clear:
  00053	48 8b 47 50	 mov	 rax, QWORD PTR [rdi+80]
  00057	49 8b 1c 06	 mov	 rbx, QWORD PTR [r14+rax]

; 1753 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

  0005b	48 85 db	 test	 rbx, rbx
  0005e	0f 84 8a 00 00
	00		 je	 $LN8@Clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3125 :     ClearOutputData();

  00064	48 8b cb	 mov	 rcx, rbx
  00067	e8 00 00 00 00	 call	 ?ClearOutputData@ImFont@@QEAAXXZ ; ImFont::ClearOutputData
  0006c	90		 npad	 1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0006d	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00071	48 85 c9	 test	 rcx, rcx
  00074	74 19		 je	 SHORT $LN29@Clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0007d	48 85 c0	 test	 rax, rax
  00080	74 06		 je	 SHORT $LN27@Clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00082	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN27@Clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0008e	90		 npad	 1
$LN29@Clear:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0008f	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00093	48 85 c9	 test	 rcx, rcx
  00096	74 19		 je	 SHORT $LN41@Clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00098	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0009f	48 85 c0	 test	 rax, rax
  000a2	74 06		 je	 SHORT $LN39@Clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000a4	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN39@Clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000b0	90		 npad	 1
$LN41@Clear:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  000b1	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000b5	48 85 c9	 test	 rcx, rcx
  000b8	74 19		 je	 SHORT $LN53@Clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000c1	48 85 c0	 test	 rax, rax
  000c4	74 06		 je	 SHORT $LN51@Clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000c6	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN51@Clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000d2	90		 npad	 1
$LN53@Clear:

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000da	48 85 c0	 test	 rax, rax
  000dd	74 06		 je	 SHORT $LN59@Clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000df	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN59@Clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000e5	48 8b cb	 mov	 rcx, rbx
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@Clear:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1786 :     inline void         clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

  000ee	ff c6		 inc	 esi
  000f0	49 83 c6 08	 add	 r14, 8
  000f4	3b 77 48	 cmp	 esi, DWORD PTR [rdi+72]
  000f7	0f 8c 56 ff ff
	ff		 jl	 $LL10@Clear
$LN9@Clear:

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000fd	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  00101	48 85 c9	 test	 rcx, rcx
  00104	74 28		 je	 SHORT $LN80@Clear
  00106	48 c7 47 48 00
	00 00 00	 mov	 QWORD PTR [rdi+72], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0010e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00115	48 85 c0	 test	 rax, rax
  00118	74 06		 je	 SHORT $LN70@Clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0011a	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN70@Clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00126	48 c7 47 50 00
	00 00 00	 mov	 QWORD PTR [rdi+80], 0
$LN80@Clear:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2036 : }

  0012e	c6 47 19 00	 mov	 BYTE PTR [rdi+25], 0
  00132	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00137	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0013c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00141	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00145	41 5e		 pop	 r14
  00147	c3		 ret	 0
?Clear@ImFontAtlas@@QEAAXXZ ENDP			; ImFontAtlas::Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
font_cfg$1 = 48
$T2 = 192
__$ArrayPad$ = 336
this$ = 368
out_pixels$ = 376
out_width$dead$ = 384
out_height$dead$ = 392
out_bytes_per_pixel$dead$ = 400
?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z PROC ; ImFontAtlas::GetTexDataAsAlpha8

; 2039 : {

$LN32:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	55		 push	 rbp
  0000b	48 8d 6c 24 a0	 lea	 rbp, QWORD PTR [rsp-96]
  00010	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 45 50	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 2040 :     // Build atlas on demand
; 2041 :     if (TexPixelsAlpha8 == NULL)

  00025	48 83 79 20 00	 cmp	 QWORD PTR [rcx+32], 0
  0002a	48 8b fa	 mov	 rdi, rdx
  0002d	48 8b d9	 mov	 rbx, rcx
  00030	0f 85 8f 01 00
	00		 jne	 $LN30@GetTexData

; 2262 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00036	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  0003a	74 1a		 je	 SHORT $LN12@GetTexData
  0003c	41 b8 d6 08 00
	00		 mov	 r8d, 2262		; 000008d6H
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN12@GetTexData:

; 2263 : 
; 2264 :     // Default font is none are specified
; 2265 :     if (ConfigData.Size == 0)

  00056	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  0005a	0f 85 36 01 00
	00		 jne	 $LN8@GetTexData

; 1916 :     GlyphMaxAdvanceX = FLT_MAX;

  00060	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@7f7fffff
  00068	0f 57 e4	 xorps	 xmm4, xmm4

; 1917 :     RasterizerMultiply = 1.0f;

  0006b	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00073	33 c0		 xor	 eax, eax
  00075	0f 11 65 d0	 movups	 XMMWORD PTR $T2[rbp-240], xmm4
  00079	48 89 45 40	 mov	 QWORD PTR $T2[rbp-128], rax

; 1918 :     EllipsisChar = (ImWchar)-1;

  0007d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00082	0f 11 65 c0	 movups	 XMMWORD PTR $T2[rbp-256], xmm4
  00086	c6 45 cc 01	 mov	 BYTE PTR $T2[rbp-244], 1

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  0008a	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T2[rbp-256]
  0008e	0f 29 44 24 30	 movaps	 XMMWORD PTR font_cfg$1[rsp], xmm0
  00093	0f 57 c0	 xorps	 xmm0, xmm0
  00096	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H
  0009a	f3 0f 10 c2	 movss	 xmm0, xmm2

; 1914 :     OversampleH = 3; // FIXME: 2 may be a better default?

  0009e	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR $T2[rbp-232], 3

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000a5	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H
  000a9	0f 29 44 24 70	 movaps	 XMMWORD PTR font_cfg$1[rsp+64], xmm0

; 1912 :     memset(this, 0, sizeof(*this));

  000ae	0f 11 65 10	 movups	 XMMWORD PTR $T2[rbp-176], xmm4

; 1918 :     EllipsisChar = (ImWchar)-1;

  000b2	66 89 45 14	 mov	 WORD PTR $T2[rbp-172], ax

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000b6	0f 28 45 10	 movaps	 xmm0, XMMWORD PTR $T2[rbp-176]
  000ba	f3 0f 10 c3	 movss	 xmm0, xmm3

; 1915 :     OversampleV = 1;

  000be	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR $T2[rbp-228], 1

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000c5	0f 28 4d d0	 movaps	 xmm1, XMMWORD PTR $T2[rbp-240]
  000c9	0f 29 4c 24 40	 movaps	 XMMWORD PTR font_cfg$1[rsp+16], xmm1

; 2126 :     if (!font_cfg_template)
; 2127 :     {
; 2128 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;
; 2129 :         font_cfg.PixelSnapH = true;
; 2130 :     }
; 2131 :     if (font_cfg.SizePixels <= 0.0f)

  000ce	f3 0f 10 54 24
	44		 movss	 xmm2, DWORD PTR font_cfg$1[rsp+20]
  000d4	0f 29 45 80	 movaps	 XMMWORD PTR font_cfg$1[rbp-176], xmm0
  000d8	f2 0f 10 45 40	 movsd	 xmm0, QWORD PTR $T2[rbp-128]
  000dd	f2 0f 11 45 b0	 movsd	 QWORD PTR font_cfg$1[rbp-128], xmm0
  000e2	0f 57 c0	 xorps	 xmm0, xmm0
  000e5	0f 2f c2	 comiss	 xmm0, xmm2
  000e8	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR font_cfg$1[rsp+28], 1
  000f0	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR font_cfg$1[rsp+24], 1
  000f8	0f 29 64 24 50	 movaps	 XMMWORD PTR font_cfg$1[rsp+32], xmm4
  000fd	0f 29 64 24 60	 movaps	 XMMWORD PTR font_cfg$1[rsp+48], xmm4
  00102	0f 29 65 90	 movaps	 XMMWORD PTR font_cfg$1[rbp-160], xmm4
  00106	0f 29 65 a0	 movaps	 XMMWORD PTR font_cfg$1[rbp-144], xmm4
  0010a	c6 44 24 50 01	 mov	 BYTE PTR font_cfg$1[rsp+32], 1
  0010f	72 0e		 jb	 SHORT $LN15@GetTexData

; 2132 :         font_cfg.SizePixels = 13.0f * 1.0f;

  00111	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@41500000
  00119	f3 0f 11 54 24
	44		 movss	 DWORD PTR font_cfg$1[rsp+20], xmm2
$LN15@GetTexData:

; 2133 :     if (font_cfg.Name[0] == '\0')

  0011f	80 7d 86 00	 cmp	 BYTE PTR font_cfg$1[rbp-170], 0
  00123	75 20		 jne	 SHORT $LN16@GetTexData

; 2134 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

  00125	f3 44 0f 2c ca	 cvttss2si r9d, xmm2
  0012a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
  00131	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00136	48 8d 4d 86	 lea	 rcx, QWORD PTR font_cfg$1[rbp-170]
  0013a	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPEAD_KPEBDZZ ; ImFormatString
  0013f	f3 0f 10 54 24
	44		 movss	 xmm2, DWORD PTR font_cfg$1[rsp+20]
$LN16@GetTexData:

; 2135 :     font_cfg.EllipsisChar = (ImWchar)0x0085;
; 2136 :     font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units

  00145	0f 28 c2	 movaps	 xmm0, xmm2

; 2137 : 
; 2138 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2139 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
  0014f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41500000
  00157	b8 85 00 00 00	 mov	 eax, 133		; 00000085H

; 2140 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

  0015c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR font_cfg$1[rsp]
  00161	66 89 45 84	 mov	 WORD PTR font_cfg$1[rbp-172], ax
  00165	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB
  0016c	f3 0f 2c c0	 cvttss2si eax, xmm0
  00170	66 0f 6e c0	 movd	 xmm0, eax

; 2137 : 
; 2138 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2139 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

  00174	48 8b 44 24 68	 mov	 rax, QWORD PTR font_cfg$1[rsp+56]
  00179	48 85 c0	 test	 rax, rax
  0017c	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0017f	48 0f 45 c8	 cmovne	 rcx, rax

; 2140 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

  00183	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00188	48 8b cb	 mov	 rcx, rbx
  0018b	f3 0f 11 44 24
	60		 movss	 DWORD PTR font_cfg$1[rsp+48], xmm0
  00191	e8 00 00 00 00	 call	 ?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
$LN8@GetTexData:

; 2273 :     const ImFontBuilderIO* builder_io = FontBuilderIO;

  00196	48 8b 83 78 04
	00 00		 mov	 rax, QWORD PTR [rbx+1144]

; 2274 :     if (builder_io == NULL)

  0019d	48 85 c0	 test	 rax, rax
  001a0	75 15		 jne	 SHORT $LN9@GetTexData

; 2599 :     io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;

  001a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
  001a9	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A, rax

; 2279 :         builder_io = ImFontAtlasGetBuilderForStbTruetype();

  001b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A
$LN9@GetTexData:

; 2280 : #else
; 2281 :         IM_ASSERT(0); // Invalid Build function
; 2282 : #endif
; 2283 :     }
; 2284 : 
; 2285 :     // Build
; 2286 :     return builder_io->FontBuilder_Build(this);

  001b7	48 8b cb	 mov	 rcx, rbx
  001ba	ff 10		 call	 QWORD PTR [rax]

; 2042 :         Build();
; 2043 : 
; 2044 :     *out_pixels = TexPixelsAlpha8;

  001bc	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001c0	48 89 07	 mov	 QWORD PTR [rdi], rax
  001c3	eb 07		 jmp	 SHORT $LN2@GetTexData
$LN30@GetTexData:
  001c5	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  001c9	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN2@GetTexData:

; 2045 :     if (out_width) *out_width = TexWidth;
; 2046 :     if (out_height) *out_height = TexHeight;
; 2047 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;
; 2048 : }

  001cc	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  001d0	48 33 cc	 xor	 rcx, rsp
  001d3	e8 00 00 00 00	 call	 __security_check_cookie
  001d8	4c 8d 9c 24 60
	01 00 00	 lea	 r11, QWORD PTR [rsp+352]
  001e0	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  001e4	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  001e8	49 8b e3	 mov	 rsp, r11
  001eb	5d		 pop	 rbp
  001ec	c3		 ret	 0
?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ENDP ; ImFontAtlas::GetTexDataAsAlpha8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
font_cfg$1 = 48
$T2 = 192
__$ArrayPad$3 = 336
this$ = 416
out_pixels$ = 424
out_width$ = 432
out_height$ = 440
out_bytes_per_pixel$dead$ = 448
?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z PROC ; ImFontAtlas::GetTexDataAsRGBA32

; 2051 : {

$LN53:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	55		 push	 rbp
  00004	53		 push	 rbx
  00005	56		 push	 rsi
  00006	48 8d 6c 24 80	 lea	 rbp, QWORD PTR [rsp-128]
  0000b	48 81 ec 80 01
	00 00		 sub	 rsp, 384		; 00000180H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 45 50	 mov	 QWORD PTR __$ArrayPad$3[rbp-256], rax

; 2052 :     // Convert to RGBA32 format on demand
; 2053 :     // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
; 2054 :     if (!TexPixelsRGBA32)

  00020	48 83 79 28 00	 cmp	 QWORD PTR [rcx+40], 0
  00025	49 8b f1	 mov	 rsi, r9
  00028	4d 89 73 d8	 mov	 QWORD PTR [r11-40], r14
  0002c	48 8b d9	 mov	 rbx, rcx
  0002f	4d 89 7b d0	 mov	 QWORD PTR [r11-48], r15
  00033	4d 8b f0	 mov	 r14, r8
  00036	4c 8b fa	 mov	 r15, rdx
  00039	0f 85 06 02 00
	00		 jne	 $LN3@GetTexData

; 2041 :     if (TexPixelsAlpha8 == NULL)

  0003f	48 83 79 20 00	 cmp	 QWORD PTR [rcx+32], 0
  00044	49 89 7b e0	 mov	 QWORD PTR [r11-32], rdi
  00048	0f 85 86 01 00
	00		 jne	 $LN12@GetTexData

; 2262 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0004e	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  00052	74 1a		 je	 SHORT $LN22@GetTexData
  00054	41 b8 d6 08 00
	00		 mov	 r8d, 2262		; 000008d6H
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN22@GetTexData:

; 2263 : 
; 2264 :     // Default font is none are specified
; 2265 :     if (ConfigData.Size == 0)

  0006e	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  00072	0f 85 36 01 00
	00		 jne	 $LN18@GetTexData

; 1916 :     GlyphMaxAdvanceX = FLT_MAX;

  00078	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@7f7fffff
  00080	0f 57 e4	 xorps	 xmm4, xmm4

; 1917 :     RasterizerMultiply = 1.0f;

  00083	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  0008b	33 c0		 xor	 eax, eax
  0008d	0f 11 65 d0	 movups	 XMMWORD PTR $T2[rbp-240], xmm4
  00091	48 89 45 40	 mov	 QWORD PTR $T2[rbp-128], rax

; 1918 :     EllipsisChar = (ImWchar)-1;

  00095	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0009a	0f 11 65 c0	 movups	 XMMWORD PTR $T2[rbp-256], xmm4
  0009e	c6 45 cc 01	 mov	 BYTE PTR $T2[rbp-244], 1

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000a2	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T2[rbp-256]
  000a6	0f 29 44 24 30	 movaps	 XMMWORD PTR font_cfg$1[rsp], xmm0
  000ab	0f 57 c0	 xorps	 xmm0, xmm0
  000ae	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H
  000b2	f3 0f 10 c2	 movss	 xmm0, xmm2

; 1914 :     OversampleH = 3; // FIXME: 2 may be a better default?

  000b6	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR $T2[rbp-232], 3

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000bd	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H
  000c1	0f 29 44 24 70	 movaps	 XMMWORD PTR font_cfg$1[rsp+64], xmm0

; 1912 :     memset(this, 0, sizeof(*this));

  000c6	0f 11 65 10	 movups	 XMMWORD PTR $T2[rbp-176], xmm4

; 1918 :     EllipsisChar = (ImWchar)-1;

  000ca	66 89 45 14	 mov	 WORD PTR $T2[rbp-172], ax

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000ce	0f 28 45 10	 movaps	 xmm0, XMMWORD PTR $T2[rbp-176]
  000d2	f3 0f 10 c3	 movss	 xmm0, xmm3

; 1915 :     OversampleV = 1;

  000d6	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR $T2[rbp-228], 1

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000dd	0f 28 4d d0	 movaps	 xmm1, XMMWORD PTR $T2[rbp-240]
  000e1	0f 29 4c 24 40	 movaps	 XMMWORD PTR font_cfg$1[rsp+16], xmm1

; 2126 :     if (!font_cfg_template)
; 2127 :     {
; 2128 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;
; 2129 :         font_cfg.PixelSnapH = true;
; 2130 :     }
; 2131 :     if (font_cfg.SizePixels <= 0.0f)

  000e6	f3 0f 10 54 24
	44		 movss	 xmm2, DWORD PTR font_cfg$1[rsp+20]
  000ec	0f 29 45 80	 movaps	 XMMWORD PTR font_cfg$1[rbp-176], xmm0
  000f0	f2 0f 10 45 40	 movsd	 xmm0, QWORD PTR $T2[rbp-128]
  000f5	f2 0f 11 45 b0	 movsd	 QWORD PTR font_cfg$1[rbp-128], xmm0
  000fa	0f 57 c0	 xorps	 xmm0, xmm0
  000fd	0f 2f c2	 comiss	 xmm0, xmm2
  00100	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR font_cfg$1[rsp+28], 1
  00108	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR font_cfg$1[rsp+24], 1
  00110	0f 29 64 24 50	 movaps	 XMMWORD PTR font_cfg$1[rsp+32], xmm4
  00115	0f 29 64 24 60	 movaps	 XMMWORD PTR font_cfg$1[rsp+48], xmm4
  0011a	0f 29 65 90	 movaps	 XMMWORD PTR font_cfg$1[rbp-160], xmm4
  0011e	0f 29 65 a0	 movaps	 XMMWORD PTR font_cfg$1[rbp-144], xmm4
  00122	c6 44 24 50 01	 mov	 BYTE PTR font_cfg$1[rsp+32], 1
  00127	72 0e		 jb	 SHORT $LN25@GetTexData

; 2132 :         font_cfg.SizePixels = 13.0f * 1.0f;

  00129	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@41500000
  00131	f3 0f 11 54 24
	44		 movss	 DWORD PTR font_cfg$1[rsp+20], xmm2
$LN25@GetTexData:

; 2133 :     if (font_cfg.Name[0] == '\0')

  00137	80 7d 86 00	 cmp	 BYTE PTR font_cfg$1[rbp-170], 0
  0013b	75 20		 jne	 SHORT $LN26@GetTexData

; 2134 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

  0013d	f3 44 0f 2c ca	 cvttss2si r9d, xmm2
  00142	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
  00149	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0014e	48 8d 4d 86	 lea	 rcx, QWORD PTR font_cfg$1[rbp-170]
  00152	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPEAD_KPEBDZZ ; ImFormatString
  00157	f3 0f 10 54 24
	44		 movss	 xmm2, DWORD PTR font_cfg$1[rsp+20]
$LN26@GetTexData:

; 2135 :     font_cfg.EllipsisChar = (ImWchar)0x0085;
; 2136 :     font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units

  0015d	0f 28 c2	 movaps	 xmm0, xmm2

; 2137 : 
; 2138 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2139 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
  00167	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41500000
  0016f	b8 85 00 00 00	 mov	 eax, 133		; 00000085H

; 2140 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

  00174	4c 8d 4c 24 30	 lea	 r9, QWORD PTR font_cfg$1[rsp]
  00179	66 89 45 84	 mov	 WORD PTR font_cfg$1[rbp-172], ax
  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB
  00184	f3 0f 2c c0	 cvttss2si eax, xmm0
  00188	66 0f 6e c0	 movd	 xmm0, eax

; 2137 : 
; 2138 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2139 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

  0018c	48 8b 44 24 68	 mov	 rax, QWORD PTR font_cfg$1[rsp+56]
  00191	48 85 c0	 test	 rax, rax
  00194	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00197	48 0f 45 c8	 cmovne	 rcx, rax

; 2140 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

  0019b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001a0	48 8b cb	 mov	 rcx, rbx
  001a3	f3 0f 11 44 24
	60		 movss	 DWORD PTR font_cfg$1[rsp+48], xmm0
  001a9	e8 00 00 00 00	 call	 ?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
$LN18@GetTexData:

; 2273 :     const ImFontBuilderIO* builder_io = FontBuilderIO;

  001ae	48 8b 83 78 04
	00 00		 mov	 rax, QWORD PTR [rbx+1144]

; 2274 :     if (builder_io == NULL)

  001b5	48 85 c0	 test	 rax, rax
  001b8	75 15		 jne	 SHORT $LN19@GetTexData

; 2599 :     io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;

  001ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
  001c1	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A, rax

; 2279 :         builder_io = ImFontAtlasGetBuilderForStbTruetype();

  001c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A
$LN19@GetTexData:

; 2280 : #else
; 2281 :         IM_ASSERT(0); // Invalid Build function
; 2282 : #endif
; 2283 :     }
; 2284 : 
; 2285 :     // Build
; 2286 :     return builder_io->FontBuilder_Build(this);

  001cf	48 8b cb	 mov	 rcx, rbx
  001d2	ff 10		 call	 QWORD PTR [rax]
$LN12@GetTexData:

; 2044 :     *out_pixels = TexPixelsAlpha8;

  001d4	48 8b 7b 20	 mov	 rdi, QWORD PTR [rbx+32]

; 2055 :     {
; 2056 :         unsigned char* pixels = NULL;
; 2057 :         GetTexDataAsAlpha8(&pixels, NULL, NULL);
; 2058 :         if (pixels)

  001d8	48 85 ff	 test	 rdi, rdi
  001db	74 60		 je	 SHORT $LN51@GetTexData

; 2060 :             TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);

  001dd	48 63 43 30	 movsxd	 rax, DWORD PTR [rbx+48]
  001e1	48 63 4b 34	 movsxd	 rcx, DWORD PTR [rbx+52]
  001e5	48 0f af c8	 imul	 rcx, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  001e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2060 :             TexPixelsRGBA32 = (unsigned int*)IM_ALLOC((size_t)TexWidth * (size_t)TexHeight * 4);

  001f0	48 c1 e1 02	 shl	 rcx, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  001f4	48 85 c0	 test	 rax, rax
  001f7	74 06		 je	 SHORT $LN41@GetTexData

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  001f9	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN41@GetTexData:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2063 :             for (int n = TexWidth * TexHeight; n > 0; n--)

  00205	8b 53 34	 mov	 edx, DWORD PTR [rbx+52]
  00208	0f af 53 30	 imul	 edx, DWORD PTR [rbx+48]
  0020c	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00210	85 d2		 test	 edx, edx
  00212	7e 29		 jle	 SHORT $LN51@GetTexData
  00214	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@GetTexData:

; 2064 :                 *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));

  00220	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00223	48 8d 40 04	 lea	 rax, QWORD PTR [rax+4]
  00227	c1 e1 18	 shl	 ecx, 24
  0022a	48 8d 7f 01	 lea	 rdi, QWORD PTR [rdi+1]
  0022e	81 c9 ff ff ff
	00		 or	 ecx, 16777215		; 00ffffffH
  00234	ff ca		 dec	 edx
  00236	89 48 fc	 mov	 DWORD PTR [rax-4], ecx
  00239	85 d2		 test	 edx, edx
  0023b	7f e3		 jg	 SHORT $LL4@GetTexData
$LN51@GetTexData:
  0023d	48 8b bc 24 78
	01 00 00	 mov	 rdi, QWORD PTR [rsp+376]
$LN3@GetTexData:

; 2065 :         }
; 2066 :     }
; 2067 : 
; 2068 :     *out_pixels = (unsigned char*)TexPixelsRGBA32;

  00245	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00249	49 89 07	 mov	 QWORD PTR [r15], rax
  0024c	4c 8b bc 24 68
	01 00 00	 mov	 r15, QWORD PTR [rsp+360]

; 2069 :     if (out_width) *out_width = TexWidth;

  00254	4d 85 f6	 test	 r14, r14
  00257	74 06		 je	 SHORT $LN7@GetTexData
  00259	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  0025c	41 89 06	 mov	 DWORD PTR [r14], eax
$LN7@GetTexData:

; 2070 :     if (out_height) *out_height = TexHeight;

  0025f	4c 8b b4 24 70
	01 00 00	 mov	 r14, QWORD PTR [rsp+368]
  00267	48 85 f6	 test	 rsi, rsi
  0026a	74 05		 je	 SHORT $LN9@GetTexData
  0026c	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  0026f	89 06		 mov	 DWORD PTR [rsi], eax
$LN9@GetTexData:

; 2071 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;
; 2072 : }

  00271	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ArrayPad$3[rbp-256]
  00275	48 33 cc	 xor	 rcx, rsp
  00278	e8 00 00 00 00	 call	 __security_check_cookie
  0027d	48 81 c4 80 01
	00 00		 add	 rsp, 384		; 00000180H
  00284	5e		 pop	 rsi
  00285	5b		 pop	 rbx
  00286	5d		 pop	 rbp
  00287	c3		 ret	 0
?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z ENDP ; ImFontAtlas::GetTexDataAsRGBA32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 64
this$ = 64
font_cfg$ = 72
?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z PROC ; ImFontAtlas::AddFont

; 2075 : {

$LN76:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2076 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00018	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  0001c	4c 8b f2	 mov	 r14, rdx
  0001f	48 8b d9	 mov	 rbx, rcx
  00022	74 1a		 je	 SHORT $LN9@AddFont
  00024	41 b8 1c 08 00
	00		 mov	 r8d, 2076		; 0000081cH
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN9@AddFont:

; 2077 :     IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);

  0003e	49 83 3e 00	 cmp	 QWORD PTR [r14], 0
  00042	74 07		 je	 SHORT $LN10@AddFont
  00044	41 83 7e 08 00	 cmp	 DWORD PTR [r14+8], 0
  00049	7f 1a		 jg	 SHORT $LN11@AddFont
$LN10@AddFont:
  0004b	41 b8 1d 08 00
	00		 mov	 r8d, 2077		; 0000081dH
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GM@FAHJAOLI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AAD@
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN11@AddFont:

; 2078 :     IM_ASSERT(font_cfg->SizePixels > 0.0f);

  00065	f3 41 0f 10 4e
	14		 movss	 xmm1, DWORD PTR [r14+20]
  0006b	0f 57 c0	 xorps	 xmm0, xmm0
  0006e	0f 2f c8	 comiss	 xmm1, xmm0
  00071	77 1a		 ja	 SHORT $LN12@AddFont
  00073	41 b8 1e 08 00
	00		 mov	 r8d, 2078		; 0000081eH
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@LEOIHPJH@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?9?$AA?$DO?$AAS?$AAi?$AAz?$AAe?$AAP@
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN12@AddFont:

; 2079 : 
; 2080 :     // Create new font
; 2081 :     if (!font_cfg->MergeMode)

  0008d	41 80 7e 48 00	 cmp	 BYTE PTR [r14+72], 0
  00092	bd ff ff 00 00	 mov	 ebp, 65535		; 0000ffffH
  00097	0f 85 87 00 00
	00		 jne	 $LN2@AddFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0009d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000a4	48 85 c0	 test	 rax, rax
  000a7	74 06		 je	 SHORT $LN19@AddFont

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  000a9	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN19@AddFont:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  000af	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2082 :         Fonts.push_back(IM_NEW(ImFont));

  000ba	33 c9		 xor	 ecx, ecx
  000bc	48 85 c0	 test	 rax, rax
  000bf	74 4b		 je	 SHORT $LN13@AddFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  000c1	48 89 08	 mov	 QWORD PTR [rax], rcx
  000c4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000c8	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  000cc	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  000d0	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
  000d4	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3108 :     FallbackAdvanceX = 0.0f;

  000d8	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3109 :     FallbackChar = (ImWchar)-1;

  000dc	c7 40 52 ff ff
	ff ff		 mov	 DWORD PTR [rax+82], -1	; ffffffffH

; 3110 :     EllipsisChar = (ImWchar)-1;
; 3111 :     DotChar = (ImWchar)-1;

  000e3	66 89 68 56	 mov	 WORD PTR [rax+86], bp

; 3112 :     FallbackGlyph = NULL;

  000e7	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 3113 :     ContainerAtlas = NULL;

  000eb	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 3114 :     ConfigData = NULL;

  000ef	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 3115 :     ConfigDataCount = 0;

  000f3	66 89 48 50	 mov	 WORD PTR [rax+80], cx

; 3116 :     DirtyLookupTables = false;

  000f7	88 48 58	 mov	 BYTE PTR [rax+88], cl

; 3117 :     Scale = 1.0f;

  000fa	48 c7 40 5c 00
	00 80 3f	 mov	 QWORD PTR [rax+92], 1065353216 ; 3f800000H

; 3118 :     Ascent = Descent = 0.0f;

  00102	48 89 48 64	 mov	 QWORD PTR [rax+100], rcx

; 3119 :     MetricsTotalSurface = 0;
; 3120 :     memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));

  00106	66 89 48 6c	 mov	 WORD PTR [rax+108], cx

; 2082 :         Fonts.push_back(IM_NEW(ImFont));

  0010a	eb 03		 jmp	 SHORT $LN14@AddFont
$LN13@AddFont:
  0010c	48 8b c1	 mov	 rax, rcx
$LN14@AddFont:
  0010f	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T1[rsp]
  00114	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  00119	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
  0011d	e8 00 00 00 00	 call	 ?push_back@?$ImVector@PEAUImFont@@@@QEAAXAEBQEAUImFont@@@Z ; ImVector<ImFont *>::push_back
  00122	eb 20		 jmp	 SHORT $LN16@AddFont
$LN2@AddFont:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1789 :     inline bool         empty() const { return Size == 0; }

  00124	83 7b 48 00	 cmp	 DWORD PTR [rbx+72], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2084 :         IM_ASSERT(!Fonts.empty() && "Cannot use MergeMode for the first font"); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.

  00128	75 1a		 jne	 SHORT $LN16@AddFont
  0012a	41 b8 24 08 00
	00		 mov	 r8d, 2084		; 00000824H
  00130	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HI@KOOOLAEJ@?$AA?$CB?$AAF?$AAo?$AAn?$AAt?$AAs?$AA?4?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AA?$CJ?$AA?5@
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN16@AddFont:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00144	8b 7b 68	 mov	 edi, DWORD PTR [rbx+104]
  00147	8b 4b 6c	 mov	 ecx, DWORD PTR [rbx+108]
  0014a	3b f9		 cmp	 edi, ecx
  0014c	0f 85 88 00 00
	00		 jne	 $LN42@AddFont
  00152	ff c7		 inc	 edi

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00154	85 c9		 test	 ecx, ecx
  00156	74 0b		 je	 SHORT $LN40@AddFont
  00158	8b c1		 mov	 eax, ecx
  0015a	99		 cdq
  0015b	2b c2		 sub	 eax, edx
  0015d	d1 f8		 sar	 eax, 1
  0015f	03 c1		 add	 eax, ecx
  00161	eb 05		 jmp	 SHORT $LN41@AddFont
$LN40@AddFont:
  00163	b8 08 00 00 00	 mov	 eax, 8
$LN41@AddFont:
  00168	3b c7		 cmp	 eax, edi
  0016a	0f 4f f8	 cmovg	 edi, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0016d	3b f9		 cmp	 edi, ecx
  0016f	7e 69		 jle	 SHORT $LN42@AddFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00171	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00178	48 85 c0	 test	 rax, rax
  0017b	74 06		 je	 SHORT $LN47@AddFont

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  0017d	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN47@AddFont:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00183	48 63 c7	 movsxd	 rax, edi
  00186	48 69 c8 88 00
	00 00		 imul	 rcx, rax, 136		; 00000088H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00193	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00197	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0019a	48 85 d2	 test	 rdx, rdx
  0019d	74 34		 je	 SHORT $LN57@AddFont
  0019f	48 63 4b 68	 movsxd	 rcx, DWORD PTR [rbx+104]
  001a3	4c 69 c1 88 00
	00 00		 imul	 r8, rcx, 136		; 00000088H
  001aa	48 8b c8	 mov	 rcx, rax
  001ad	e8 00 00 00 00	 call	 memcpy
  001b2	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  001b6	48 85 c9	 test	 rcx, rcx
  001b9	74 12		 je	 SHORT $LN55@AddFont

; 3610 :         if (ImGuiContext* ctx = GImGui)

  001bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  001c2	48 85 c0	 test	 rax, rax
  001c5	74 06		 je	 SHORT $LN55@AddFont

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  001c7	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN55@AddFont:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN57@AddFont:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  001d3	48 89 73 70	 mov	 QWORD PTR [rbx+112], rsi
  001d7	89 7b 6c	 mov	 DWORD PTR [rbx+108], edi
$LN42@AddFont:

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  001da	48 63 43 68	 movsxd	 rax, DWORD PTR [rbx+104]
  001de	41 0f 10 06	 movups	 xmm0, XMMWORD PTR [r14]
  001e2	41 0f 10 4e 10	 movups	 xmm1, XMMWORD PTR [r14+16]
  001e7	48 69 c8 88 00
	00 00		 imul	 rcx, rax, 136		; 00000088H
  001ee	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  001f2	0f 11 04 01	 movups	 XMMWORD PTR [rcx+rax], xmm0
  001f6	41 0f 10 46 20	 movups	 xmm0, XMMWORD PTR [r14+32]
  001fb	0f 11 4c 01 10	 movups	 XMMWORD PTR [rcx+rax+16], xmm1
  00200	41 0f 10 4e 30	 movups	 xmm1, XMMWORD PTR [r14+48]
  00205	0f 11 44 01 20	 movups	 XMMWORD PTR [rcx+rax+32], xmm0
  0020a	41 0f 10 46 40	 movups	 xmm0, XMMWORD PTR [r14+64]
  0020f	0f 11 4c 01 30	 movups	 XMMWORD PTR [rcx+rax+48], xmm1
  00214	41 0f 10 4e 50	 movups	 xmm1, XMMWORD PTR [r14+80]
  00219	0f 11 44 01 40	 movups	 XMMWORD PTR [rcx+rax+64], xmm0
  0021e	41 0f 10 46 60	 movups	 xmm0, XMMWORD PTR [r14+96]
  00223	0f 11 4c 01 50	 movups	 XMMWORD PTR [rcx+rax+80], xmm1
  00228	41 0f 10 4e 70	 movups	 xmm1, XMMWORD PTR [r14+112]
  0022d	0f 11 44 01 60	 movups	 XMMWORD PTR [rcx+rax+96], xmm0
  00232	f2 41 0f 10 86
	80 00 00 00	 movsd	 xmm0, QWORD PTR [r14+128]
  0023b	0f 11 4c 01 70	 movups	 XMMWORD PTR [rcx+rax+112], xmm1
  00240	f2 0f 11 84 01
	80 00 00 00	 movsd	 QWORD PTR [rcx+rax+128], xmm0
  00249	ff 43 68	 inc	 DWORD PTR [rbx+104]
  0024c	8b 43 68	 mov	 eax, DWORD PTR [rbx+104]

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  0024f	85 c0		 test	 eax, eax
  00251	7f 1d		 jg	 SHORT $LN63@AddFont
  00253	41 b8 0b 07 00
	00		 mov	 r8d, 1803		; 0000070bH
  00259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0026d	8b 43 68	 mov	 eax, DWORD PTR [rbx+104]
$LN63@AddFont:
  00270	48 8b 73 70	 mov	 rsi, QWORD PTR [rbx+112]
  00274	48 98		 cdqe
  00276	48 69 f8 88 00
	00 00		 imul	 rdi, rax, 136		; 00000088H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2088 :     if (new_font_cfg.DstFont == NULL)

  0027d	48 83 7c 37 f8
	00		 cmp	 QWORD PTR [rdi+rsi-8], 0
  00283	75 35		 jne	 SHORT $LN4@AddFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00285	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  00288	85 c0		 test	 eax, eax
  0028a	7f 1d		 jg	 SHORT $LN66@AddFont
  0028c	41 b8 0b 07 00
	00		 mov	 r8d, 1803		; 0000070bH
  00292	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00299	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002a6	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
$LN66@AddFont:
  002a9	48 63 c8	 movsxd	 rcx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2089 :         new_font_cfg.DstFont = Fonts.back();

  002ac	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  002b0	48 8b 4c c8 f8	 mov	 rcx, QWORD PTR [rax+rcx*8-8]
  002b5	48 89 4c 37 f8	 mov	 QWORD PTR [rdi+rsi-8], rcx
$LN4@AddFont:

; 2090 :     if (!new_font_cfg.FontDataOwnedByAtlas)

  002ba	80 7c 37 84 00	 cmp	 BYTE PTR [rdi+rsi-124], 0
  002bf	75 3a		 jne	 SHORT $LN5@AddFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  002c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2092 :         new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize);

  002c8	48 63 4c 37 80	 movsxd	 rcx, DWORD PTR [rdi+rsi-128]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  002cd	48 85 c0	 test	 rax, rax
  002d0	74 06		 je	 SHORT $LN68@AddFont

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  002d2	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN68@AddFont:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2094 :         memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);

  002de	4c 63 44 37 80	 movsxd	 r8, DWORD PTR [rdi+rsi-128]
  002e3	48 8b c8	 mov	 rcx, rax
  002e6	49 8b 16	 mov	 rdx, QWORD PTR [r14]
  002e9	48 89 84 37 78
	ff ff ff	 mov	 QWORD PTR [rdi+rsi-136], rax
  002f1	c6 44 37 84 01	 mov	 BYTE PTR [rdi+rsi-124], 1
  002f6	e8 00 00 00 00	 call	 memcpy
$LN5@AddFont:

; 2095 :     }
; 2096 : 
; 2097 :     if (new_font_cfg.DstFont->EllipsisChar == (ImWchar)-1)

  002fb	48 8b 4c 37 f8	 mov	 rcx, QWORD PTR [rdi+rsi-8]
  00300	66 39 69 54	 cmp	 WORD PTR [rcx+84], bp
  00304	75 09		 jne	 SHORT $LN6@AddFont

; 2098 :         new_font_cfg.DstFont->EllipsisChar = font_cfg->EllipsisChar;

  00306	41 0f b7 46 54	 movzx	 eax, WORD PTR [r14+84]
  0030b	66 89 41 54	 mov	 WORD PTR [rcx+84], ax
$LN6@AddFont:

; 2099 : 
; 2100 :     // Invalidate texture
; 2101 :     TexReady = false;
; 2102 :     ClearTexData();

  0030f	48 8b cb	 mov	 rcx, rbx
  00312	c6 43 19 00	 mov	 BYTE PTR [rbx+25], 0
  00316	e8 00 00 00 00	 call	 ?ClearTexData@ImFontAtlas@@QEAAXXZ ; ImFontAtlas::ClearTexData

; 2103 :     return new_font_cfg.DstFont;

  0031b	48 8b 44 37 f8	 mov	 rax, QWORD PTR [rdi+rsi-8]

; 2104 : }

  00320	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00325	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0032a	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0032f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00333	41 5f		 pop	 r15
  00335	41 5e		 pop	 r14
  00337	5f		 pop	 rdi
  00338	c3		 ret	 0
?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ENDP ; ImFontAtlas::AddFont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
c$ = 8
?Decode85Byte@@YAID@Z PROC				; Decode85Byte

; 2110 : static unsigned int Decode85Byte(char c) { return c >= '\\' ? c - 36 : c - 35; }

  00000	33 d2		 xor	 edx, edx
  00002	0f be c1	 movsx	 eax, cl
  00005	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  00008	0f 9d c2	 setge	 dl
  0000b	83 c2 23	 add	 edx, 35			; 00000023H
  0000e	2b c2		 sub	 eax, edx
  00010	c3		 ret	 0
?Decode85Byte@@YAID@Z ENDP				; Decode85Byte
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
src$ = 8
dst$ = 16
?Decode85@@YAXPEBEPEAE@Z PROC				; Decode85

; 2112 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 2113 :     while (*src)

  00005	0f b6 19	 movzx	 ebx, BYTE PTR [rcx]
  00008	84 db		 test	 bl, bl
  0000a	0f 84 b0 00 00
	00		 je	 $LN3@Decode85
  00010	4c 8d 5a 02	 lea	 r11, QWORD PTR [rdx+2]
  00014	4c 8d 51 02	 lea	 r10, QWORD PTR [rcx+2]
  00018	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@Decode85:

; 2114 :     {
; 2115 :         unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));

  00020	41 0f be 52 01	 movsx	 edx, BYTE PTR [r10+1]
  00025	33 c9		 xor	 ecx, ecx
  00027	41 0f be 42 02	 movsx	 eax, BYTE PTR [r10+2]

; 2116 :         dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
; 2117 :         src += 5;
; 2118 :         dst += 4;

  0002c	4d 8d 5b 04	 lea	 r11, QWORD PTR [r11+4]
  00030	45 0f be 02	 movsx	 r8d, BYTE PTR [r10]
  00034	3c 5c		 cmp	 al, 92			; 0000005cH
  00036	45 0f be 4a ff	 movsx	 r9d, BYTE PTR [r10-1]
  0003b	4d 8d 52 05	 lea	 r10, QWORD PTR [r10+5]
  0003f	0f 9d c1	 setge	 cl
  00042	83 c1 23	 add	 ecx, 35			; 00000023H
  00045	2b c1		 sub	 eax, ecx
  00047	6b c8 55	 imul	 ecx, eax, 85		; 00000055H
  0004a	33 c0		 xor	 eax, eax
  0004c	80 fa 5c	 cmp	 dl, 92			; 0000005cH
  0004f	0f 9d c0	 setge	 al
  00052	83 c0 23	 add	 eax, 35			; 00000023H
  00055	2b c8		 sub	 ecx, eax
  00057	33 c0		 xor	 eax, eax
  00059	03 ca		 add	 ecx, edx
  0005b	6b d1 55	 imul	 edx, ecx, 85		; 00000055H
  0005e	41 80 f8 5c	 cmp	 r8b, 92			; 0000005cH
  00062	0f 9d c0	 setge	 al
  00065	83 c0 23	 add	 eax, 35			; 00000023H
  00068	2b d0		 sub	 edx, eax
  0006a	33 c0		 xor	 eax, eax
  0006c	41 03 d0	 add	 edx, r8d
  0006f	6b ca 55	 imul	 ecx, edx, 85		; 00000055H
  00072	41 80 f9 5c	 cmp	 r9b, 92			; 0000005cH
  00076	0f 9d c0	 setge	 al
  00079	83 c0 23	 add	 eax, 35			; 00000023H
  0007c	2b c8		 sub	 ecx, eax
  0007e	33 c0		 xor	 eax, eax
  00080	41 03 c9	 add	 ecx, r9d
  00083	6b d1 55	 imul	 edx, ecx, 85		; 00000055H
  00086	80 fb 5c	 cmp	 bl, 92			; 0000005cH
  00089	0f 9d c0	 setge	 al
  0008c	83 c0 23	 add	 eax, 35			; 00000023H
  0008f	2b d0		 sub	 edx, eax
  00091	0f be c3	 movsx	 eax, bl
  00094	03 d0		 add	 edx, eax
  00096	41 88 53 fa	 mov	 BYTE PTR [r11-6], dl
  0009a	8b c2		 mov	 eax, edx
  0009c	c1 e8 08	 shr	 eax, 8
  0009f	41 88 43 fb	 mov	 BYTE PTR [r11-5], al
  000a3	8b c2		 mov	 eax, edx
  000a5	c1 e8 10	 shr	 eax, 16
  000a8	c1 ea 18	 shr	 edx, 24
  000ab	41 88 43 fc	 mov	 BYTE PTR [r11-4], al
  000af	41 88 53 fd	 mov	 BYTE PTR [r11-3], dl
  000b3	41 0f b6 5a fe	 movzx	 ebx, BYTE PTR [r10-2]
  000b8	84 db		 test	 bl, bl
  000ba	0f 85 60 ff ff
	ff		 jne	 $LL2@Decode85
$LN3@Decode85:

; 2119 :     }
; 2120 : }

  000c0	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000c5	c3		 ret	 0
?Decode85@@YAXPEBEPEAE@Z ENDP				; Decode85
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
font_cfg$ = 48
$T1 = 192
__$ArrayPad$ = 336
this$ = 368
font_cfg_template$dead$ = 376
?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z PROC ; ImFontAtlas::AddFontDefault

; 2124 : {

$LN17:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	48 8d 6c 24 a0	 lea	 rbp, QWORD PTR [rsp-96]
  0000b	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 45 50	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 1916 :     GlyphMaxAdvanceX = FLT_MAX;

  00020	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@7f7fffff
  00028	0f 57 e4	 xorps	 xmm4, xmm4

; 1917 :     RasterizerMultiply = 1.0f;

  0002b	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00033	33 c0		 xor	 eax, eax
  00035	0f 11 65 d0	 movups	 XMMWORD PTR $T1[rbp-240], xmm4
  00039	48 89 45 40	 mov	 QWORD PTR $T1[rbp-128], rax

; 1918 :     EllipsisChar = (ImWchar)-1;

  0003d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00042	0f 11 65 c0	 movups	 XMMWORD PTR $T1[rbp-256], xmm4
  00046	c6 45 cc 01	 mov	 BYTE PTR $T1[rbp-244], 1

; 2124 : {

  0004a	48 8b d9	 mov	 rbx, rcx

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  0004d	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T1[rbp-256]
  00051	0f 29 44 24 30	 movaps	 XMMWORD PTR font_cfg$[rsp], xmm0
  00056	0f 57 c0	 xorps	 xmm0, xmm0
  00059	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H
  0005d	f3 0f 10 c2	 movss	 xmm0, xmm2

; 1914 :     OversampleH = 3; // FIXME: 2 may be a better default?

  00061	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR $T1[rbp-232], 3

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  00068	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H
  0006c	0f 29 44 24 70	 movaps	 XMMWORD PTR font_cfg$[rsp+64], xmm0

; 1912 :     memset(this, 0, sizeof(*this));

  00071	0f 11 65 10	 movups	 XMMWORD PTR $T1[rbp-176], xmm4

; 1918 :     EllipsisChar = (ImWchar)-1;

  00075	66 89 45 14	 mov	 WORD PTR $T1[rbp-172], ax

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  00079	0f 28 45 10	 movaps	 xmm0, XMMWORD PTR $T1[rbp-176]
  0007d	f3 0f 10 c3	 movss	 xmm0, xmm3

; 1915 :     OversampleV = 1;

  00081	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR $T1[rbp-228], 1

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  00088	0f 28 4d d0	 movaps	 xmm1, XMMWORD PTR $T1[rbp-240]
  0008c	0f 29 4c 24 40	 movaps	 XMMWORD PTR font_cfg$[rsp+16], xmm1

; 2126 :     if (!font_cfg_template)
; 2127 :     {
; 2128 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;
; 2129 :         font_cfg.PixelSnapH = true;
; 2130 :     }
; 2131 :     if (font_cfg.SizePixels <= 0.0f)

  00091	f3 0f 10 54 24
	44		 movss	 xmm2, DWORD PTR font_cfg$[rsp+20]
  00097	0f 29 45 80	 movaps	 XMMWORD PTR font_cfg$[rbp-176], xmm0
  0009b	f2 0f 10 45 40	 movsd	 xmm0, QWORD PTR $T1[rbp-128]
  000a0	f2 0f 11 45 b0	 movsd	 QWORD PTR font_cfg$[rbp-128], xmm0
  000a5	0f 57 c0	 xorps	 xmm0, xmm0
  000a8	0f 2f c2	 comiss	 xmm0, xmm2
  000ab	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR font_cfg$[rsp+28], 1
  000b3	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR font_cfg$[rsp+24], 1
  000bb	0f 29 64 24 50	 movaps	 XMMWORD PTR font_cfg$[rsp+32], xmm4
  000c0	0f 29 64 24 60	 movaps	 XMMWORD PTR font_cfg$[rsp+48], xmm4
  000c5	0f 29 65 90	 movaps	 XMMWORD PTR font_cfg$[rbp-160], xmm4
  000c9	0f 29 65 a0	 movaps	 XMMWORD PTR font_cfg$[rbp-144], xmm4
  000cd	c6 44 24 50 01	 mov	 BYTE PTR font_cfg$[rsp+32], 1
  000d2	72 0e		 jb	 SHORT $LN3@AddFontDef

; 2132 :         font_cfg.SizePixels = 13.0f * 1.0f;

  000d4	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@41500000
  000dc	f3 0f 11 54 24
	44		 movss	 DWORD PTR font_cfg$[rsp+20], xmm2
$LN3@AddFontDef:

; 2133 :     if (font_cfg.Name[0] == '\0')

  000e2	80 7d 86 00	 cmp	 BYTE PTR font_cfg$[rbp-170], 0
  000e6	75 20		 jne	 SHORT $LN4@AddFontDef

; 2134 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

  000e8	f3 44 0f 2c ca	 cvttss2si r9d, xmm2
  000ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
  000f4	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  000f9	48 8d 4d 86	 lea	 rcx, QWORD PTR font_cfg$[rbp-170]
  000fd	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPEAD_KPEBDZZ ; ImFormatString
  00102	f3 0f 10 54 24
	44		 movss	 xmm2, DWORD PTR font_cfg$[rsp+20]
$LN4@AddFontDef:

; 2135 :     font_cfg.EllipsisChar = (ImWchar)0x0085;
; 2136 :     font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units

  00108	0f 28 c2	 movaps	 xmm0, xmm2

; 2137 : 
; 2138 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2139 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
  00112	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41500000
  0011a	b8 85 00 00 00	 mov	 eax, 133		; 00000085H

; 2140 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

  0011f	4c 8d 4c 24 30	 lea	 r9, QWORD PTR font_cfg$[rsp]
  00124	66 89 45 84	 mov	 WORD PTR font_cfg$[rbp-172], ax
  00128	48 8b cb	 mov	 rcx, rbx
  0012b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0012f	66 0f 6e c0	 movd	 xmm0, eax
  00133	48 8b 44 24 68	 mov	 rax, QWORD PTR font_cfg$[rsp+56]
  00138	48 85 c0	 test	 rax, rax
  0013b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0013e	48 0f 45 d0	 cmovne	 rdx, rax
  00142	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB
  0014e	f3 0f 11 44 24
	60		 movss	 DWORD PTR font_cfg$[rsp+48], xmm0
  00154	e8 00 00 00 00	 call	 ?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF

; 2141 :     return font;
; 2142 : }

  00159	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  0015d	48 33 cc	 xor	 rcx, rsp
  00160	e8 00 00 00 00	 call	 __security_check_cookie
  00165	48 8b 9c 24 78
	01 00 00	 mov	 rbx, QWORD PTR [rsp+376]
  0016d	48 81 c4 60 01
	00 00		 add	 rsp, 352		; 00000160H
  00174	5d		 pop	 rbp
  00175	c3		 ret	 0
?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ENDP ; ImFontAtlas::AddFontDefault
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
data_size$ = 48
$T1 = 64
font_cfg$ = 208
__$ArrayPad$ = 352
this$ = 416
filename$ = 424
size_pixels$ = 432
font_cfg_template$dead$ = 440
glyph_ranges$dead$ = 448
?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromFileTTF

; 2145 : {

$LN26:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 8d 6c 24 80	 lea	 rbp, QWORD PTR [rsp-128]
  0000d	48 81 ec 80 01
	00 00		 sub	 rsp, 384		; 00000180H
  00014	0f 29 b4 24 70
	01 00 00	 movaps	 XMMWORD PTR [rsp+368], xmm6
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 45 60	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 2146 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0002a	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  0002e	0f 28 f2	 movaps	 xmm6, xmm2
  00031	48 8b da	 mov	 rbx, rdx
  00034	48 8b f1	 mov	 rsi, rcx
  00037	74 1a		 je	 SHORT $LN9@AddFontFro
  00039	41 b8 62 08 00
	00		 mov	 r8d, 2146		; 00000862H
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN9@AddFontFro:

; 2147 :     size_t data_size = 0;
; 2148 :     void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);

  00053	4c 8d 44 24 30	 lea	 r8, QWORD PTR data_size$[rsp]
  00058	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR data_size$[rsp], 0
  00061	48 8b cb	 mov	 rcx, rbx
  00064	e8 00 00 00 00	 call	 ?ImFileLoadToMemory@@YAPEAXPEBD0PEA_KH@Z ; ImFileLoadToMemory
  00069	48 8b f8	 mov	 rdi, rax

; 2149 :     if (!data)

  0006c	48 85 c0	 test	 rax, rax
  0006f	75 21		 jne	 SHORT $LN11@AddFontFro

; 2150 :     {
; 2151 :         IM_ASSERT_USER_ERROR(0, "Could not load font file!");

  00071	41 b8 67 08 00
	00		 mov	 r8d, 2151		; 00000867H
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@KCPDJPKE@?$AA?$CI?$AA0?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAo?$AAu?$AAl?$AAd?$AA?5?$AAn@
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2152 :         return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	e9 20 01 00 00	 jmp	 $LN1@AddFontFro
$LN11@AddFontFro:

; 1917 :     RasterizerMultiply = 1.0f;

  00092	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  0009a	0f 57 e4	 xorps	 xmm4, xmm4

; 1914 :     OversampleH = 3; // FIXME: 2 may be a better default?
; 1915 :     OversampleV = 1;
; 1916 :     GlyphMaxAdvanceX = FLT_MAX;

  0009d	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@7f7fffff
  000a5	33 c0		 xor	 eax, eax
  000a7	0f 11 64 24 50	 movups	 XMMWORD PTR $T1[rsp+16], xmm4
  000ac	48 89 45 c0	 mov	 QWORD PTR $T1[rbp-128], rax

; 1918 :     EllipsisChar = (ImWchar)-1;

  000b0	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000b5	0f 11 64 24 40	 movups	 XMMWORD PTR $T1[rsp], xmm4
  000ba	c7 44 24 58 03
	00 00 00	 mov	 DWORD PTR $T1[rsp+24], 3
  000c2	0f 11 65 90	 movups	 XMMWORD PTR $T1[rbp-176], xmm4
  000c6	66 89 45 94	 mov	 WORD PTR $T1[rbp-172], ax
  000ca	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR $T1[rsp+28], 1

; 2153 :     }
; 2154 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000d2	0f 28 4c 24 50	 movaps	 xmm1, XMMWORD PTR $T1[rsp+16]
  000d7	0f 29 4d e0	 movaps	 XMMWORD PTR font_cfg$[rbp-240], xmm1
  000db	0f 28 4d 90	 movaps	 xmm1, XMMWORD PTR $T1[rbp-176]
  000df	f3 0f 10 cb	 movss	 xmm1, xmm3

; 1913 :     FontDataOwnedByAtlas = true;

  000e3	c6 44 24 4c 01	 mov	 BYTE PTR $T1[rsp+12], 1

; 2153 :     }
; 2154 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000e8	0f 28 44 24 40	 movaps	 xmm0, XMMWORD PTR $T1[rsp]
  000ed	0f 29 45 d0	 movaps	 XMMWORD PTR font_cfg$[rbp-256], xmm0
  000f1	0f 57 c0	 xorps	 xmm0, xmm0
  000f4	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H
  000f8	f3 0f 10 c2	 movss	 xmm0, xmm2
  000fc	0f 29 4d 20	 movaps	 XMMWORD PTR font_cfg$[rbp-176], xmm1
  00100	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H

; 2155 :     if (font_cfg.Name[0] == '\0')

  00104	66 0f 73 d9 06	 psrldq	 xmm1, 6
  00109	66 0f 7e c8	 movd	 eax, xmm1
  0010d	0f 29 45 10	 movaps	 XMMWORD PTR font_cfg$[rbp-192], xmm0
  00111	f2 0f 10 45 c0	 movsd	 xmm0, QWORD PTR $T1[rbp-128]
  00116	0f 29 65 f0	 movaps	 XMMWORD PTR font_cfg$[rbp-224], xmm4
  0011a	0f 29 65 00	 movaps	 XMMWORD PTR font_cfg$[rbp-208], xmm4
  0011e	0f 29 65 30	 movaps	 XMMWORD PTR font_cfg$[rbp-160], xmm4
  00122	0f 29 65 40	 movaps	 XMMWORD PTR font_cfg$[rbp-144], xmm4
  00126	f2 0f 11 45 50	 movsd	 QWORD PTR font_cfg$[rbp-128], xmm0
  0012b	84 c0		 test	 al, al
  0012d	75 5e		 jne	 SHORT $LN6@AddFontFro

; 2156 :     {
; 2157 :         // Store a short copy of filename into into the font name for convenience
; 2158 :         const char* p;
; 2159 :         for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}

  0012f	49 c7 c1 ff ff
	ff ff		 mov	 r9, -1
$LL23@AddFontFro:
  00136	49 ff c1	 inc	 r9
  00139	42 80 3c 0b 00	 cmp	 BYTE PTR [rbx+r9], 0
  0013e	75 f6		 jne	 SHORT $LL23@AddFontFro
  00140	4c 03 cb	 add	 r9, rbx
  00143	4c 3b cb	 cmp	 r9, rbx
  00146	76 23		 jbe	 SHORT $LN24@AddFontFro
  00148	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@AddFontFro:
  00150	41 0f b6 49 ff	 movzx	 ecx, BYTE PTR [r9-1]
  00155	49 8d 41 ff	 lea	 rax, QWORD PTR [r9-1]
  00159	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  0015c	74 0d		 je	 SHORT $LN24@AddFontFro
  0015e	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  00161	74 08		 je	 SHORT $LN24@AddFontFro
  00163	4c 8b c8	 mov	 r9, rax
  00166	48 3b c3	 cmp	 rax, rbx
  00169	77 e5		 ja	 SHORT $LL4@AddFontFro
$LN24@AddFontFro:

; 2160 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);

  0016b	0f 57 c0	 xorps	 xmm0, xmm0
  0016e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@EPCGLJHG@?$CFs?0?5?$CF?40fpx@
  00175	f3 0f 5a c6	 cvtss2sd xmm0, xmm6
  00179	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0017e	48 8d 4d 26	 lea	 rcx, QWORD PTR font_cfg$[rbp-170]
  00182	f2 0f 11 44 24
	20		 movsd	 QWORD PTR [rsp+32], xmm0
  00188	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPEAD_KPEBDZZ ; ImFormatString
$LN6@AddFontFro:

; 2161 :     }
; 2162 :     return AddFontFromMemoryTTF(data, (int)data_size, size_pixels, &font_cfg, glyph_ranges);

  0018d	44 8b 44 24 30	 mov	 r8d, DWORD PTR data_size$[rsp]
  00192	48 8d 45 d0	 lea	 rax, QWORD PTR font_cfg$[rbp-256]
  00196	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0019f	0f 28 de	 movaps	 xmm3, xmm6
  001a2	48 8b d7	 mov	 rdx, rdi
  001a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001aa	48 8b ce	 mov	 rcx, rsi
  001ad	e8 00 00 00 00	 call	 ?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
$LN1@AddFontFro:

; 2163 : }

  001b2	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  001b6	48 33 cc	 xor	 rcx, rsp
  001b9	e8 00 00 00 00	 call	 __security_check_cookie
  001be	48 8b 9c 24 b8
	01 00 00	 mov	 rbx, QWORD PTR [rsp+440]
  001c6	0f 28 b4 24 70
	01 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+368]
  001ce	48 81 c4 80 01
	00 00		 add	 rsp, 384		; 00000180H
  001d5	5f		 pop	 rdi
  001d6	5e		 pop	 rsi
  001d7	5d		 pop	 rbp
  001d8	c3		 ret	 0
?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromFileTTF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
font_cfg$ = 32
$T1 = 176
$T2 = 176
__$ArrayPad$ = 320
this$ = 416
ttf_data$ = 424
ttf_size$ = 432
size_pixels$ = 440
font_cfg_template$ = 448
glyph_ranges$ = 456
?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromMemoryTTF

; 2167 : {

$LN19:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 8d 6c 24 98	 lea	 rbp, QWORD PTR [rsp-104]
  0000e	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00015	0f 29 b4 24 50
	01 00 00	 movaps	 XMMWORD PTR [rsp+336], xmm6
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 45 40	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 2168 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  0002b	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  0002f	0f 28 f3	 movaps	 xmm6, xmm3
  00032	48 8b 9d c0 00
	00 00		 mov	 rbx, QWORD PTR font_cfg_template$[rbp-256]
  00039	45 8b f8	 mov	 r15d, r8d
  0003c	48 8b bd c8 00
	00 00		 mov	 rdi, QWORD PTR glyph_ranges$[rbp-256]
  00043	4c 8b f2	 mov	 r14, rdx
  00046	48 8b f1	 mov	 rsi, rcx
  00049	74 1a		 je	 SHORT $LN5@AddFontFro
  0004b	41 b8 78 08 00
	00		 mov	 r8d, 2168		; 00000878H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN5@AddFontFro:

; 2169 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  00065	48 85 db	 test	 rbx, rbx
  00068	74 4e		 je	 SHORT $LN6@AddFontFro
  0006a	0f 28 03	 movaps	 xmm0, XMMWORD PTR [rbx]
  0006d	0f 28 4b 10	 movaps	 xmm1, XMMWORD PTR [rbx+16]
  00071	0f 29 45 b0	 movaps	 XMMWORD PTR $T2[rbp-256], xmm0
  00075	0f 28 43 20	 movaps	 xmm0, XMMWORD PTR [rbx+32]
  00079	0f 29 45 d0	 movaps	 XMMWORD PTR $T2[rbp-224], xmm0
  0007d	0f 28 43 40	 movaps	 xmm0, XMMWORD PTR [rbx+64]
  00081	0f 29 4d c0	 movaps	 XMMWORD PTR $T2[rbp-240], xmm1
  00085	0f 28 4b 30	 movaps	 xmm1, XMMWORD PTR [rbx+48]
  00089	0f 29 45 f0	 movaps	 XMMWORD PTR $T2[rbp-192], xmm0
  0008d	0f 28 43 60	 movaps	 xmm0, XMMWORD PTR [rbx+96]
  00091	0f 29 4d e0	 movaps	 XMMWORD PTR $T2[rbp-208], xmm1
  00095	0f 28 4b 50	 movaps	 xmm1, XMMWORD PTR [rbx+80]
  00099	0f 29 45 10	 movaps	 XMMWORD PTR $T2[rbp-160], xmm0
  0009d	f2 0f 10 83 80
	00 00 00	 movsd	 xmm0, QWORD PTR [rbx+128]
  000a5	0f 29 4d 00	 movaps	 XMMWORD PTR $T2[rbp-176], xmm1
  000a9	0f 28 4b 70	 movaps	 xmm1, XMMWORD PTR [rbx+112]
  000ad	f2 0f 11 45 30	 movsd	 QWORD PTR $T2[rbp-128], xmm0
  000b2	0f 29 4d 20	 movaps	 XMMWORD PTR $T2[rbp-144], xmm1
  000b6	eb 5e		 jmp	 SHORT $LN17@AddFontFro
$LN6@AddFontFro:

; 1917 :     RasterizerMultiply = 1.0f;

  000b8	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  000c0	0f 57 c0	 xorps	 xmm0, xmm0

; 1912 :     memset(this, 0, sizeof(*this));

  000c3	0f 11 45 c0	 movups	 XMMWORD PTR $T1[rbp-240], xmm0
  000c7	33 c0		 xor	 eax, eax

; 1913 :     FontDataOwnedByAtlas = true;
; 1914 :     OversampleH = 3; // FIXME: 2 may be a better default?

  000c9	c7 45 c8 03 00
	00 00		 mov	 DWORD PTR $T1[rbp-232], 3
  000d0	0f 11 45 00	 movups	 XMMWORD PTR $T1[rbp-176], xmm0
  000d4	48 89 45 30	 mov	 QWORD PTR $T1[rbp-128], rax

; 1918 :     EllipsisChar = (ImWchar)-1;

  000d8	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000dd	0f 11 45 b0	 movups	 XMMWORD PTR $T1[rbp-256], xmm0
  000e1	66 89 45 04	 mov	 WORD PTR $T1[rbp-172], ax
  000e5	0f 11 45 f0	 movups	 XMMWORD PTR $T1[rbp-192], xmm0
  000e9	c6 45 bc 01	 mov	 BYTE PTR $T1[rbp-244], 1
  000ed	0f 11 45 d0	 movups	 XMMWORD PTR $T1[rbp-224], xmm0
  000f1	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR $T1[rbp-228], 1
  000f8	0f 11 45 e0	 movups	 XMMWORD PTR $T1[rbp-208], xmm0
  000fc	0f 11 45 10	 movups	 XMMWORD PTR $T1[rbp-160], xmm0
  00100	0f 11 45 20	 movups	 XMMWORD PTR $T1[rbp-144], xmm0
  00104	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  0010c	f3 0f 11 45 f4	 movss	 DWORD PTR $T1[rbp-188], xmm0
  00111	f3 0f 11 4d 00	 movss	 DWORD PTR $T1[rbp-176], xmm1
$LN17@AddFontFro:

; 2169 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  00116	48 8d 45 b0	 lea	 rax, QWORD PTR $T1[rbp-256]
  0011a	0f 28 40 10	 movaps	 xmm0, XMMWORD PTR [rax+16]
  0011e	0f 28 48 20	 movaps	 xmm1, XMMWORD PTR [rax+32]
  00122	0f 28 10	 movaps	 xmm2, XMMWORD PTR [rax]
  00125	0f 29 44 24 30	 movaps	 XMMWORD PTR font_cfg$[rsp+16], xmm0
  0012a	0f 28 40 30	 movaps	 xmm0, XMMWORD PTR [rax+48]
  0012e	0f 29 4c 24 40	 movaps	 XMMWORD PTR font_cfg$[rsp+32], xmm1
  00133	0f 28 48 40	 movaps	 xmm1, XMMWORD PTR [rax+64]
  00137	0f 29 44 24 50	 movaps	 XMMWORD PTR font_cfg$[rsp+48], xmm0
  0013c	0f 28 40 50	 movaps	 xmm0, XMMWORD PTR [rax+80]
  00140	0f 29 4c 24 60	 movaps	 XMMWORD PTR font_cfg$[rsp+64], xmm1
  00145	0f 28 48 60	 movaps	 xmm1, XMMWORD PTR [rax+96]
  00149	0f 29 44 24 70	 movaps	 XMMWORD PTR font_cfg$[rsp+80], xmm0
  0014e	0f 28 40 70	 movaps	 xmm0, XMMWORD PTR [rax+112]
  00152	0f 29 4d 80	 movaps	 XMMWORD PTR font_cfg$[rbp-160], xmm1
  00156	f2 0f 10 88 80
	00 00 00	 movsd	 xmm1, QWORD PTR [rax+128]

; 2170 :     IM_ASSERT(font_cfg.FontData == NULL);

  0015e	66 48 0f 7e d0	 movq	 rax, xmm2
  00163	0f 29 54 24 20	 movaps	 XMMWORD PTR font_cfg$[rsp], xmm2
  00168	0f 29 45 90	 movaps	 XMMWORD PTR font_cfg$[rbp-144], xmm0
  0016c	f2 0f 11 4d a0	 movsd	 QWORD PTR font_cfg$[rbp-128], xmm1
  00171	48 85 c0	 test	 rax, rax
  00174	74 1a		 je	 SHORT $LN8@AddFontFro
  00176	41 b8 7a 08 00
	00		 mov	 r8d, 2170		; 0000087aH
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN8@AddFontFro:

; 2171 :     font_cfg.FontData = ttf_data;

  00190	0f 57 c0	 xorps	 xmm0, xmm0
  00193	4c 89 74 24 20	 mov	 QWORD PTR font_cfg$[rsp], r14

; 2172 :     font_cfg.FontDataSize = ttf_size;
; 2173 :     font_cfg.SizePixels = size_pixels > 0.0f ? size_pixels : font_cfg.SizePixels;

  00198	0f 2f f0	 comiss	 xmm6, xmm0
  0019b	44 89 7c 24 28	 mov	 DWORD PTR font_cfg$[rsp+8], r15d
  001a0	76 06		 jbe	 SHORT $LN9@AddFontFro
  001a2	f3 0f 11 74 24
	34		 movss	 DWORD PTR font_cfg$[rsp+20], xmm6
$LN9@AddFontFro:

; 2174 :     if (glyph_ranges)

  001a8	48 8b 44 24 58	 mov	 rax, QWORD PTR font_cfg$[rsp+56]

; 2175 :         font_cfg.GlyphRanges = glyph_ranges;
; 2176 :     return AddFont(&font_cfg);

  001ad	48 8d 54 24 20	 lea	 rdx, QWORD PTR font_cfg$[rsp]
  001b2	48 85 ff	 test	 rdi, rdi
  001b5	48 8b ce	 mov	 rcx, rsi
  001b8	48 0f 45 c7	 cmovne	 rax, rdi
  001bc	48 89 44 24 58	 mov	 QWORD PTR font_cfg$[rsp+56], rax
  001c1	e8 00 00 00 00	 call	 ?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z ; ImFontAtlas::AddFont

; 2177 : }

  001c6	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  001ca	48 33 cc	 xor	 rcx, rsp
  001cd	e8 00 00 00 00	 call	 __security_check_cookie
  001d2	0f 28 b4 24 50
	01 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+336]
  001da	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  001e1	41 5f		 pop	 r15
  001e3	41 5e		 pop	 r14
  001e5	5f		 pop	 rdi
  001e6	5e		 pop	 rsi
  001e7	5b		 pop	 rbx
  001e8	5d		 pop	 rbp
  001e9	c3		 ret	 0
?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryTTF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$GSCopy$1$ = 48
glyph_ranges$GSCopy$1$ = 56
font_cfg$ = 64
$T1 = 208
$T2 = 208
__$ArrayPad$ = 352
this$ = 448
compressed_ttf_data$ = 456
compressed_ttf_size$dead$ = 464
size_pixels$ = 472
font_cfg_template$ = 480
glyph_ranges$ = 488
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedTTF

; 2180 : {

$LN54:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	55		 push	 rbp
  00004	56		 push	 rsi
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 57		 push	 r15
  0000a	49 8d ab 48 ff
	ff ff		 lea	 rbp, QWORD PTR [r11-184]
  00011	48 81 ec 90 01
	00 00		 sub	 rsp, 400		; 00000190H
  00018	41 0f 29 73 b8	 movaps	 XMMWORD PTR [r11-72], xmm6
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 45 60	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  0002b	0f b6 42 09	 movzx	 eax, BYTE PTR [rdx+9]

; 2180 : {

  0002f	0f 28 f3	 movaps	 xmm6, xmm3

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00032	44 0f b6 7a 0a	 movzx	 r15d, BYTE PTR [rdx+10]

; 2180 : {

  00037	48 8b f9	 mov	 rdi, rcx
  0003a	48 8b b5 e8 00
	00 00		 mov	 rsi, QWORD PTR glyph_ranges$[rbp-256]

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00041	c1 e0 10	 shl	 eax, 16
  00044	41 c1 e7 08	 shl	 r15d, 8
  00048	44 03 f8	 add	 r15d, eax

; 2180 : {

  0004b	49 89 5b 18	 mov	 QWORD PTR [r11+24], rbx

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  0004f	0f b6 42 08	 movzx	 eax, BYTE PTR [rdx+8]

; 2180 : {

  00053	48 8b da	 mov	 rbx, rdx

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00056	c1 e0 18	 shl	 eax, 24
  00059	44 03 f8	 add	 r15d, eax

; 2180 : {

  0005c	4d 89 73 c8	 mov	 QWORD PTR [r11-56], r14

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00060	0f b6 42 0b	 movzx	 eax, BYTE PTR [rdx+11]

; 2180 : {

  00064	4c 8b b5 e0 00
	00 00		 mov	 r14, QWORD PTR font_cfg_template$[rbp-256]

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  0006b	44 03 f8	 add	 r15d, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0006e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2180 : {

  00075	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$1$[rsp], rcx
  0007a	48 89 74 24 38	 mov	 QWORD PTR glyph_ranges$GSCopy$1$[rsp], rsi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0007f	48 85 c0	 test	 rax, rax
  00082	74 06		 je	 SHORT $LN9@AddFontFro

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00084	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN9@AddFontFro:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2182 :     unsigned char* buf_decompressed_data = (unsigned char*)IM_ALLOC(buf_decompressed_size);

  0008a	41 8b cf	 mov	 ecx, r15d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 4054 :     if (stb__in4(0) != 0x57bC0000) return 0;

  00093	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00096	4c 8b e0	 mov	 r12, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 4054 :     if (stb__in4(0) != 0x57bC0000) return 0;

  00099	0f b6 53 01	 movzx	 edx, BYTE PTR [rbx+1]
  0009d	c1 e1 08	 shl	 ecx, 8
  000a0	03 d1		 add	 edx, ecx
  000a2	0f b6 4b 02	 movzx	 ecx, BYTE PTR [rbx+2]
  000a6	c1 e2 08	 shl	 edx, 8
  000a9	03 d1		 add	 edx, ecx
  000ab	0f b6 4b 03	 movzx	 ecx, BYTE PTR [rbx+3]
  000af	c1 e2 08	 shl	 edx, 8
  000b2	03 d1		 add	 edx, ecx
  000b4	81 fa 00 00 bc
	57		 cmp	 edx, 1471938560		; 57bc0000H
  000ba	0f 85 1b 01 00
	00		 jne	 $LN42@AddFontFro

; 4055 :     if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB

  000c0	0f b6 43 05	 movzx	 eax, BYTE PTR [rbx+5]
  000c4	0f b6 4b 04	 movzx	 ecx, BYTE PTR [rbx+4]
  000c8	c1 e1 08	 shl	 ecx, 8
  000cb	03 c8		 add	 ecx, eax
  000cd	0f b6 43 06	 movzx	 eax, BYTE PTR [rbx+6]
  000d1	c1 e1 08	 shl	 ecx, 8
  000d4	03 c8		 add	 ecx, eax
  000d6	0f b6 43 07	 movzx	 eax, BYTE PTR [rbx+7]
  000da	c1 e1 08	 shl	 ecx, 8
  000dd	03 c8		 add	 ecx, eax
  000df	0f 85 f6 00 00
	00		 jne	 $LN42@AddFontFro

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  000e5	0f b6 43 09	 movzx	 eax, BYTE PTR [rbx+9]
  000e9	4c 89 ac 24 88
	01 00 00	 mov	 QWORD PTR [rsp+392], r13
  000f1	44 0f b6 6b 0a	 movzx	 r13d, BYTE PTR [rbx+10]
  000f6	c1 e0 10	 shl	 eax, 16
  000f9	41 c1 e5 08	 shl	 r13d, 8
  000fd	44 03 e8	 add	 r13d, eax

; 4057 :     stb__barrier_in_b = i;

  00100	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?stb__barrier_in_b@@3PEBEEB, rbx

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00107	0f b6 43 08	 movzx	 eax, BYTE PTR [rbx+8]
  0010b	c1 e0 18	 shl	 eax, 24
  0010e	44 03 e8	 add	 r13d, eax

; 4059 :     stb__barrier_out_b = output;

  00111	4c 89 25 00 00
	00 00		 mov	 QWORD PTR ?stb__barrier_out_b@@3PEAEEA, r12

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00118	0f b6 43 0b	 movzx	 eax, BYTE PTR [rbx+11]

; 4060 :     i += 16;

  0011c	48 83 c3 10	 add	 rbx, 16

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00120	44 03 e8	 add	 r13d, eax

; 4062 :     stb__dout = output;

  00123	4c 89 25 00 00
	00 00		 mov	 QWORD PTR ?stb__dout@@3PEAEEA, r12
  0012a	41 8b f5	 mov	 esi, r13d

; 4063 :     for (;;) {
; 4064 :         const unsigned char* old_i = i;
; 4065 :         i = stb_decompress_token(i);

  0012d	48 8b cb	 mov	 rcx, rbx
  00130	49 03 f4	 add	 rsi, r12
  00133	48 89 35 00 00
	00 00		 mov	 QWORD PTR ?stb__barrier_out_e@@3PEAEEA, rsi
  0013a	e8 00 00 00 00	 call	 ?stb_decompress_token@@YAPEBEPEBE@Z ; stb_decompress_token
  0013f	48 8b f8	 mov	 rdi, rax

; 4066 :         if (i == old_i) {

  00142	48 3b c3	 cmp	 rax, rbx
  00145	74 3f		 je	 SHORT $LN44@AddFontFro
$LL16@AddFontFro:

; 4076 :                 return 0;
; 4077 :             }
; 4078 :         }
; 4079 :         IM_ASSERT(stb__dout <= output + olen);

  00147	48 39 35 00 00
	00 00		 cmp	 QWORD PTR ?stb__dout@@3PEAEEA, rsi
  0014e	76 23		 jbe	 SHORT $LN47@AddFontFro
  00150	41 b8 ef 0f 00
	00		 mov	 r8d, 4079		; 00000fefH
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@EGIPGKEG@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAo?$AAu@
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 4080 :         if (stb__dout > output + olen)

  0016a	48 39 35 00 00
	00 00		 cmp	 QWORD PTR ?stb__dout@@3PEAEEA, rsi
  00171	77 56		 ja	 SHORT $LN49@AddFontFro
$LN47@AddFontFro:

; 4063 :     for (;;) {
; 4064 :         const unsigned char* old_i = i;
; 4065 :         i = stb_decompress_token(i);

  00173	48 8b cf	 mov	 rcx, rdi
  00176	48 8b df	 mov	 rbx, rdi
  00179	e8 00 00 00 00	 call	 ?stb_decompress_token@@YAPEBEPEBE@Z ; stb_decompress_token
  0017e	48 8b f8	 mov	 rdi, rax

; 4066 :         if (i == old_i) {

  00181	48 3b c3	 cmp	 rax, rbx
  00184	75 c1		 jne	 SHORT $LL16@AddFontFro
$LN44@AddFontFro:

; 4067 :             if (*i == 0x05 && i[1] == 0xfa) {

  00186	80 3f 05	 cmp	 BYTE PTR [rdi], 5
  00189	75 24		 jne	 SHORT $LN22@AddFontFro
  0018b	80 7f 01 fa	 cmp	 BYTE PTR [rdi+1], 250	; 000000faH
  0018f	75 1e		 jne	 SHORT $LN22@AddFontFro
  00191	41 8b c5	 mov	 eax, r13d

; 4068 :                 IM_ASSERT(stb__dout == output + olen);

  00194	49 03 c4	 add	 rax, r12
  00197	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?stb__dout@@3PEAEEA, rax
  0019e	74 29		 je	 SHORT $LN49@AddFontFro
  001a0	41 b8 e4 0f 00
	00		 mov	 r8d, 4068		; 00000fe4H
  001a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@GCANDLHA@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@
  001ad	eb 0d		 jmp	 SHORT $LN52@AddFontFro
$LN22@AddFontFro:

; 4069 :                 if (stb__dout != output + olen) return 0;
; 4070 :                 if (stb_adler32(1, output, olen) != (unsigned int)stb__in4(2))
; 4071 :                     return 0;
; 4072 :                 return olen;
; 4073 :             }
; 4074 :             else {
; 4075 :                 IM_ASSERT(0); /* NOTREACHED */

  001af	41 b8 eb 0f 00
	00		 mov	 r8d, 4075		; 00000febH
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
$LN52@AddFontFro:

; 4080 :         if (stb__dout > output + olen)

  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN49@AddFontFro:
  001c9	48 8b 74 24 38	 mov	 rsi, QWORD PTR glyph_ranges$GSCopy$1$[rsp]
  001ce	48 8b 7c 24 30	 mov	 rdi, QWORD PTR this$GSCopy$1$[rsp]
  001d3	4c 8b ac 24 88
	01 00 00	 mov	 r13, QWORD PTR [rsp+392]
$LN42@AddFontFro:
  001db	48 8b 9c 24 d0
	01 00 00	 mov	 rbx, QWORD PTR [rsp+464]

; 2183 :     stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);
; 2184 : 
; 2185 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  001e3	4d 85 f6	 test	 r14, r14
  001e6	74 57		 je	 SHORT $LN3@AddFontFro
  001e8	41 0f 28 06	 movaps	 xmm0, XMMWORD PTR [r14]
  001ec	41 0f 28 4e 10	 movaps	 xmm1, XMMWORD PTR [r14+16]
  001f1	0f 29 45 d0	 movaps	 XMMWORD PTR $T2[rbp-256], xmm0
  001f5	41 0f 28 46 20	 movaps	 xmm0, XMMWORD PTR [r14+32]
  001fa	0f 29 45 f0	 movaps	 XMMWORD PTR $T2[rbp-224], xmm0
  001fe	41 0f 28 46 40	 movaps	 xmm0, XMMWORD PTR [r14+64]
  00203	0f 29 4d e0	 movaps	 XMMWORD PTR $T2[rbp-240], xmm1
  00207	41 0f 28 4e 30	 movaps	 xmm1, XMMWORD PTR [r14+48]
  0020c	0f 29 45 10	 movaps	 XMMWORD PTR $T2[rbp-192], xmm0
  00210	41 0f 28 46 60	 movaps	 xmm0, XMMWORD PTR [r14+96]
  00215	0f 29 4d 00	 movaps	 XMMWORD PTR $T2[rbp-208], xmm1
  00219	41 0f 28 4e 50	 movaps	 xmm1, XMMWORD PTR [r14+80]
  0021e	0f 29 45 30	 movaps	 XMMWORD PTR $T2[rbp-160], xmm0
  00222	f2 41 0f 10 86
	80 00 00 00	 movsd	 xmm0, QWORD PTR [r14+128]
  0022b	0f 29 4d 20	 movaps	 XMMWORD PTR $T2[rbp-176], xmm1
  0022f	41 0f 28 4e 70	 movaps	 xmm1, XMMWORD PTR [r14+112]
  00234	f2 0f 11 45 50	 movsd	 QWORD PTR $T2[rbp-128], xmm0
  00239	0f 29 4d 40	 movaps	 XMMWORD PTR $T2[rbp-144], xmm1
  0023d	eb 5e		 jmp	 SHORT $LN51@AddFontFro
$LN3@AddFontFro:

; 1917 :     RasterizerMultiply = 1.0f;

  0023f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00247	0f 57 c0	 xorps	 xmm0, xmm0

; 1912 :     memset(this, 0, sizeof(*this));

  0024a	0f 11 45 e0	 movups	 XMMWORD PTR $T1[rbp-240], xmm0
  0024e	33 c0		 xor	 eax, eax

; 1913 :     FontDataOwnedByAtlas = true;
; 1914 :     OversampleH = 3; // FIXME: 2 may be a better default?

  00250	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR $T1[rbp-232], 3
  00257	0f 11 45 20	 movups	 XMMWORD PTR $T1[rbp-176], xmm0
  0025b	48 89 45 50	 mov	 QWORD PTR $T1[rbp-128], rax

; 1918 :     EllipsisChar = (ImWchar)-1;

  0025f	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00264	0f 11 45 d0	 movups	 XMMWORD PTR $T1[rbp-256], xmm0
  00268	66 89 45 24	 mov	 WORD PTR $T1[rbp-172], ax
  0026c	0f 11 45 10	 movups	 XMMWORD PTR $T1[rbp-192], xmm0
  00270	c6 45 dc 01	 mov	 BYTE PTR $T1[rbp-244], 1
  00274	0f 11 45 f0	 movups	 XMMWORD PTR $T1[rbp-224], xmm0
  00278	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T1[rbp-228], 1
  0027f	0f 11 45 00	 movups	 XMMWORD PTR $T1[rbp-208], xmm0
  00283	0f 11 45 30	 movups	 XMMWORD PTR $T1[rbp-160], xmm0
  00287	0f 11 45 40	 movups	 XMMWORD PTR $T1[rbp-144], xmm0
  0028b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@7f7fffff
  00293	f3 0f 11 45 14	 movss	 DWORD PTR $T1[rbp-188], xmm0
  00298	f3 0f 11 4d 20	 movss	 DWORD PTR $T1[rbp-176], xmm1
$LN51@AddFontFro:

; 2186 :     IM_ASSERT(font_cfg.FontData == NULL);

  0029d	4c 8b b4 24 80
	01 00 00	 mov	 r14, QWORD PTR [rsp+384]
  002a5	48 8d 45 d0	 lea	 rax, QWORD PTR $T1[rbp-256]
  002a9	0f 28 40 10	 movaps	 xmm0, XMMWORD PTR [rax+16]
  002ad	0f 28 48 20	 movaps	 xmm1, XMMWORD PTR [rax+32]
  002b1	0f 28 10	 movaps	 xmm2, XMMWORD PTR [rax]
  002b4	0f 29 44 24 50	 movaps	 XMMWORD PTR font_cfg$[rsp+16], xmm0
  002b9	0f 28 40 30	 movaps	 xmm0, XMMWORD PTR [rax+48]
  002bd	0f 29 4c 24 60	 movaps	 XMMWORD PTR font_cfg$[rsp+32], xmm1
  002c2	0f 28 48 40	 movaps	 xmm1, XMMWORD PTR [rax+64]
  002c6	0f 29 44 24 70	 movaps	 XMMWORD PTR font_cfg$[rsp+48], xmm0
  002cb	0f 28 40 50	 movaps	 xmm0, XMMWORD PTR [rax+80]
  002cf	0f 29 4d 80	 movaps	 XMMWORD PTR font_cfg$[rbp-192], xmm1
  002d3	0f 28 48 60	 movaps	 xmm1, XMMWORD PTR [rax+96]
  002d7	0f 29 45 90	 movaps	 XMMWORD PTR font_cfg$[rbp-176], xmm0
  002db	0f 28 40 70	 movaps	 xmm0, XMMWORD PTR [rax+112]
  002df	0f 29 4d a0	 movaps	 XMMWORD PTR font_cfg$[rbp-160], xmm1
  002e3	f2 0f 10 88 80
	00 00 00	 movsd	 xmm1, QWORD PTR [rax+128]
  002eb	66 48 0f 7e d0	 movq	 rax, xmm2
  002f0	0f 29 54 24 40	 movaps	 XMMWORD PTR font_cfg$[rsp], xmm2
  002f5	0f 29 45 b0	 movaps	 XMMWORD PTR font_cfg$[rbp-144], xmm0
  002f9	f2 0f 11 4d c0	 movsd	 QWORD PTR font_cfg$[rbp-128], xmm1
  002fe	48 85 c0	 test	 rax, rax
  00301	74 1a		 je	 SHORT $LN5@AddFontFro
  00303	41 b8 8a 08 00
	00		 mov	 r8d, 2186		; 0000088aH
  00309	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00310	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@ODFMNMML@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAc?$AAf?$AAg?$AA?4?$AAF?$AAo?$AAn?$AAt?$AAD?$AAa@
  00317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN5@AddFontFro:

; 2187 :     font_cfg.FontDataOwnedByAtlas = true;
; 2188 :     return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);

  0031d	48 8d 44 24 40	 lea	 rax, QWORD PTR font_cfg$[rsp]
  00322	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  00327	0f 28 de	 movaps	 xmm3, xmm6
  0032a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0032f	45 8b c7	 mov	 r8d, r15d
  00332	c6 44 24 4c 01	 mov	 BYTE PTR font_cfg$[rsp+12], 1
  00337	49 8b d4	 mov	 rdx, r12
  0033a	48 8b cf	 mov	 rcx, rdi
  0033d	e8 00 00 00 00	 call	 ?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryTTF

; 2189 : }

  00342	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00346	48 33 cc	 xor	 rcx, rsp
  00349	e8 00 00 00 00	 call	 __security_check_cookie
  0034e	0f 28 b4 24 70
	01 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+368]
  00356	48 81 c4 90 01
	00 00		 add	 rsp, 400		; 00000190H
  0035d	41 5f		 pop	 r15
  0035f	41 5c		 pop	 r12
  00361	5f		 pop	 rdi
  00362	5e		 pop	 rsi
  00363	5d		 pop	 rbp
  00364	c3		 ret	 0
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedTTF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 80
compressed_ttf_data_base85$ = 88
size_pixels$ = 96
font_cfg$ = 104
glyph_ranges$ = 112
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF

; 2192 : {

$LN48:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00019	49 8b f1	 mov	 rsi, r9
  0001c	0f 28 f2	 movaps	 xmm6, xmm2
  0001f	48 8b da	 mov	 rbx, rdx
  00022	48 8b e9	 mov	 rbp, rcx

; 2193 :     int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;

  00025	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0002c	0f 1f 40 00	 npad	 4
$LL46@AddFontFro:
  00030	49 ff c0	 inc	 r8
  00033	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  00038	75 f6		 jne	 SHORT $LL46@AddFontFro
  0003a	41 83 c0 04	 add	 r8d, 4
  0003e	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00043	41 f7 e8	 imul	 r8d
  00046	d1 fa		 sar	 edx, 1
  00048	8b c2		 mov	 eax, edx
  0004a	c1 e8 1f	 shr	 eax, 31
  0004d	03 d0		 add	 edx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0004f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2193 :     int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;

  00056	c1 e2 02	 shl	 edx, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00059	48 85 c0	 test	 rax, rax
  0005c	74 06		 je	 SHORT $LN4@AddFontFro

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  0005e	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN4@AddFontFro:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2194 :     void* compressed_ttf = IM_ALLOC((size_t)compressed_ttf_size);

  00064	48 63 ca	 movsxd	 rcx, edx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2113 :     while (*src)

  0006d	44 0f b6 1b	 movzx	 r11d, BYTE PTR [rbx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00071	48 8b f8	 mov	 rdi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2113 :     while (*src)

  00074	45 84 db	 test	 r11b, r11b
  00077	0f 84 b4 00 00
	00		 je	 $LN12@AddFontFro
  0007d	4c 8d 50 02	 lea	 r10, QWORD PTR [rax+2]
  00081	48 83 c3 02	 add	 rbx, 2
  00085	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL11@AddFontFro:

; 2114 :     {
; 2115 :         unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));

  00090	0f be 53 01	 movsx	 edx, BYTE PTR [rbx+1]
  00094	33 c9		 xor	 ecx, ecx
  00096	0f be 43 02	 movsx	 eax, BYTE PTR [rbx+2]

; 2116 :         dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
; 2117 :         src += 5;
; 2118 :         dst += 4;

  0009a	4d 8d 52 04	 lea	 r10, QWORD PTR [r10+4]
  0009e	44 0f be 03	 movsx	 r8d, BYTE PTR [rbx]
  000a2	3c 5c		 cmp	 al, 92			; 0000005cH
  000a4	44 0f be 4b ff	 movsx	 r9d, BYTE PTR [rbx-1]
  000a9	48 8d 5b 05	 lea	 rbx, QWORD PTR [rbx+5]
  000ad	0f 9d c1	 setge	 cl
  000b0	83 c1 23	 add	 ecx, 35			; 00000023H
  000b3	2b c1		 sub	 eax, ecx
  000b5	6b c8 55	 imul	 ecx, eax, 85		; 00000055H
  000b8	33 c0		 xor	 eax, eax
  000ba	80 fa 5c	 cmp	 dl, 92			; 0000005cH
  000bd	0f 9d c0	 setge	 al
  000c0	83 c0 23	 add	 eax, 35			; 00000023H
  000c3	2b c8		 sub	 ecx, eax
  000c5	33 c0		 xor	 eax, eax
  000c7	03 ca		 add	 ecx, edx
  000c9	6b d1 55	 imul	 edx, ecx, 85		; 00000055H
  000cc	41 80 f8 5c	 cmp	 r8b, 92			; 0000005cH
  000d0	0f 9d c0	 setge	 al
  000d3	83 c0 23	 add	 eax, 35			; 00000023H
  000d6	2b d0		 sub	 edx, eax
  000d8	33 c0		 xor	 eax, eax
  000da	41 03 d0	 add	 edx, r8d
  000dd	6b ca 55	 imul	 ecx, edx, 85		; 00000055H
  000e0	41 80 f9 5c	 cmp	 r9b, 92			; 0000005cH
  000e4	0f 9d c0	 setge	 al
  000e7	83 c0 23	 add	 eax, 35			; 00000023H
  000ea	2b c8		 sub	 ecx, eax
  000ec	33 c0		 xor	 eax, eax
  000ee	41 03 c9	 add	 ecx, r9d
  000f1	6b d1 55	 imul	 edx, ecx, 85		; 00000055H
  000f4	41 80 fb 5c	 cmp	 r11b, 92		; 0000005cH
  000f8	0f 9d c0	 setge	 al
  000fb	83 c0 23	 add	 eax, 35			; 00000023H
  000fe	2b d0		 sub	 edx, eax
  00100	41 0f be c3	 movsx	 eax, r11b
  00104	03 d0		 add	 edx, eax
  00106	41 88 52 fa	 mov	 BYTE PTR [r10-6], dl
  0010a	8b c2		 mov	 eax, edx
  0010c	c1 e8 08	 shr	 eax, 8
  0010f	41 88 42 fb	 mov	 BYTE PTR [r10-5], al
  00113	8b c2		 mov	 eax, edx
  00115	c1 e8 10	 shr	 eax, 16
  00118	c1 ea 18	 shr	 edx, 24
  0011b	41 88 42 fc	 mov	 BYTE PTR [r10-4], al
  0011f	41 88 52 fd	 mov	 BYTE PTR [r10-3], dl
  00123	44 0f b6 5b fe	 movzx	 r11d, BYTE PTR [rbx-2]
  00128	45 84 db	 test	 r11b, r11b
  0012b	0f 85 5f ff ff
	ff		 jne	 $LL11@AddFontFro
$LN12@AddFontFro:

; 2195 :     Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
; 2196 :     ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);

  00131	48 8b 44 24 70	 mov	 rax, QWORD PTR glyph_ranges$[rsp]
  00136	0f 28 de	 movaps	 xmm3, xmm6
  00139	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0013e	48 8b d7	 mov	 rdx, rdi
  00141	48 8b cd	 mov	 rcx, rbp
  00144	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00149	e8 00 00 00 00	 call	 ?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF
  0014e	48 8b d8	 mov	 rbx, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00151	48 85 ff	 test	 rdi, rdi
  00154	74 12		 je	 SHORT $LN36@AddFontFro

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00156	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0015d	48 85 c9	 test	 rcx, rcx
  00160	74 06		 je	 SHORT $LN36@AddFontFro

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00162	ff 89 ec 00 00
	00		 dec	 DWORD PTR [rcx+236]
$LN36@AddFontFro:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00168	48 8b cf	 mov	 rcx, rdi
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2199 : }

  00171	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00176	48 8b c3	 mov	 rax, rbx
  00179	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0017e	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00183	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00188	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0018c	5f		 pop	 rdi
  0018d	c3		 ret	 0
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
r$ = 32
this$ = 80
width$ = 88
height$ = 96
?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z PROC	; ImFontAtlas::AddCustomRectRegular

; 2202 : {

$LN16:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2203 :     IM_ASSERT(width > 0 && width <= 0xFFFF);

  0000f	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  00012	41 8b d8	 mov	 ebx, r8d
  00015	8b fa		 mov	 edi, edx
  00017	48 8b f1	 mov	 rsi, rcx
  0001a	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0001f	76 1a		 jbe	 SHORT $LN4@AddCustomR
  00021	41 b8 9b 08 00
	00		 mov	 r8d, 2203		; 0000089bH
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@GHLOFHKF@?$AAw?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAw?$AAi@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@AddCustomR:

; 2204 :     IM_ASSERT(height > 0 && height <= 0xFFFF);

  0003b	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]
  0003e	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  00043	76 1a		 jbe	 SHORT $LN6@AddCustomR
  00045	41 b8 9c 08 00
	00		 mov	 r8d, 2204		; 0000089cH
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@CAIIJEKF@?$AAh?$AAe?$AAi?$AAg?$AAh?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAh@
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN6@AddCustomR:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2711 :     ImFontAtlasCustomRect() { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

  0005f	33 c0		 xor	 eax, eax
  00061	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR r$[rsp+4], -1	; ffffffffH
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2208 :     CustomRects.push_back(r);

  00069	48 8d 54 24 20	 lea	 rdx, QWORD PTR r$[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2711 :     ImFontAtlasCustomRect() { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

  0006e	48 89 44 24 28	 mov	 QWORD PTR r$[rsp+8], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2208 :     CustomRects.push_back(r);

  00073	48 8d 4e 58	 lea	 rcx, QWORD PTR [rsi+88]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2711 :     ImFontAtlasCustomRect() { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }

  00077	48 89 44 24 30	 mov	 QWORD PTR r$[rsp+16], rax
  0007c	48 89 44 24 38	 mov	 QWORD PTR r$[rsp+24], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2206 :     r.Width = (unsigned short)width;

  00081	66 89 7c 24 20	 mov	 WORD PTR r$[rsp], di

; 2207 :     r.Height = (unsigned short)height;

  00086	66 89 5c 24 22	 mov	 WORD PTR r$[rsp+2], bx

; 2208 :     CustomRects.push_back(r);

  0008b	e8 00 00 00 00	 call	 ?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ; ImVector<ImFontAtlasCustomRect>::push_back

; 2209 :     return CustomRects.Size - 1; // Return index

  00090	8b 46 58	 mov	 eax, DWORD PTR [rsi+88]

; 2210 : }

  00093	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00098	ff c8		 dec	 eax
  0009a	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0009f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a3	5f		 pop	 rdi
  000a4	c3		 ret	 0
?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z ENDP	; ImFontAtlas::AddCustomRectRegular
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
rect$ = 56
out_uv_min$ = 64
out_uv_max$ = 72
?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z PROC ; ImFontAtlas::CalcCustomRectUV

; 2232 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2233 :     IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates

  00014	83 79 30 00	 cmp	 DWORD PTR [rcx+48], 0
  00018	49 8b f1	 mov	 rsi, r9
  0001b	49 8b e8	 mov	 rbp, r8
  0001e	48 8b da	 mov	 rbx, rdx
  00021	48 8b f9	 mov	 rdi, rcx
  00024	7e 06		 jle	 SHORT $LN3@CalcCustom
  00026	83 79 34 00	 cmp	 DWORD PTR [rcx+52], 0
  0002a	7f 1a		 jg	 SHORT $LN4@CalcCustom
$LN3@CalcCustom:
  0002c	41 b8 b9 08 00
	00		 mov	 r8d, 2233		; 000008b9H
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@CMBJAGBP@?$AAT?$AAe?$AAx?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@CalcCustom:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2712 :     bool IsPacked() const { return X != 0xFFFF; }

  00046	0f b7 43 04	 movzx	 eax, WORD PTR [rbx+4]
  0004a	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0004f	66 3b c1	 cmp	 ax, cx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2234 :     IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed

  00052	75 1e		 jne	 SHORT $LN5@CalcCustom
  00054	41 b8 ba 08 00
	00		 mov	 r8d, 2234		; 000008baH
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DEJIAPCP@?$AAr?$AAe?$AAc?$AAt?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI@
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006e	0f b7 43 04	 movzx	 eax, WORD PTR [rbx+4]
$LN5@CalcCustom:

; 2235 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

  00072	0f b7 c0	 movzx	 eax, ax
  00075	66 0f 6e c0	 movd	 xmm0, eax
  00079	0f b7 43 06	 movzx	 eax, WORD PTR [rbx+6]
  0007d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00080	66 0f 6e c8	 movd	 xmm1, eax
  00084	f3 0f 59 47 38	 mulss	 xmm0, DWORD PTR [rdi+56]
  00089	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0008c	f3 0f 59 4f 3c	 mulss	 xmm1, DWORD PTR [rdi+60]
  00091	0f 14 c1	 unpcklps xmm0, xmm1
  00094	f2 0f 11 45 00	 movsd	 QWORD PTR [rbp], xmm0

; 2236 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

  00099	0f b7 43 04	 movzx	 eax, WORD PTR [rbx+4]
  0009d	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]

; 2237 : }

  000a0	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a5	03 c8		 add	 ecx, eax
  000a7	0f b7 43 06	 movzx	 eax, WORD PTR [rbx+6]
  000ab	66 0f 6e c1	 movd	 xmm0, ecx
  000af	0f b7 4b 02	 movzx	 ecx, WORD PTR [rbx+2]
  000b3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b8	03 c8		 add	 ecx, eax
  000ba	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000bd	66 0f 6e c9	 movd	 xmm1, ecx
  000c1	f3 0f 59 47 38	 mulss	 xmm0, DWORD PTR [rdi+56]
  000c6	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000c9	f3 0f 59 4f 3c	 mulss	 xmm1, DWORD PTR [rdi+60]
  000ce	0f 14 c1	 unpcklps xmm0, xmm1
  000d1	f2 0f 11 06	 movsd	 QWORD PTR [rsi], xmm0
  000d5	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000de	5f		 pop	 rdi
  000df	c3		 ret	 0
?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z ENDP ; ImFontAtlas::CalcCustomRectUV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
cursor_type$ = 56
out_offset$ = 64
out_size$ = 72
out_uv_border$ = 80
out_uv_fill$ = 88
?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z PROC ; ImFontAtlas::GetMouseCursorTexData

; 2240 : {

$LN38:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 63 fa	 movsxd	 rdi, edx
  00017	49 8b f1	 mov	 rsi, r9
  0001a	49 8b e8	 mov	 rbp, r8
  0001d	48 8b d9	 mov	 rbx, rcx

; 2241 :     if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)

  00020	83 ff 08	 cmp	 edi, 8
  00023	0f 87 0d 01 00
	00		 ja	 $LN3@GetMouseCu

; 2243 :     if (Flags & ImFontAtlasFlags_NoMouseCursors)

  00029	f6 01 02	 test	 BYTE PTR [rcx], 2
  0002c	0f 85 04 01 00
	00		 jne	 $LN3@GetMouseCu

; 2244 :         return false;
; 2245 : 
; 2246 :     IM_ASSERT(PackIdMouseCursors != -1);

  00032	8b 91 84 04 00
	00		 mov	 edx, DWORD PTR [rcx+1156]
  00038	83 fa ff	 cmp	 edx, -1
  0003b	75 20		 jne	 SHORT $LN6@GetMouseCu
  0003d	41 b8 c6 08 00
	00		 mov	 r8d, 2246		; 000008c6H
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@JHOLDEIK@?$AAP?$AAa?$AAc?$AAk?$AAI?$AAd?$AAM?$AAo?$AAu?$AAs?$AAe?$AAC?$AAu?$AAr?$AAs@
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00057	8b 93 84 04 00
	00		 mov	 edx, DWORD PTR [rbx+1156]
$LN6@GetMouseCu:

; 2247 :     ImFontAtlasCustomRect* r = GetCustomRectByIndex(PackIdMouseCursors);

  0005d	48 8b cb	 mov	 rcx, rbx
  00060	e8 00 00 00 00	 call	 ?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z ; ImFontAtlas::GetCustomRectByIndex

; 2248 :     ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r->X, (float)r->Y);

  00065	48 8d 14 7f	 lea	 rdx, QWORD PTR [rdi+rdi*2]
  00069	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA@@3QAY02$$CBUImVec2@@A

; 2249 :     ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];

  00070	f3 41 0f 10 54
	d0 08		 movss	 xmm2, DWORD PTR [r8+rdx*8+8]
  00077	0f b7 48 04	 movzx	 ecx, WORD PTR [rax+4]

; 2250 :     *out_size = size;

  0007b	0f 28 c2	 movaps	 xmm0, xmm2
  0007e	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  00082	f3 41 0f 10 64
	d0 0c		 movss	 xmm4, DWORD PTR [r8+rdx*8+12]
  00089	0f 14 c4	 unpcklps xmm0, xmm4
  0008c	66 0f 6e e9	 movd	 xmm5, ecx
  00090	0f 5b ed	 cvtdq2ps xmm5, xmm5
  00093	66 0f 6e d8	 movd	 xmm3, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00097	f3 41 0f 58 2c
	d0		 addss	 xmm5, DWORD PTR [r8+rdx*8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2252 :     out_uv_border[0] = (pos)*TexUvScale;

  0009d	48 8b 44 24 50	 mov	 rax, QWORD PTR out_uv_border$[rsp]
  000a2	0f 5b db	 cvtdq2ps xmm3, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  000a5	0f 28 cd	 movaps	 xmm1, xmm5

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  000a8	f3 41 0f 58 5c
	d0 04		 addss	 xmm3, DWORD PTR [r8+rdx*8+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2250 :     *out_size = size;

  000af	f2 0f 11 06	 movsd	 QWORD PTR [rsi], xmm0

; 2251 :     *out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];

  000b3	f2 41 0f 10 44
	d0 10		 movsd	 xmm0, QWORD PTR [r8+rdx*8+16]
  000ba	f2 0f 11 45 00	 movsd	 QWORD PTR [rbp], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  000bf	f3 0f 59 4b 38	 mulss	 xmm1, DWORD PTR [rbx+56]
  000c4	0f 28 c3	 movaps	 xmm0, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  000c7	f3 0f 58 e3	 addss	 xmm4, xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  000cb	f3 0f 59 43 3c	 mulss	 xmm0, DWORD PTR [rbx+60]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2252 :     out_uv_border[0] = (pos)*TexUvScale;

  000d0	f3 0f 11 08	 movss	 DWORD PTR [rax], xmm1

; 2253 :     out_uv_border[1] = (pos + size) * TexUvScale;

  000d4	0f 28 cd	 movaps	 xmm1, xmm5
  000d7	f3 0f 58 2d 00
	00 00 00	 addss	 xmm5, DWORD PTR __real@42f60000
  000df	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  000e4	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  000e8	0f 28 c4	 movaps	 xmm0, xmm4
  000eb	f3 0f 59 43 3c	 mulss	 xmm0, DWORD PTR [rbx+60]
  000f0	f3 0f 59 4b 38	 mulss	 xmm1, DWORD PTR [rbx+56]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2253 :     out_uv_border[1] = (pos + size) * TexUvScale;

  000f5	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  000fa	0f 28 c5	 movaps	 xmm0, xmm5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2256 :     out_uv_fill[1] = (pos + size) * TexUvScale;

  000fd	f3 0f 58 ea	 addss	 xmm5, xmm2
  00101	f3 0f 11 48 08	 movss	 DWORD PTR [rax+8], xmm1
  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR out_uv_fill$[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  0010b	f3 0f 59 43 38	 mulss	 xmm0, DWORD PTR [rbx+56]
  00110	f3 0f 59 5b 3c	 mulss	 xmm3, DWORD PTR [rbx+60]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2255 :     out_uv_fill[0] = (pos)*TexUvScale;

  00115	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00119	f3 0f 11 58 04	 movss	 DWORD PTR [rax+4], xmm3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  0011e	f3 0f 59 6b 38	 mulss	 xmm5, DWORD PTR [rbx+56]
  00123	f3 0f 59 63 3c	 mulss	 xmm4, DWORD PTR [rbx+60]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2256 :     out_uv_fill[1] = (pos + size) * TexUvScale;

  00128	f3 0f 11 68 08	 movss	 DWORD PTR [rax+8], xmm5
  0012d	f3 0f 11 60 0c	 movss	 DWORD PTR [rax+12], xmm4

; 2257 :     return true;

  00132	b0 01		 mov	 al, 1
  00134	eb 02		 jmp	 SHORT $LN1@GetMouseCu
$LN3@GetMouseCu:

; 2242 :         return false;

  00136	32 c0		 xor	 al, al
$LN1@GetMouseCu:

; 2258 : }

  00138	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0013d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00142	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00147	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z ENDP ; ImFontAtlas::GetMouseCursorTexData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
font_cfg$1 = 48
$T2 = 192
__$ArrayPad$ = 336
this$ = 368
?Build@ImFontAtlas@@QEAA_NXZ PROC			; ImFontAtlas::Build

; 2261 : {

$LN25:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	48 8d 6c 24 a0	 lea	 rbp, QWORD PTR [rsp-96]
  0000b	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 45 50	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax

; 2262 :     IM_ASSERT(!Locked && "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!");

  00020	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  00024	48 8b d9	 mov	 rbx, rcx
  00027	74 1a		 je	 SHORT $LN6@Build
  00029	41 b8 d6 08 00
	00		 mov	 r8d, 2262		; 000008d6H
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LE@PGHOGCJ@?$AA?$CB?$AAL?$AAo?$AAc?$AAk?$AAe?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAC?$AAa?$AAn@
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN6@Build:

; 2263 : 
; 2264 :     // Default font is none are specified
; 2265 :     if (ConfigData.Size == 0)

  00043	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  00047	0f 85 36 01 00
	00		 jne	 $LN2@Build

; 1916 :     GlyphMaxAdvanceX = FLT_MAX;

  0004d	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@7f7fffff
  00055	0f 57 e4	 xorps	 xmm4, xmm4

; 1917 :     RasterizerMultiply = 1.0f;

  00058	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00060	33 c0		 xor	 eax, eax
  00062	0f 11 65 d0	 movups	 XMMWORD PTR $T2[rbp-240], xmm4
  00066	48 89 45 40	 mov	 QWORD PTR $T2[rbp-128], rax

; 1918 :     EllipsisChar = (ImWchar)-1;

  0006a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0006f	0f 11 65 c0	 movups	 XMMWORD PTR $T2[rbp-256], xmm4
  00073	c6 45 cc 01	 mov	 BYTE PTR $T2[rbp-244], 1

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  00077	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR $T2[rbp-256]
  0007b	0f 29 44 24 30	 movaps	 XMMWORD PTR font_cfg$1[rsp], xmm0
  00080	0f 57 c0	 xorps	 xmm0, xmm0
  00083	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H
  00087	f3 0f 10 c2	 movss	 xmm0, xmm2

; 1914 :     OversampleH = 3; // FIXME: 2 may be a better default?

  0008b	c7 45 d8 03 00
	00 00		 mov	 DWORD PTR $T2[rbp-232], 3

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  00092	0f c6 c0 e1	 shufps	 xmm0, xmm0, 225		; 000000e1H
  00096	0f 29 44 24 70	 movaps	 XMMWORD PTR font_cfg$1[rsp+64], xmm0

; 1912 :     memset(this, 0, sizeof(*this));

  0009b	0f 11 65 10	 movups	 XMMWORD PTR $T2[rbp-176], xmm4

; 1918 :     EllipsisChar = (ImWchar)-1;

  0009f	66 89 45 14	 mov	 WORD PTR $T2[rbp-172], ax

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000a3	0f 28 45 10	 movaps	 xmm0, XMMWORD PTR $T2[rbp-176]
  000a7	f3 0f 10 c3	 movss	 xmm0, xmm3

; 1915 :     OversampleV = 1;

  000ab	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR $T2[rbp-228], 1

; 2125 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

  000b2	0f 28 4d d0	 movaps	 xmm1, XMMWORD PTR $T2[rbp-240]
  000b6	0f 29 4c 24 40	 movaps	 XMMWORD PTR font_cfg$1[rsp+16], xmm1

; 2126 :     if (!font_cfg_template)
; 2127 :     {
; 2128 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;
; 2129 :         font_cfg.PixelSnapH = true;
; 2130 :     }
; 2131 :     if (font_cfg.SizePixels <= 0.0f)

  000bb	f3 0f 10 54 24
	44		 movss	 xmm2, DWORD PTR font_cfg$1[rsp+20]
  000c1	0f 29 45 80	 movaps	 XMMWORD PTR font_cfg$1[rbp-176], xmm0
  000c5	f2 0f 10 45 40	 movsd	 xmm0, QWORD PTR $T2[rbp-128]
  000ca	f2 0f 11 45 b0	 movsd	 QWORD PTR font_cfg$1[rbp-128], xmm0
  000cf	0f 57 c0	 xorps	 xmm0, xmm0
  000d2	0f 2f c2	 comiss	 xmm0, xmm2
  000d5	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR font_cfg$1[rsp+28], 1
  000dd	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR font_cfg$1[rsp+24], 1
  000e5	0f 29 64 24 50	 movaps	 XMMWORD PTR font_cfg$1[rsp+32], xmm4
  000ea	0f 29 64 24 60	 movaps	 XMMWORD PTR font_cfg$1[rsp+48], xmm4
  000ef	0f 29 65 90	 movaps	 XMMWORD PTR font_cfg$1[rbp-160], xmm4
  000f3	0f 29 65 a0	 movaps	 XMMWORD PTR font_cfg$1[rbp-144], xmm4
  000f7	c6 44 24 50 01	 mov	 BYTE PTR font_cfg$1[rsp+32], 1
  000fc	72 0e		 jb	 SHORT $LN9@Build

; 2132 :         font_cfg.SizePixels = 13.0f * 1.0f;

  000fe	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@41500000
  00106	f3 0f 11 54 24
	44		 movss	 DWORD PTR font_cfg$1[rsp+20], xmm2
$LN9@Build:

; 2133 :     if (font_cfg.Name[0] == '\0')

  0010c	80 7d 86 00	 cmp	 BYTE PTR font_cfg$1[rbp-170], 0
  00110	75 20		 jne	 SHORT $LN10@Build

; 2134 :         ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "ProggyClean.ttf, %dpx", (int)font_cfg.SizePixels);

  00112	f3 44 0f 2c ca	 cvttss2si r9d, xmm2
  00117	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@CONABPA@ProggyClean?4ttf?0?5?$CFdpx@
  0011e	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00123	48 8d 4d 86	 lea	 rcx, QWORD PTR font_cfg$1[rbp-170]
  00127	e8 00 00 00 00	 call	 ?ImFormatString@@YAHPEAD_KPEBDZZ ; ImFormatString
  0012c	f3 0f 10 54 24
	44		 movss	 xmm2, DWORD PTR font_cfg$1[rsp+20]
$LN10@Build:

; 2135 :     font_cfg.EllipsisChar = (ImWchar)0x0085;
; 2136 :     font_cfg.GlyphOffset.y = 1.0f * IM_FLOOR(font_cfg.SizePixels / 13.0f);  // Add +1 offset per 13 units

  00132	0f 28 c2	 movaps	 xmm0, xmm2

; 2137 : 
; 2138 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2139 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
  0013c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41500000
  00144	b8 85 00 00 00	 mov	 eax, 133		; 00000085H

; 2140 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

  00149	4c 8d 4c 24 30	 lea	 r9, QWORD PTR font_cfg$1[rsp]
  0014e	66 89 45 84	 mov	 WORD PTR font_cfg$1[rbp-172], ax
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB
  00159	f3 0f 2c c0	 cvttss2si eax, xmm0
  0015d	66 0f 6e c0	 movd	 xmm0, eax

; 2137 : 
; 2138 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 2139 :     const ImWchar* glyph_ranges = font_cfg.GlyphRanges != NULL ? font_cfg.GlyphRanges : GetGlyphRangesDefault();

  00161	48 8b 44 24 68	 mov	 rax, QWORD PTR font_cfg$1[rsp+56]
  00166	48 85 c0	 test	 rax, rax
  00169	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0016c	48 0f 45 c8	 cmovne	 rcx, rax

; 2140 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, glyph_ranges);

  00170	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00175	48 8b cb	 mov	 rcx, rbx
  00178	f3 0f 11 44 24
	60		 movss	 DWORD PTR font_cfg$1[rsp+48], xmm0
  0017e	e8 00 00 00 00	 call	 ?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
$LN2@Build:

; 2266 :         AddFontDefault();
; 2267 : 
; 2268 :     // Select builder
; 2269 :     // - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
; 2270 :     //   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
; 2271 :     //   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
; 2272 :     //   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
; 2273 :     const ImFontBuilderIO* builder_io = FontBuilderIO;

  00183	48 8b 83 78 04
	00 00		 mov	 rax, QWORD PTR [rbx+1144]

; 2274 :     if (builder_io == NULL)

  0018a	48 85 c0	 test	 rax, rax
  0018d	75 15		 jne	 SHORT $LN3@Build

; 2599 :     io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;

  0018f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
  00196	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A, rax

; 2275 :     {
; 2276 : #ifdef IMGUI_ENABLE_FREETYPE
; 2277 :         builder_io = ImGuiFreeType::GetBuilderForFreeType();
; 2278 : #elif defined(IMGUI_ENABLE_STB_TRUETYPE)
; 2279 :         builder_io = ImFontAtlasGetBuilderForStbTruetype();

  0019d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A
$LN3@Build:

; 2280 : #else
; 2281 :         IM_ASSERT(0); // Invalid Build function
; 2282 : #endif
; 2283 :     }
; 2284 : 
; 2285 :     // Build
; 2286 :     return builder_io->FontBuilder_Build(this);

  001a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a7	48 8b cb	 mov	 rcx, rbx
  001aa	ff d0		 call	 rax

; 2287 : }

  001ac	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  001b0	48 33 cc	 xor	 rcx, rsp
  001b3	e8 00 00 00 00	 call	 __security_check_cookie
  001b8	48 8b 9c 24 78
	01 00 00	 mov	 rbx, QWORD PTR [rsp+376]
  001c0	48 81 c4 60 01
	00 00		 add	 rsp, 352		; 00000160H
  001c7	5d		 pop	 rbp
  001c8	c3		 ret	 0
?Build@ImFontAtlas@@QEAA_NXZ ENDP			; ImFontAtlas::Build
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
out_table$ = 8
in_brighten_factor$ = 16
?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z PROC ; ImFontAtlasBuildMultiplyCalcLookupTable

; 2291 :     for (unsigned int i = 0; i < 256; i++)

  00000	45 33 c9	 xor	 r9d, r9d
  00003	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL10@ImFontAtla:

; 2292 :     {
; 2293 :         unsigned int value = (unsigned int)(i * in_brighten_factor);

  00010	41 8b c1	 mov	 eax, r9d
  00013	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  00017	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :         out_table[i] = value > 255 ? 255 : (value & 0xFF);

  0001a	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  00020	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00025	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00029	f3 48 0f 2c d0	 cvttss2si rdx, xmm0
  0002e	41 3b d0	 cmp	 edx, r8d
  00031	0f b6 c2	 movzx	 eax, dl
  00034	44 0f 46 c0	 cmovbe	 r8d, eax
  00038	41 ff c1	 inc	 r9d
  0003b	44 88 41 ff	 mov	 BYTE PTR [rcx-1], r8b
  0003f	41 81 f9 00 01
	00 00		 cmp	 r9d, 256		; 00000100H
  00046	72 c8		 jb	 SHORT $LL10@ImFontAtla

; 2295 :     }
; 2296 : }

  00048	c3		 ret	 0
?ImFontAtlasBuildMultiplyCalcLookupTable@@YAXQEAEM@Z ENDP ; ImFontAtlasBuildMultiplyCalcLookupTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
table$ = 16
pixels$ = 24
x$ = 32
y$ = 40
w$ = 48
h$ = 56
stride$ = 64
?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z PROC ; ImFontAtlasBuildMultiplyRectAlpha8

; 2299 : {

$LN18:
  00000	40 53		 push	 rbx

; 2302 :         for (int i = 0; i < w; i++)

  00002	48 63 5c 24 30	 movsxd	 rbx, DWORD PTR w$[rsp]
  00007	4c 8b d1	 mov	 r10, rcx
  0000a	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR stride$[rsp]
  0000f	44 0f af c9	 imul	 r9d, ecx
  00013	4d 63 d8	 movsxd	 r11, r8d
  00016	49 63 c1	 movsxd	 rax, r9d
  00019	44 8b 4c 24 38	 mov	 r9d, DWORD PTR h$[rsp]
  0001e	48 03 c2	 add	 rax, rdx
  00021	4c 03 d8	 add	 r11, rax
  00024	45 85 c9	 test	 r9d, r9d
  00027	7e 3c		 jle	 SHORT $LN3@ImFontAtla
  00029	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0002e	48 8b f9	 mov	 rdi, rcx
$LL4@ImFontAtla:
  00031	48 85 db	 test	 rbx, rbx
  00034	7e 1f		 jle	 SHORT $LN2@ImFontAtla
  00036	49 8b c3	 mov	 rax, r11
  00039	4c 8b c3	 mov	 r8, rbx
  0003c	0f 1f 40 00	 npad	 4
$LL7@ImFontAtla:

; 2303 :             data[i] = table[data[i]];

  00040	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00043	48 8d 40 01	 lea	 rax, QWORD PTR [rax+1]
  00047	42 0f b6 14 11	 movzx	 edx, BYTE PTR [rcx+r10]
  0004c	88 50 ff	 mov	 BYTE PTR [rax-1], dl
  0004f	49 83 e8 01	 sub	 r8, 1
  00053	75 eb		 jne	 SHORT $LL7@ImFontAtla
$LN2@ImFontAtla:

; 2300 :     unsigned char* data = pixels + x + y * stride;
; 2301 :     for (int j = h; j > 0; j--, data += stride)

  00055	41 ff c9	 dec	 r9d
  00058	4c 03 df	 add	 r11, rdi
  0005b	45 85 c9	 test	 r9d, r9d
  0005e	7f d1		 jg	 SHORT $LL4@ImFontAtla
  00060	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
$LN3@ImFontAtla:

; 2304 : }

  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
?ImFontAtlasBuildMultiplyRectAlpha8@@YAXQEBEPEAEHHHHH@Z ENDP ; ImFontAtlasBuildMultiplyRectAlpha8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
in$ = 80
out$ = 88
?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z PROC ; UnpackBitVectorToFlatIndexList

; 2333 : {

  00000	40 57		 push	 rdi
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2334 :     IM_ASSERT(sizeof(in->Storage.Data[0]) == sizeof(int));
; 2335 :     const ImU32* it_begin = in->Storage.begin();

  0000c	4c 8b 61 08	 mov	 r12, QWORD PTR [rcx+8]
  00010	48 8b fa	 mov	 rdi, rdx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1800 :     inline const T* end() const { return Data + Size; }

  00013	48 63 01	 movsxd	 rax, DWORD PTR [rcx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2337 :     for (const ImU32* it = it_begin; it < it_end; it++)

  00016	4d 8b f4	 mov	 r14, r12
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1800 :     inline const T* end() const { return Data + Size; }

  00019	4d 8d 2c 84	 lea	 r13, QWORD PTR [r12+rax*4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2337 :     for (const ImU32* it = it_begin; it < it_end; it++)

  0001d	4d 3b e5	 cmp	 r12, r13
  00020	0f 83 ad 00 00
	00		 jae	 $LN3@UnpackBitV
  00026	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0002b	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00030	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00035	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL4@UnpackBitV:

; 2338 :         if (ImU32 entries_32 = *it)

  00040	45 8b 3e	 mov	 r15d, DWORD PTR [r14]
  00043	45 85 ff	 test	 r15d, r15d
  00046	74 6e		 je	 SHORT $LN2@UnpackBitV

; 2339 :             for (ImU32 bit_n = 0; bit_n < 32; bit_n++)

  00048	33 f6		 xor	 esi, esi
  0004a	bb 01 00 00 00	 mov	 ebx, 1
  0004f	90		 npad	 1
$LL7@UnpackBitV:

; 2340 :                 if (entries_32 & ((ImU32)1 << bit_n))

  00050	41 85 df	 test	 ebx, r15d
  00053	74 58		 je	 SHORT $LN5@UnpackBitV
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00055	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2341 :                     out->push_back((int)(((it - it_begin) << 5) + bit_n));

  00058	4a 8d 04 e5 00
	00 00 00	 lea	 rax, QWORD PTR [r12*8]
  00060	4a 8d 2c f5 00
	00 00 00	 lea	 rbp, QWORD PTR [r14*8]
  00068	2b e8		 sub	 ebp, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0006a	8b 07		 mov	 eax, DWORD PTR [rdi]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2341 :                     out->push_back((int)(((it - it_begin) << 5) + bit_n));

  0006c	83 e5 e0	 and	 ebp, -32		; ffffffffffffffe0H
  0006f	03 ee		 add	 ebp, esi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00071	3b c1		 cmp	 eax, ecx
  00073	75 2c		 jne	 SHORT $LN14@UnpackBitV
  00075	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00079	85 c9		 test	 ecx, ecx
  0007b	74 0b		 je	 SHORT $LN18@UnpackBitV
  0007d	8b c1		 mov	 eax, ecx
  0007f	99		 cdq
  00080	2b c2		 sub	 eax, edx
  00082	d1 f8		 sar	 eax, 1
  00084	03 c1		 add	 eax, ecx
  00086	eb 05		 jmp	 SHORT $LN19@UnpackBitV
$LN18@UnpackBitV:
  00088	b8 08 00 00 00	 mov	 eax, 8
$LN19@UnpackBitV:
  0008d	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00090	48 8b cf	 mov	 rcx, rdi

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00093	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00097	41 8b d0	 mov	 edx, r8d
  0009a	e8 00 00 00 00	 call	 ?reserve@?$ImVector@H@@QEAAXH@Z ; ImVector<int>::reserve
  0009f	8b 07		 mov	 eax, DWORD PTR [rdi]
$LN14@UnpackBitV:
  000a1	48 63 c8	 movsxd	 rcx, eax
  000a4	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000a8	89 2c 88	 mov	 DWORD PTR [rax+rcx*4], ebp
  000ab	ff 07		 inc	 DWORD PTR [rdi]
$LN5@UnpackBitV:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2339 :             for (ImU32 bit_n = 0; bit_n < 32; bit_n++)

  000ad	ff c6		 inc	 esi
  000af	d1 c3		 rol	 ebx, 1
  000b1	83 fe 20	 cmp	 esi, 32			; 00000020H
  000b4	72 9a		 jb	 SHORT $LL7@UnpackBitV
$LN2@UnpackBitV:

; 2337 :     for (const ImU32* it = it_begin; it < it_end; it++)

  000b6	49 83 c6 04	 add	 r14, 4
  000ba	4d 3b f5	 cmp	 r14, r13
  000bd	72 81		 jb	 SHORT $LL4@UnpackBitV
  000bf	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  000c4	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000c9	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000ce	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN3@UnpackBitV:

; 2342 : }

  000d3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d7	41 5e		 pop	 r14
  000d9	41 5d		 pop	 r13
  000db	41 5c		 pop	 r12
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
?UnpackBitVectorToFlatIndexList@@YAXPEBUImBitVector@@PEAU?$ImVector@H@@@Z ENDP ; UnpackBitVectorToFlatIndexList
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
src_tmp_array$2$ = 96
new_size$1$ = 100
buf_packedchars_out_n$1$ = 100
total_surface$1$ = 104
src_i$1$ = 104
src_i$1$ = 104
total_glyphs_count$2$ = 108
src_i$1$ = 112
src_i$1$ = 112
src_tmp_array$1$ = 120
$T4 = 128
$T5 = 128
padding$1$ = 128
atlas$GSCopy$1$ = 136
dst_tmp_array$1$ = 144
buf_rects_out_n$1$ = 152
$T6 = 160
$T7 = 168
buf_packedchars$1$ = 168
it_end$1$ = 176
tv8082 = 176
tv8055 = 176
glyph_i$1$ = 184
buf_rects$1$ = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
$T8 = 248
buf_packedchars$ = 256
spc$ = 272
c$9 = 336
multiply_table$10 = 400
__$ArrayPad$ = 656
atlas$ = 848
?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildWithStbTruetype

; 2345 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d a8 b8 fd
	ff ff		 lea	 rbp, QWORD PTR [rax-584]
  0001f	48 81 ec 20 03
	00 00		 sub	 rsp, 800		; 00000320H
  00026	0f 29 70 c8	 movaps	 XMMWORD PTR [rax-56], xmm6
  0002a	0f 29 78 b8	 movaps	 XMMWORD PTR [rax-72], xmm7
  0002e	44 0f 29 40 a8	 movaps	 XMMWORD PTR [rax-88], xmm8
  00033	44 0f 29 48 98	 movaps	 XMMWORD PTR [rax-104], xmm9
  00038	44 0f 29 50 88	 movaps	 XMMWORD PTR [rax-120], xmm10
  0003d	44 0f 29 98 78
	ff ff ff	 movaps	 XMMWORD PTR [rax-136], xmm11
  00045	44 0f 29 a0 68
	ff ff ff	 movaps	 XMMWORD PTR [rax-152], xmm12
  0004d	44 0f 29 a8 58
	ff ff ff	 movaps	 XMMWORD PTR [rax-168], xmm13
  00055	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0005c	48 33 c4	 xor	 rax, rsp
  0005f	48 89 85 90 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  00066	48 8b f1	 mov	 rsi, rcx
  00069	48 89 4d 88	 mov	 QWORD PTR atlas$GSCopy$1$[rbp-256], rcx

; 2346 :     IM_ASSERT(atlas->ConfigData.Size > 0);

  0006d	48 8d 59 68	 lea	 rbx, QWORD PTR [rcx+104]
  00071	48 89 5d a0	 mov	 QWORD PTR $T6[rbp-256], rbx
  00075	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00078	7f 1a		 jg	 SHORT $LN66@ImFontAtla
  0007a	41 b8 2a 09 00
	00		 mov	 r8d, 2346		; 0000092aH
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@BBHAKCJP@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAf?$AAi?$AAg?$AAD?$AAa@
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN66@ImFontAtla:

; 2762 :     if (atlas->PackIdMouseCursors < 0)

  00094	83 be 84 04 00
	00 00		 cmp	 DWORD PTR [rsi+1156], 0
  0009b	7d 28		 jge	 SHORT $LN93@ImFontAtla

; 2763 :     {
; 2764 :         if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	f6 06 02	 test	 BYTE PTR [rsi], 2
  000a3	75 0d		 jne	 SHORT $LN92@ImFontAtla

; 2765 :             atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);

  000a5	ba f5 00 00 00	 mov	 edx, 245		; 000000f5H
  000aa	41 b8 1b 00 00
	00		 mov	 r8d, 27
  000b0	eb 08		 jmp	 SHORT $LN878@ImFontAtla
$LN92@ImFontAtla:

; 2766 :         else
; 2767 :             atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);

  000b2	ba 02 00 00 00	 mov	 edx, 2
  000b7	44 8b c2	 mov	 r8d, edx
$LN878@ImFontAtla:

; 2768 :     }
; 2769 : 
; 2770 :     // Register texture region for thick lines
; 2771 :     // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
; 2772 :     if (atlas->PackIdLines < 0)

  000ba	e8 00 00 00 00	 call	 ?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z ; ImFontAtlas::AddCustomRectRegular
  000bf	89 86 84 04 00
	00		 mov	 DWORD PTR [rsi+1156], eax
$LN93@ImFontAtla:
  000c5	83 be 88 04 00
	00 00		 cmp	 DWORD PTR [rsi+1160], 0
  000cc	7d 1c		 jge	 SHORT $LN95@ImFontAtla

; 2773 :     {
; 2774 :         if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))

  000ce	f6 06 04	 test	 BYTE PTR [rsi], 4
  000d1	75 17		 jne	 SHORT $LN95@ImFontAtla

; 2775 :             atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);

  000d3	ba 41 00 00 00	 mov	 edx, 65			; 00000041H
  000d8	44 8d 42 ff	 lea	 r8d, QWORD PTR [rdx-1]
  000dc	48 8b ce	 mov	 rcx, rsi
  000df	e8 00 00 00 00	 call	 ?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z ; ImFontAtlas::AddCustomRectRegular
  000e4	89 86 88 04 00
	00		 mov	 DWORD PTR [rsi+1160], eax
$LN95@ImFontAtla:

; 2347 : 
; 2348 :     ImFontAtlasBuildInit(atlas);
; 2349 : 
; 2350 :     // Clear atlas
; 2351 :     atlas->TexID = (ImTextureID)NULL;

  000ea	45 33 e4	 xor	 r12d, r12d
  000ed	4c 89 66 08	 mov	 QWORD PTR [rsi+8], r12

; 2352 :     atlas->TexWidth = atlas->TexHeight = 0;

  000f1	4c 89 66 30	 mov	 QWORD PTR [rsi+48], r12

; 2353 :     atlas->TexUvScale = ImVec2(0.0f, 0.0f);

  000f5	4c 89 66 38	 mov	 QWORD PTR [rsi+56], r12

; 2354 :     atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);

  000f9	4c 89 66 40	 mov	 QWORD PTR [rsi+64], r12

; 2355 :     atlas->ClearTexData();

  000fd	48 8b ce	 mov	 rcx, rsi
  00100	e8 00 00 00 00	 call	 ?ClearTexData@ImFontAtlas@@QEAAXXZ ; ImFontAtlas::ClearTexData
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00105	44 89 65 ec	 mov	 DWORD PTR src_tmp_array$[rbp-252], r12d
  00109	41 8b fc	 mov	 edi, r12d
  0010c	4c 89 64 24 78	 mov	 QWORD PTR src_tmp_array$1$[rsp], r12
  00111	4c 89 65 f0	 mov	 QWORD PTR src_tmp_array$[rbp-248], r12
  00115	44 89 65 cc	 mov	 DWORD PTR dst_tmp_array$[rbp-252], r12d
  00119	45 8b ec	 mov	 r13d, r12d
  0011c	4c 89 65 90	 mov	 QWORD PTR dst_tmp_array$1$[rbp-256], r12
  00120	4c 89 65 d0	 mov	 QWORD PTR dst_tmp_array$[rbp-248], r12
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2360 :     src_tmp_array.resize(atlas->ConfigData.Size);

  00124	44 8b 33	 mov	 r14d, DWORD PTR [rbx]
  00127	44 89 74 24 60	 mov	 DWORD PTR src_tmp_array$2$[rsp], r14d
  0012c	41 8d 44 24 08	 lea	 eax, QWORD PTR [r12+8]
  00131	45 85 f6	 test	 r14d, r14d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00134	7e 43		 jle	 SHORT $LN112@ImFontAtla

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00136	41 8b de	 mov	 ebx, r14d
  00139	44 3b f0	 cmp	 r14d, eax
  0013c	0f 4c d8	 cmovl	 ebx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0013f	85 db		 test	 ebx, ebx

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00141	7e 36		 jle	 SHORT $LN112@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00143	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0014a	48 85 c0	 test	 rax, rax
  0014d	74 06		 je	 SHORT $LN117@ImFontAtla

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  0014f	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN117@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00155	48 63 c3	 movsxd	 rax, ebx
  00158	48 69 c8 10 01
	00 00		 imul	 rcx, rax, 272		; 00000110H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00165	48 8b f8	 mov	 rdi, rax
  00168	48 89 44 24 78	 mov	 QWORD PTR src_tmp_array$1$[rsp], rax
  0016d	48 89 45 f0	 mov	 QWORD PTR src_tmp_array$[rbp-248], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00171	89 5d ec	 mov	 DWORD PTR src_tmp_array$[rbp-252], ebx
  00174	b8 08 00 00 00	 mov	 eax, 8
$LN112@ImFontAtla:

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00179	44 89 75 e8	 mov	 DWORD PTR src_tmp_array$[rbp-256], r14d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2361 :     dst_tmp_array.resize(atlas->Fonts.Size);

  0017d	44 8b 7e 48	 mov	 r15d, DWORD PTR [rsi+72]
  00181	44 89 7c 24 64	 mov	 DWORD PTR new_size$1$[rsp], r15d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00186	45 85 ff	 test	 r15d, r15d
  00189	7e 3b		 jle	 SHORT $LN138@ImFontAtla

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0018b	41 8b df	 mov	 ebx, r15d
  0018e	41 83 ff 08	 cmp	 r15d, 8
  00192	0f 4c d8	 cmovl	 ebx, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00195	85 db		 test	 ebx, ebx
  00197	7e 2d		 jle	 SHORT $LN138@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00199	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  001a0	48 85 c0	 test	 rax, rax
  001a3	74 06		 je	 SHORT $LN143@ImFontAtla

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  001a5	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN143@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  001ab	48 63 cb	 movsxd	 rcx, ebx
  001ae	48 c1 e1 05	 shl	 rcx, 5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001b8	4c 8b e8	 mov	 r13, rax
  001bb	48 89 45 90	 mov	 QWORD PTR dst_tmp_array$1$[rbp-256], rax
  001bf	48 89 45 d0	 mov	 QWORD PTR dst_tmp_array$[rbp-248], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  001c3	89 5d cc	 mov	 DWORD PTR dst_tmp_array$[rbp-252], ebx
$LN138@ImFontAtla:

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  001c6	44 89 7d c8	 mov	 DWORD PTR dst_tmp_array$[rbp-256], r15d

; 1791 :     inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

  001ca	41 69 ce 10 01
	00 00		 imul	 ecx, r14d, 272		; 00000110H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2362 :     memset(src_tmp_array.Data, 0, (size_t)src_tmp_array.size_in_bytes());

  001d1	4c 63 c1	 movsxd	 r8, ecx
  001d4	33 d2		 xor	 edx, edx
  001d6	48 8b cf	 mov	 rcx, rdi
  001d9	e8 00 00 00 00	 call	 memset

; 2363 :     memset(dst_tmp_array.Data, 0, (size_t)dst_tmp_array.size_in_bytes());

  001de	41 8b cf	 mov	 ecx, r15d
  001e1	c1 e1 05	 shl	 ecx, 5
  001e4	4c 63 c1	 movsxd	 r8, ecx
  001e7	33 d2		 xor	 edx, edx
  001e9	49 8b cd	 mov	 rcx, r13
  001ec	e8 00 00 00 00	 call	 memset

; 2364 : 
; 2365 :     // 1. Initialize font loading structure, check font data validity
; 2366 :     for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)

  001f1	48 8d 5e 68	 lea	 rbx, QWORD PTR [rsi+104]
  001f5	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  001f8	0f 8e 33 02 00
	00		 jle	 $LN873@ImFontAtla
  001fe	33 c0		 xor	 eax, eax
  00200	44 8b e8	 mov	 r13d, eax
  00203	44 8b f8	 mov	 r15d, eax
  00206	48 81 c7 e4 00
	00 00		 add	 rdi, 228		; 000000e4H
  0020d	eb 05		 jmp	 SHORT $LN4@ImFontAtla
  0020f	90		 npad	 1
$LL869@ImFontAtla:
  00210	48 8b 75 88	 mov	 rsi, QWORD PTR atlas$GSCopy$1$[rbp-256]
$LN4@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00214	4d 85 ed	 test	 r13, r13
  00217	78 05		 js	 SHORT $LN163@ImFontAtla
  00219	45 3b e6	 cmp	 r12d, r14d
  0021c	7c 1a		 jl	 SHORT $LN164@ImFontAtla
$LN163@ImFontAtla:
  0021e	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00224	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN164@ImFontAtla:
  00238	4d 85 ed	 test	 r13, r13
  0023b	78 05		 js	 SHORT $LN167@ImFontAtla
  0023d	44 3b 23	 cmp	 r12d, DWORD PTR [rbx]
  00240	7c 1a		 jl	 SHORT $LN168@ImFontAtla
$LN167@ImFontAtla:
  00242	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00248	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN168@ImFontAtla:
  0025c	4c 8b 73 08	 mov	 r14, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2370 :         IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));

  00260	4b 8b 84 37 80
	00 00 00	 mov	 rax, QWORD PTR [r15+r14+128]
  00268	48 85 c0	 test	 rax, rax
  0026b	74 0e		 je	 SHORT $LN68@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2873 :     bool                        IsLoaded() const { return ContainerAtlas != NULL; }

  0026d	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00271	48 85 c0	 test	 rax, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2370 :         IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));

  00274	74 1f		 je	 SHORT $LN67@ImFontAtla
  00276	48 3b c6	 cmp	 rax, rsi
  00279	74 1a		 je	 SHORT $LN67@ImFontAtla
$LN68@ImFontAtla:
  0027b	41 b8 42 09 00
	00		 mov	 r8d, 2370		; 00000942H
  00281	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00288	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@NPGLPIC@?$AAc?$AAf?$AAg?$AA?4?$AAD?$AAs?$AAt?$AAF?$AAo?$AAn?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
  0028f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN67@ImFontAtla:

; 2371 : 
; 2372 :         // Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
; 2373 :         src_tmp.DstIndex = -1;

  00295	c7 47 fc ff ff
	ff ff		 mov	 DWORD PTR [rdi-4], -1

; 2374 :         for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)

  0029c	33 d2		 xor	 edx, edx
  0029e	8b da		 mov	 ebx, edx
  002a0	8b 4e 48	 mov	 ecx, DWORD PTR [rsi+72]
  002a3	85 c9		 test	 ecx, ecx
  002a5	0f 8e 65 01 00
	00		 jle	 $LN767@ImFontAtla

; 2376 :                 src_tmp.DstIndex = output_i;

  002ab	b8 ff ff ff ff	 mov	 eax, -1
  002b0	8b f2		 mov	 esi, edx
  002b2	48 8b 55 88	 mov	 rdx, QWORD PTR atlas$GSCopy$1$[rbp-256]
$LL7@ImFontAtla:

; 2374 :         for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)

  002b6	83 f8 ff	 cmp	 eax, -1
  002b9	75 58		 jne	 SHORT $LN851@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  002bb	85 db		 test	 ebx, ebx
  002bd	78 04		 js	 SHORT $LN173@ImFontAtla
  002bf	3b d9		 cmp	 ebx, ecx
  002c1	7c 1e		 jl	 SHORT $LN174@ImFontAtla
$LN173@ImFontAtla:
  002c3	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  002c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002dd	48 8b 55 88	 mov	 rdx, QWORD PTR atlas$GSCopy$1$[rbp-256]
$LN174@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2375 :             if (cfg.DstFont == atlas->Fonts[output_i])

  002e1	48 8b 42 50	 mov	 rax, QWORD PTR [rdx+80]
  002e5	48 8b 0c 06	 mov	 rcx, QWORD PTR [rsi+rax]
  002e9	4b 39 8c 37 80
	00 00 00	 cmp	 QWORD PTR [r15+r14+128], rcx
  002f1	75 07		 jne	 SHORT $LN818@ImFontAtla

; 2376 :                 src_tmp.DstIndex = output_i;

  002f3	89 5f fc	 mov	 DWORD PTR [rdi-4], ebx
  002f6	8b c3		 mov	 eax, ebx
  002f8	eb 03		 jmp	 SHORT $LN5@ImFontAtla
$LN818@ImFontAtla:
  002fa	8b 47 fc	 mov	 eax, DWORD PTR [rdi-4]
$LN5@ImFontAtla:

; 2374 :         for (int output_i = 0; output_i < atlas->Fonts.Size && src_tmp.DstIndex == -1; output_i++)

  002fd	ff c3		 inc	 ebx
  002ff	48 83 c6 08	 add	 rsi, 8
  00303	8b 4a 48	 mov	 ecx, DWORD PTR [rdx+72]
  00306	3b d9		 cmp	 ebx, ecx
  00308	7c ac		 jl	 SHORT $LL7@ImFontAtla

; 2377 :         if (src_tmp.DstIndex == -1)

  0030a	83 f8 ff	 cmp	 eax, -1
  0030d	0f 84 fd 00 00
	00		 je	 $LN767@ImFontAtla
$LN851@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 4843 :     return stbtt_GetFontOffsetForIndex_internal((unsigned char*)data, index);

  00313	4f 8b 0c 37	 mov	 r9, QWORD PTR [r15+r14]
  00317	43 8b 54 37 10	 mov	 edx, DWORD PTR [r15+r14+16]
  0031c	49 8b c9	 mov	 rcx, r9
  0031f	e8 00 00 00 00	 call	 ?stbtt_GetFontOffsetForIndex_internal@@YAHPEAEH@Z ; stbtt_GetFontOffsetForIndex_internal
  00324	8b f0		 mov	 esi, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2384 :         IM_ASSERT(font_offset >= 0 && "FontData is incorrect, or FontNo cannot be found.");

  00326	85 c0		 test	 eax, eax
  00328	79 1e		 jns	 SHORT $LN71@ImFontAtla
  0032a	41 b8 50 09 00
	00		 mov	 r8d, 2384		; 00000950H
  00330	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00337	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JA@MENENCJI@?$AAf?$AAo?$AAn?$AAt?$AA_?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5@
  0033e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00344	4f 8b 0c 37	 mov	 r9, QWORD PTR [r15+r14]
$LN71@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 4853 :     return stbtt_InitFont_internal(info, (unsigned char*)data, offset);

  00348	44 8b c6	 mov	 r8d, esi
  0034b	49 8b d1	 mov	 rdx, r9
  0034e	48 8d 8f 1c ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-228]
  00355	e8 00 00 00 00	 call	 ?stbtt_InitFont_internal@@YAHPEAUstbtt_fontinfo@@PEAEH@Z ; stbtt_InitFont_internal
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2385 :         if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))

  0035a	85 c0		 test	 eax, eax
  0035c	0f 84 c8 00 00
	00		 je	 $LN69@ImFontAtla

; 2386 :             return false;
; 2387 : 
; 2388 :         // Measure highest codepoints
; 2389 :         ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];

  00362	48 63 5f fc	 movsxd	 rbx, DWORD PTR [rdi-4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00366	85 db		 test	 ebx, ebx
  00368	78 06		 js	 SHORT $LN229@ImFontAtla
  0036a	3b 5c 24 64	 cmp	 ebx, DWORD PTR new_size$1$[rsp]
  0036e	7c 1a		 jl	 SHORT $LN230@ImFontAtla
$LN229@ImFontAtla:
  00370	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00376	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0037d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00384	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN230@ImFontAtla:
  0038a	4c 8b c3	 mov	 r8, rbx
  0038d	49 c1 e0 05	 shl	 r8, 5
  00391	48 8b 75 90	 mov	 rsi, QWORD PTR dst_tmp_array$1$[rbp-256]
  00395	4c 03 c6	 add	 r8, rsi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2390 :         src_tmp.SrcRanges = cfg.GlyphRanges ? cfg.GlyphRanges : atlas->GetGlyphRangesDefault();

  00398	4b 8b 44 37 38	 mov	 rax, QWORD PTR [r15+r14+56]
  0039d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB
  003a4	48 85 c0	 test	 rax, rax
  003a7	48 0f 45 d0	 cmovne	 rdx, rax
  003ab	48 89 57 f4	 mov	 QWORD PTR [rdi-12], rdx

; 2391 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

  003af	66 83 3a 00	 cmp	 WORD PTR [rdx], 0
  003b3	74 1c		 je	 SHORT $LN9@ImFontAtla
$LL10@ImFontAtla:
  003b5	0f b7 42 02	 movzx	 eax, WORD PTR [rdx+2]
  003b9	66 85 c0	 test	 ax, ax
  003bc	74 13		 je	 SHORT $LN9@ImFontAtla

; 2392 :             src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);

  003be	8b c8		 mov	 ecx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  003c0	39 07		 cmp	 DWORD PTR [rdi], eax
  003c2	0f 4d 0f	 cmovge	 ecx, DWORD PTR [rdi]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2392 :             src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, (int)src_range[1]);

  003c5	89 0f		 mov	 DWORD PTR [rdi], ecx

; 2391 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

  003c7	48 83 c2 04	 add	 rdx, 4
  003cb	66 83 3a 00	 cmp	 WORD PTR [rdx], 0
  003cf	75 e4		 jne	 SHORT $LL10@ImFontAtla
$LN9@ImFontAtla:

; 2393 :         dst_tmp.SrcCount++;

  003d1	41 ff 00	 inc	 DWORD PTR [r8]

; 2394 :         dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);

  003d4	8b 0f		 mov	 ecx, DWORD PTR [rdi]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  003d6	41 39 48 04	 cmp	 DWORD PTR [r8+4], ecx
  003da	41 0f 4d 48 04	 cmovge	 ecx, DWORD PTR [r8+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2394 :         dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest);

  003df	41 89 48 04	 mov	 DWORD PTR [r8+4], ecx

; 2364 : 
; 2365 :     // 1. Initialize font loading structure, check font data validity
; 2366 :     for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)

  003e3	41 ff c4	 inc	 r12d
  003e6	49 ff c5	 inc	 r13
  003e9	48 81 c7 10 01
	00 00		 add	 rdi, 272		; 00000110H
  003f0	49 81 c7 88 00
	00 00		 add	 r15, 136		; 00000088H
  003f7	48 8b 5d a0	 mov	 rbx, QWORD PTR $T6[rbp-256]
  003fb	44 3b 23	 cmp	 r12d, DWORD PTR [rbx]
  003fe	44 8b 74 24 60	 mov	 r14d, DWORD PTR src_tmp_array$2$[rsp]
  00403	0f 8c 07 fe ff
	ff		 jl	 $LL869@ImFontAtla

; 2385 :         if (!stbtt_InitFont(&src_tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))

  00409	44 8b 7c 24 64	 mov	 r15d, DWORD PTR new_size$1$[rsp]
  0040e	eb 25		 jmp	 SHORT $LN3@ImFontAtla
$LN767@ImFontAtla:

; 2378 :         {
; 2379 :             IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts[] array?

  00410	41 b8 4b 09 00
	00		 mov	 r8d, 2379		; 0000094bH
  00416	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0041d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@NKKOCLPN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAD?$AAs?$AAt?$AAI?$AAn?$AAd?$AAe@
  00424	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN69@ImFontAtla:
  0042a	32 db		 xor	 bl, bl
  0042c	e9 39 13 00 00	 jmp	 $LN711@ImFontAtla
$LN873@ImFontAtla:

; 2364 : 
; 2365 :     // 1. Initialize font loading structure, check font data validity
; 2366 :     for (int src_i = 0; src_i < atlas->ConfigData.Size; src_i++)

  00431	48 8b 75 90	 mov	 rsi, QWORD PTR dst_tmp_array$1$[rbp-256]
$LN3@ImFontAtla:

; 2395 :     }
; 2396 : 
; 2397 :     // 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
; 2398 :     int total_glyphs_count = 0;

  00435	33 c0		 xor	 eax, eax
  00437	89 44 24 6c	 mov	 DWORD PTR total_glyphs_count$2$[rsp], eax
  0043b	8b f8		 mov	 edi, eax
  0043d	89 44 24 68	 mov	 DWORD PTR src_i$1$[rsp], eax

; 2399 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  00441	45 85 f6	 test	 r14d, r14d
  00444	0f 8e d5 03 00
	00		 jle	 $LN12@ImFontAtla

; 2376 :                 src_tmp.DstIndex = output_i;

  0044a	4c 8b 74 24 78	 mov	 r14, QWORD PTR src_tmp_array$1$[rsp]
  0044f	49 81 c6 e8 00
	00 00		 add	 r14, 232		; 000000e8H
$LL13@ImFontAtla:

; 2400 :     {
; 2401 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
; 2402 :         ImFontBuildDstData& dst_tmp = dst_tmp_array[src_tmp.DstIndex];

  00456	49 63 5e f8	 movsxd	 rbx, DWORD PTR [r14-8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  0045a	85 db		 test	 ebx, ebx
  0045c	78 05		 js	 SHORT $LN241@ImFontAtla
  0045e	41 3b df	 cmp	 ebx, r15d
  00461	7c 1a		 jl	 SHORT $LN242@ImFontAtla
$LN241@ImFontAtla:
  00463	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00469	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00470	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00477	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN242@ImFontAtla:
  0047d	4c 8b eb	 mov	 r13, rbx
  00480	49 c1 e5 05	 shl	 r13, 5
  00484	4c 03 ee	 add	 r13, rsi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 562  :     void            Create(int sz) { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

  00487	41 8b 5e fc	 mov	 ebx, DWORD PTR [r14-4]
  0048b	83 c3 20	 add	 ebx, 32			; 00000020H
  0048e	c1 fb 05	 sar	 ebx, 5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00491	41 8b 4e 0c	 mov	 ecx, DWORD PTR [r14+12]
  00495	3b d9		 cmp	 ebx, ecx
  00497	7e 24		 jle	 SHORT $LN246@ImFontAtla

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00499	85 c9		 test	 ecx, ecx
  0049b	74 0b		 je	 SHORT $LN250@ImFontAtla
  0049d	8b c1		 mov	 eax, ecx
  0049f	99		 cdq
  004a0	2b c2		 sub	 eax, edx
  004a2	d1 f8		 sar	 eax, 1
  004a4	03 c1		 add	 eax, ecx
  004a6	eb 05		 jmp	 SHORT $LN251@ImFontAtla
$LN250@ImFontAtla:
  004a8	b8 08 00 00 00	 mov	 eax, 8
$LN251@ImFontAtla:
  004ad	8b d3		 mov	 edx, ebx
  004af	3b c3		 cmp	 eax, ebx
  004b1	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  004b4	49 8d 4e 08	 lea	 rcx, QWORD PTR [r14+8]
  004b8	e8 00 00 00 00	 call	 ?reserve@?$ImVector@I@@QEAAXH@Z ; ImVector<unsigned int>::reserve
$LN246@ImFontAtla:
  004bd	41 89 5e 08	 mov	 DWORD PTR [r14+8], ebx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 562  :     void            Create(int sz) { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

  004c1	4c 63 c3	 movsxd	 r8, ebx
  004c4	49 c1 e0 02	 shl	 r8, 2
  004c8	33 d2		 xor	 edx, edx
  004ca	49 8b 4e 10	 mov	 rcx, QWORD PTR [r14+16]
  004ce	e8 00 00 00 00	 call	 memset
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1789 :     inline bool         empty() const { return Size == 0; }

  004d3	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2404 :         if (dst_tmp.GlyphsSet.Storage.empty())

  004d8	75 4c		 jne	 SHORT $LN53@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 562  :     void            Create(int sz) { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

  004da	41 8b 5d 04	 mov	 ebx, DWORD PTR [r13+4]
  004de	83 c3 20	 add	 ebx, 32			; 00000020H
  004e1	c1 fb 05	 sar	 ebx, 5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  004e4	41 8b 4d 14	 mov	 ecx, DWORD PTR [r13+20]
  004e8	3b d9		 cmp	 ebx, ecx
  004ea	7e 24		 jle	 SHORT $LN257@ImFontAtla

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  004ec	85 c9		 test	 ecx, ecx
  004ee	74 0b		 je	 SHORT $LN261@ImFontAtla
  004f0	8b c1		 mov	 eax, ecx
  004f2	99		 cdq
  004f3	2b c2		 sub	 eax, edx
  004f5	d1 f8		 sar	 eax, 1
  004f7	03 c1		 add	 eax, ecx
  004f9	eb 05		 jmp	 SHORT $LN262@ImFontAtla
$LN261@ImFontAtla:
  004fb	b8 08 00 00 00	 mov	 eax, 8
$LN262@ImFontAtla:
  00500	8b d3		 mov	 edx, ebx
  00502	3b c3		 cmp	 eax, ebx
  00504	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00507	49 8d 4d 10	 lea	 rcx, QWORD PTR [r13+16]
  0050b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@I@@QEAAXH@Z ; ImVector<unsigned int>::reserve
$LN257@ImFontAtla:
  00510	41 89 5d 10	 mov	 DWORD PTR [r13+16], ebx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 562  :     void            Create(int sz) { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }

  00514	4c 63 c3	 movsxd	 r8, ebx
  00517	49 c1 e0 02	 shl	 r8, 2
  0051b	33 d2		 xor	 edx, edx
  0051d	49 8b 4d 18	 mov	 rcx, QWORD PTR [r13+24]
  00521	e8 00 00 00 00	 call	 memset
$LN53@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2407 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

  00526	4d 8b 66 f0	 mov	 r12, QWORD PTR [r14-16]
  0052a	41 0f b7 04 24	 movzx	 eax, WORD PTR [r12]
  0052f	66 85 c0	 test	 ax, ax
  00532	0f 84 08 01 00
	00		 je	 $LN11@ImFontAtla
  00538	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@ImFontAtla:
  00540	41 0f b7 4c 24
	02		 movzx	 ecx, WORD PTR [r12+2]
  00546	66 85 c9	 test	 cx, cx
  00549	0f 84 e9 00 00
	00		 je	 $LN866@ImFontAtla

; 2408 :             for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)

  0054f	0f b7 d8	 movzx	 ebx, ax
  00552	3b d9		 cmp	 ebx, ecx
  00554	0f 87 cc 00 00
	00		 ja	 $LN14@ImFontAtla
  0055a	66 0f 1f 44 00
	00		 npad	 6
$LL19@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 564  :     bool            TestBit(int n) const { IM_ASSERT(n < (Storage.Size << 5)); return ImBitArrayTestBit(Storage.Data, n); }

  00560	41 8b 45 10	 mov	 eax, DWORD PTR [r13+16]
  00564	c1 e0 05	 shl	 eax, 5
  00567	3b d8		 cmp	 ebx, eax
  00569	7c 1a		 jl	 SHORT $LN265@ImFontAtla
  0056b	41 b8 34 02 00
	00		 mov	 r8d, 564		; 00000234H
  00571	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@MPMNJHLP@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00578	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@HCNHOFJN@?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAo?$AAr?$AAa?$AAg?$AAe?$AA?4?$AAS?$AAi@
  0057f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN265@ImFontAtla:

; 525  : inline bool     ImBitArrayTestBit(const ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); return (arr[n >> 5] & mask) != 0; }

  00585	8b cb		 mov	 ecx, ebx
  00587	83 e1 1f	 and	 ecx, 31
  0058a	be 01 00 00 00	 mov	 esi, 1
  0058f	d3 e6		 shl	 esi, cl
  00591	48 63 fb	 movsxd	 rdi, ebx
  00594	48 c1 ff 05	 sar	 rdi, 5
  00598	49 8b 45 18	 mov	 rax, QWORD PTR [r13+24]
  0059c	85 34 b8	 test	 DWORD PTR [rax+rdi*4], esi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2410 :                 if (dst_tmp.GlyphsSet.TestBit(codepoint))    // Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)

  0059f	75 75		 jne	 SHORT $LN17@ImFontAtla

; 2411 :                     continue;
; 2412 :                 if (!stbtt_FindGlyphIndex(&src_tmp.FontInfo, codepoint))    // It is actually in the font?

  005a1	49 8d 8e 18 ff
	ff ff		 lea	 rcx, QWORD PTR [r14-232]
  005a8	8b d3		 mov	 edx, ebx
  005aa	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  005af	85 c0		 test	 eax, eax
  005b1	74 63		 je	 SHORT $LN17@ImFontAtla

; 2413 :                     continue;
; 2414 : 
; 2415 :                 // Add to avail set/counters
; 2416 :                 src_tmp.GlyphsCount++;

  005b3	41 ff 06	 inc	 DWORD PTR [r14]

; 2417 :                 dst_tmp.GlyphsCount++;

  005b6	41 ff 45 08	 inc	 DWORD PTR [r13+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 565  :     void            SetBit(int n) { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }

  005ba	41 8b 46 08	 mov	 eax, DWORD PTR [r14+8]
  005be	c1 e0 05	 shl	 eax, 5
  005c1	3b d8		 cmp	 ebx, eax
  005c3	7c 1a		 jl	 SHORT $LN270@ImFontAtla
  005c5	41 b8 35 02 00
	00		 mov	 r8d, 565		; 00000235H
  005cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@MPMNJHLP@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  005d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@HCNHOFJN@?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAo?$AAr?$AAa?$AAg?$AAe?$AA?4?$AAS?$AAi@
  005d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN270@ImFontAtla:
  005df	49 8b 46 10	 mov	 rax, QWORD PTR [r14+16]

; 527  : inline void     ImBitArraySetBit(ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }

  005e3	09 34 b8	 or	 DWORD PTR [rax+rdi*4], esi

; 565  :     void            SetBit(int n) { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }

  005e6	41 8b 45 10	 mov	 eax, DWORD PTR [r13+16]
  005ea	c1 e0 05	 shl	 eax, 5
  005ed	3b d8		 cmp	 ebx, eax
  005ef	7c 1a		 jl	 SHORT $LN275@ImFontAtla
  005f1	41 b8 35 02 00
	00		 mov	 r8d, 565		; 00000235H
  005f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LE@MPMNJHLP@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  005fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@HCNHOFJN@?$AAn?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAS?$AAt?$AAo?$AAr?$AAa?$AAg?$AAe?$AA?4?$AAS?$AAi@
  00605	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN275@ImFontAtla:
  0060b	49 8b 45 18	 mov	 rax, QWORD PTR [r13+24]

; 527  : inline void     ImBitArraySetBit(ImU32* arr, int n) { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }

  0060f	09 34 b8	 or	 DWORD PTR [rax+rdi*4], esi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2420 :                 total_glyphs_count++;

  00612	ff 44 24 6c	 inc	 DWORD PTR total_glyphs_count$2$[rsp]
$LN17@ImFontAtla:

; 2408 :             for (unsigned int codepoint = src_range[0]; codepoint <= src_range[1]; codepoint++)

  00616	ff c3		 inc	 ebx
  00618	41 0f b7 44 24
	02		 movzx	 eax, WORD PTR [r12+2]
  0061e	3b d8		 cmp	 ebx, eax
  00620	0f 86 3a ff ff
	ff		 jbe	 $LL19@ImFontAtla
$LN14@ImFontAtla:

; 2407 :         for (const ImWchar* src_range = src_tmp.SrcRanges; src_range[0] && src_range[1]; src_range += 2)

  00626	49 83 c4 04	 add	 r12, 4
  0062a	41 0f b7 04 24	 movzx	 eax, WORD PTR [r12]
  0062f	66 85 c0	 test	 ax, ax
  00632	0f 85 08 ff ff
	ff		 jne	 $LL16@ImFontAtla
$LN866@ImFontAtla:
  00638	8b 7c 24 68	 mov	 edi, DWORD PTR src_i$1$[rsp]
  0063c	48 8b 75 90	 mov	 rsi, QWORD PTR dst_tmp_array$1$[rbp-256]
$LN11@ImFontAtla:

; 2399 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  00640	ff c7		 inc	 edi
  00642	89 7c 24 68	 mov	 DWORD PTR src_i$1$[rsp], edi
  00646	49 81 c6 10 01
	00 00		 add	 r14, 272		; 00000110H
  0064d	3b 7c 24 60	 cmp	 edi, DWORD PTR src_tmp_array$2$[rsp]
  00651	44 8b 7c 24 64	 mov	 r15d, DWORD PTR new_size$1$[rsp]
  00656	0f 8c fa fd ff
	ff		 jl	 $LL13@ImFontAtla

; 2376 :                 src_tmp.DstIndex = output_i;

  0065c	33 f6		 xor	 esi, esi
  0065e	44 8b e6	 mov	 r12d, esi
  00661	48 89 75 a8	 mov	 QWORD PTR $T7[rbp-256], rsi
  00665	48 8b 5c 24 78	 mov	 rbx, QWORD PTR src_tmp_array$1$[rsp]
  0066a	48 81 c3 00 01
	00 00		 add	 rbx, 256		; 00000100H
  00671	44 8b f6	 mov	 r14d, esi
  00674	89 74 24 68	 mov	 DWORD PTR src_i$1$[rsp], esi
  00678	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL22@ImFontAtla:

; 2426 :     {
; 2427 :         ImFontBuildSrcData& src_tmp = src_tmp_array[src_i];
; 2428 :         src_tmp.GlyphsList.reserve(src_tmp.GlyphsCount);

  00680	48 63 7b e8	 movsxd	 rdi, DWORD PTR [rbx-24]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00684	3b 7b 04	 cmp	 edi, DWORD PTR [rbx+4]
  00687	7e 64		 jle	 SHORT $LN854@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00689	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00690	48 85 c0	 test	 rax, rax
  00693	74 06		 je	 SHORT $LN287@ImFontAtla

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00695	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN287@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0069b	48 8b cf	 mov	 rcx, rdi
  0069e	48 c1 e1 02	 shl	 rcx, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  006a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  006a8	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  006ab	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  006af	48 85 d2	 test	 rdx, rdx
  006b2	74 30		 je	 SHORT $LN297@ImFontAtla
  006b4	4c 63 03	 movsxd	 r8, DWORD PTR [rbx]
  006b7	49 c1 e0 02	 shl	 r8, 2
  006bb	48 8b c8	 mov	 rcx, rax
  006be	e8 00 00 00 00	 call	 memcpy
  006c3	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  006c7	48 85 c9	 test	 rcx, rcx
  006ca	74 12		 je	 SHORT $LN295@ImFontAtla

; 3610 :         if (ImGuiContext* ctx = GImGui)

  006cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  006d3	48 85 c0	 test	 rax, rax
  006d6	74 06		 je	 SHORT $LN295@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  006d8	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN295@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  006de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN297@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  006e4	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  006e8	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
  006eb	33 f6		 xor	 esi, esi
$LN854@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2335 :     const ImU32* it_begin = in->Storage.begin();

  006ed	4c 8b 6b f8	 mov	 r13, QWORD PTR [rbx-8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1800 :     inline const T* end() const { return Data + Size; }

  006f1	48 63 43 f0	 movsxd	 rax, DWORD PTR [rbx-16]
  006f5	48 8d 04 85 00
	00 00 00	 lea	 rax, QWORD PTR [rax*4]
  006fd	49 03 c5	 add	 rax, r13
  00700	48 89 45 b0	 mov	 QWORD PTR it_end$1$[rbp-256], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2337 :     for (const ImU32* it = it_begin; it < it_end; it++)

  00704	4d 8b fd	 mov	 r15, r13
  00707	4c 3b e8	 cmp	 r13, rax
  0070a	0f 83 98 00 00
	00		 jae	 $LN303@ImFontAtla
$LL304@ImFontAtla:

; 2338 :         if (ImU32 entries_32 = *it)

  00710	45 8b 27	 mov	 r12d, DWORD PTR [r15]
  00713	45 85 e4	 test	 r12d, r12d
  00716	74 75		 je	 SHORT $LN302@ImFontAtla

; 2339 :             for (ImU32 bit_n = 0; bit_n < 32; bit_n++)

  00718	44 8b f6	 mov	 r14d, esi

; 2376 :                 src_tmp.DstIndex = output_i;

  0071b	be 01 00 00 00	 mov	 esi, 1
$LL307@ImFontAtla:

; 2340 :                 if (entries_32 & ((ImU32)1 << bit_n))

  00720	41 85 f4	 test	 esi, r12d
  00723	74 59		 je	 SHORT $LN305@ImFontAtla

; 2341 :                     out->push_back((int)(((it - it_begin) << 5) + bit_n));

  00725	4a 8d 3c fd 00
	00 00 00	 lea	 rdi, QWORD PTR [r15*8]
  0072d	4a 8d 04 ed 00
	00 00 00	 lea	 rax, QWORD PTR [r13*8]
  00735	2b f8		 sub	 edi, eax
  00737	83 e7 e0	 and	 edi, -32		; ffffffffffffffe0H
  0073a	41 03 fe	 add	 edi, r14d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0073d	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  00740	8b 03		 mov	 eax, DWORD PTR [rbx]
  00742	3b c1		 cmp	 eax, ecx
  00744	75 2c		 jne	 SHORT $LN314@ImFontAtla
  00746	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0074a	85 c9		 test	 ecx, ecx
  0074c	74 0b		 je	 SHORT $LN318@ImFontAtla
  0074e	8b c1		 mov	 eax, ecx
  00750	99		 cdq
  00751	2b c2		 sub	 eax, edx
  00753	d1 f8		 sar	 eax, 1
  00755	03 c1		 add	 eax, ecx
  00757	eb 05		 jmp	 SHORT $LN319@ImFontAtla
$LN318@ImFontAtla:
  00759	b8 08 00 00 00	 mov	 eax, 8
$LN319@ImFontAtla:
  0075e	41 3b c0	 cmp	 eax, r8d
  00761	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00765	41 8b d0	 mov	 edx, r8d
  00768	48 8b cb	 mov	 rcx, rbx
  0076b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@H@@QEAAXH@Z ; ImVector<int>::reserve
  00770	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN314@ImFontAtla:
  00772	48 63 c8	 movsxd	 rcx, eax
  00775	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00779	89 3c 88	 mov	 DWORD PTR [rax+rcx*4], edi
  0077c	ff 03		 inc	 DWORD PTR [rbx]
$LN305@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2339 :             for (ImU32 bit_n = 0; bit_n < 32; bit_n++)

  0077e	41 ff c6	 inc	 r14d
  00781	d1 c6		 rol	 esi, 1
  00783	41 83 fe 20	 cmp	 r14d, 32		; 00000020H
  00787	72 97		 jb	 SHORT $LL307@ImFontAtla
  00789	48 8b 45 b0	 mov	 rax, QWORD PTR it_end$1$[rbp-256]
$LN302@ImFontAtla:

; 2337 :     for (const ImU32* it = it_begin; it < it_end; it++)

  0078d	49 83 c7 04	 add	 r15, 4
  00791	4c 3b f8	 cmp	 r15, rax
  00794	be 00 00 00 00	 mov	 esi, 0
  00799	0f 82 71 ff ff
	ff		 jb	 $LL304@ImFontAtla
  0079f	44 8b 74 24 68	 mov	 r14d, DWORD PTR src_i$1$[rsp]
  007a4	4c 8b 65 a8	 mov	 r12, QWORD PTR $T7[rbp-256]
$LN303@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  007a8	48 8b 4b f8	 mov	 rcx, QWORD PTR [rbx-8]
  007ac	33 f6		 xor	 esi, esi
  007ae	48 85 c9	 test	 rcx, rcx
  007b1	74 20		 je	 SHORT $LN855@ImFontAtla
  007b3	48 89 73 f0	 mov	 QWORD PTR [rbx-16], rsi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  007b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  007be	48 85 c0	 test	 rax, rax
  007c1	74 06		 je	 SHORT $LN327@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  007c3	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN327@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  007c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  007cf	48 89 73 f8	 mov	 QWORD PTR [rbx-8], rsi
$LN855@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2431 :         IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount);

  007d3	8b 43 e8	 mov	 eax, DWORD PTR [rbx-24]
  007d6	39 03		 cmp	 DWORD PTR [rbx], eax
  007d8	74 1a		 je	 SHORT $LN20@ImFontAtla
  007da	41 b8 7f 09 00
	00		 mov	 r8d, 2431		; 0000097fH
  007e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  007e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@GJGKHCEN@?$AAs?$AAr?$AAc?$AA_?$AAt?$AAm?$AAp?$AA?4?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AAL@
  007ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN20@ImFontAtla:

; 2421 :             }
; 2422 :     }
; 2423 : 
; 2424 :     // 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
; 2425 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  007f4	41 ff c6	 inc	 r14d
  007f7	44 89 74 24 68	 mov	 DWORD PTR src_i$1$[rsp], r14d
  007fc	49 ff c4	 inc	 r12
  007ff	4c 89 65 a8	 mov	 QWORD PTR $T7[rbp-256], r12
  00803	48 81 c3 10 01
	00 00		 add	 rbx, 272		; 00000110H
  0080a	44 8b 7c 24 60	 mov	 r15d, DWORD PTR src_tmp_array$2$[rsp]
  0080f	45 3b f7	 cmp	 r14d, r15d
  00812	0f 8c 68 fe ff
	ff		 jl	 $LL22@ImFontAtla
  00818	44 8b 6c 24 6c	 mov	 r13d, DWORD PTR total_glyphs_count$2$[rsp]
  0081d	eb 0a		 jmp	 SHORT $LN21@ImFontAtla
$LN12@ImFontAtla:
  0081f	33 f6		 xor	 esi, esi
  00821	44 8b ee	 mov	 r13d, esi
  00824	44 8b 7c 24 60	 mov	 r15d, DWORD PTR src_tmp_array$2$[rsp]
$LN21@ImFontAtla:

; 2433 :     for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)

  00829	8b fe		 mov	 edi, esi
  0082b	8b 74 24 64	 mov	 esi, DWORD PTR new_size$1$[rsp]
  0082f	85 f6		 test	 esi, esi
  00831	7e 43		 jle	 SHORT $LN24@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00833	48 8b 5d 90	 mov	 rbx, QWORD PTR dst_tmp_array$1$[rbp-256]
  00837	48 83 c3 18	 add	 rbx, 24
  0083b	45 33 ff	 xor	 r15d, r15d
  0083e	66 90		 npad	 2
$LL25@ImFontAtla:

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00840	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00843	48 85 c9	 test	 rcx, rcx
  00846	74 1f		 je	 SHORT $LN23@ImFontAtla
  00848	4c 89 7b f8	 mov	 QWORD PTR [rbx-8], r15
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0084c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00853	48 85 c0	 test	 rax, rax
  00856	74 06		 je	 SHORT $LN344@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00858	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN344@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0085e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00864	4c 89 3b	 mov	 QWORD PTR [rbx], r15
$LN23@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2433 :     for (int dst_i = 0; dst_i < dst_tmp_array.Size; dst_i++)

  00867	ff c7		 inc	 edi
  00869	48 83 c3 20	 add	 rbx, 32			; 00000020H
  0086d	3b fe		 cmp	 edi, esi
  0086f	7c cf		 jl	 SHORT $LL25@ImFontAtla
  00871	44 8b 7c 24 60	 mov	 r15d, DWORD PTR src_tmp_array$2$[rsp]
$LN24@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00876	48 8b 4d 90	 mov	 rcx, QWORD PTR dst_tmp_array$1$[rbp-256]
  0087a	33 db		 xor	 ebx, ebx
  0087c	48 85 c9	 test	 rcx, rcx
  0087f	74 24		 je	 SHORT $LN351@ImFontAtla
  00881	48 89 5d c8	 mov	 QWORD PTR dst_tmp_array$[rbp-256], rbx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00885	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0088c	48 85 c0	 test	 rax, rax
  0088f	74 06		 je	 SHORT $LN355@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00891	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN355@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00897	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0089d	48 89 5d 90	 mov	 QWORD PTR dst_tmp_array$1$[rbp-256], rbx
  008a1	48 89 5d d0	 mov	 QWORD PTR dst_tmp_array$[rbp-248], rbx
$LN351@ImFontAtla:

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  008a5	89 5d dc	 mov	 DWORD PTR buf_rects$[rbp-252], ebx
  008a8	48 8b fb	 mov	 rdi, rbx
  008ab	48 89 5d c0	 mov	 QWORD PTR buf_rects$1$[rbp-256], rbx
  008af	48 89 5d e0	 mov	 QWORD PTR buf_rects$[rbp-248], rbx
  008b3	89 5d 04	 mov	 DWORD PTR buf_packedchars$[rbp-252], ebx
  008b6	48 8b f3	 mov	 rsi, rbx
  008b9	48 89 5d a8	 mov	 QWORD PTR buf_packedchars$1$[rbp-256], rbx
  008bd	48 89 5d 08	 mov	 QWORD PTR buf_packedchars$[rbp-248], rbx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  008c1	b8 08 00 00 00	 mov	 eax, 8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2440 :     ImVector<stbtt_packedchar> buf_packedchars;

  008c6	45 85 ed	 test	 r13d, r13d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  008c9	7e 3f		 jle	 SHORT $LN372@ImFontAtla

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  008cb	41 8b dd	 mov	 ebx, r13d
  008ce	44 3b e8	 cmp	 r13d, eax
  008d1	0f 4c d8	 cmovl	 ebx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  008d4	85 db		 test	 ebx, ebx

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  008d6	7e 32		 jle	 SHORT $LN372@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  008d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  008df	48 85 c0	 test	 rax, rax
  008e2	74 06		 je	 SHORT $LN377@ImFontAtla

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  008e4	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN377@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  008ea	48 63 cb	 movsxd	 rcx, ebx
  008ed	48 c1 e1 04	 shl	 rcx, 4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  008f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  008f7	48 8b f8	 mov	 rdi, rax
  008fa	48 89 45 c0	 mov	 QWORD PTR buf_rects$1$[rbp-256], rax
  008fe	48 89 45 e0	 mov	 QWORD PTR buf_rects$[rbp-248], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00902	89 5d dc	 mov	 DWORD PTR buf_rects$[rbp-252], ebx
  00905	b8 08 00 00 00	 mov	 eax, 8
$LN372@ImFontAtla:

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0090a	44 89 6d d8	 mov	 DWORD PTR buf_rects$[rbp-256], r13d
  0090e	45 85 ed	 test	 r13d, r13d
  00911	7e 3b		 jle	 SHORT $LN398@ImFontAtla

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00913	41 8b dd	 mov	 ebx, r13d
  00916	41 83 fd 08	 cmp	 r13d, 8
  0091a	0f 4c d8	 cmovl	 ebx, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0091d	85 db		 test	 ebx, ebx
  0091f	7e 2d		 jle	 SHORT $LN398@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00921	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00928	48 85 c0	 test	 rax, rax
  0092b	74 06		 je	 SHORT $LN403@ImFontAtla

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  0092d	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN403@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00933	48 63 c3	 movsxd	 rax, ebx
  00936	48 6b c8 1c	 imul	 rcx, rax, 28
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0093a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00940	48 8b f0	 mov	 rsi, rax
  00943	48 89 45 a8	 mov	 QWORD PTR buf_packedchars$1$[rbp-256], rax
  00947	48 89 45 08	 mov	 QWORD PTR buf_packedchars$[rbp-248], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0094b	89 5d 04	 mov	 DWORD PTR buf_packedchars$[rbp-252], ebx
$LN398@ImFontAtla:

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0094e	44 89 6d 00	 mov	 DWORD PTR buf_packedchars$[rbp-256], r13d

; 1791 :     inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

  00952	41 8b cd	 mov	 ecx, r13d
  00955	c1 e1 04	 shl	 ecx, 4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2443 :     memset(buf_rects.Data, 0, (size_t)buf_rects.size_in_bytes());

  00958	4c 63 c1	 movsxd	 r8, ecx
  0095b	33 d2		 xor	 edx, edx
  0095d	48 8b cf	 mov	 rcx, rdi
  00960	e8 00 00 00 00	 call	 memset

; 2444 :     memset(buf_packedchars.Data, 0, (size_t)buf_packedchars.size_in_bytes());

  00965	41 6b cd 1c	 imul	 ecx, r13d, 28
  00969	4c 63 c1	 movsxd	 r8, ecx
  0096c	33 d2		 xor	 edx, edx
  0096e	48 8b ce	 mov	 rcx, rsi
  00971	e8 00 00 00 00	 call	 memset

; 2445 : 
; 2446 :     // 4. Gather glyphs sizes so we can pack them in our virtual canvas.
; 2447 :     int total_surface = 0;

  00976	33 db		 xor	 ebx, ebx
  00978	8b d3		 mov	 edx, ebx
  0097a	89 5c 24 68	 mov	 DWORD PTR total_surface$1$[rsp], ebx

; 2448 :     int buf_rects_out_n = 0;

  0097e	44 8b f3	 mov	 r14d, ebx

; 2449 :     int buf_packedchars_out_n = 0;

  00981	8b f3		 mov	 esi, ebx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00983	44 8b e3	 mov	 r12d, ebx
  00986	89 5c 24 70	 mov	 DWORD PTR src_i$1$[rsp], ebx
  0098a	45 0f 57 ed	 xorps	 xmm13, xmm13
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2450 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  0098e	45 85 ff	 test	 r15d, r15d
  00991	0f 8e 89 04 00
	00		 jle	 $LN27@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00997	44 8b fb	 mov	 r15d, ebx
  0099a	48 8b 5c 24 78	 mov	 rbx, QWORD PTR src_tmp_array$1$[rsp]
  0099f	48 81 c3 d0 00
	00 00		 add	 rbx, 208		; 000000d0H
  009a6	f3 44 0f 10 0d
	00 00 00 00	 movss	 xmm9, DWORD PTR __xmm@80000000800000008000000080000000
  009af	8b 44 24 60	 mov	 eax, DWORD PTR src_tmp_array$2$[rsp]
$LL28@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2453 :         if (src_tmp.GlyphsCount == 0)

  009b3	83 7b 18 00	 cmp	 DWORD PTR [rbx+24], 0
  009b7	0f 84 42 04 00
	00		 je	 $LN26@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  009bd	45 85 f6	 test	 r14d, r14d
  009c0	78 0c		 js	 SHORT $LN427@ImFontAtla
  009c2	41 8b cd	 mov	 ecx, r13d
  009c5	89 4c 24 6c	 mov	 DWORD PTR total_glyphs_count$2$[rsp], ecx
  009c9	45 3b f5	 cmp	 r14d, r13d
  009cc	7c 21		 jl	 SHORT $LN428@ImFontAtla
$LN427@ImFontAtla:
  009ce	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  009d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  009db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  009e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009e8	41 8b cd	 mov	 ecx, r13d
  009eb	89 4c 24 6c	 mov	 DWORD PTR total_glyphs_count$2$[rsp], ecx
$LN428@ImFontAtla:
  009ef	49 63 c6	 movsxd	 rax, r14d
  009f2	48 c1 e0 04	 shl	 rax, 4
  009f6	48 03 45 c0	 add	 rax, QWORD PTR buf_rects$1$[rbp-256]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2456 :         src_tmp.Rects = &buf_rects[buf_rects_out_n];

  009fa	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  009fe	85 f6		 test	 esi, esi
  00a00	78 04		 js	 SHORT $LN431@ImFontAtla
  00a02	3b f1		 cmp	 esi, ecx
  00a04	7c 1a		 jl	 SHORT $LN879@ImFontAtla
$LN431@ImFontAtla:
  00a06	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00a0c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00a13	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00a1a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN879@ImFontAtla:
  00a20	48 63 c6	 movsxd	 rax, esi
  00a23	48 6b d0 1c	 imul	 rdx, rax, 28
  00a27	48 03 55 a8	 add	 rdx, QWORD PTR buf_packedchars$1$[rbp-256]
  00a2b	44 03 73 18	 add	 r14d, DWORD PTR [rbx+24]
  00a2f	03 73 18	 add	 esi, DWORD PTR [rbx+24]
  00a32	48 8b cb	 mov	 rcx, rbx
  00a35	48 8b c2	 mov	 rax, rdx
  00a38	48 8b 7d a0	 mov	 rdi, QWORD PTR $T6[rbp-256]
  00a3c	89 74 24 64	 mov	 DWORD PTR buf_packedchars_out_n$1$[rsp], esi
  00a40	44 89 75 98	 mov	 DWORD PTR buf_rects_out_n$1$[rbp-256], r14d
  00a44	48 89 13	 mov	 QWORD PTR [rbx], rdx
  00a47	44 3b 27	 cmp	 r12d, DWORD PTR [rdi]
  00a4a	7c 25		 jl	 SHORT $LN436@ImFontAtla
  00a4c	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00a52	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00a59	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00a60	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00a66	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00a69	44 89 75 98	 mov	 DWORD PTR buf_rects_out_n$1$[rbp-256], r14d
  00a6d	89 74 24 64	 mov	 DWORD PTR buf_packedchars_out_n$1$[rsp], esi
$LN436@ImFontAtla:
  00a71	4c 8b 6f 08	 mov	 r13, QWORD PTR [rdi+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2463 :         src_tmp.PackRange.font_size = cfg.SizePixels;

  00a75	43 8b 44 2f 14	 mov	 eax, DWORD PTR [r15+r13+20]
  00a7a	89 43 d0	 mov	 DWORD PTR [rbx-48], eax

; 2464 :         src_tmp.PackRange.first_unicode_codepoint_in_range = 0;

  00a7d	33 f6		 xor	 esi, esi
  00a7f	89 73 d4	 mov	 DWORD PTR [rbx-44], esi

; 2465 :         src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data;

  00a82	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00a86	48 89 43 d8	 mov	 QWORD PTR [rbx-40], rax

; 2466 :         src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size;

  00a8a	8b 7b 30	 mov	 edi, DWORD PTR [rbx+48]
  00a8d	89 7b e0	 mov	 DWORD PTR [rbx-32], edi

; 2467 :         src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars;

  00a90	48 89 53 e8	 mov	 QWORD PTR [rbx-24], rdx

; 2468 :         src_tmp.PackRange.h_oversample = (unsigned char)cfg.OversampleH;

  00a94	43 0f b6 44 2f
	18		 movzx	 eax, BYTE PTR [r15+r13+24]
  00a9a	88 43 f0	 mov	 BYTE PTR [rbx-16], al

; 2469 :         src_tmp.PackRange.v_oversample = (unsigned char)cfg.OversampleV;

  00a9d	43 0f b6 44 2f
	1c		 movzx	 eax, BYTE PTR [r15+r13+28]
  00aa3	88 43 f1	 mov	 BYTE PTR [rbx-15], al

; 2472 :         const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);

  00aa6	f3 47 0f 10 44
	2f 14		 movss	 xmm8, DWORD PTR [r15+r13+20]
  00aad	45 0f 2f c5	 comiss	 xmm8, xmm13
  00ab1	76 52		 jbe	 SHORT $LN75@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  00ab3	4c 63 9b 54 ff
	ff ff		 movsxd	 r11, DWORD PTR [rbx-172]
  00aba	4c 8b 93 38 ff
	ff ff		 mov	 r10, QWORD PTR [rbx-200]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00ac1	47 0f b6 44 13
	07		 movzx	 r8d, BYTE PTR [r11+r10+7]
  00ac7	43 0f b6 54 13
	06		 movzx	 edx, BYTE PTR [r11+r10+6]
  00acd	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00ad2	0f bf c9	 movsx	 ecx, cx
  00ad5	0f af d1	 imul	 edx, ecx
  00ad8	66 44 03 c2	 add	 r8w, dx

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  00adc	45 0f bf c8	 movsx	 r9d, r8w

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00ae0	47 0f b6 44 13
	05		 movzx	 r8d, BYTE PTR [r11+r10+5]
  00ae6	43 0f b6 44 13
	04		 movzx	 eax, BYTE PTR [r11+r10+4]
  00aec	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00af1	0f bf c9	 movsx	 ecx, cx
  00af4	0f af c1	 imul	 eax, ecx
  00af7	66 41 03 c0	 add	 ax, r8w

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  00afb	98		 cwde
  00afc	41 2b c1	 sub	 eax, r9d
  00aff	66 0f 6e c0	 movd	 xmm0, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2472 :         const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);

  00b03	eb 25		 jmp	 SHORT $LN880@ImFontAtla
$LN75@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2641 :     int unitsPerEm = ttUSHORT(info->data + info->head + 18);

  00b05	48 63 8b 4c ff
	ff ff		 movsxd	 rcx, DWORD PTR [rbx-180]
  00b0c	48 8b 83 38 ff
	ff ff		 mov	 rax, QWORD PTR [rbx-200]
  00b13	0f b6 54 01 13	 movzx	 edx, BYTE PTR [rcx+rax+19]
  00b18	0f b6 44 01 12	 movzx	 eax, BYTE PTR [rcx+rax+18]
  00b1d	c1 e0 08	 shl	 eax, 8
  00b20	03 d0		 add	 edx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2472 :         const float scale = (cfg.SizePixels > 0) ? stbtt_ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels) : stbtt_ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels);

  00b22	45 0f 57 c1	 xorps	 xmm8, xmm9
  00b26	66 0f 6e c2	 movd	 xmm0, edx
$LN880@ImFontAtla:

; 2473 :         const int padding = atlas->TexGlyphPadding;

  00b2a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00b2d	f3 44 0f 5e c0	 divss	 xmm8, xmm0
  00b32	48 8b 45 88	 mov	 rax, QWORD PTR atlas$GSCopy$1$[rbp-256]
  00b36	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00b39	89 45 80	 mov	 DWORD PTR padding$1$[rbp-256], eax

; 2474 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)

  00b3c	8b c6		 mov	 eax, esi
  00b3e	89 45 b8	 mov	 DWORD PTR glyph_i$1$[rbp-256], eax
  00b41	48 89 75 f8	 mov	 QWORD PTR $T8[rbp-256], rsi
  00b45	85 ff		 test	 edi, edi
  00b47	0f 8e a1 02 00
	00		 jle	 $LN868@ImFontAtla

; 2479 :             stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);

  00b4d	45 33 e4	 xor	 r12d, r12d
  00b50	4c 89 65 b0	 mov	 QWORD PTR tv8082[rbp-256], r12
$LL31@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00b54	48 85 f6	 test	 rsi, rsi
  00b57	78 04		 js	 SHORT $LN449@ImFontAtla
  00b59	3b c7		 cmp	 eax, edi
  00b5b	7c 1a		 jl	 SHORT $LN450@ImFontAtla
$LN449@ImFontAtla:
  00b5d	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00b63	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00b6a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00b71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN450@ImFontAtla:
  00b77	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2477 :             const int glyph_index_in_font = stbtt_FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList[glyph_i]);

  00b7b	8b 14 b0	 mov	 edx, DWORD PTR [rax+rsi*4]
  00b7e	48 8d 8b 30 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-208]
  00b85	e8 00 00 00 00	 call	 stbtt_FindGlyphIndex
  00b8a	8b f0		 mov	 esi, eax

; 2478 :             IM_ASSERT(glyph_index_in_font != 0);

  00b8c	85 c0		 test	 eax, eax
  00b8e	75 1a		 jne	 SHORT $LN77@ImFontAtla
  00b90	41 b8 ae 09 00
	00		 mov	 r8d, 2478		; 000009aeH
  00b96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00b9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@ENBGOGEF@?$AAg?$AAl?$AAy?$AAp?$AAh?$AA_?$AAi?$AAn?$AAd?$AAe?$AAx?$AA_?$AAi?$AAn?$AA_@
  00ba4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN77@ImFontAtla:
  00baa	66 43 0f 6e 7c
	2f 1c		 movd	 xmm7, DWORD PTR [r15+r13+28]

; 2479 :             stbtt_GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * cfg.OversampleH, scale * cfg.OversampleV, 0, 0, &x0, &y0, &x1, &y1);

  00bb1	0f 5b ff	 cvtdq2ps xmm7, xmm7
  00bb4	f3 41 0f 59 f8	 mulss	 xmm7, xmm8
  00bb9	66 43 0f 6e 74
	2f 18		 movd	 xmm6, DWORD PTR [r15+r13+24]
  00bc0	0f 5b f6	 cvtdq2ps xmm6, xmm6
  00bc3	f3 41 0f 59 f0	 mulss	 xmm6, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1599 :     if (info->cff.size) {

  00bc8	8b d6		 mov	 edx, esi
  00bca	48 8d 8b 30 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-208]
  00bd1	83 bb 7c ff ff
	ff 00		 cmp	 DWORD PTR [rbx-132], 0
  00bd8	74 4d		 je	 SHORT $LN464@ImFontAtla

; 2281 :     stbtt__csctx c = STBTT__CSCTX_INIT(1);

  00bda	48 c7 45 50 01
	00 00 00	 mov	 QWORD PTR c$9[rbp-256], 1
  00be2	0f 57 c0	 xorps	 xmm0, xmm0
  00be5	0f 11 45 58	 movups	 XMMWORD PTR c$9[rbp-248], xmm0
  00be9	0f 57 c9	 xorps	 xmm1, xmm1
  00bec	f3 0f 7f 4d 68	 movdqu	 XMMWORD PTR c$9[rbp-232], xmm1
  00bf1	4c 89 65 78	 mov	 QWORD PTR c$9[rbp-216], r12
  00bf5	44 89 a5 80 00
	00 00		 mov	 DWORD PTR c$9[rbp-208], r12d

; 2282 :     int r = stbtt__run_charstring(info, glyph_index, &c);

  00bfc	4c 8d 45 50	 lea	 r8, QWORD PTR c$9[rbp-256]
  00c00	e8 00 00 00 00	 call	 ?stbtt__run_charstring@@YAHPEBUstbtt_fontinfo@@HPEAUstbtt__csctx@@@Z ; stbtt__run_charstring

; 2283 :     if (x0)  *x0 = r ? c.min_x : 0;

  00c05	45 8b dc	 mov	 r11d, r12d
  00c08	85 c0		 test	 eax, eax
  00c0a	44 0f 45 5d 68	 cmovne	 r11d, DWORD PTR c$9[rbp-232]

; 2284 :     if (y0)  *y0 = r ? c.min_y : 0;

  00c0f	44 0f 45 65 70	 cmovne	 r12d, DWORD PTR c$9[rbp-224]

; 2285 :     if (x1)  *x1 = r ? c.max_x : 0;

  00c14	33 c9		 xor	 ecx, ecx
  00c16	8b f9		 mov	 edi, ecx
  00c18	85 c0		 test	 eax, eax
  00c1a	0f 45 7d 6c	 cmovne	 edi, DWORD PTR c$9[rbp-228]

; 2286 :     if (y1)  *y1 = r ? c.max_y : 0;

  00c1e	0f 45 4d 74	 cmovne	 ecx, DWORD PTR c$9[rbp-220]

; 1601 :     }

  00c22	e9 91 00 00 00	 jmp	 $LN470@ImFontAtla
$LN464@ImFontAtla:

; 1602 :     else {
; 1603 :         int g = stbtt__GetGlyfOffset(info, glyph_index);

  00c27	e8 00 00 00 00	 call	 ?stbtt__GetGlyfOffset@@YAHPEBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1604 :         if (g < 0) return 0;

  00c2c	85 c0		 test	 eax, eax
  00c2e	79 11		 jns	 SHORT $LN466@ImFontAtla

; 2660 :         if (ix0) *ix0 = 0;

  00c30	45 8b f4	 mov	 r14d, r12d

; 2661 :         if (iy0) *iy0 = 0;

  00c33	41 8b f4	 mov	 esi, r12d

; 2662 :         if (ix1) *ix1 = 0;

  00c36	41 8b fc	 mov	 edi, r12d

; 2663 :         if (iy1) *iy1 = 0;

  00c39	41 8b d4	 mov	 edx, r12d

; 2664 :     }

  00c3c	e9 1f 01 00 00	 jmp	 $LN461@ImFontAtla
$LN466@ImFontAtla:

; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  00c41	4c 63 d0	 movsxd	 r10, eax
  00c44	4c 8b 8b 38 ff
	ff ff		 mov	 r9, QWORD PTR [rbx-200]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00c4b	47 0f b6 44 0a
	03		 movzx	 r8d, BYTE PTR [r10+r9+3]
  00c51	43 0f b6 54 0a
	02		 movzx	 edx, BYTE PTR [r10+r9+2]
  00c57	be 00 01 00 00	 mov	 esi, 256		; 00000100H
  00c5c	0f bf ce	 movsx	 ecx, si
  00c5f	0f af d1	 imul	 edx, ecx
  00c62	66 44 03 c2	 add	 r8w, dx

; 1606 :         if (x0) *x0 = ttSHORT(info->data + g + 2);

  00c66	45 0f bf d8	 movsx	 r11d, r8w

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00c6a	47 0f b6 44 0a
	05		 movzx	 r8d, BYTE PTR [r10+r9+5]
  00c70	43 0f b6 54 0a
	04		 movzx	 edx, BYTE PTR [r10+r9+4]
  00c76	0f bf ce	 movsx	 ecx, si
  00c79	0f af d1	 imul	 edx, ecx
  00c7c	66 44 03 c2	 add	 r8w, dx

; 1607 :         if (y0) *y0 = ttSHORT(info->data + g + 4);

  00c80	45 0f bf e0	 movsx	 r12d, r8w

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00c84	47 0f b6 44 0a
	07		 movzx	 r8d, BYTE PTR [r10+r9+7]
  00c8a	43 0f b6 54 0a
	06		 movzx	 edx, BYTE PTR [r10+r9+6]
  00c90	0f bf ce	 movsx	 ecx, si
  00c93	0f af d1	 imul	 edx, ecx
  00c96	66 44 03 c2	 add	 r8w, dx

; 1608 :         if (x1) *x1 = ttSHORT(info->data + g + 6);

  00c9a	41 0f bf f8	 movsx	 edi, r8w

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  00c9e	47 0f b6 44 0a
	09		 movzx	 r8d, BYTE PTR [r10+r9+9]
  00ca4	43 0f b6 54 0a
	08		 movzx	 edx, BYTE PTR [r10+r9+8]
  00caa	0f bf ce	 movsx	 ecx, si
  00cad	0f af d1	 imul	 edx, ecx
  00cb0	66 44 03 c2	 add	 r8w, dx

; 1609 :         if (y1) *y1 = ttSHORT(info->data + g + 8);

  00cb4	41 0f bf c8	 movsx	 ecx, r8w
$LN470@ImFontAtla:
  00cb8	66 41 0f 6e cb	 movd	 xmm1, r11d

; 2667 :         if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);

  00cbd	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00cc0	f3 0f 59 ce	 mulss	 xmm1, xmm6
  00cc4	f3 41 0f 58 cd	 addss	 xmm1, xmm13
  00cc9	f3 0f 2c c1	 cvttss2si eax, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00ccd	41 0f 2f cd	 comiss	 xmm1, xmm13
  00cd1	73 10		 jae	 SHORT $LN489@ImFontAtla
  00cd3	66 0f 6e c0	 movd	 xmm0, eax
  00cd7	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00cda	0f 2e c1	 ucomiss xmm0, xmm1
  00cdd	7a 02		 jp	 SHORT $LN863@ImFontAtla
  00cdf	74 02		 je	 SHORT $LN489@ImFontAtla
$LN863@ImFontAtla:
  00ce1	ff c8		 dec	 eax
$LN489@ImFontAtla:
  00ce3	66 0f 6e c0	 movd	 xmm0, eax
  00ce7	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2667 :         if (ix0) *ix0 = STBTT_ifloor(x0 * scale_x + shift_x);

  00cea	f3 44 0f 2c f0	 cvttss2si r14d, xmm0
  00cef	66 0f 6e c9	 movd	 xmm1, ecx

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  00cf3	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00cf6	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00cfa	41 0f 28 d5	 movaps	 xmm2, xmm13
  00cfe	f3 0f 5c d1	 subss	 xmm2, xmm1
  00d02	f3 0f 2c c2	 cvttss2si eax, xmm2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 443  : static inline float  ImFloorSigned(float f) { return (float)((f >= 0 || (float)(int)f == f) ? (int)f : (int)f - 1); } // Decent replacement for floorf()

  00d06	41 0f 2f d5	 comiss	 xmm2, xmm13
  00d0a	73 10		 jae	 SHORT $LN493@ImFontAtla
  00d0c	66 0f 6e c0	 movd	 xmm0, eax
  00d10	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00d13	0f 2e c2	 ucomiss xmm0, xmm2
  00d16	7a 02		 jp	 SHORT $LN862@ImFontAtla
  00d18	74 02		 je	 SHORT $LN493@ImFontAtla
$LN862@ImFontAtla:
  00d1a	ff c8		 dec	 eax
$LN493@ImFontAtla:
  00d1c	0f 57 c0	 xorps	 xmm0, xmm0
  00d1f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2668 :         if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

  00d23	f3 0f 2c f0	 cvttss2si esi, xmm0
  00d27	0f 57 c0	 xorps	 xmm0, xmm0

; 2669 :         if (ix1) *ix1 = STBTT_iceil(x1 * scale_x + shift_x);

  00d2a	f3 0f 2a c7	 cvtsi2ss xmm0, edi
  00d2e	f3 0f 59 c6	 mulss	 xmm0, xmm6
  00d32	f3 41 0f 58 c5	 addss	 xmm0, xmm13
  00d37	e8 00 00 00 00	 call	 ceilf
  00d3c	f3 0f 2c f8	 cvttss2si edi, xmm0
  00d40	0f 57 c9	 xorps	 xmm1, xmm1

; 2670 :         if (iy1) *iy1 = STBTT_iceil(-y0 * scale_y + shift_y);

  00d43	f3 41 0f 2a cc	 cvtsi2ss xmm1, r12d
  00d48	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00d4c	41 0f 28 c5	 movaps	 xmm0, xmm13
  00d50	f3 0f 5c c1	 subss	 xmm0, xmm1
  00d54	e8 00 00 00 00	 call	 ceilf
  00d59	f3 0f 2c d0	 cvttss2si edx, xmm0
  00d5d	45 33 e4	 xor	 r12d, r12d
$LN461@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2480 :             src_tmp.Rects[glyph_i].w = (stbrp_coord)(x1 - x0 + padding + cfg.OversampleH - 1);

  00d60	66 41 2b fe	 sub	 di, r14w
  00d64	66 ff cf	 dec	 di
  00d67	44 8b 4d 80	 mov	 r9d, DWORD PTR padding$1$[rbp-256]
  00d6b	66 43 03 7c 2f
	18		 add	 di, WORD PTR [r15+r13+24]
  00d71	66 41 03 f9	 add	 di, r9w
  00d75	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]
  00d79	4c 8b 45 b0	 mov	 r8, QWORD PTR tv8082[rbp-256]
  00d7d	66 42 89 7c 00
	04		 mov	 WORD PTR [rax+r8+4], di

; 2481 :             src_tmp.Rects[glyph_i].h = (stbrp_coord)(y1 - y0 + padding + cfg.OversampleV - 1);

  00d83	43 0f b7 4c 2f
	1c		 movzx	 ecx, WORD PTR [r15+r13+28]
  00d89	66 2b ce	 sub	 cx, si
  00d8c	66 ff ca	 dec	 dx
  00d8f	66 03 ca	 add	 cx, dx
  00d92	66 41 03 c9	 add	 cx, r9w
  00d96	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]
  00d9a	66 42 89 4c 00
	06		 mov	 WORD PTR [rax+r8+6], cx

; 2482 :             total_surface += src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h;

  00da0	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]
  00da4	42 0f b7 4c 00
	06		 movzx	 ecx, WORD PTR [rax+r8+6]
  00daa	42 0f b7 44 00
	04		 movzx	 eax, WORD PTR [rax+r8+4]
  00db0	0f af c8	 imul	 ecx, eax
  00db3	8b 54 24 68	 mov	 edx, DWORD PTR total_surface$1$[rsp]
  00db7	03 d1		 add	 edx, ecx
  00db9	89 54 24 68	 mov	 DWORD PTR total_surface$1$[rsp], edx

; 2474 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i++)

  00dbd	8b 45 b8	 mov	 eax, DWORD PTR glyph_i$1$[rbp-256]
  00dc0	ff c0		 inc	 eax
  00dc2	89 45 b8	 mov	 DWORD PTR glyph_i$1$[rbp-256], eax
  00dc5	48 8b 75 f8	 mov	 rsi, QWORD PTR $T8[rbp-256]
  00dc9	48 ff c6	 inc	 rsi
  00dcc	48 89 75 f8	 mov	 QWORD PTR $T8[rbp-256], rsi
  00dd0	49 83 c0 10	 add	 r8, 16
  00dd4	4c 89 45 b0	 mov	 QWORD PTR tv8082[rbp-256], r8
  00dd8	8b 7b 30	 mov	 edi, DWORD PTR [rbx+48]
  00ddb	3b c7		 cmp	 eax, edi
  00ddd	0f 8c 71 fd ff
	ff		 jl	 $LL31@ImFontAtla
  00de3	44 8b 75 98	 mov	 r14d, DWORD PTR buf_rects_out_n$1$[rbp-256]
  00de7	44 8b 64 24 70	 mov	 r12d, DWORD PTR src_i$1$[rsp]
  00dec	eb 04		 jmp	 SHORT $LN881@ImFontAtla
$LN868@ImFontAtla:
  00dee	8b 54 24 68	 mov	 edx, DWORD PTR total_surface$1$[rsp]
$LN881@ImFontAtla:

; 2450 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  00df2	8b 44 24 60	 mov	 eax, DWORD PTR src_tmp_array$2$[rsp]
  00df6	44 8b 6c 24 6c	 mov	 r13d, DWORD PTR total_glyphs_count$2$[rsp]
  00dfb	8b 74 24 64	 mov	 esi, DWORD PTR buf_packedchars_out_n$1$[rsp]
$LN26@ImFontAtla:
  00dff	41 ff c4	 inc	 r12d
  00e02	44 89 64 24 70	 mov	 DWORD PTR src_i$1$[rsp], r12d
  00e07	48 81 c3 10 01
	00 00		 add	 rbx, 272		; 00000110H
  00e0e	49 81 c7 88 00
	00 00		 add	 r15, 136		; 00000088H
  00e15	44 3b e0	 cmp	 r12d, eax
  00e18	0f 8c 95 fb ff
	ff		 jl	 $LL28@ImFontAtla
  00e1e	33 db		 xor	 ebx, ebx
$LN27@ImFontAtla:
  00e20	66 0f 6e ca	 movd	 xmm1, edx

; 2483 :         }
; 2484 :     }
; 2485 : 
; 2486 :     // We need a width for the skyline algorithm, any width!
; 2487 :     // The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
; 2488 :     // User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
; 2489 :     const int surface_sqrt = (int)ImSqrt((float)total_surface) + 1;

  00e24	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00e27	0f 57 c0	 xorps	 xmm0, xmm0
  00e2a	0f 2e c1	 ucomiss xmm0, xmm1
  00e2d	77 09		 ja	 SHORT $LN860@ImFontAtla
  00e2f	0f 57 c0	 xorps	 xmm0, xmm0
  00e32	f3 0f 51 c1	 sqrtss	 xmm0, xmm1
  00e36	eb 08		 jmp	 SHORT $LN861@ImFontAtla
$LN860@ImFontAtla:
  00e38	0f 28 c1	 movaps	 xmm0, xmm1
  00e3b	e8 00 00 00 00	 call	 sqrtf
$LN861@ImFontAtla:
  00e40	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00e44	ff c1		 inc	 ecx

; 2490 :     atlas->TexHeight = 0;

  00e46	4c 8b 6d 88	 mov	 r13, QWORD PTR atlas$GSCopy$1$[rbp-256]
  00e4a	41 89 5d 34	 mov	 DWORD PTR [r13+52], ebx

; 2491 :     if (atlas->TexDesiredWidth > 0)

  00e4e	41 8b 45 10	 mov	 eax, DWORD PTR [r13+16]
  00e52	85 c0		 test	 eax, eax
  00e54	7f 3b		 jg	 SHORT $LN58@ImFontAtla
  00e56	66 0f 6e c1	 movd	 xmm0, ecx

; 2492 :         atlas->TexWidth = atlas->TexDesiredWidth;
; 2493 :     else
; 2494 :         atlas->TexWidth = (surface_sqrt >= 4096 * 0.7f) ? 4096 : (surface_sqrt >= 2048 * 0.7f) ? 2048 : (surface_sqrt >= 1024 * 0.7f) ? 1024 : 512;

  00e5a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00e5d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@45333333
  00e64	72 07		 jb	 SHORT $LN80@ImFontAtla
  00e66	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00e6b	eb 24		 jmp	 SHORT $LN58@ImFontAtla
$LN80@ImFontAtla:
  00e6d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@44b33333
  00e74	72 07		 jb	 SHORT $LN78@ImFontAtla
  00e76	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  00e7b	eb 14		 jmp	 SHORT $LN58@ImFontAtla
$LN78@ImFontAtla:
  00e7d	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00e82	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00e87	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@44333333
  00e8e	0f 43 c1	 cmovae	 eax, ecx
$LN58@ImFontAtla:

; 2495 : 
; 2496 :     // 5. Start packing
; 2497 :     // Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
; 2498 :     const int TEX_HEIGHT_MAX = 1024 * 32;
; 2499 :     stbtt_pack_context spc = {};

  00e91	41 89 45 30	 mov	 DWORD PTR [r13+48], eax
  00e95	48 89 5d 10	 mov	 QWORD PTR spc$[rbp-256], rbx
  00e99	4c 8b f3	 mov	 r14, rbx
  00e9c	48 89 5d 18	 mov	 QWORD PTR spc$[rbp-248], rbx
  00ea0	89 5d 20	 mov	 DWORD PTR spc$[rbp-240], ebx
  00ea3	48 89 5d 28	 mov	 QWORD PTR spc$[rbp-232], rbx
  00ea7	0f 57 c0	 xorps	 xmm0, xmm0
  00eaa	66 0f 7f 45 30	 movdqa	 XMMWORD PTR spc$[rbp-224], xmm0
  00eaf	4c 8b e3	 mov	 r12, rbx
  00eb2	48 89 5d 48	 mov	 QWORD PTR spc$[rbp-200], rbx

; 2500 :     stbtt_PackBegin(&spc, NULL, atlas->TexWidth, TEX_HEIGHT_MAX, 0, atlas->TexGlyphPadding, NULL);

  00eb6	41 8b 75 14	 mov	 esi, DWORD PTR [r13+20]
  00eba	45 8b 7d 30	 mov	 r15d, DWORD PTR [r13+48]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00ebe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00ec5	48 85 c0	 test	 rax, rax
  00ec8	74 06		 je	 SHORT $LN502@ImFontAtla

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00eca	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN502@ImFontAtla:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00ed0	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00ed5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00edb	48 8b f8	 mov	 rdi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3848 :     int            num_nodes = pw - padding;

  00ede	41 8b df	 mov	 ebx, r15d
  00ee1	2b de		 sub	 ebx, esi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00ee3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00eea	48 85 c0	 test	 rax, rax
  00eed	74 06		 je	 SHORT $LN509@ImFontAtla

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00eef	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN509@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3849 :     stbrp_node* nodes = (stbrp_node*)STBTT_malloc(sizeof(*nodes) * num_nodes, alloc_context);

  00ef5	48 63 cb	 movsxd	 rcx, ebx
  00ef8	48 c1 e1 04	 shl	 rcx, 4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00efc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3851 :     if (context == NULL || nodes == NULL) {

  00f02	48 85 ff	 test	 rdi, rdi
  00f05	74 66		 je	 SHORT $LN519@ImFontAtla
  00f07	48 85 c0	 test	 rax, rax
  00f0a	74 4a		 je	 SHORT $LN496@ImFontAtla

; 3854 :         return 0;
; 3855 :     }
; 3856 : 
; 3857 :     spc->user_allocator_context = alloc_context;
; 3858 :     spc->width = pw;

  00f0c	44 89 7d 20	 mov	 DWORD PTR spc$[rbp-240], r15d

; 3859 :     spc->height = ph;
; 3860 :     spc->pixels = pixels;
; 3861 :     spc->pack_info = context;

  00f10	4c 8b f7	 mov	 r14, rdi
  00f13	48 89 7d 18	 mov	 QWORD PTR spc$[rbp-248], rdi

; 3862 :     spc->nodes = nodes;

  00f17	4c 8b e0	 mov	 r12, rax
  00f1a	48 89 45 48	 mov	 QWORD PTR spc$[rbp-200], rax

; 3863 :     spc->padding = padding;

  00f1e	89 75 2c	 mov	 DWORD PTR spc$[rbp-228], esi

; 3864 :     spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;

  00f21	44 89 7d 28	 mov	 DWORD PTR spc$[rbp-232], r15d

; 3865 :     spc->h_oversample = 1;

  00f25	c7 45 34 01 00
	00 00		 mov	 DWORD PTR spc$[rbp-220], 1

; 3866 :     spc->v_oversample = 1;

  00f2c	c7 45 38 01 00
	00 00		 mov	 DWORD PTR spc$[rbp-216], 1

; 3867 :     spc->skip_missing = 0;

  00f33	c7 45 30 00 00
	00 00		 mov	 DWORD PTR spc$[rbp-224], 0

; 3868 : 
; 3869 :     stbrp_init_target(context, pw - padding, ph - padding, nodes, num_nodes);

  00f3a	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00f40	44 2b c6	 sub	 r8d, esi
  00f43	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  00f47	4c 8b c8	 mov	 r9, rax
  00f4a	8b d3		 mov	 edx, ebx
  00f4c	48 8b cf	 mov	 rcx, rdi
  00f4f	e8 00 00 00 00	 call	 stbrp_init_target

; 3870 : 
; 3871 :     if (pixels)

  00f54	eb 37		 jmp	 SHORT $LN527@ImFontAtla
$LN496@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00f56	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00f5d	48 85 c0	 test	 rax, rax
  00f60	74 06		 je	 SHORT $LN517@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00f62	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN517@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00f68	48 8b cf	 mov	 rcx, rdi
  00f6b	eb 1a		 jmp	 SHORT $LN882@ImFontAtla
$LN519@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 3853 :         if (nodes != NULL) STBTT_free(nodes, alloc_context);

  00f6d	48 85 c0	 test	 rax, rax
  00f70	74 1b		 je	 SHORT $LN527@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00f72	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00f79	48 85 c9	 test	 rcx, rcx
  00f7c	74 06		 je	 SHORT $LN525@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00f7e	ff 89 ec 00 00
	00		 dec	 DWORD PTR [rcx+236]
$LN525@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00f84	48 8b c8	 mov	 rcx, rax
$LN882@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2501 :     ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

  00f87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN527@ImFontAtla:
  00f8d	49 8b d6	 mov	 rdx, r14
  00f90	49 8b cd	 mov	 rcx, r13
  00f93	e8 00 00 00 00	 call	 ?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z ; ImFontAtlasBuildPackCustomRects
  00f98	33 c9		 xor	 ecx, ecx
  00f9a	8b f9		 mov	 edi, ecx

; 2502 : 
; 2503 :     // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
; 2504 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  00f9c	8b 74 24 60	 mov	 esi, DWORD PTR src_tmp_array$2$[rsp]
  00fa0	85 f6		 test	 esi, esi
  00fa2	0f 8e a4 00 00
	00		 jle	 $LN33@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 1608 :         if (x1) *x1 = ttSHORT(info->data + g + 6);

  00fa8	8b f1		 mov	 esi, ecx
  00faa	48 8b 5c 24 78	 mov	 rbx, QWORD PTR src_tmp_array$1$[rsp]
  00faf	48 81 c3 e8 00
	00 00		 add	 rbx, 232		; 000000e8H
  00fb6	44 8b 7c 24 60	 mov	 r15d, DWORD PTR src_tmp_array$2$[rsp]
  00fbb	0f 1f 44 00 00	 npad	 5
$LL34@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00fc0	48 85 f6	 test	 rsi, rsi
  00fc3	78 05		 js	 SHORT $LN533@ImFontAtla
  00fc5	41 3b ff	 cmp	 edi, r15d
  00fc8	7c 1a		 jl	 SHORT $LN534@ImFontAtla
$LN533@ImFontAtla:
  00fca	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00fd0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00fd7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00fde	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN534@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2507 :         if (src_tmp.GlyphsCount == 0)

  00fe4	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  00fe7	45 85 c0	 test	 r8d, r8d
  00fea	74 47		 je	 SHORT $LN32@ImFontAtla

; 2508 :             continue;
; 2509 : 
; 2510 :         stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

  00fec	48 8b 53 e0	 mov	 rdx, QWORD PTR [rbx-32]
  00ff0	49 8b ce	 mov	 rcx, r14
  00ff3	e8 00 00 00 00	 call	 stbrp_pack_rects

; 2511 : 
; 2512 :         // Extend texture height and mark missing glyphs as non-packed so we won't render them.
; 2513 :         // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
; 2514 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

  00ff8	33 c9		 xor	 ecx, ecx
  00ffa	44 8b c1	 mov	 r8d, ecx
  00ffd	39 0b		 cmp	 DWORD PTR [rbx], ecx
  00fff	7e 32		 jle	 SHORT $LN32@ImFontAtla

; 2508 :             continue;
; 2509 : 
; 2510 :         stbrp_pack_rects((stbrp_context*)spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount);

  01001	8b d1		 mov	 edx, ecx
$LL37@ImFontAtla:

; 2515 :             if (src_tmp.Rects[glyph_i].was_packed)

  01003	48 8b 43 e0	 mov	 rax, QWORD PTR [rbx-32]
  01007	83 7c 10 0c 00	 cmp	 DWORD PTR [rax+rdx+12], 0
  0100c	74 19		 je	 SHORT $LN35@ImFontAtla

; 2516 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

  0100e	0f b7 4c 10 0a	 movzx	 ecx, WORD PTR [rax+rdx+10]
  01013	0f b7 44 10 06	 movzx	 eax, WORD PTR [rax+rdx+6]
  01018	03 c8		 add	 ecx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  0101a	41 39 4d 34	 cmp	 DWORD PTR [r13+52], ecx
  0101e	41 0f 4d 4d 34	 cmovge	 ecx, DWORD PTR [r13+52]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2516 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

  01023	41 89 4d 34	 mov	 DWORD PTR [r13+52], ecx
$LN35@ImFontAtla:

; 2511 : 
; 2512 :         // Extend texture height and mark missing glyphs as non-packed so we won't render them.
; 2513 :         // FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
; 2514 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

  01027	41 ff c0	 inc	 r8d
  0102a	48 83 c2 10	 add	 rdx, 16
  0102e	44 3b 03	 cmp	 r8d, DWORD PTR [rbx]
  01031	7c d0		 jl	 SHORT $LL37@ImFontAtla
$LN32@ImFontAtla:

; 2502 : 
; 2503 :     // 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
; 2504 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  01033	ff c7		 inc	 edi
  01035	48 ff c6	 inc	 rsi
  01038	48 81 c3 10 01
	00 00		 add	 rbx, 272		; 00000110H
  0103f	41 3b ff	 cmp	 edi, r15d
  01042	0f 8c 78 ff ff
	ff		 jl	 $LL34@ImFontAtla
  01048	8b 74 24 60	 mov	 esi, DWORD PTR src_tmp_array$2$[rsp]
$LN33@ImFontAtla:

; 2520 :     atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);

  0104c	41 8b 45 34	 mov	 eax, DWORD PTR [r13+52]
  01050	41 f6 45 00 01	 test	 BYTE PTR [r13], 1
  01055	75 25		 jne	 SHORT $LN83@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 314  : static inline int       ImUpperPowerOfTwo(int v) { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

  01057	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0105a	8b c1		 mov	 eax, ecx
  0105c	d1 f8		 sar	 eax, 1
  0105e	0b c8		 or	 ecx, eax
  01060	8b c1		 mov	 eax, ecx
  01062	c1 f8 02	 sar	 eax, 2
  01065	0b c8		 or	 ecx, eax
  01067	8b c1		 mov	 eax, ecx
  01069	c1 f8 04	 sar	 eax, 4
  0106c	0b c8		 or	 ecx, eax
  0106e	8b c1		 mov	 eax, ecx
  01070	c1 f8 08	 sar	 eax, 8
  01073	0b c8		 or	 ecx, eax
  01075	8b c1		 mov	 eax, ecx
  01077	c1 f8 10	 sar	 eax, 16
  0107a	0b c1		 or	 eax, ecx
$LN83@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2520 :     atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);

  0107c	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]
  0107f	41 89 4d 34	 mov	 DWORD PTR [r13+52], ecx
  01083	66 0f 6e c1	 movd	 xmm0, ecx

; 2521 :     atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);

  01087	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0108a	f3 44 0f 10 25
	00 00 00 00	 movss	 xmm12, DWORD PTR __real@3f800000
  01093	41 0f 28 d4	 movaps	 xmm2, xmm12
  01097	f3 0f 5e d0	 divss	 xmm2, xmm0
  0109b	41 8b 45 30	 mov	 eax, DWORD PTR [r13+48]
  0109f	66 0f 6e c0	 movd	 xmm0, eax
  010a3	0f 5b c0	 cvtdq2ps xmm0, xmm0
  010a6	41 0f 28 cc	 movaps	 xmm1, xmm12
  010aa	f3 0f 5e c8	 divss	 xmm1, xmm0
  010ae	f3 41 0f 11 4d
	38		 movss	 DWORD PTR [r13+56], xmm1
  010b4	f3 41 0f 11 55
	3c		 movss	 DWORD PTR [r13+60], xmm2

; 2522 :     atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);

  010ba	0f af c1	 imul	 eax, ecx
  010bd	48 63 c8	 movsxd	 rcx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  010c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  010c7	48 85 c0	 test	 rax, rax
  010ca	74 06		 je	 SHORT $LN542@ImFontAtla

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  010cc	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN542@ImFontAtla:

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  010d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2522 :     atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);

  010d8	49 89 45 20	 mov	 QWORD PTR [r13+32], rax

; 2523 :     memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);

  010dc	41 8b 4d 34	 mov	 ecx, DWORD PTR [r13+52]
  010e0	41 0f af 4d 30	 imul	 ecx, DWORD PTR [r13+48]
  010e5	4c 63 c1	 movsxd	 r8, ecx
  010e8	33 d2		 xor	 edx, edx
  010ea	48 8b c8	 mov	 rcx, rax
  010ed	e8 00 00 00 00	 call	 memset

; 2524 :     spc.pixels = atlas->TexPixelsAlpha8;

  010f2	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  010f6	48 89 45 40	 mov	 QWORD PTR spc$[rbp-208], rax

; 2525 :     spc.height = atlas->TexHeight;

  010fa	41 8b 45 34	 mov	 eax, DWORD PTR [r13+52]
  010fe	89 45 24	 mov	 DWORD PTR spc$[rbp-236], eax

; 2522 :     atlas->TexPixelsAlpha8 = (unsigned char*)IM_ALLOC(atlas->TexWidth * atlas->TexHeight);

  01101	33 c0		 xor	 eax, eax
  01103	44 8b f8	 mov	 r15d, eax

; 2526 : 
; 2527 :     // 8. Render/rasterize font characters into the texture
; 2528 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  01106	85 f6		 test	 esi, esi
  01108	0f 8e c5 01 00
	00		 jle	 $LN39@ImFontAtla

; 2516 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

  0110e	44 8b e0	 mov	 r12d, eax
  01111	48 89 45 80	 mov	 QWORD PTR $T4[rbp-256], rax
  01115	44 8b e8	 mov	 r13d, eax
  01118	4c 8b 74 24 78	 mov	 r14, QWORD PTR src_tmp_array$1$[rsp]
  0111d	0f 1f 00	 npad	 3
$LL40@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  01120	48 8b 5d a0	 mov	 rbx, QWORD PTR $T6[rbp-256]
  01124	4d 85 e4	 test	 r12, r12
  01127	78 05		 js	 SHORT $LN550@ImFontAtla
  01129	44 3b 3b	 cmp	 r15d, DWORD PTR [rbx]
  0112c	7c 1a		 jl	 SHORT $LN551@ImFontAtla
$LN550@ImFontAtla:
  0112e	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  01134	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0113b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  01142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN551@ImFontAtla:
  01148	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  0114c	4d 85 e4	 test	 r12, r12
  0114f	78 05		 js	 SHORT $LN554@ImFontAtla
  01151	44 3b fe	 cmp	 r15d, esi
  01154	7c 1a		 jl	 SHORT $LN555@ImFontAtla
$LN554@ImFontAtla:
  01156	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0115c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  01163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0116a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN555@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2532 :         if (src_tmp.GlyphsCount == 0)

  01170	41 83 be e8 00
	00 00 00	 cmp	 DWORD PTR [r14+232], 0
  01178	0f 84 2c 01 00
	00		 je	 $LN38@ImFontAtla

; 2533 :             continue;
; 2534 : 
; 2535 :         stbtt_PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects);

  0117e	4d 8d 86 a0 00
	00 00		 lea	 r8, QWORD PTR [r14+160]
  01185	49 8b 86 c8 00
	00 00		 mov	 rax, QWORD PTR [r14+200]
  0118c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01191	49 8b d6	 mov	 rdx, r14
  01194	48 8d 4d 10	 lea	 rcx, QWORD PTR spc$[rbp-256]
  01198	e8 00 00 00 00	 call	 stbtt_PackFontRangesRenderIntoRects

; 2536 : 
; 2537 :         // Apply multiply operator
; 2538 :         if (cfg.RasterizerMultiply != 1.0f)

  0119d	f3 42 0f 10 4c
	2b 50		 movss	 xmm1, DWORD PTR [rbx+r13+80]
  011a4	41 0f 2e cc	 ucomiss xmm1, xmm12
  011a8	7a 06		 jp	 SHORT $LN859@ImFontAtla
  011aa	0f 84 ef 00 00
	00		 je	 $LN42@ImFontAtla
$LN859@ImFontAtla:

; 2539 :         {
; 2540 :             unsigned char multiply_table[256];
; 2541 :             ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);

  011b0	33 f6		 xor	 esi, esi
  011b2	44 8b c6	 mov	 r8d, esi
  011b5	4c 8d 8d 90 00
	00 00		 lea	 r9, QWORD PTR multiply_table$10[rbp-256]
  011bc	41 bc 00 01 00
	00		 mov	 r12d, 256		; 00000100H
  011c2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL791@ImFontAtla:

; 2293 :         unsigned int value = (unsigned int)(i * in_brighten_factor);

  011d0	41 8b c0	 mov	 eax, r8d
  011d3	0f 57 c0	 xorps	 xmm0, xmm0
  011d6	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  011db	f3 0f 59 c1	 mulss	 xmm0, xmm1
  011df	f3 48 0f 2c c8	 cvttss2si rcx, xmm0

; 2294 :         out_table[i] = value > 255 ? 255 : (value & 0xFF);

  011e4	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  011e9	0f b6 c1	 movzx	 eax, cl
  011ec	3b ca		 cmp	 ecx, edx
  011ee	0f 46 d0	 cmovbe	 edx, eax
  011f1	41 88 11	 mov	 BYTE PTR [r9], dl

; 2291 :     for (unsigned int i = 0; i < 256; i++)

  011f4	41 ff c0	 inc	 r8d
  011f7	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  011fb	45 3b c4	 cmp	 r8d, r12d
  011fe	72 d0		 jb	 SHORT $LL791@ImFontAtla

; 2542 :             stbrp_rect* r = &src_tmp.Rects[0];

  01200	49 8b be c8 00
	00 00		 mov	 rdi, QWORD PTR [r14+200]

; 2543 :             for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)

  01207	41 39 b6 e8 00
	00 00		 cmp	 DWORD PTR [r14+232], esi
  0120e	4c 8b 65 80	 mov	 r12, QWORD PTR $T4[rbp-256]
  01212	0f 8e 83 00 00
	00		 jle	 $LN870@ImFontAtla

; 2542 :             stbrp_rect* r = &src_tmp.Rects[0];

  01218	48 83 c7 06	 add	 rdi, 6
  0121c	4c 8b 65 88	 mov	 r12, QWORD PTR atlas$GSCopy$1$[rbp-256]
$LL43@ImFontAtla:

; 2544 :                 if (r->was_packed)

  01220	83 7f 06 00	 cmp	 DWORD PTR [rdi+6], 0
  01224	74 62		 je	 SHORT $LN41@ImFontAtla

; 2545 :                     ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);

  01226	49 63 5c 24 30	 movsxd	 rbx, DWORD PTR [r12+48]
  0122b	44 0f b7 1f	 movzx	 r11d, WORD PTR [rdi]
  0122f	0f b7 4f 04	 movzx	 ecx, WORD PTR [rdi+4]

; 2300 :     unsigned char* data = pixels + x + y * stride;

  01233	8b c3		 mov	 eax, ebx
  01235	0f af c1	 imul	 eax, ecx
  01238	48 98		 cdqe
  0123a	44 0f b7 57 02	 movzx	 r10d, WORD PTR [rdi+2]
  0123f	49 03 44 24 20	 add	 rax, QWORD PTR [r12+32]
  01244	4c 03 d0	 add	 r10, rax

; 2302 :         for (int i = 0; i < w; i++)

  01247	44 0f b7 4f fe	 movzx	 r9d, WORD PTR [rdi-2]

; 2301 :     for (int j = h; j > 0; j--, data += stride)

  0124c	45 85 db	 test	 r11d, r11d
  0124f	74 37		 je	 SHORT $LN41@ImFontAtla

; 2545 :                     ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas->TexPixelsAlpha8, r->x, r->y, r->w, r->h, atlas->TexWidth * 1);

  01251	4d 8b c2	 mov	 r8, r10
  01254	49 f7 d8	 neg	 r8
$LL566@ImFontAtla:

; 2302 :         for (int i = 0; i < w; i++)

  01257	4d 85 c9	 test	 r9, r9
  0125a	74 1e		 je	 SHORT $LN564@ImFontAtla
  0125c	49 8b d2	 mov	 rdx, r10
  0125f	90		 npad	 1
$LL569@ImFontAtla:

; 2303 :             data[i] = table[data[i]];

  01260	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  01263	0f b6 8c 05 90
	00 00 00	 movzx	 ecx, BYTE PTR multiply_table$10[rbp+rax-256]
  0126b	88 0a		 mov	 BYTE PTR [rdx], cl

; 2302 :         for (int i = 0; i < w; i++)

  0126d	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  01271	49 8d 04 10	 lea	 rax, QWORD PTR [r8+rdx]
  01275	49 3b c1	 cmp	 rax, r9
  01278	7c e6		 jl	 SHORT $LL569@ImFontAtla
$LN564@ImFontAtla:

; 2301 :     for (int j = h; j > 0; j--, data += stride)

  0127a	41 ff cb	 dec	 r11d
  0127d	4c 03 d3	 add	 r10, rbx
  01280	4c 2b c3	 sub	 r8, rbx
  01283	45 85 db	 test	 r11d, r11d
  01286	7f cf		 jg	 SHORT $LL566@ImFontAtla
$LN41@ImFontAtla:

; 2543 :             for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++, r++)

  01288	ff c6		 inc	 esi
  0128a	48 83 c7 10	 add	 rdi, 16
  0128e	41 3b b6 e8 00
	00 00		 cmp	 esi, DWORD PTR [r14+232]
  01295	7c 89		 jl	 SHORT $LL43@ImFontAtla
  01297	4c 8b 65 80	 mov	 r12, QWORD PTR $T4[rbp-256]
$LN870@ImFontAtla:

; 2546 :         }
; 2547 :         src_tmp.Rects = NULL;

  0129b	8b 74 24 60	 mov	 esi, DWORD PTR src_tmp_array$2$[rsp]
$LN42@ImFontAtla:
  0129f	49 c7 86 c8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [r14+200], 0
$LN38@ImFontAtla:

; 2526 : 
; 2527 :     // 8. Render/rasterize font characters into the texture
; 2528 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  012aa	41 ff c7	 inc	 r15d
  012ad	49 ff c4	 inc	 r12
  012b0	4c 89 65 80	 mov	 QWORD PTR $T4[rbp-256], r12
  012b4	49 81 c5 88 00
	00 00		 add	 r13, 136		; 00000088H
  012bb	49 81 c6 10 01
	00 00		 add	 r14, 272		; 00000110H
  012c2	44 3b fe	 cmp	 r15d, esi
  012c5	0f 8c 55 fe ff
	ff		 jl	 $LL40@ImFontAtla
  012cb	4c 8b 65 48	 mov	 r12, QWORD PTR spc$[rbp-200]
  012cf	4c 8b 75 18	 mov	 r14, QWORD PTR spc$[rbp-248]
$LN39@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  012d3	4d 85 e4	 test	 r12, r12
  012d6	74 12		 je	 SHORT $LN575@ImFontAtla

; 3610 :         if (ImGuiContext* ctx = GImGui)

  012d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  012df	48 85 c0	 test	 rax, rax
  012e2	74 06		 je	 SHORT $LN575@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  012e4	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN575@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  012ea	49 8b cc	 mov	 rcx, r12
  012ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3609 :     if (ptr)

  012f3	4d 85 f6	 test	 r14, r14
  012f6	74 12		 je	 SHORT $LN583@ImFontAtla

; 3610 :         if (ImGuiContext* ctx = GImGui)

  012f8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  012ff	48 85 c0	 test	 rax, rax
  01302	74 06		 je	 SHORT $LN583@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  01304	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN583@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0130a	49 8b ce	 mov	 rcx, r14
  0130d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  01313	48 8b 4d c0	 mov	 rcx, QWORD PTR buf_rects$1$[rbp-256]
  01317	45 33 ff	 xor	 r15d, r15d
  0131a	48 85 c9	 test	 rcx, rcx
  0131d	74 27		 je	 SHORT $LN590@ImFontAtla
  0131f	4c 89 7d d8	 mov	 QWORD PTR buf_rects$[rbp-256], r15
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  01323	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0132a	48 85 c0	 test	 rax, rax
  0132d	74 06		 je	 SHORT $LN594@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0132f	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN594@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  01335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0133b	49 8b cf	 mov	 rcx, r15
  0133e	48 89 4d c0	 mov	 QWORD PTR buf_rects$1$[rbp-256], rcx
  01342	48 89 4d e0	 mov	 QWORD PTR buf_rects$[rbp-248], rcx
$LN590@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2555 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  01346	45 8b e7	 mov	 r12d, r15d
  01349	44 89 7c 24 70	 mov	 DWORD PTR src_i$1$[rsp], r15d
  0134e	85 f6		 test	 esi, esi
  01350	0f 8e 8f 03 00
	00		 jle	 $LN650@ImFontAtla

; 2516 :                 atlas->TexHeight = ImMax(atlas->TexHeight, src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h);

  01356	49 8b c7	 mov	 rax, r15
  01359	48 89 45 80	 mov	 QWORD PTR $T5[rbp-256], rax
  0135d	49 8b ff	 mov	 rdi, r15
  01360	4c 89 7d b0	 mov	 QWORD PTR tv8055[rbp-256], r15
  01364	48 8b 5c 24 78	 mov	 rbx, QWORD PTR src_tmp_array$1$[rsp]
  01369	48 83 c3 08	 add	 rbx, 8
  0136d	f3 44 0f 10 1d
	00 00 00 00	 movss	 xmm11, DWORD PTR __real@3f000000
$LL46@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  01376	48 85 c0	 test	 rax, rax
  01379	78 05		 js	 SHORT $LN602@ImFontAtla
  0137b	44 3b e6	 cmp	 r12d, esi
  0137e	7c 1e		 jl	 SHORT $LN603@ImFontAtla
$LN602@ImFontAtla:
  01380	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  01386	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0138d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  01394	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0139a	48 8b 45 80	 mov	 rax, QWORD PTR $T5[rbp-256]
$LN603@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2558 :         if (src_tmp.GlyphsCount == 0)

  0139e	83 bb e0 00 00
	00 00		 cmp	 DWORD PTR [rbx+224], 0
  013a5	0f 84 b2 02 00
	00		 je	 $LN44@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  013ab	48 8b 75 a0	 mov	 rsi, QWORD PTR $T6[rbp-256]
  013af	48 85 c0	 test	 rax, rax
  013b2	78 05		 js	 SHORT $LN606@ImFontAtla
  013b4	44 3b 26	 cmp	 r12d, DWORD PTR [rsi]
  013b7	7c 1a		 jl	 SHORT $LN607@ImFontAtla
$LN606@ImFontAtla:
  013b9	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  013bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  013c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  013cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN607@ImFontAtla:
  013d3	4c 8b 6e 08	 mov	 r13, QWORD PTR [rsi+8]
  013d7	4c 03 ef	 add	 r13, rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2565 :         ImFont* dst_font = cfg.DstFont;

  013da	49 8b b5 80 00
	00 00		 mov	 rsi, QWORD PTR [r13+128]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  013e1	4c 63 4b 1c	 movsxd	 r9, DWORD PTR [rbx+28]
  013e5	4c 8b 03	 mov	 r8, QWORD PTR [rbx]

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  013e8	43 0f b6 54 01
	06		 movzx	 edx, BYTE PTR [r9+r8+6]
  013ee	41 bb 00 01 00
	00		 mov	 r11d, 256		; 00000100H
  013f4	41 0f bf cb	 movsx	 ecx, r11w
  013f8	0f af d1	 imul	 edx, ecx
  013fb	43 0f b6 44 01
	07		 movzx	 eax, BYTE PTR [r9+r8+7]
  01401	66 03 d0	 add	 dx, ax

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  01404	44 0f bf d2	 movsx	 r10d, dx

; 1271 : static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }

  01408	43 0f b6 54 01
	04		 movzx	 edx, BYTE PTR [r9+r8+4]
  0140e	41 0f bf cb	 movsx	 ecx, r11w
  01412	0f af d1	 imul	 edx, ecx
  01415	43 0f b6 44 01
	05		 movzx	 eax, BYTE PTR [r9+r8+5]
  0141b	66 03 d0	 add	 dx, ax

; 2635 :     int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

  0141e	0f bf ca	 movsx	 ecx, dx
  01421	8b c1		 mov	 eax, ecx
  01423	41 2b c2	 sub	 eax, r10d
  01426	66 0f 6e c0	 movd	 xmm0, eax

; 2636 :     return (float)height / fheight;

  0142a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0142d	f3 41 0f 10 55
	14		 movss	 xmm2, DWORD PTR [r13+20]
  01433	f3 0f 5e d0	 divss	 xmm2, xmm0
  01437	66 0f 6e c9	 movd	 xmm1, ecx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2571 :         const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));

  0143b	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0143e	b8 ff ff ff ff	 mov	 eax, -1
  01443	41 0f 2f cd	 comiss	 xmm1, xmm13
  01447	b9 01 00 00 00	 mov	 ecx, 1
  0144c	0f 47 c1	 cmova	 eax, ecx
  0144f	66 0f 6e c0	 movd	 xmm0, eax
  01453	0f 5b c0	 cvtdq2ps xmm0, xmm0
  01456	f3 0f 59 ca	 mulss	 xmm1, xmm2
  0145a	f3 0f 58 c1	 addss	 xmm0, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 442  : static inline float  ImFloor(float f) { return (float)(int)(f); }

  0145e	f3 0f 2c c0	 cvttss2si eax, xmm0
  01462	66 0f 6e f0	 movd	 xmm6, eax
  01466	0f 5b f6	 cvtdq2ps xmm6, xmm6
  01469	66 41 0f 6e ca	 movd	 xmm1, r10d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2572 :         const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));

  0146e	0f 5b c9	 cvtdq2ps xmm1, xmm1
  01471	b8 ff ff ff ff	 mov	 eax, -1
  01476	41 0f 2f cd	 comiss	 xmm1, xmm13
  0147a	0f 47 c1	 cmova	 eax, ecx
  0147d	66 0f 6e c0	 movd	 xmm0, eax
  01481	0f 5b c0	 cvtdq2ps xmm0, xmm0
  01484	f3 0f 59 ca	 mulss	 xmm1, xmm2
  01488	f3 0f 58 c1	 addss	 xmm0, xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 442  : static inline float  ImFloor(float f) { return (float)(int)(f); }

  0148c	f3 0f 2c c0	 cvttss2si eax, xmm0
  01490	66 0f 6e f8	 movd	 xmm7, eax
  01494	0f 5b ff	 cvtdq2ps xmm7, xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2607 :     if (!font_config->MergeMode)

  01497	41 80 7d 48 00	 cmp	 BYTE PTR [r13+72], 0
  0149c	75 2b		 jne	 SHORT $LN828@ImFontAtla

; 2608 :     {
; 2609 :         font->ClearOutputData();

  0149e	48 8b ce	 mov	 rcx, rsi
  014a1	e8 00 00 00 00	 call	 ?ClearOutputData@ImFont@@QEAAXXZ ; ImFont::ClearOutputData

; 2610 :         font->FontSize = font_config->SizePixels;

  014a6	41 8b 45 14	 mov	 eax, DWORD PTR [r13+20]
  014aa	89 46 14	 mov	 DWORD PTR [rsi+20], eax

; 2611 :         font->ConfigData = font_config;

  014ad	4c 89 6e 48	 mov	 QWORD PTR [rsi+72], r13

; 2612 :         font->ConfigDataCount = 0;
; 2613 :         font->ContainerAtlas = atlas;

  014b1	48 8b 45 88	 mov	 rax, QWORD PTR atlas$GSCopy$1$[rbp-256]
  014b5	48 89 46 40	 mov	 QWORD PTR [rsi+64], rax

; 2614 :         font->Ascent = ascent;

  014b9	f3 0f 11 76 60	 movss	 DWORD PTR [rsi+96], xmm6

; 2615 :         font->Descent = descent;

  014be	f3 0f 11 7e 64	 movss	 DWORD PTR [rsi+100], xmm7
  014c3	41 0f b7 c7	 movzx	 eax, r15w
  014c7	eb 09		 jmp	 SHORT $LN630@ImFontAtla
$LN828@ImFontAtla:
  014c9	0f b7 46 50	 movzx	 eax, WORD PTR [rsi+80]
  014cd	f3 0f 10 76 60	 movss	 xmm6, DWORD PTR [rsi+96]
$LN630@ImFontAtla:

; 2616 :     }
; 2617 :     font->ConfigDataCount++;

  014d2	66 ff c0	 inc	 ax
  014d5	66 89 46 50	 mov	 WORD PTR [rsi+80], ax

; 2573 :         ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
; 2574 :         const float font_off_x = cfg.GlyphOffset.x;

  014d9	f3 45 0f 10 55
	2c		 movss	 xmm10, DWORD PTR [r13+44]

; 2575 :         const float font_off_y = cfg.GlyphOffset.y + IM_ROUND(dst_font->Ascent);

  014df	f3 41 0f 58 f3	 addss	 xmm6, xmm11
  014e4	f3 0f 2c c6	 cvttss2si eax, xmm6
  014e8	66 44 0f 6e c8	 movd	 xmm9, eax
  014ed	45 0f 5b c9	 cvtdq2ps xmm9, xmm9
  014f1	f3 45 0f 58 4d
	30		 addss	 xmm9, DWORD PTR [r13+48]

; 2576 : 
; 2577 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

  014f7	45 8b f7	 mov	 r14d, r15d
  014fa	83 bb e0 00 00
	00 00		 cmp	 DWORD PTR [rbx+224], 0
  01501	0f 8e 4b 01 00
	00		 jle	 $LN867@ImFontAtla

; 2617 :     font->ConfigDataCount++;

  01507	33 c0		 xor	 eax, eax
  01509	8b f8		 mov	 edi, eax
  0150b	4c 8b 65 88	 mov	 r12, QWORD PTR atlas$GSCopy$1$[rbp-256]
  0150f	90		 npad	 1
$LL49@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  01510	4d 85 ff	 test	 r15, r15
  01513	78 09		 js	 SHORT $LN634@ImFontAtla
  01515	44 3b b3 f8 00
	00 00		 cmp	 r14d, DWORD PTR [rbx+248]
  0151c	7c 1a		 jl	 SHORT $LN635@ImFontAtla
$LN634@ImFontAtla:
  0151e	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  01524	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0152b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  01532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN635@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2580 :             const int codepoint = src_tmp.GlyphsList[glyph_i];

  01538	48 8b 83 00 01
	00 00		 mov	 rax, QWORD PTR [rbx+256]
  0153f	46 8b 04 b8	 mov	 r8d, DWORD PTR [rax+r15*4]

; 2581 :             const stbtt_packedchar& pc = src_tmp.PackedChars[glyph_i];

  01543	48 8b 8b c8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+200]
  0154a	66 41 0f 6e 44
	24 30		 movd	 xmm0, DWORD PTR [r12+48]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 4245 :     float ipw = 1.0f / pw, iph = 1.0f / ph;

  01551	0f 5b c0	 cvtdq2ps xmm0, xmm0
  01554	41 0f 28 d4	 movaps	 xmm2, xmm12
  01558	f3 0f 5e d0	 divss	 xmm2, xmm0
  0155c	66 41 0f 6e 4c
	24 34		 movd	 xmm1, DWORD PTR [r12+52]
  01563	0f 5b c9	 cvtdq2ps xmm1, xmm1
  01566	41 0f 28 c4	 movaps	 xmm0, xmm12
  0156a	f3 0f 5e c1	 divss	 xmm0, xmm1

; 4261 :     }
; 4262 : 
; 4263 :     q->s0 = b->x0 * ipw;

  0156e	0f b7 04 0f	 movzx	 eax, WORD PTR [rdi+rcx]
  01572	66 44 0f 6e c0	 movd	 xmm8, eax
  01577	45 0f 5b c0	 cvtdq2ps xmm8, xmm8
  0157b	f3 44 0f 59 c2	 mulss	 xmm8, xmm2

; 4264 :     q->t0 = b->y0 * iph;

  01580	0f b7 44 0f 02	 movzx	 eax, WORD PTR [rdi+rcx+2]
  01585	66 0f 6e f8	 movd	 xmm7, eax
  01589	0f 5b ff	 cvtdq2ps xmm7, xmm7
  0158c	f3 0f 59 f8	 mulss	 xmm7, xmm0

; 4265 :     q->s1 = b->x1 * ipw;

  01590	0f b7 44 0f 04	 movzx	 eax, WORD PTR [rdi+rcx+4]
  01595	66 0f 6e f0	 movd	 xmm6, eax
  01599	0f 5b f6	 cvtdq2ps xmm6, xmm6
  0159c	f3 0f 59 f2	 mulss	 xmm6, xmm2

; 4266 :     q->t1 = b->y1 * iph;

  015a0	0f b7 44 0f 06	 movzx	 eax, WORD PTR [rdi+rcx+6]
  015a5	66 0f 6e e0	 movd	 xmm4, eax
  015a9	0f 5b e4	 cvtdq2ps xmm4, xmm4
  015ac	f3 0f 59 e0	 mulss	 xmm4, xmm0

; 4260 :         q->y1 = *ypos + b->yoff2;

  015b0	f3 0f 10 6c 0f
	18		 movss	 xmm5, DWORD PTR [rdi+rcx+24]
  015b6	f3 41 0f 58 ed	 addss	 xmm5, xmm13
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2585 :             dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);

  015bb	f3 41 0f 58 e9	 addss	 xmm5, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 4259 :         q->x1 = *xpos + b->xoff2;

  015c0	f3 0f 10 54 0f
	14		 movss	 xmm2, DWORD PTR [rdi+rcx+20]
  015c6	f3 41 0f 58 d5	 addss	 xmm2, xmm13
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2585 :             dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);

  015cb	f3 41 0f 58 d2	 addss	 xmm2, xmm10
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 4258 :         q->y0 = *ypos + b->yoff;

  015d0	f3 0f 10 4c 0f
	0c		 movss	 xmm1, DWORD PTR [rdi+rcx+12]
  015d6	f3 41 0f 58 cd	 addss	 xmm1, xmm13
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2585 :             dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);

  015db	f3 41 0f 58 c9	 addss	 xmm1, xmm9
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imstb_truetype.h

; 4257 :         q->x0 = *xpos + b->xoff;

  015e0	f3 0f 10 5c 0f
	08		 movss	 xmm3, DWORD PTR [rdi+rcx+8]
  015e6	f3 41 0f 58 dd	 addss	 xmm3, xmm13
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2585 :             dst_font->AddGlyph(&cfg, (ImWchar)codepoint, q.x0 + font_off_x, q.y0 + font_off_y, q.x1 + font_off_x, q.y1 + font_off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);

  015eb	f3 41 0f 58 da	 addss	 xmm3, xmm10
  015f0	f3 0f 10 44 0f
	10		 movss	 xmm0, DWORD PTR [rdi+rcx+16]
  015f6	f3 0f 11 44 24
	58		 movss	 DWORD PTR [rsp+88], xmm0
  015fc	f3 0f 11 64 24
	50		 movss	 DWORD PTR [rsp+80], xmm4
  01602	f3 0f 11 74 24
	48		 movss	 DWORD PTR [rsp+72], xmm6
  01608	f3 0f 11 7c 24
	40		 movss	 DWORD PTR [rsp+64], xmm7
  0160e	f3 44 0f 11 44
	24 38		 movss	 DWORD PTR [rsp+56], xmm8
  01615	f3 0f 11 6c 24
	30		 movss	 DWORD PTR [rsp+48], xmm5
  0161b	f3 0f 11 54 24
	28		 movss	 DWORD PTR [rsp+40], xmm2
  01621	f3 0f 11 4c 24
	20		 movss	 DWORD PTR [rsp+32], xmm1
  01627	49 8b d5	 mov	 rdx, r13
  0162a	48 8b ce	 mov	 rcx, rsi
  0162d	e8 00 00 00 00	 call	 ?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z ; ImFont::AddGlyph

; 2576 : 
; 2577 :         for (int glyph_i = 0; glyph_i < src_tmp.GlyphsCount; glyph_i++)

  01632	41 ff c6	 inc	 r14d
  01635	49 ff c7	 inc	 r15
  01638	48 83 c7 1c	 add	 rdi, 28
  0163c	44 3b b3 e0 00
	00 00		 cmp	 r14d, DWORD PTR [rbx+224]
  01643	0f 8c c7 fe ff
	ff		 jl	 $LL49@ImFontAtla
  01649	44 8b 64 24 70	 mov	 r12d, DWORD PTR src_i$1$[rsp]
  0164e	48 8b 7d b0	 mov	 rdi, QWORD PTR tv8055[rbp-256]
$LN867@ImFontAtla:

; 2555 :     for (int src_i = 0; src_i < src_tmp_array.Size; src_i++)

  01652	45 33 ff	 xor	 r15d, r15d
  01655	8b 74 24 60	 mov	 esi, DWORD PTR src_tmp_array$2$[rsp]
  01659	48 8b 45 80	 mov	 rax, QWORD PTR $T5[rbp-256]
$LN44@ImFontAtla:
  0165d	41 ff c4	 inc	 r12d
  01660	44 89 64 24 70	 mov	 DWORD PTR src_i$1$[rsp], r12d
  01665	48 ff c0	 inc	 rax
  01668	48 89 45 80	 mov	 QWORD PTR $T5[rbp-256], rax
  0166c	48 81 c3 10 01
	00 00		 add	 rbx, 272		; 00000110H
  01673	48 81 c7 88 00
	00 00		 add	 rdi, 136		; 00000088H
  0167a	48 89 7d b0	 mov	 QWORD PTR tv8055[rbp-256], rdi
  0167e	44 3b e6	 cmp	 r12d, esi
  01681	0f 8c ef fc ff
	ff		 jl	 $LL46@ImFontAtla

; 2615 :         font->Descent = descent;

  01687	48 8b 5c 24 78	 mov	 rbx, QWORD PTR src_tmp_array$1$[rsp]
  0168c	48 81 c3 f8 00
	00 00		 add	 rbx, 248		; 000000f8H
  01693	8b fe		 mov	 edi, esi
$LL651@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  01695	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  01699	48 85 c9	 test	 rcx, rcx
  0169c	74 19		 je	 SHORT $LN667@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0169e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  016a5	48 85 c0	 test	 rax, rax
  016a8	74 06		 je	 SHORT $LN665@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  016aa	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN665@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  016b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  016b6	90		 npad	 1
$LN667@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  016b7	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  016ba	48 85 c9	 test	 rcx, rcx
  016bd	74 19		 je	 SHORT $LN682@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  016bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  016c6	48 85 c0	 test	 rax, rax
  016c9	74 06		 je	 SHORT $LN680@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  016cb	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN680@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  016d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  016d7	90		 npad	 1
$LN682@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1787 :     inline void         clear_destruct() { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.

  016d8	48 81 c3 10 01
	00 00		 add	 rbx, 272		; 00000110H
  016df	48 83 ef 01	 sub	 rdi, 1
  016e3	75 b0		 jne	 SHORT $LL651@ImFontAtla
$LN650@ImFontAtla:

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  016e5	48 8b 7c 24 78	 mov	 rdi, QWORD PTR src_tmp_array$1$[rsp]
  016ea	48 85 ff	 test	 rdi, rdi
  016ed	74 2c		 je	 SHORT $LN687@ImFontAtla
  016ef	48 c7 45 e8 00
	00 00 00	 mov	 QWORD PTR src_tmp_array$[rbp-256], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  016f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  016fe	48 85 c0	 test	 rax, rax
  01701	74 06		 je	 SHORT $LN691@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  01703	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN691@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  01709	48 8b cf	 mov	 rcx, rdi
  0170c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  01712	4c 89 7c 24 78	 mov	 QWORD PTR src_tmp_array$1$[rsp], r15
  01717	4c 89 7d f0	 mov	 QWORD PTR src_tmp_array$[rbp-248], r15
$LN687@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2592 :     ImFontAtlasBuildFinish(atlas);

  0171b	48 8b 4d 88	 mov	 rcx, QWORD PTR atlas$GSCopy$1$[rbp-256]
  0171f	e8 00 00 00 00	 call	 ?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildFinish

; 2593 :     return true;

  01724	b3 01		 mov	 bl, 1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  01726	48 8b 4d a8	 mov	 rcx, QWORD PTR buf_packedchars$1$[rbp-256]
  0172a	48 85 c9	 test	 rcx, rcx
  0172d	74 19		 je	 SHORT $LN705@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0172f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  01736	48 85 c0	 test	 rax, rax
  01739	74 06		 je	 SHORT $LN703@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0173b	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN703@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  01741	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  01747	90		 npad	 1
$LN705@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  01748	48 8b 4d c0	 mov	 rcx, QWORD PTR buf_rects$1$[rbp-256]
  0174c	48 85 c9	 test	 rcx, rcx
  0174f	74 19		 je	 SHORT $LN717@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  01751	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  01758	48 85 c0	 test	 rax, rax
  0175b	74 06		 je	 SHORT $LN715@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0175d	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN715@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  01763	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  01769	90		 npad	 1
$LN717@ImFontAtla:
$LN711@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0176a	48 8b 4d 90	 mov	 rcx, QWORD PTR dst_tmp_array$1$[rbp-256]
  0176e	48 85 c9	 test	 rcx, rcx
  01771	74 19		 je	 SHORT $LN729@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  01773	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0177a	48 85 c0	 test	 rax, rax
  0177d	74 06		 je	 SHORT $LN727@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0177f	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN727@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  01785	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0178b	90		 npad	 1
$LN729@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0178c	48 8b 44 24 78	 mov	 rax, QWORD PTR src_tmp_array$1$[rsp]
  01791	48 85 c0	 test	 rax, rax
  01794	74 1c		 je	 SHORT $LN864@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  01796	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0179d	48 85 c9	 test	 rcx, rcx
  017a0	74 06		 je	 SHORT $LN739@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  017a2	ff 89 ec 00 00
	00		 dec	 DWORD PTR [rcx+236]
$LN739@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  017a8	48 8b c8	 mov	 rcx, rax
  017ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  017b1	90		 npad	 1
$LN864@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2594 : }

  017b2	0f b6 c3	 movzx	 eax, bl
  017b5	48 8b 8d 90 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  017bc	48 33 cc	 xor	 rcx, rsp
  017bf	e8 00 00 00 00	 call	 __security_check_cookie
  017c4	4c 8d 9c 24 20
	03 00 00	 lea	 r11, QWORD PTR [rsp+800]
  017cc	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  017d0	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  017d4	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  017d8	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  017dd	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  017e2	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  017e7	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  017ec	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  017f1	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  017f6	45 0f 28 63 90	 movaps	 xmm12, XMMWORD PTR [r11-112]
  017fb	45 0f 28 6b 80	 movaps	 xmm13, XMMWORD PTR [r11-128]
  01800	49 8b e3	 mov	 rsp, r11
  01803	41 5f		 pop	 r15
  01805	41 5e		 pop	 r14
  01807	41 5d		 pop	 r13
  01809	41 5c		 pop	 r12
  0180b	5d		 pop	 rbp
  0180c	c3		 ret	 0
?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildWithStbTruetype
_TEXT	ENDS
text$x	SEGMENT
src_tmp_array$2$ = 96
new_size$1$ = 100
buf_packedchars_out_n$1$ = 100
total_surface$1$ = 104
src_i$1$ = 104
src_i$1$ = 104
total_glyphs_count$2$ = 108
src_i$1$ = 112
src_i$1$ = 112
src_tmp_array$1$ = 120
$T4 = 128
$T5 = 128
padding$1$ = 128
atlas$GSCopy$1$ = 136
dst_tmp_array$1$ = 144
buf_rects_out_n$1$ = 152
$T6 = 160
$T7 = 168
buf_packedchars$1$ = 168
it_end$1$ = 176
tv8082 = 176
tv8055 = 176
glyph_i$1$ = 184
buf_rects$1$ = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
$T8 = 248
buf_packedchars$ = 256
spc$ = 272
c$9 = 336
multiply_table$10 = 400
__$ArrayPad$ = 656
atlas$ = 848
?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$0
  00000	48 8d 8a e8 00
	00 00		 lea	 rcx, QWORD PTR src_tmp_array$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$0
src_tmp_array$2$ = 96
new_size$1$ = 100
buf_packedchars_out_n$1$ = 100
total_surface$1$ = 104
src_i$1$ = 104
src_i$1$ = 104
total_glyphs_count$2$ = 108
src_i$1$ = 112
src_i$1$ = 112
src_tmp_array$1$ = 120
$T4 = 128
$T5 = 128
padding$1$ = 128
atlas$GSCopy$1$ = 136
dst_tmp_array$1$ = 144
buf_rects_out_n$1$ = 152
$T6 = 160
$T7 = 168
buf_packedchars$1$ = 168
it_end$1$ = 176
tv8082 = 176
tv8055 = 176
glyph_i$1$ = 184
buf_rects$1$ = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
$T8 = 248
buf_packedchars$ = 256
spc$ = 272
c$9 = 336
multiply_table$10 = 400
__$ArrayPad$ = 656
atlas$ = 848
?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$1
  0000c	48 8d 8a c8 00
	00 00		 lea	 rcx, QWORD PTR dst_tmp_array$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$1
src_tmp_array$2$ = 96
new_size$1$ = 100
buf_packedchars_out_n$1$ = 100
total_surface$1$ = 104
src_i$1$ = 104
src_i$1$ = 104
total_glyphs_count$2$ = 108
src_i$1$ = 112
src_i$1$ = 112
src_tmp_array$1$ = 120
$T4 = 128
$T5 = 128
padding$1$ = 128
atlas$GSCopy$1$ = 136
dst_tmp_array$1$ = 144
buf_rects_out_n$1$ = 152
$T6 = 160
$T7 = 168
buf_packedchars$1$ = 168
it_end$1$ = 176
tv8082 = 176
tv8055 = 176
glyph_i$1$ = 184
buf_rects$1$ = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
$T8 = 248
buf_packedchars$ = 256
spc$ = 272
c$9 = 336
multiply_table$10 = 400
__$ArrayPad$ = 656
atlas$ = 848
?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$2
  00018	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR buf_rects$[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ ; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$2
src_tmp_array$2$ = 96
new_size$1$ = 100
buf_packedchars_out_n$1$ = 100
total_surface$1$ = 104
src_i$1$ = 104
src_i$1$ = 104
total_glyphs_count$2$ = 108
src_i$1$ = 112
src_i$1$ = 112
src_tmp_array$1$ = 120
$T4 = 128
$T5 = 128
padding$1$ = 128
atlas$GSCopy$1$ = 136
dst_tmp_array$1$ = 144
buf_rects_out_n$1$ = 152
$T6 = 160
$T7 = 168
buf_packedchars$1$ = 168
it_end$1$ = 176
tv8082 = 176
tv8055 = 176
glyph_i$1$ = 184
buf_rects$1$ = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
$T8 = 248
buf_packedchars$ = 256
spc$ = 272
c$9 = 336
multiply_table$10 = 400
__$ArrayPad$ = 656
atlas$ = 848
?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$3
  00024	48 8d 8a 00 01
	00 00		 lea	 rcx, QWORD PTR buf_packedchars$[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
src_tmp_array$2$ = 96
new_size$1$ = 100
buf_packedchars_out_n$1$ = 100
total_surface$1$ = 104
src_i$1$ = 104
src_i$1$ = 104
total_glyphs_count$2$ = 108
src_i$1$ = 112
src_i$1$ = 112
src_tmp_array$1$ = 120
$T4 = 128
$T5 = 128
padding$1$ = 128
atlas$GSCopy$1$ = 136
dst_tmp_array$1$ = 144
buf_rects_out_n$1$ = 152
$T6 = 160
$T7 = 168
buf_packedchars$1$ = 168
it_end$1$ = 176
tv8082 = 176
tv8055 = 176
glyph_i$1$ = 184
buf_rects$1$ = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
$T8 = 248
buf_packedchars$ = 256
spc$ = 272
c$9 = 336
multiply_table$10 = 400
__$ArrayPad$ = 656
atlas$ = 848
?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$0
  00000	48 8d 8a e8 00
	00 00		 lea	 rcx, QWORD PTR src_tmp_array$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
?dtor$0@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
src_tmp_array$2$ = 96
new_size$1$ = 100
buf_packedchars_out_n$1$ = 100
total_surface$1$ = 104
src_i$1$ = 104
src_i$1$ = 104
total_glyphs_count$2$ = 108
src_i$1$ = 112
src_i$1$ = 112
src_tmp_array$1$ = 120
$T4 = 128
$T5 = 128
padding$1$ = 128
atlas$GSCopy$1$ = 136
dst_tmp_array$1$ = 144
buf_rects_out_n$1$ = 152
$T6 = 160
$T7 = 168
buf_packedchars$1$ = 168
it_end$1$ = 176
tv8082 = 176
tv8055 = 176
glyph_i$1$ = 184
buf_rects$1$ = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
$T8 = 248
buf_packedchars$ = 256
spc$ = 272
c$9 = 336
multiply_table$10 = 400
__$ArrayPad$ = 656
atlas$ = 848
?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$1
  0000c	48 8d 8a c8 00
	00 00		 lea	 rcx, QWORD PTR dst_tmp_array$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
?dtor$1@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
src_tmp_array$2$ = 96
new_size$1$ = 100
buf_packedchars_out_n$1$ = 100
total_surface$1$ = 104
src_i$1$ = 104
src_i$1$ = 104
total_glyphs_count$2$ = 108
src_i$1$ = 112
src_i$1$ = 112
src_tmp_array$1$ = 120
$T4 = 128
$T5 = 128
padding$1$ = 128
atlas$GSCopy$1$ = 136
dst_tmp_array$1$ = 144
buf_rects_out_n$1$ = 152
$T6 = 160
$T7 = 168
buf_packedchars$1$ = 168
it_end$1$ = 176
tv8082 = 176
tv8055 = 176
glyph_i$1$ = 184
buf_rects$1$ = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
$T8 = 248
buf_packedchars$ = 256
spc$ = 272
c$9 = 336
multiply_table$10 = 400
__$ArrayPad$ = 656
atlas$ = 848
?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$2
  00018	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR buf_rects$[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ ; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
?dtor$2@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
src_tmp_array$2$ = 96
new_size$1$ = 100
buf_packedchars_out_n$1$ = 100
total_surface$1$ = 104
src_i$1$ = 104
src_i$1$ = 104
total_glyphs_count$2$ = 108
src_i$1$ = 112
src_i$1$ = 112
src_tmp_array$1$ = 120
$T4 = 128
$T5 = 128
padding$1$ = 128
atlas$GSCopy$1$ = 136
dst_tmp_array$1$ = 144
buf_rects_out_n$1$ = 152
$T6 = 160
$T7 = 168
buf_packedchars$1$ = 168
it_end$1$ = 176
tv8082 = 176
tv8055 = 176
glyph_i$1$ = 184
buf_rects$1$ = 192
dst_tmp_array$ = 200
buf_rects$ = 216
src_tmp_array$ = 232
$T8 = 248
buf_packedchars$ = 256
spc$ = 272
c$9 = 336
multiply_table$10 = 400
__$ArrayPad$ = 656
atlas$ = 848
?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA PROC ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$3
  00024	48 8d 8a 00 01
	00 00		 lea	 rcx, QWORD PTR buf_packedchars$[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
?dtor$3@?0??ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z@4HA ENDP ; `ImFontAtlasBuildWithStbTruetype'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
?ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ PROC ; ImFontAtlasGetBuilderForStbTruetype

; 2598 :     static ImFontBuilderIO io;
; 2599 :     io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?ImFontAtlasBuildWithStbTruetype@@YA_NPEAUImFontAtlas@@@Z ; ImFontAtlasBuildWithStbTruetype
  00007	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A, rax

; 2600 :     return &io;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?io@?1??ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ@4U2@A

; 2601 : }

  00015	c3		 ret	 0
?ImFontAtlasGetBuilderForStbTruetype@@YAPEBUImFontBuilderIO@@XZ ENDP ; ImFontAtlasGetBuilderForStbTruetype
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
atlas$ = 64
font$ = 72
font_config$ = 80
ascent$ = 88
descent$ = 96
?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z PROC ; ImFontAtlasBuildSetupFont

; 2606 : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2607 :     if (!font_config->MergeMode)

  0000f	41 80 78 48 00	 cmp	 BYTE PTR [r8+72], 0
  00014	49 8b f8	 mov	 rdi, r8
  00017	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0001c	48 8b da	 mov	 rbx, rdx
  0001f	0f 28 f3	 movaps	 xmm6, xmm3
  00022	48 8b f1	 mov	 rsi, rcx
  00025	75 2a		 jne	 SHORT $LN4@ImFontAtla

; 2608 :     {
; 2609 :         font->ClearOutputData();

  00027	48 8b ca	 mov	 rcx, rdx
  0002a	e8 00 00 00 00	 call	 ?ClearOutputData@ImFont@@QEAAXXZ ; ImFont::ClearOutputData

; 2610 :         font->FontSize = font_config->SizePixels;

  0002f	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]

; 2611 :         font->ConfigData = font_config;
; 2612 :         font->ConfigDataCount = 0;
; 2613 :         font->ContainerAtlas = atlas;
; 2614 :         font->Ascent = ascent;
; 2615 :         font->Descent = descent;

  00032	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR descent$[rsp]
  00038	89 43 14	 mov	 DWORD PTR [rbx+20], eax
  0003b	33 c0		 xor	 eax, eax
  0003d	f3 0f 11 43 64	 movss	 DWORD PTR [rbx+100], xmm0
  00042	f3 0f 11 73 60	 movss	 DWORD PTR [rbx+96], xmm6
  00047	48 89 7b 48	 mov	 QWORD PTR [rbx+72], rdi
  0004b	48 89 73 40	 mov	 QWORD PTR [rbx+64], rsi
  0004f	eb 04		 jmp	 SHORT $LN2@ImFontAtla
$LN4@ImFontAtla:
  00051	0f b7 42 50	 movzx	 eax, WORD PTR [rdx+80]
$LN2@ImFontAtla:

; 2616 :     }
; 2617 :     font->ConfigDataCount++;
; 2618 : }

  00055	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0005a	66 ff c0	 inc	 ax
  0005d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00062	66 89 43 50	 mov	 WORD PTR [rbx+80], ax
  00066	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
?ImFontAtlasBuildSetupFont@@YAXPEAUImFontAtlas@@PEAUImFont@@PEAUImFontConfig@@MM@Z ENDP ; ImFontAtlasBuildSetupFont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
pack_rects$ = 32
pack_rects$1$ = 112
atlas$ = 112
tv1354 = 120
stbrp_context_opaque$ = 120
?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z PROC ; ImFontAtlasBuildPackCustomRects

; 2621 : {

$LN151:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fa	 mov	 rdi, rdx
  0001c	48 8b f1	 mov	 rsi, rcx

; 2622 :     stbrp_context* pack_context = (stbrp_context*)stbrp_context_opaque;
; 2623 :     IM_ASSERT(pack_context != NULL);

  0001f	48 85 d2	 test	 rdx, rdx
  00022	75 1a		 jne	 SHORT $LN10@ImFontAtla
  00024	41 b8 3f 0a 00
	00		 mov	 r8d, 2623		; 00000a3fH
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@FMMHMDCM@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?5?$AA?$CB?$AA?$DN@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN10@ImFontAtla:

; 2624 : 
; 2625 :     ImVector<ImFontAtlasCustomRect>& user_rects = atlas->CustomRects;
; 2626 :     IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.

  0003e	44 8b 6e 58	 mov	 r13d, DWORD PTR [rsi+88]
  00042	41 83 fd 01	 cmp	 r13d, 1
  00046	7d 1e		 jge	 SHORT $LN11@ImFontAtla
  00048	41 b8 42 0a 00
	00		 mov	 r8d, 2626		; 00000a42H
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@POMOOFJC@?$AAu?$AAs?$AAe?$AAr?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe@
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00062	44 8b 6e 58	 mov	 r13d, DWORD PTR [rsi+88]
$LN11@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00066	33 ed		 xor	 ebp, ebp
  00068	44 8b e5	 mov	 r12d, ebp
  0006b	48 89 6c 24 70	 mov	 QWORD PTR pack_rects$1$[rsp], rbp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2629 :     pack_rects.resize(user_rects.Size);

  00070	45 85 ed	 test	 r13d, r13d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00073	7e 39		 jle	 SHORT $LN24@ImFontAtla

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00075	41 8b c5	 mov	 eax, r13d
  00078	b9 08 00 00 00	 mov	 ecx, 8
  0007d	44 3b e9	 cmp	 r13d, ecx
  00080	0f 4c c1	 cmovl	 eax, ecx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00083	85 c0		 test	 eax, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00085	7e 27		 jle	 SHORT $LN24@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0008e	48 85 c9	 test	 rcx, rcx
  00091	74 06		 je	 SHORT $LN29@ImFontAtla

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00093	ff 81 ec 00 00
	00		 inc	 DWORD PTR [rcx+236]
$LN29@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00099	48 63 c8	 movsxd	 rcx, eax
  0009c	48 c1 e1 04	 shl	 rcx, 4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000a6	4c 8b e0	 mov	 r12, rax
  000a9	48 89 44 24 70	 mov	 QWORD PTR pack_rects$1$[rsp], rax
$LN24@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2630 :     memset(pack_rects.Data, 0, (size_t)pack_rects.size_in_bytes());

  000ae	41 8b cd	 mov	 ecx, r13d
  000b1	c1 e1 04	 shl	 ecx, 4
  000b4	4c 63 c1	 movsxd	 r8, ecx
  000b7	33 d2		 xor	 edx, edx
  000b9	49 8b cc	 mov	 rcx, r12
  000bc	e8 00 00 00 00	 call	 memset

; 2631 :     for (int i = 0; i < user_rects.Size; i++)

  000c1	8b dd		 mov	 ebx, ebp
  000c3	8b 4e 58	 mov	 ecx, DWORD PTR [rsi+88]
  000c6	85 c9		 test	 ecx, ecx
  000c8	0f 8e df 00 00
	00		 jle	 $LN3@ImFontAtla
  000ce	48 8b fd	 mov	 rdi, rbp
  000d1	4c 8b f5	 mov	 r14, rbp
  000d4	4d 8d 7c 24 06	 lea	 r15, QWORD PTR [r12+6]
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  000e0	48 85 ff	 test	 rdi, rdi
  000e3	78 04		 js	 SHORT $LN47@ImFontAtla
  000e5	3b d9		 cmp	 ebx, ecx
  000e7	7c 1a		 jl	 SHORT $LN48@ImFontAtla
$LN47@ImFontAtla:
  000e9	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN48@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2633 :         pack_rects[i].w = user_rects[i].Width;

  00103	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  00107	45 0f b7 24 06	 movzx	 r12d, WORD PTR [r14+rax]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  0010c	48 85 ff	 test	 rdi, rdi
  0010f	78 05		 js	 SHORT $LN51@ImFontAtla
  00111	41 3b dd	 cmp	 ebx, r13d
  00114	7c 1a		 jl	 SHORT $LN52@ImFontAtla
$LN51@ImFontAtla:
  00116	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN52@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2633 :         pack_rects[i].w = user_rects[i].Width;

  00130	66 45 89 67 fe	 mov	 WORD PTR [r15-2], r12w
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00135	48 85 ff	 test	 rdi, rdi
  00138	78 05		 js	 SHORT $LN55@ImFontAtla
  0013a	3b 5e 58	 cmp	 ebx, DWORD PTR [rsi+88]
  0013d	7c 1a		 jl	 SHORT $LN56@ImFontAtla
$LN55@ImFontAtla:
  0013f	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN56@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2634 :         pack_rects[i].h = user_rects[i].Height;

  00159	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  0015d	45 0f b7 64 06
	02		 movzx	 r12d, WORD PTR [r14+rax+2]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00163	48 85 ff	 test	 rdi, rdi
  00166	78 05		 js	 SHORT $LN59@ImFontAtla
  00168	41 3b dd	 cmp	 ebx, r13d
  0016b	7c 1a		 jl	 SHORT $LN60@ImFontAtla
$LN59@ImFontAtla:
  0016d	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00173	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN60@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2634 :         pack_rects[i].h = user_rects[i].Height;

  00187	66 45 89 27	 mov	 WORD PTR [r15], r12w

; 2631 :     for (int i = 0; i < user_rects.Size; i++)

  0018b	ff c3		 inc	 ebx
  0018d	48 ff c7	 inc	 rdi
  00190	49 83 c6 20	 add	 r14, 32			; 00000020H
  00194	49 83 c7 10	 add	 r15, 16
  00198	8b 4e 58	 mov	 ecx, DWORD PTR [rsi+88]
  0019b	3b d9		 cmp	 ebx, ecx
  0019d	0f 8c 3d ff ff
	ff		 jl	 $LL4@ImFontAtla
  001a3	48 8b 7c 24 78	 mov	 rdi, QWORD PTR stbrp_context_opaque$[rsp]
  001a8	4c 8b 64 24 70	 mov	 r12, QWORD PTR pack_rects$1$[rsp]
$LN3@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  001ad	45 85 ed	 test	 r13d, r13d
  001b0	7f 2d		 jg	 SHORT $LN64@ImFontAtla
  001b2	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  001b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001cc	45 8b c5	 mov	 r8d, r13d
  001cf	49 8b d4	 mov	 rdx, r12
  001d2	48 8b cf	 mov	 rcx, rdi
  001d5	e8 00 00 00 00	 call	 stbrp_pack_rects
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2642 :             IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);

  001da	e9 49 01 00 00	 jmp	 $LN6@ImFontAtla
$LN64@ImFontAtla:

; 2635 :     }
; 2636 :     stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);

  001df	45 8b c5	 mov	 r8d, r13d
  001e2	49 8b d4	 mov	 rdx, r12
  001e5	48 8b cf	 mov	 rcx, rdi
  001e8	e8 00 00 00 00	 call	 stbrp_pack_rects
  001ed	4c 8b fd	 mov	 r15, rbp
  001f0	4d 8d 74 24 08	 lea	 r14, QWORD PTR [r12+8]
$LL7@ImFontAtla:

; 2638 :         if (pack_rects[i].was_packed)

  001f5	41 83 7e 04 00	 cmp	 DWORD PTR [r14+4], 0
  001fa	0f 84 10 01 00
	00		 je	 $LN5@ImFontAtla

; 2640 :             user_rects[i].X = pack_rects[i].x;

  00200	41 0f b7 1e	 movzx	 ebx, WORD PTR [r14]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00204	3b 6e 58	 cmp	 ebp, DWORD PTR [rsi+88]
  00207	7c 2c		 jl	 SHORT $LN76@ImFontAtla
  00209	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0020f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00223	48 8d 7e 60	 lea	 rdi, QWORD PTR [rsi+96]
  00227	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0022a	66 42 89 5c 38
	04		 mov	 WORD PTR [rax+r15+4], bx
  00230	4c 8b e7	 mov	 r12, rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2642 :             IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);

  00233	eb 11		 jmp	 SHORT $LN147@ImFontAtla
$LN76@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00235	4c 8d 66 60	 lea	 r12, QWORD PTR [rsi+96]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2640 :             user_rects[i].X = pack_rects[i].x;

  00239	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0023d	66 41 89 5c 07
	04		 mov	 WORD PTR [r15+rax+4], bx

; 2641 :             user_rects[i].Y = pack_rects[i].y;

  00243	49 8b fc	 mov	 rdi, r12
$LN147@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00246	49 8d 5e 02	 lea	 rbx, QWORD PTR [r14+2]
  0024a	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0024d	66 89 4c 24 78	 mov	 WORD PTR tv1354[rsp], cx
  00252	3b 6e 58	 cmp	 ebp, DWORD PTR [rsi+88]
  00255	7c 25		 jl	 SHORT $LN84@ImFontAtla
  00257	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0025d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0026b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00271	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00275	0f b7 4c 24 78	 movzx	 ecx, WORD PTR tv1354[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2642 :             IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);

  0027a	eb 03		 jmp	 SHORT $LN148@ImFontAtla
$LN84@ImFontAtla:

; 2641 :             user_rects[i].Y = pack_rects[i].y;

  0027c	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN148@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  0027f	66 41 89 4c 07
	06		 mov	 WORD PTR [r15+rax+6], cx
  00285	3b 6e 58	 cmp	 ebp, DWORD PTR [rsi+88]
  00288	7c 1a		 jl	 SHORT $LN92@ImFontAtla
  0028a	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00290	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00297	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN92@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2642 :             IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);

  002a4	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  002a7	41 0f b7 0c 07	 movzx	 ecx, WORD PTR [r15+rax]
  002ac	66 41 39 4e fc	 cmp	 WORD PTR [r14-4], cx
  002b1	75 2f		 jne	 SHORT $LN137@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  002b3	3b 6e 58	 cmp	 ebp, DWORD PTR [rsi+88]
  002b6	7c 1a		 jl	 SHORT $LN100@ImFontAtla
  002b8	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  002be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  002c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN100@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2642 :             IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);

  002d2	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  002d5	41 0f b7 4c 07
	02		 movzx	 ecx, WORD PTR [r15+rax+2]
  002db	66 41 39 4e fe	 cmp	 WORD PTR [r14-2], cx
  002e0	74 1a		 je	 SHORT $LN108@ImFontAtla
$LN137@ImFontAtla:
  002e2	41 b8 52 0a 00
	00		 mov	 r8d, 2642		; 00000a52H
  002e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  002ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KE@CBAIECN@?$AAp?$AAa?$AAc?$AAk?$AA_?$AAr?$AAe?$AAc?$AAt?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAw@
  002f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN108@ImFontAtla:

; 2643 :             atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);

  002fc	41 0f b7 4e fe	 movzx	 ecx, WORD PTR [r14-2]
  00301	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00304	03 c8		 add	 ecx, eax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  00306	39 4e 34	 cmp	 DWORD PTR [rsi+52], ecx
  00309	0f 4d 4e 34	 cmovge	 ecx, DWORD PTR [rsi+52]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2643 :             atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);

  0030d	89 4e 34	 mov	 DWORD PTR [rsi+52], ecx
$LN5@ImFontAtla:

; 2637 :     for (int i = 0; i < pack_rects.Size; i++)

  00310	ff c5		 inc	 ebp
  00312	49 83 c7 20	 add	 r15, 32			; 00000020H
  00316	49 83 c6 10	 add	 r14, 16
  0031a	41 3b ed	 cmp	 ebp, r13d
  0031d	0f 8c d2 fe ff
	ff		 jl	 $LL7@ImFontAtla
  00323	4c 8b 64 24 70	 mov	 r12, QWORD PTR pack_rects$1$[rsp]
$LN6@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00328	4d 85 e4	 test	 r12, r12
  0032b	74 1c		 je	 SHORT $LN146@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0032d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00334	48 85 c0	 test	 rax, rax
  00337	74 06		 je	 SHORT $LN117@ImFontAtla

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00339	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN117@ImFontAtla:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0033f	49 8b cc	 mov	 rcx, r12
  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00348	90		 npad	 1
$LN146@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2645 : }

  00349	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00351	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00355	41 5f		 pop	 r15
  00357	41 5e		 pop	 r14
  00359	41 5d		 pop	 r13
  0035b	41 5c		 pop	 r12
  0035d	5f		 pop	 rdi
  0035e	5e		 pop	 rsi
  0035f	5d		 pop	 rbp
  00360	c3		 ret	 0
?ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z ENDP ; ImFontAtlasBuildPackCustomRects
_TEXT	ENDS
text$x	SEGMENT
pack_rects$ = 32
pack_rects$1$ = 112
atlas$ = 112
tv1354 = 120
stbrp_context_opaque$ = 120
?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA PROC ; `ImFontAtlasBuildPackCustomRects'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR pack_rects$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ ; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA ENDP ; `ImFontAtlasBuildPackCustomRects'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
pack_rects$ = 32
pack_rects$1$ = 112
atlas$ = 112
tv1354 = 120
stbrp_context_opaque$ = 120
?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA PROC ; `ImFontAtlasBuildPackCustomRects'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR pack_rects$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ ; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
?dtor$0@?0??ImFontAtlasBuildPackCustomRects@@YAXPEAUImFontAtlas@@PEAX@Z@4HA ENDP ; `ImFontAtlasBuildPackCustomRects'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
atlas$ = 48
x$ = 56
y$ = 64
w$dead$ = 72
h$dead$ = 80
in_str$dead$ = 88
in_marker_char$ = 96
in_marker_pixel_value$dead$ = 104
?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z PROC ; ImFontAtlasBuildRender8bppRectFromString

; 2648 : {

$LN33:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 63 ea	 movsxd	 rbp, edx
  00017	41 8b f8	 mov	 edi, r8d
  0001a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB
  00021	48 8b f1	 mov	 rsi, rcx

; 2649 :     IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);

  00024	85 d2		 test	 edx, edx
  00026	78 08		 js	 SHORT $LN31@ImFontAtla
  00028	8d 45 7a	 lea	 eax, DWORD PTR [rbp+122]
  0002b	3b 41 30	 cmp	 eax, DWORD PTR [rcx+48]
  0002e	7e 1a		 jle	 SHORT $LN10@ImFontAtla
$LN31@ImFontAtla:
  00030	41 b8 59 0a 00
	00		 mov	 r8d, 2649		; 00000a59H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@KOLNNAOF@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AAw@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN10@ImFontAtla:

; 2650 :     IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);

  0004a	85 ff		 test	 edi, edi
  0004c	78 08		 js	 SHORT $LN11@ImFontAtla
  0004e	8d 47 1b	 lea	 eax, DWORD PTR [rdi+27]
  00051	3b 46 34	 cmp	 eax, DWORD PTR [rsi+52]
  00054	7e 1a		 jle	 SHORT $LN12@ImFontAtla
$LN11@ImFontAtla:
  00056	41 b8 5a 0a 00
	00		 mov	 r8d, 2650		; 00000a5aH
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@CHFOHLGN@?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAy?$AA?5?$AA?$CL?$AA?5?$AAh@
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN12@ImFontAtla:

; 2651 :     unsigned char* out_pixel = atlas->TexPixelsAlpha8 + x + (y * atlas->TexWidth);

  00070	0f af 7e 30	 imul	 edi, DWORD PTR [rsi+48]
  00074	44 0f b6 54 24
	60		 movzx	 r10d, BYTE PTR in_marker_char$[rsp]
  0007a	4c 63 cf	 movsxd	 r9, edi
  0007d	4c 03 4e 20	 add	 r9, QWORD PTR [rsi+32]
  00081	4c 03 cd	 add	 r9, rbp
  00084	33 ff		 xor	 edi, edi
  00086	44 8d 5f 1b	 lea	 r11d, QWORD PTR [rdi+27]
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL4@ImFontAtla:

; 2653 :         for (int off_x = 0; off_x < w; off_x++)

  00090	48 8b d3	 mov	 rdx, rbx
  00093	49 8d 41 01	 lea	 rax, QWORD PTR [r9+1]
  00097	49 2b d1	 sub	 rdx, r9
  0009a	41 b8 3d 00 00
	00		 mov	 r8d, 61			; 0000003dH
$LL19@ImFontAtla:

; 2654 :             out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00;

  000a0	44 38 54 02 ff	 cmp	 BYTE PTR [rdx+rax-1], r10b
  000a5	48 8d 40 02	 lea	 rax, QWORD PTR [rax+2]
  000a9	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  000ae	0f 45 cf	 cmovne	 ecx, edi
  000b1	88 48 fd	 mov	 BYTE PTR [rax-3], cl
  000b4	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  000b9	44 38 54 02 fe	 cmp	 BYTE PTR [rdx+rax-2], r10b
  000be	0f 45 cf	 cmovne	 ecx, edi
  000c1	88 48 fe	 mov	 BYTE PTR [rax-2], cl
  000c4	49 83 e8 01	 sub	 r8, 1
  000c8	75 d6		 jne	 SHORT $LL19@ImFontAtla

; 2652 :     for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)

  000ca	48 63 46 30	 movsxd	 rax, DWORD PTR [rsi+48]
  000ce	48 83 c3 7a	 add	 rbx, 122		; 0000007aH
  000d2	4c 03 c8	 add	 r9, rax
  000d5	49 83 eb 01	 sub	 r11, 1
  000d9	75 b5		 jne	 SHORT $LL4@ImFontAtla

; 2655 : }

  000db	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e0	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000e5	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ea	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z ENDP ; ImFontAtlasBuildRender8bppRectFromString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
atlas$ = 48
x$ = 56
y$ = 64
w$dead$ = 72
h$dead$ = 80
in_str$dead$ = 88
in_marker_char$ = 96
in_marker_pixel_value$dead$ = 104
?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z PROC ; ImFontAtlasBuildRender32bppRectFromString

; 2658 : {

$LN29:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 63 ea	 movsxd	 rbp, edx
  00017	41 8b f8	 mov	 edi, r8d
  0001a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS@@3QBDB
  00021	48 8b f1	 mov	 rsi, rcx

; 2659 :     IM_ASSERT(x >= 0 && x + w <= atlas->TexWidth);

  00024	85 d2		 test	 edx, edx
  00026	78 08		 js	 SHORT $LN27@ImFontAtla
  00028	8d 45 7a	 lea	 eax, DWORD PTR [rbp+122]
  0002b	3b 41 30	 cmp	 eax, DWORD PTR [rcx+48]
  0002e	7e 1a		 jle	 SHORT $LN10@ImFontAtla
$LN27@ImFontAtla:
  00030	41 b8 63 0a 00
	00		 mov	 r8d, 2659		; 00000a63H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@KOLNNAOF@?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAx?$AA?5?$AA?$CL?$AA?5?$AAw@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN10@ImFontAtla:

; 2660 :     IM_ASSERT(y >= 0 && y + h <= atlas->TexHeight);

  0004a	85 ff		 test	 edi, edi
  0004c	78 08		 js	 SHORT $LN11@ImFontAtla
  0004e	8d 47 1b	 lea	 eax, DWORD PTR [rdi+27]
  00051	3b 46 34	 cmp	 eax, DWORD PTR [rsi+52]
  00054	7e 1a		 jle	 SHORT $LN12@ImFontAtla
$LN11@ImFontAtla:
  00056	41 b8 64 0a 00
	00		 mov	 r8d, 2660		; 00000a64H
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@CHFOHLGN@?$AAy?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAy?$AA?5?$AA?$CL?$AA?5?$AAh@
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN12@ImFontAtla:

; 2661 :     unsigned int* out_pixel = atlas->TexPixelsRGBA32 + x + (y * atlas->TexWidth);

  00070	0f af 7e 30	 imul	 edi, DWORD PTR [rsi+48]
  00074	41 ba 1b 00 00
	00		 mov	 r10d, 27
  0007a	48 8b 46 28	 mov	 rax, QWORD PTR [rsi+40]
  0007e	41 bb ff ff ff
	ff		 mov	 r11d, -1		; ffffffffH
  00084	44 0f b6 44 24
	60		 movzx	 r8d, BYTE PTR in_marker_char$[rsp]
  0008a	48 63 cf	 movsxd	 rcx, edi
  0008d	48 03 cd	 add	 rcx, rbp
  00090	4c 8d 0c 88	 lea	 r9, QWORD PTR [rax+rcx*4]
  00094	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@ImFontAtla:

; 2663 :         for (int off_x = 0; off_x < w; off_x++)

  000a0	49 8b c9	 mov	 rcx, r9
  000a3	ba 3d 00 00 00	 mov	 edx, 61			; 0000003dH
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL17@ImFontAtla:

; 2664 :             out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : IM_COL32_BLACK_TRANS;

  000b0	33 c0		 xor	 eax, eax
  000b2	48 8d 49 08	 lea	 rcx, QWORD PTR [rcx+8]
  000b6	44 38 03	 cmp	 BYTE PTR [rbx], r8b
  000b9	41 0f 44 c3	 cmove	 eax, r11d
  000bd	89 41 f8	 mov	 DWORD PTR [rcx-8], eax
  000c0	33 c0		 xor	 eax, eax
  000c2	44 38 43 01	 cmp	 BYTE PTR [rbx+1], r8b
  000c6	41 0f 44 c3	 cmove	 eax, r11d
  000ca	48 83 c3 02	 add	 rbx, 2
  000ce	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  000d1	48 83 ea 01	 sub	 rdx, 1
  000d5	75 d9		 jne	 SHORT $LL17@ImFontAtla

; 2662 :     for (int off_y = 0; off_y < h; off_y++, out_pixel += atlas->TexWidth, in_str += w)

  000d7	48 63 46 30	 movsxd	 rax, DWORD PTR [rsi+48]
  000db	4d 8d 0c 81	 lea	 r9, QWORD PTR [r9+rax*4]
  000df	49 83 ea 01	 sub	 r10, 1
  000e3	75 bb		 jne	 SHORT $LL4@ImFontAtla

; 2665 : }

  000e5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ea	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000ef	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000f4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z ENDP ; ImFontAtlasBuildRender32bppRectFromString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
atlas$ = 80
?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildRenderDefaultTexData

; 2668 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2669 :     ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdMouseCursors);

  0000f	48 63 b9 84 04
	00 00		 movsxd	 rdi, DWORD PTR [rcx+1156]
  00016	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2796 :     ImFontAtlasCustomRect* GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }

  00019	85 ff		 test	 edi, edi
  0001b	79 1c		 jns	 SHORT $LN16@ImFontAtla
  0001d	41 b8 ec 0a 00
	00		 mov	 r8d, 2796		; 00000aecH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@HMJJDGFN@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	eb 05		 jmp	 SHORT $LN19@ImFontAtla
$LN16@ImFontAtla:

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00039	3b 79 58	 cmp	 edi, DWORD PTR [rcx+88]
  0003c	7c 1a		 jl	 SHORT $LN20@ImFontAtla
$LN19@ImFontAtla:
  0003e	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN20@ImFontAtla:
  00058	48 c1 e7 05	 shl	 rdi, 5

; 2712 :     bool IsPacked() const { return X != 0xFFFF; }

  0005c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00061	48 03 7b 60	 add	 rdi, QWORD PTR [rbx+96]

; 2712 :     bool IsPacked() const { return X != 0xFFFF; }

  00065	66 39 47 04	 cmp	 WORD PTR [rdi+4], ax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2670 :     IM_ASSERT(r->IsPacked());

  00069	75 1a		 jne	 SHORT $LN9@ImFontAtla
  0006b	41 b8 6e 0a 00
	00		 mov	 r8d, 2670		; 00000a6eH
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@DDBMCGAE@?$AAr?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI?$AA?$CJ@
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN9@ImFontAtla:

; 2671 : 
; 2672 :     const int w = atlas->TexWidth;
; 2673 :     if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

  00085	f6 03 02	 test	 BYTE PTR [rbx], 2
  00088	8b 73 30	 mov	 esi, DWORD PTR [rbx+48]
  0008b	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  0008e	0f 85 82 00 00
	00		 jne	 $LN2@ImFontAtla

; 2674 :     {
; 2675 :         // Render/copy pixels
; 2676 :         IM_ASSERT(r->Width == FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1 && r->Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);

  00094	b9 f5 00 00 00	 mov	 ecx, 245		; 000000f5H
  00099	66 3b c1	 cmp	 ax, cx
  0009c	75 07		 jne	 SHORT $LN10@ImFontAtla
  0009e	66 83 7f 02 1b	 cmp	 WORD PTR [rdi+2], 27
  000a3	74 1a		 je	 SHORT $LN11@ImFontAtla
$LN10@ImFontAtla:
  000a5	41 b8 74 0a 00
	00		 mov	 r8d, 2676		; 00000a74H
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1MA@PDHEAINP@?$AAr?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAN@
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN11@ImFontAtla:

; 2677 :         const int x_for_white = r->X;
; 2678 :         const int x_for_black = r->X + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1;
; 2679 :         if (atlas->TexPixelsAlpha8 != NULL)

  000bf	48 83 7b 20 00	 cmp	 QWORD PTR [rbx+32], 0
  000c4	48 8b cb	 mov	 rcx, rbx
  000c7	0f b7 57 04	 movzx	 edx, WORD PTR [rdi+4]
  000cb	44 0f b7 47 06	 movzx	 r8d, WORD PTR [rdi+6]
  000d0	c6 44 24 30 2e	 mov	 BYTE PTR [rsp+48], 46	; 0000002eH
  000d5	8d 72 7b	 lea	 esi, DWORD PTR [rdx+123]
  000d8	74 1e		 je	 SHORT $LN4@ImFontAtla

; 2680 :         {
; 2681 :             ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', 0xFF);

  000da	e8 00 00 00 00	 call	 ?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z ; ImFontAtlasBuildRender8bppRectFromString

; 2682 :             ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', 0xFF);

  000df	44 0f b7 47 06	 movzx	 r8d, WORD PTR [rdi+6]
  000e4	8b d6		 mov	 edx, esi
  000e6	48 8b cb	 mov	 rcx, rbx
  000e9	c6 44 24 30 58	 mov	 BYTE PTR [rsp+48], 88	; 00000058H
  000ee	e8 00 00 00 00	 call	 ?ImFontAtlasBuildRender8bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDE@Z ; ImFontAtlasBuildRender8bppRectFromString

; 2683 :         }

  000f3	e9 b6 00 00 00	 jmp	 $LN7@ImFontAtla
$LN4@ImFontAtla:

; 2684 :         else
; 2685 :         {
; 2686 :             ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, '.', IM_COL32_WHITE);

  000f8	e8 00 00 00 00	 call	 ?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z ; ImFontAtlasBuildRender32bppRectFromString

; 2687 :             ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, r->Y, FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS, 'X', IM_COL32_WHITE);

  000fd	44 0f b7 47 06	 movzx	 r8d, WORD PTR [rdi+6]
  00102	8b d6		 mov	 edx, esi
  00104	48 8b cb	 mov	 rcx, rbx
  00107	c6 44 24 30 58	 mov	 BYTE PTR [rsp+48], 88	; 00000058H
  0010c	e8 00 00 00 00	 call	 ?ImFontAtlasBuildRender32bppRectFromString@@YAXPEAUImFontAtlas@@HHHHPEBDDI@Z ; ImFontAtlasBuildRender32bppRectFromString

; 2688 :         }
; 2689 :     }

  00111	e9 98 00 00 00	 jmp	 $LN7@ImFontAtla
$LN2@ImFontAtla:

; 2690 :     else
; 2691 :     {
; 2692 :         // Render 4 white pixels
; 2693 :         IM_ASSERT(r->Width == 2 && r->Height == 2);

  00116	66 83 f8 02	 cmp	 ax, 2
  0011a	75 06		 jne	 SHORT $LN12@ImFontAtla
  0011c	66 39 47 02	 cmp	 WORD PTR [rdi+2], ax
  00120	74 1a		 je	 SHORT $LN13@ImFontAtla
$LN12@ImFontAtla:
  00122	41 b8 85 0a 00
	00		 mov	 r8d, 2693		; 00000a85H
  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@DBHHBIED@?$AAr?$AA?9?$AA?$DO?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?5?$AA?$CG@
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN13@ImFontAtla:

; 2694 :         const int offset = (int)r->X + (int)r->Y * w;

  0013c	0f b7 47 04	 movzx	 eax, WORD PTR [rdi+4]
  00140	0f b7 57 06	 movzx	 edx, WORD PTR [rdi+6]

; 2695 :         if (atlas->TexPixelsAlpha8 != NULL)

  00144	4c 8b 4b 20	 mov	 r9, QWORD PTR [rbx+32]
  00148	0f af d6	 imul	 edx, esi
  0014b	03 d0		 add	 edx, eax
  0014d	4c 63 c2	 movsxd	 r8, edx
  00150	8d 04 32	 lea	 eax, DWORD PTR [rdx+rsi]
  00153	48 63 c8	 movsxd	 rcx, eax
  00156	4d 85 c9	 test	 r9, r9
  00159	74 23		 je	 SHORT $LN6@ImFontAtla

; 2696 :         {
; 2697 :             atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;

  0015b	42 c6 44 09 01
	ff		 mov	 BYTE PTR [rcx+r9+1], 255 ; 000000ffH
  00161	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00165	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00169	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0016d	41 c6 44 00 01
	ff		 mov	 BYTE PTR [r8+rax+1], 255 ; 000000ffH
  00173	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00177	41 c6 04 00 ff	 mov	 BYTE PTR [r8+rax], 255	; 000000ffH

; 2698 :         }

  0017c	eb 30		 jmp	 SHORT $LN7@ImFontAtla
$LN6@ImFontAtla:

; 2699 :         else
; 2700 :         {
; 2701 :             atlas->TexPixelsRGBA32[offset] = atlas->TexPixelsRGBA32[offset + 1] = atlas->TexPixelsRGBA32[offset + w] = atlas->TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE;

  0017e	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00182	c7 44 88 04 ff
	ff ff ff	 mov	 DWORD PTR [rax+rcx*4+4], -1 ; ffffffffH
  0018a	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  0018e	c7 04 88 ff ff
	ff ff		 mov	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  00195	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00199	42 c7 44 80 04
	ff ff ff ff	 mov	 DWORD PTR [rax+r8*4+4], -1 ; ffffffffH
  001a2	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  001a6	42 c7 04 80 ff
	ff ff ff	 mov	 DWORD PTR [rax+r8*4], -1 ; ffffffffH
$LN7@ImFontAtla:

; 2702 :         }
; 2703 :     }
; 2704 :     atlas->TexUvWhitePixel = ImVec2((r->X + 0.5f) * atlas->TexUvScale.x, (r->Y + 0.5f) * atlas->TexUvScale.y);

  001ae	0f b7 47 04	 movzx	 eax, WORD PTR [rdi+4]

; 2705 : }

  001b2	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001b7	66 0f 6e d0	 movd	 xmm2, eax
  001bb	0f b7 47 06	 movzx	 eax, WORD PTR [rdi+6]
  001bf	0f 5b d2	 cvtdq2ps xmm2, xmm2
  001c2	66 0f 6e c8	 movd	 xmm1, eax
  001c6	f3 0f 58 15 00
	00 00 00	 addss	 xmm2, DWORD PTR __real@3f000000
  001ce	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001d1	f3 0f 59 53 38	 mulss	 xmm2, DWORD PTR [rbx+56]
  001d6	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@3f000000
  001de	f3 0f 11 53 40	 movss	 DWORD PTR [rbx+64], xmm2
  001e3	f3 0f 59 4b 3c	 mulss	 xmm1, DWORD PTR [rbx+60]
  001e8	f3 0f 11 4b 44	 movss	 DWORD PTR [rbx+68], xmm1
  001ed	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001f2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001f6	5f		 pop	 rdi
  001f7	c3		 ret	 0
?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildRenderDefaultTexData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
atlas$ = 112
?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z PROC ; ImFontAtlasBuildRenderLinesTexData

; 2708 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	41 57		 push	 r15
  00005	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 2709 :     if (atlas->Flags & ImFontAtlasFlags_NoBakedLines)

  00009	f6 01 04	 test	 BYTE PTR [rcx], 4
  0000c	4c 8b f9	 mov	 r15, rcx
  0000f	0f 85 13 02 00
	00		 jne	 $LN3@ImFontAtla

; 2710 :         return;
; 2711 : 
; 2712 :     // This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
; 2713 :     ImFontAtlasCustomRect* r = atlas->GetCustomRectByIndex(atlas->PackIdLines);

  00015	8b 91 88 04 00
	00		 mov	 edx, DWORD PTR [rcx+1160]
  0001b	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0001f	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  00023	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  00027	48 89 78 f0	 mov	 QWORD PTR [rax-16], rdi
  0002b	4c 89 60 e8	 mov	 QWORD PTR [rax-24], r12
  0002f	4c 89 68 e0	 mov	 QWORD PTR [rax-32], r13
  00033	0f 29 70 c8	 movaps	 XMMWORD PTR [rax-56], xmm6
  00037	e8 00 00 00 00	 call	 ?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z ; ImFontAtlas::GetCustomRectByIndex
  0003c	4c 8b e0	 mov	 r12, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2712 :     bool IsPacked() const { return X != 0xFFFF; }

  0003f	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00044	66 41 39 44 24
	04		 cmp	 WORD PTR [r12+4], ax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2714 :     IM_ASSERT(r->IsPacked());

  0004a	75 1a		 jne	 SHORT $LN27@ImFontAtla
  0004c	41 b8 9a 0a 00
	00		 mov	 r8d, 2714		; 00000a9aH
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@DDBMCGAE@?$AAr?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI?$AA?$CJ@
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN27@ImFontAtla:

; 2715 :     for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row

  00066	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3f000000
  0006e	4d 8d 6f 78	 lea	 r13, QWORD PTR [r15+120]
  00072	33 ff		 xor	 edi, edi
  00074	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@ImFontAtla:

; 2716 :     {
; 2717 :         // Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
; 2718 :         unsigned int y = n;
; 2719 :         unsigned int line_width = n;
; 2720 :         unsigned int pad_left = (r->Width - line_width) / 2;

  00080	41 0f b7 34 24	 movzx	 esi, WORD PTR [r12]

; 2721 :         unsigned int pad_right = r->Width - (pad_left + line_width);
; 2722 : 
; 2723 :         // Write each slice
; 2724 :         IM_ASSERT(pad_left + line_width + pad_right == r->Width && y < r->Height); // Make sure we're inside the texture bounds before we start writing pixels

  00085	41 0f b7 44 24
	02		 movzx	 eax, WORD PTR [r12+2]
  0008b	8b de		 mov	 ebx, esi
  0008d	2b df		 sub	 ebx, edi
  0008f	d1 eb		 shr	 ebx, 1
  00091	2b f3		 sub	 esi, ebx
  00093	2b f7		 sub	 esi, edi
  00095	3b f8		 cmp	 edi, eax
  00097	72 1a		 jb	 SHORT $LN29@ImFontAtla
  00099	41 b8 a4 0a 00
	00		 mov	 r8d, 2724		; 00000aa4H
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HO@DLMJCKJA@?$AAp?$AAa?$AAd?$AA_?$AAl?$AAe?$AAf?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAi?$AAn?$AAe@
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN29@ImFontAtla:

; 2725 :         if (atlas->TexPixelsAlpha8 != NULL)

  000b3	41 0f b7 4c 24
	06		 movzx	 ecx, WORD PTR [r12+6]
  000b9	41 0f b7 44 24
	04		 movzx	 eax, WORD PTR [r12+4]
  000bf	03 cf		 add	 ecx, edi
  000c1	41 0f af 4f 30	 imul	 ecx, DWORD PTR [r15+48]
  000c6	49 8b 57 20	 mov	 rdx, QWORD PTR [r15+32]
  000ca	03 c8		 add	 ecx, eax
  000cc	8b e9		 mov	 ebp, ecx
  000ce	48 85 d2	 test	 rdx, rdx
  000d1	74 41		 je	 SHORT $LN24@ImFontAtla

; 2726 :         {
; 2727 :             unsigned char* write_ptr = &atlas->TexPixelsAlpha8[r->X + ((r->Y + y) * atlas->TexWidth)];

  000d3	48 03 ea	 add	 rbp, rdx

; 2728 :             for (unsigned int i = 0; i < pad_left; i++)

  000d6	85 db		 test	 ebx, ebx
  000d8	74 0d		 je	 SHORT $LN7@ImFontAtla
  000da	44 8b c3	 mov	 r8d, ebx
  000dd	33 d2		 xor	 edx, edx
  000df	48 8b cd	 mov	 rcx, rbp
  000e2	e8 00 00 00 00	 call	 memset
$LN7@ImFontAtla:

; 2729 :                 *(write_ptr + i) = 0x00;
; 2730 : 
; 2731 :             for (unsigned int i = 0; i < line_width; i++)

  000e7	44 8b f3	 mov	 r14d, ebx
  000ea	85 ff		 test	 edi, edi
  000ec	74 0e		 je	 SHORT $LN10@ImFontAtla
  000ee	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  000f2	44 8b c7	 mov	 r8d, edi
  000f5	b2 ff		 mov	 dl, 255			; 000000ffH
  000f7	e8 00 00 00 00	 call	 memset
$LN10@ImFontAtla:

; 2732 :                 *(write_ptr + pad_left + i) = 0xFF;
; 2733 : 
; 2734 :             for (unsigned int i = 0; i < pad_right; i++)

  000fc	85 f6		 test	 esi, esi
  000fe	74 6c		 je	 SHORT $LN62@ImFontAtla

; 2735 :                 *(write_ptr + pad_left + line_width + i) = 0x00;
; 2736 :         }

  00100	8b cf		 mov	 ecx, edi
  00102	33 d2		 xor	 edx, edx
  00104	49 03 ce	 add	 rcx, r14
  00107	44 8b c6	 mov	 r8d, esi
  0010a	48 03 cd	 add	 rcx, rbp
  0010d	e8 00 00 00 00	 call	 memset
  00112	eb 58		 jmp	 SHORT $LN62@ImFontAtla
$LN24@ImFontAtla:

; 2737 :         else
; 2738 :         {
; 2739 :             unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];

  00114	4d 8b 77 28	 mov	 r14, QWORD PTR [r15+40]
  00118	49 8d 0c 8e	 lea	 rcx, QWORD PTR [r14+rcx*4]

; 2740 :             for (unsigned int i = 0; i < pad_left; i++)

  0011c	85 db		 test	 ebx, ebx
  0011e	74 0e		 je	 SHORT $LN15@ImFontAtla

; 2737 :         else
; 2738 :         {
; 2739 :             unsigned int* write_ptr = &atlas->TexPixelsRGBA32[r->X + ((r->Y + y) * atlas->TexWidth)];

  00120	44 8b c3	 mov	 r8d, ebx
  00123	33 d2		 xor	 edx, edx
  00125	49 c1 e0 02	 shl	 r8, 2
  00129	e8 00 00 00 00	 call	 memset
$LN15@ImFontAtla:

; 2741 :                 *(write_ptr + i) = IM_COL32_BLACK_TRANS;
; 2742 : 
; 2743 :             for (unsigned int i = 0; i < line_width; i++)

  0012e	85 ff		 test	 edi, edi
  00130	74 1a		 je	 SHORT $LN81@ImFontAtla
  00132	8b c3		 mov	 eax, ebx
  00134	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00139	48 03 c5	 add	 rax, rbp
  0013c	44 8b c7	 mov	 r8d, edi
  0013f	49 c1 e0 02	 shl	 r8, 2
  00143	49 8d 0c 86	 lea	 rcx, QWORD PTR [r14+rax*4]
  00147	e8 00 00 00 00	 call	 memset
$LN81@ImFontAtla:

; 2744 :                 *(write_ptr + pad_left + i) = IM_COL32_WHITE;
; 2745 : 
; 2746 :             for (unsigned int i = 0; i < pad_right; i++)

  0014c	8b cb		 mov	 ecx, ebx
  0014e	85 f6		 test	 esi, esi
  00150	74 1a		 je	 SHORT $LN62@ImFontAtla
  00152	8b c7		 mov	 eax, edi
  00154	33 d2		 xor	 edx, edx
  00156	48 03 c1	 add	 rax, rcx
  00159	44 8b c6	 mov	 r8d, esi
  0015c	48 03 c5	 add	 rax, rbp
  0015f	49 c1 e0 02	 shl	 r8, 2
  00163	49 8d 0c 86	 lea	 rcx, QWORD PTR [r14+rax*4]
  00167	e8 00 00 00 00	 call	 memset
$LN62@ImFontAtla:

; 2751 :         ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;

  0016c	45 0f b7 44 24
	04		 movzx	 r8d, WORD PTR [r12+4]
  00172	0f 57 c9	 xorps	 xmm1, xmm1
  00175	41 0f b7 54 24
	06		 movzx	 edx, WORD PTR [r12+6]
  0017b	0f 57 c0	 xorps	 xmm0, xmm0
  0017e	03 d7		 add	 edx, edi
  00180	0f 57 db	 xorps	 xmm3, xmm3
  00183	8b c2		 mov	 eax, edx

; 2752 :         ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;

  00185	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
  00188	f3 48 0f 2a d9	 cvtsi2ss xmm3, rcx
  0018d	41 8d 48 ff	 lea	 ecx, DWORD PTR [r8-1]
  00191	03 cb		 add	 ecx, ebx
  00193	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  00198	f3 41 0f 59 5f
	3c		 mulss	 xmm3, DWORD PTR [r15+60]
  0019e	f3 41 0f 59 47
	3c		 mulss	 xmm0, DWORD PTR [r15+60]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2751 :         ImVec2 uv0 = ImVec2((float)(r->X + pad_left - 1), (float)(r->Y + y)) * atlas->TexUvScale;

  001a4	f3 48 0f 2a c9	 cvtsi2ss xmm1, rcx

; 2752 :         ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;

  001a9	41 8d 48 01	 lea	 ecx, DWORD PTR [r8+1]
  001ad	03 cb		 add	 ecx, ebx
  001af	03 cf		 add	 ecx, edi
  001b1	ff c7		 inc	 edi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  001b3	f3 0f 58 d8	 addss	 xmm3, xmm0
  001b7	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  001ba	f3 41 0f 59 4f
	38		 mulss	 xmm1, DWORD PTR [r15+56]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2752 :         ImVec2 uv1 = ImVec2((float)(r->X + pad_left + line_width + 1), (float)(r->Y + y + 1)) * atlas->TexUvScale;

  001c0	f3 48 0f 2a c1	 cvtsi2ss xmm0, rcx

; 2754 :         atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);

  001c5	0f c6 c9 e1	 shufps	 xmm1, xmm1, 225		; 000000e1H
  001c9	f3 0f 59 de	 mulss	 xmm3, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 356  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

  001cd	f3 41 0f 59 47
	38		 mulss	 xmm0, DWORD PTR [r15+56]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2754 :         atlas->TexUvLines[n] = ImVec4(uv0.x, half_v, uv1.x, half_v);

  001d3	f3 0f 10 cb	 movss	 xmm1, xmm3
  001d7	0f c6 c9 c6	 shufps	 xmm1, xmm1, 198		; 000000c6H
  001db	f3 0f 10 c8	 movss	 xmm1, xmm0
  001df	0f c6 c9 27	 shufps	 xmm1, xmm1, 39		; 00000027H
  001e3	f3 0f 10 cb	 movss	 xmm1, xmm3
  001e7	0f c6 c9 39	 shufps	 xmm1, xmm1, 57		; 00000039H
  001eb	41 0f 11 4d 00	 movups	 XMMWORD PTR [r13], xmm1
  001f0	49 83 c5 10	 add	 r13, 16
  001f4	83 ff 40	 cmp	 edi, 64			; 00000040H
  001f7	0f 82 83 fe ff
	ff		 jb	 $LL4@ImFontAtla

; 2715 :     for (unsigned int n = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n++) // +1 because of the zero-width row

  001fd	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00202	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
  00207	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]
  0020c	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00211	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00216	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  0021e	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00223	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
$LN3@ImFontAtla:

; 2755 :     }
; 2756 : }

  00228	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0022c	41 5f		 pop	 r15
  0022e	c3		 ret	 0
?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z ENDP ; ImFontAtlasBuildRenderLinesTexData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
atlas$ = 48
?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z PROC	; ImFontAtlasBuildInit

; 2760 : {

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2761 :     // Register texture region for mouse cursors or standard white pixels
; 2762 :     if (atlas->PackIdMouseCursors < 0)

  00006	83 b9 84 04 00
	00 00		 cmp	 DWORD PTR [rcx+1156], 0
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	7d 25		 jge	 SHORT $LN4@ImFontAtla

; 2763 :     {
; 2764 :         if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))

  00012	f6 01 02	 test	 BYTE PTR [rcx], 2
  00015	75 0d		 jne	 SHORT $LN3@ImFontAtla

; 2765 :             atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);

  00017	ba f5 00 00 00	 mov	 edx, 245		; 000000f5H
  0001c	41 b8 1b 00 00
	00		 mov	 r8d, 27
  00022	eb 08		 jmp	 SHORT $LN8@ImFontAtla
$LN3@ImFontAtla:

; 2766 :         else
; 2767 :             atlas->PackIdMouseCursors = atlas->AddCustomRectRegular(2, 2);

  00024	ba 02 00 00 00	 mov	 edx, 2
  00029	44 8b c2	 mov	 r8d, edx
$LN8@ImFontAtla:

; 2768 :     }
; 2769 : 
; 2770 :     // Register texture region for thick lines
; 2771 :     // The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
; 2772 :     if (atlas->PackIdLines < 0)

  0002c	e8 00 00 00 00	 call	 ?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z ; ImFontAtlas::AddCustomRectRegular
  00031	89 83 84 04 00
	00		 mov	 DWORD PTR [rbx+1156], eax
$LN4@ImFontAtla:
  00037	83 bb 88 04 00
	00 00		 cmp	 DWORD PTR [rbx+1160], 0
  0003e	7d 1c		 jge	 SHORT $LN6@ImFontAtla

; 2773 :     {
; 2774 :         if (!(atlas->Flags & ImFontAtlasFlags_NoBakedLines))

  00040	f6 03 04	 test	 BYTE PTR [rbx], 4
  00043	75 17		 jne	 SHORT $LN6@ImFontAtla

; 2775 :             atlas->PackIdLines = atlas->AddCustomRectRegular(IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1);

  00045	ba 41 00 00 00	 mov	 edx, 65			; 00000041H
  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	44 8d 42 ff	 lea	 r8d, QWORD PTR [rdx-1]
  00051	e8 00 00 00 00	 call	 ?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z ; ImFontAtlas::AddCustomRectRegular
  00056	89 83 88 04 00
	00		 mov	 DWORD PTR [rbx+1160], eax
$LN6@ImFontAtla:

; 2776 :     }
; 2777 : }

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
?ImFontAtlasBuildInit@@YAXPEAUImFontAtlas@@@Z ENDP	; ImFontAtlasBuildInit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
atlas$ = 176
?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z PROC	; ImFontAtlasBuildFinish

; 2781 : {

$LN51:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2782 :     // Render into our custom data blocks
; 2783 :     IM_ASSERT(atlas->TexPixelsAlpha8 != NULL || atlas->TexPixelsRGBA32 != NULL);

  0000a	48 83 79 20 00	 cmp	 QWORD PTR [rcx+32], 0
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	4c 89 b4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], r14
  0001a	75 21		 jne	 SHORT $LN12@ImFontAtla
  0001c	48 83 79 28 00	 cmp	 QWORD PTR [rcx+40], 0
  00021	75 1a		 jne	 SHORT $LN12@ImFontAtla
  00023	41 b8 df 0a 00
	00		 mov	 r8d, 2783		; 00000adfH
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HG@JLCPLJIF@?$AAa?$AAt?$AAl?$AAa?$AAs?$AA?9?$AA?$DO?$AAT?$AAe?$AAx?$AAP?$AAi?$AAx?$AAe?$AAl@
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN12@ImFontAtla:

; 2784 :     ImFontAtlasBuildRenderDefaultTexData(atlas);

  0003d	48 8b cb	 mov	 rcx, rbx
  00040	48 89 bc 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rdi
  00048	e8 00 00 00 00	 call	 ?ImFontAtlasBuildRenderDefaultTexData@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildRenderDefaultTexData

; 2785 :     ImFontAtlasBuildRenderLinesTexData(atlas);

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 ?ImFontAtlasBuildRenderLinesTexData@@YAXPEAUImFontAtlas@@@Z ; ImFontAtlasBuildRenderLinesTexData

; 2786 : 
; 2787 :     // Register custom rectangle glyphs
; 2788 :     for (int i = 0; i < atlas->CustomRects.Size; i++)

  00055	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
  00058	33 f6		 xor	 esi, esi
  0005a	44 8b f6	 mov	 r14d, esi
  0005d	85 c0		 test	 eax, eax
  0005f	0f 8e e3 01 00
	00		 jle	 $LN3@ImFontAtla
  00065	48 89 ac 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rbp
  0006d	8b fe		 mov	 edi, esi
  0006f	4c 89 a4 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], r12
  00077	41 bc ff ff 00
	00		 mov	 r12d, 65535		; 0000ffffH
  0007d	4c 89 bc 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r15
  00085	44 8b fe	 mov	 r15d, esi
  00088	0f 29 b4 24 80
	00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm6
  00090	0f 29 7c 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm7
  00095	44 0f 29 44 24
	60		 movaps	 XMMWORD PTR [rsp+96], xmm8
  0009b	0f 1f 44 00 00	 npad	 5
$LL4@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  000a0	4d 85 ff	 test	 r15, r15
  000a3	78 05		 js	 SHORT $LN16@ImFontAtla
  000a5	44 3b f0	 cmp	 r14d, eax
  000a8	7c 1a		 jl	 SHORT $LN17@ImFontAtla
$LN16@ImFontAtla:
  000aa	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN17@ImFontAtla:
  000c4	48 8b 6b 60	 mov	 rbp, QWORD PTR [rbx+96]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2791 :         if (r->Font == NULL || r->GlyphID == 0)

  000c8	48 8b 44 2f 18	 mov	 rax, QWORD PTR [rdi+rbp+24]
  000cd	48 85 c0	 test	 rax, rax
  000d0	0f 84 31 01 00
	00		 je	 $LN2@ImFontAtla
  000d6	39 74 2f 08	 cmp	 DWORD PTR [rdi+rbp+8], esi
  000da	0f 84 27 01 00
	00		 je	 $LN2@ImFontAtla

; 2792 :             continue;
; 2793 : 
; 2794 :         // Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
; 2795 :         IM_ASSERT(r->Font->ContainerAtlas == atlas);

  000e0	48 39 58 40	 cmp	 QWORD PTR [rax+64], rbx
  000e4	74 1a		 je	 SHORT $LN13@ImFontAtla
  000e6	41 b8 eb 0a 00
	00		 mov	 r8d, 2795		; 00000aebH
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@BJJINGAO@?$AAr?$AA?9?$AA?$DO?$AAF?$AAo?$AAn?$AAt?$AA?9?$AA?$DO?$AAC?$AAo?$AAn?$AAt?$AAa?$AAi@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN13@ImFontAtla:

; 2233 :     IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates

  00100	39 73 30	 cmp	 DWORD PTR [rbx+48], esi
  00103	7e 05		 jle	 SHORT $LN24@ImFontAtla
  00105	39 73 34	 cmp	 DWORD PTR [rbx+52], esi
  00108	7f 1a		 jg	 SHORT $LN25@ImFontAtla
$LN24@ImFontAtla:
  0010a	41 b8 b9 08 00
	00		 mov	 r8d, 2233		; 000008b9H
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@CMBJAGBP@?$AAT?$AAe?$AAx?$AAW?$AAi?$AAd?$AAt?$AAh?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG@
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN25@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 2712 :     bool IsPacked() const { return X != 0xFFFF; }

  00124	0f b7 44 2f 04	 movzx	 eax, WORD PTR [rdi+rbp+4]
  00129	66 41 3b c4	 cmp	 ax, r12w
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2234 :     IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed

  0012d	75 1f		 jne	 SHORT $LN26@ImFontAtla
  0012f	41 b8 ba 08 00
	00		 mov	 r8d, 2234		; 000008baH
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DEJIAPCP@?$AAr?$AAe?$AAc?$AAt?$AA?9?$AA?$DO?$AAI?$AAs?$AAP?$AAa?$AAc?$AAk?$AAe?$AAd?$AA?$CI@
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00149	0f b7 44 2f 04	 movzx	 eax, WORD PTR [rdi+rbp+4]
$LN26@ImFontAtla:

; 2235 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

  0014e	0f b7 4c 2f 06	 movzx	 ecx, WORD PTR [rdi+rbp+6]

; 2236 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

  00153	0f b7 54 2f 02	 movzx	 edx, WORD PTR [rdi+rbp+2]
  00158	44 0f b7 0c 2f	 movzx	 r9d, WORD PTR [rdi+rbp]

; 2796 :         ImVec2 uv0, uv1;
; 2797 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2798 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

  0015d	f3 44 0f 10 44
	2f 14		 movss	 xmm8, DWORD PTR [rdi+rbp+20]
  00164	f3 0f 10 5c 2f
	10		 movss	 xmm3, DWORD PTR [rdi+rbp+16]
  0016a	f3 0f 10 44 2f
	0c		 movss	 xmm0, DWORD PTR [rdi+rbp+12]
  00170	f3 0f 11 44 24
	58		 movss	 DWORD PTR [rsp+88], xmm0

; 2235 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

  00176	44 0f b7 c0	 movzx	 r8d, ax

; 2236 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

  0017a	8d 04 0a	 lea	 eax, DWORD PTR [rdx+rcx]
  0017d	66 0f 6e f8	 movd	 xmm7, eax
  00181	66 0f 6e e9	 movd	 xmm5, ecx

; 2796 :         ImVec2 uv0, uv1;
; 2797 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2798 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

  00185	48 8b 4c 2f 18	 mov	 rcx, QWORD PTR [rdi+rbp+24]

; 2236 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

  0018a	43 8d 04 08	 lea	 eax, DWORD PTR [r8+r9]
  0018e	66 41 0f 6e e0	 movd	 xmm4, r8d

; 2796 :         ImVec2 uv0, uv1;
; 2797 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2798 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

  00193	44 0f b7 44 2f
	08		 movzx	 r8d, WORD PTR [rdi+rbp+8]
  00199	66 0f 6e d2	 movd	 xmm2, edx
  0019d	33 d2		 xor	 edx, edx
  0019f	66 0f 6e f0	 movd	 xmm6, eax

; 2235 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

  001a3	0f 5b ed	 cvtdq2ps xmm5, xmm5
  001a6	66 41 0f 6e c9	 movd	 xmm1, r9d
  001ab	f3 0f 59 6b 3c	 mulss	 xmm5, DWORD PTR [rbx+60]
  001b0	0f 5b e4	 cvtdq2ps xmm4, xmm4

; 2796 :         ImVec2 uv0, uv1;
; 2797 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2798 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

  001b3	0f 5b d2	 cvtdq2ps xmm2, xmm2

; 2235 :     *out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);

  001b6	f3 0f 59 63 38	 mulss	 xmm4, DWORD PTR [rbx+56]

; 2796 :         ImVec2 uv0, uv1;
; 2797 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2798 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

  001bb	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001be	f3 41 0f 58 d0	 addss	 xmm2, xmm8
  001c3	f3 0f 58 cb	 addss	 xmm1, xmm3

; 2236 :     *out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);

  001c7	0f 5b ff	 cvtdq2ps xmm7, xmm7
  001ca	0f 5b f6	 cvtdq2ps xmm6, xmm6
  001cd	f3 0f 59 7b 3c	 mulss	 xmm7, DWORD PTR [rbx+60]
  001d2	f3 0f 59 73 38	 mulss	 xmm6, DWORD PTR [rbx+56]

; 2796 :         ImVec2 uv0, uv1;
; 2797 :         atlas->CalcCustomRectUV(r, &uv0, &uv1);
; 2798 :         r->Font->AddGlyph(NULL, (ImWchar)r->GlyphID, r->GlyphOffset.x, r->GlyphOffset.y, r->GlyphOffset.x + r->Width, r->GlyphOffset.y + r->Height, uv0.x, uv0.y, uv1.x, uv1.y, r->GlyphAdvanceX);

  001d7	f3 0f 11 7c 24
	50		 movss	 DWORD PTR [rsp+80], xmm7
  001dd	f3 0f 11 74 24
	48		 movss	 DWORD PTR [rsp+72], xmm6
  001e3	f3 0f 11 6c 24
	40		 movss	 DWORD PTR [rsp+64], xmm5
  001e9	f3 0f 11 64 24
	38		 movss	 DWORD PTR [rsp+56], xmm4
  001ef	f3 0f 11 54 24
	30		 movss	 DWORD PTR [rsp+48], xmm2
  001f5	f3 0f 11 4c 24
	28		 movss	 DWORD PTR [rsp+40], xmm1
  001fb	f3 44 0f 11 44
	24 20		 movss	 DWORD PTR [rsp+32], xmm8
  00202	e8 00 00 00 00	 call	 ?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z ; ImFont::AddGlyph
$LN2@ImFontAtla:

; 2786 : 
; 2787 :     // Register custom rectangle glyphs
; 2788 :     for (int i = 0; i < atlas->CustomRects.Size; i++)

  00207	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
  0020a	41 ff c6	 inc	 r14d
  0020d	49 ff c7	 inc	 r15
  00210	48 83 c7 20	 add	 rdi, 32			; 00000020H
  00214	44 3b f0	 cmp	 r14d, eax
  00217	0f 8c 83 fe ff
	ff		 jl	 $LL4@ImFontAtla
  0021d	44 0f 28 44 24
	60		 movaps	 xmm8, XMMWORD PTR [rsp+96]
  00223	0f 28 7c 24 70	 movaps	 xmm7, XMMWORD PTR [rsp+112]
  00228	0f 28 b4 24 80
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+128]
  00230	4c 8b bc 24 90
	00 00 00	 mov	 r15, QWORD PTR [rsp+144]
  00238	4c 8b a4 24 c0
	00 00 00	 mov	 r12, QWORD PTR [rsp+192]
  00240	48 8b ac 24 b0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+176]
$LN3@ImFontAtla:

; 2799 :     }
; 2800 : 
; 2801 :     // Build all fonts lookup tables
; 2802 :     for (int i = 0; i < atlas->Fonts.Size; i++)

  00248	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  0024b	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR [rsp+200]
  00253	85 c0		 test	 eax, eax
  00255	7e 7b		 jle	 SHORT $LN49@ImFontAtla
  00257	48 8b fe	 mov	 rdi, rsi
  0025a	8b d0		 mov	 edx, eax
  0025c	0f 1f 40 00	 npad	 4
$LL7@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00260	48 85 ff	 test	 rdi, rdi
  00263	78 04		 js	 SHORT $LN35@ImFontAtla
  00265	3b f0		 cmp	 esi, eax
  00267	7c 1d		 jl	 SHORT $LN36@ImFontAtla
$LN35@ImFontAtla:
  00269	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0026f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00283	8b 53 48	 mov	 edx, DWORD PTR [rbx+72]
$LN36@ImFontAtla:
  00286	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2803 :         if (atlas->Fonts[i]->DirtyLookupTables)

  0028a	48 8b 04 f9	 mov	 rax, QWORD PTR [rcx+rdi*8]
  0028e	80 78 58 00	 cmp	 BYTE PTR [rax+88], 0
  00292	74 30		 je	 SHORT $LN5@ImFontAtla
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00294	48 85 ff	 test	 rdi, rdi
  00297	78 04		 js	 SHORT $LN39@ImFontAtla
  00299	3b f2		 cmp	 esi, edx
  0029b	7c 1e		 jl	 SHORT $LN40@ImFontAtla
$LN39@ImFontAtla:
  0029d	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  002a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  002b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b7	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
$LN40@ImFontAtla:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 2804 :             atlas->Fonts[i]->BuildLookupTable();

  002bb	48 8b 0c f9	 mov	 rcx, QWORD PTR [rcx+rdi*8]
  002bf	e8 00 00 00 00	 call	 ?BuildLookupTable@ImFont@@QEAAXXZ ; ImFont::BuildLookupTable
$LN5@ImFontAtla:

; 2799 :     }
; 2800 : 
; 2801 :     // Build all fonts lookup tables
; 2802 :     for (int i = 0; i < atlas->Fonts.Size; i++)

  002c4	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  002c7	ff c6		 inc	 esi
  002c9	48 ff c7	 inc	 rdi
  002cc	8b d0		 mov	 edx, eax
  002ce	3b f0		 cmp	 esi, eax
  002d0	7c 8e		 jl	 SHORT $LL7@ImFontAtla
$LN49@ImFontAtla:
  002d2	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+184]

; 2805 : 
; 2806 :     atlas->TexReady = true;
; 2807 : }

  002da	c6 43 19 01	 mov	 BYTE PTR [rbx+25], 1
  002de	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002e5	5e		 pop	 rsi
  002e6	5b		 pop	 rbx
  002e7	c3		 ret	 0
?ImFontAtlasBuildFinish@@YAXPEAUImFontAtlas@@@Z ENDP	; ImFontAtlasBuildFinish
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$dead$ = 8
?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ PROC	; ImFontAtlas::GetGlyphRangesDefault

; 2812 :     static const ImWchar ranges[] =
; 2813 :     {
; 2814 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 2815 :         0,
; 2816 :     };
; 2817 :     return &ranges[0];

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ@4QBGB

; 2818 : }

  00007	c3		 ret	 0
?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ ENDP	; ImFontAtlas::GetGlyphRangesDefault
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 48
?ClearOutputData@ImFont@@QEAAXXZ PROC			; ImFont::ClearOutputData

; 3129 : {

$LN37:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3130 :     FontSize = 0.0f;

  0000a	33 ff		 xor	 edi, edi
  0000c	48 8b d9	 mov	 rbx, rcx

; 3131 :     FallbackAdvanceX = 0.0f;

  0000f	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00013	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00017	48 85 c9	 test	 rcx, rcx
  0001a	74 20		 je	 SHORT $LN4@ClearOutpu
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00023	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00027	48 85 c0	 test	 rax, rax
  0002a	74 06		 je	 SHORT $LN8@ClearOutpu

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0002c	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN8@ClearOutpu:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00038	48 89 7b 30	 mov	 QWORD PTR [rbx+48], rdi
$LN4@ClearOutpu:
  0003c	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00040	48 85 c9	 test	 rcx, rcx
  00043	74 1f		 je	 SHORT $LN15@ClearOutpu
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0004c	48 89 3b	 mov	 QWORD PTR [rbx], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0004f	48 85 c0	 test	 rax, rax
  00052	74 06		 je	 SHORT $LN19@ClearOutpu

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00054	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN19@ClearOutpu:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00060	48 89 7b 08	 mov	 QWORD PTR [rbx+8], rdi
$LN15@ClearOutpu:
  00064	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00068	48 85 c9	 test	 rcx, rcx
  0006b	74 20		 je	 SHORT $LN26@ClearOutpu
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0006d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00074	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00078	48 85 c0	 test	 rax, rax
  0007b	74 06		 je	 SHORT $LN30@ClearOutpu

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0007d	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN30@ClearOutpu:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00089	48 89 7b 20	 mov	 QWORD PTR [rbx+32], rdi
$LN26@ClearOutpu:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3135 :     FallbackGlyph = NULL;

  0008d	48 89 7b 38	 mov	 QWORD PTR [rbx+56], rdi

; 3136 :     ContainerAtlas = NULL;

  00091	48 89 7b 40	 mov	 QWORD PTR [rbx+64], rdi

; 3137 :     DirtyLookupTables = true;

  00095	c6 43 58 01	 mov	 BYTE PTR [rbx+88], 1

; 3138 :     Ascent = Descent = 0.0f;

  00099	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi

; 3139 :     MetricsTotalSurface = 0;

  0009d	89 7b 68	 mov	 DWORD PTR [rbx+104], edi

; 3140 : }

  000a0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
?ClearOutputData@ImFont@@QEAAXXZ ENDP			; ImFont::ClearOutputData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
font$ = 8
candidate_chars$ = 16
candidate_chars_count$ = 24
?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z PROC	; FindFirstExistingGlyph

; 3143 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	48 8b da	 mov	 rbx, rdx
  00012	4c 8b d1	 mov	 r10, rcx

; 3144 :     for (int n = 0; n < candidate_chars_count; n++)

  00015	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  0001a	45 85 c0	 test	 r8d, r8d
  0001d	7e 43		 jle	 SHORT $LN17@FindFirstE
  0001f	48 63 79 18	 movsxd	 rdi, DWORD PTR [rcx+24]
  00023	33 c0		 xor	 eax, eax
  00025	4d 63 d8	 movsxd	 r11, r8d
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@FindFirstE:

; 3145 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

  00030	44 0f b7 04 43	 movzx	 r8d, WORD PTR [rbx+rax*2]

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  00035	4c 3b c7	 cmp	 r8, rdi
  00038	73 20		 jae	 SHORT $LN16@FindFirstE

; 3325 :         return NULL;
; 3326 :     const ImWchar i = IndexLookup.Data[c];

  0003a	49 8b 4a 20	 mov	 rcx, QWORD PTR [r10+32]
  0003e	46 0f b7 0c 41	 movzx	 r9d, WORD PTR [rcx+r8*2]

; 3327 :     if (i == (ImWchar)-1)

  00043	66 44 3b ce	 cmp	 r9w, si
  00047	74 11		 je	 SHORT $LN16@FindFirstE

; 3328 :         return NULL;
; 3329 :     return &Glyphs.Data[i];

  00049	49 8b 4a 30	 mov	 rcx, QWORD PTR [r10+48]
  0004d	4b 8d 14 89	 lea	 rdx, QWORD PTR [r9+r9*4]
  00051	48 8d 14 d1	 lea	 rdx, QWORD PTR [rcx+rdx*8]

; 3145 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

  00055	48 85 d2	 test	 rdx, rdx
  00058	75 1b		 jne	 SHORT $LN12@FindFirstE
$LN16@FindFirstE:

; 3144 :     for (int n = 0; n < candidate_chars_count; n++)

  0005a	48 ff c0	 inc	 rax
  0005d	49 3b c3	 cmp	 rax, r11
  00060	7c ce		 jl	 SHORT $LL4@FindFirstE
$LN17@FindFirstE:

; 3146 :             return candidate_chars[n];
; 3147 :     return (ImWchar)-1;

  00062	0f b7 c6	 movzx	 eax, si

; 3148 : }

  00065	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0006a	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  0006f	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  00074	c3		 ret	 0
$LN12@FindFirstE:
  00075	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0007a	41 0f b7 c0	 movzx	 eax, r8w
  0007e	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  00083	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  00088	c3		 ret	 0
?FindFirstExistingGlyph@@YAGPEAUImFont@@PEBGH@Z ENDP	; FindFirstExistingGlyph
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
ellipsis_chars$ = 32
fallback_chars$ = 36
dots_chars$ = 36
__$ArrayPad$ = 48
this$ = 144
?BuildLookupTable@ImFont@@QEAAXXZ PROC			; ImFont::BuildLookupTable

; 3151 : {

$LN194:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	55		 push	 rbp
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3153 :     for (int i = 0; i != Glyphs.Size; i++)

  0001a	8b 41 28	 mov	 eax, DWORD PTR [rcx+40]
  0001d	33 ed		 xor	 ebp, ebp
  0001f	4d 89 63 10	 mov	 QWORD PTR [r11+16], r12
  00023	48 8b d9	 mov	 rbx, rcx
  00026	4d 89 6b 18	 mov	 QWORD PTR [r11+24], r13
  0002a	8b fd		 mov	 edi, ebp
  0002c	4d 89 73 20	 mov	 QWORD PTR [r11+32], r14
  00030	41 bd ff ff 00
	00		 mov	 r13d, 65535		; 0000ffffH
  00036	4d 89 7b d8	 mov	 QWORD PTR [r11-40], r15
  0003a	44 8b fd	 mov	 r15d, ebp
  0003d	85 c0		 test	 eax, eax
  0003f	74 70		 je	 SHORT $LN19@BuildLooku
  00041	8b f5		 mov	 esi, ebp
  00043	44 8b f5	 mov	 r14d, ebp
$LL4@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00046	48 85 f6	 test	 rsi, rsi
  00049	78 06		 js	 SHORT $LN22@BuildLooku
  0004b	8b d0		 mov	 edx, eax
  0004d	3b f8		 cmp	 edi, eax
  0004f	7c 1d		 jl	 SHORT $LN182@BuildLooku
$LN22@BuildLooku:
  00051	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006b	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
$LN182@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3154 :         max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

  0006e	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00072	41 8b 0c 06	 mov	 ecx, DWORD PTR [r14+rax]
  00076	8b c2		 mov	 eax, edx
  00078	c1 e9 02	 shr	 ecx, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  0007b	44 3b f9	 cmp	 r15d, ecx
  0007e	41 0f 4d cf	 cmovge	 ecx, r15d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3153 :     for (int i = 0; i != Glyphs.Size; i++)

  00082	ff c7		 inc	 edi
  00084	48 ff c6	 inc	 rsi
  00087	49 83 c6 28	 add	 r14, 40			; 00000028H

; 3154 :         max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

  0008b	44 8b f9	 mov	 r15d, ecx
  0008e	3b fa		 cmp	 edi, edx
  00090	75 b4		 jne	 SHORT $LL4@BuildLooku

; 3155 : 
; 3156 :     // Build lookup table
; 3157 :     IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved

  00092	41 3b d5	 cmp	 edx, r13d
  00095	7c 1a		 jl	 SHORT $LN19@BuildLooku
  00097	41 b8 55 0c 00
	00		 mov	 r8d, 3157		; 00000c55H
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@FHBHHKB@?$AAG?$AAl?$AAy?$AAp?$AAh?$AAs?$AA?4?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?5?$AA0@
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN19@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000b1	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000b5	48 85 c9	 test	 rcx, rcx
  000b8	74 1f		 je	 SHORT $LN27@BuildLooku
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000c1	48 89 2b	 mov	 QWORD PTR [rbx], rbp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000c4	48 85 c0	 test	 rax, rax
  000c7	74 06		 je	 SHORT $LN31@BuildLooku

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000c9	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN31@BuildLooku:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000d5	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp
$LN27@BuildLooku:
  000d9	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000dd	48 85 c9	 test	 rcx, rcx
  000e0	74 20		 je	 SHORT $LN38@BuildLooku
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000e9	48 89 6b 18	 mov	 QWORD PTR [rbx+24], rbp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000ed	48 85 c0	 test	 rax, rax
  000f0	74 06		 je	 SHORT $LN42@BuildLooku

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000f2	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN42@BuildLooku:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000fe	48 89 6b 20	 mov	 QWORD PTR [rbx+32], rbp
$LN38@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3161 :     memset(Used4kPagesMap, 0, sizeof(Used4kPagesMap));

  00102	33 c0		 xor	 eax, eax
  00104	40 88 6b 58	 mov	 BYTE PTR [rbx+88], bpl

; 3162 :     GrowIndex(max_codepoint + 1);

  00108	45 8d 6f 01	 lea	 r13d, DWORD PTR [r15+1]
  0010c	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  00111	41 8b d5	 mov	 edx, r13d
  00114	66 89 43 6c	 mov	 WORD PTR [rbx+108], ax
  00118	48 8b cb	 mov	 rcx, rbx
  0011b	e8 00 00 00 00	 call	 ?GrowIndex@ImFont@@QEAAXH@Z ; ImFont::GrowIndex

; 3163 :     for (int i = 0; i < Glyphs.Size; i++)

  00120	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00124	8b fd		 mov	 edi, ebp
  00126	45 85 c0	 test	 r8d, r8d
  00129	0f 8e ed 00 00
	00		 jle	 $LN6@BuildLooku

; 3166 :         IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;

  0012f	41 8b c0	 mov	 eax, r8d
$LL7@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00132	85 ff		 test	 edi, edi
  00134	78 04		 js	 SHORT $LN50@BuildLooku
  00136	3b f8		 cmp	 edi, eax
  00138	7c 1e		 jl	 SHORT $LN51@BuildLooku
$LN50@BuildLooku:
  0013a	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00154	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
$LN51@BuildLooku:
  00158	48 63 c7	 movsxd	 rax, edi
  0015b	4c 8d 34 80	 lea	 r14, QWORD PTR [rax+rax*4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3165 :         int codepoint = (int)Glyphs[i].Codepoint;

  0015f	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00163	42 8b 34 f0	 mov	 esi, DWORD PTR [rax+r14*8]
  00167	c1 ee 02	 shr	 esi, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  0016a	85 ff		 test	 edi, edi
  0016c	78 05		 js	 SHORT $LN54@BuildLooku
  0016e	41 3b f8	 cmp	 edi, r8d
  00171	7c 1e		 jl	 SHORT $LN184@BuildLooku
$LN54@BuildLooku:
  00173	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00179	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0018d	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
$LN184@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3166 :         IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;

  00191	f3 42 0f 10 74
	f0 04		 movss	 xmm6, DWORD PTR [rax+r14*8+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00198	3b 33		 cmp	 esi, DWORD PTR [rbx]
  0019a	7c 1a		 jl	 SHORT $LN59@BuildLooku
  0019c	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN59@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3166 :         IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;

  001b6	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  001ba	f3 0f 11 34 b1	 movss	 DWORD PTR [rcx+rsi*4], xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  001bf	3b 73 18	 cmp	 esi, DWORD PTR [rbx+24]
  001c2	7c 1a		 jl	 SHORT $LN63@BuildLooku
  001c4	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  001ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN63@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3167 :         IndexLookup[codepoint] = (ImWchar)i;

  001de	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]

; 3168 : 
; 3169 :         // Mark 4K page as used
; 3170 :         const int page_n = codepoint / 4096;

  001e2	8b c6		 mov	 eax, esi
  001e4	99		 cdq
  001e5	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  001eb	03 c2		 add	 eax, edx
  001ed	66 89 3c 71	 mov	 WORD PTR [rcx+rsi*2], di
  001f1	ff c7		 inc	 edi
  001f3	c1 f8 0c	 sar	 eax, 12

; 3171 :         Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7);

  001f6	48 63 d0	 movsxd	 rdx, eax
  001f9	83 e0 07	 and	 eax, 7
  001fc	48 c1 fa 03	 sar	 rdx, 3
  00200	0f b6 4c 1a 6c	 movzx	 ecx, BYTE PTR [rdx+rbx+108]
  00205	0f ab c1	 bts	 ecx, eax
  00208	88 4c 1a 6c	 mov	 BYTE PTR [rdx+rbx+108], cl
  0020c	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00210	41 8b c0	 mov	 eax, r8d
  00213	41 3b f8	 cmp	 edi, r8d
  00216	0f 8c 16 ff ff
	ff		 jl	 $LL7@BuildLooku
$LN6@BuildLooku:

; 3314 :     if (c >= (size_t)IndexLookup.Size)

  0021c	83 7b 18 20	 cmp	 DWORD PTR [rbx+24], 32	; 00000020H
  00220	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  00225	77 0c		 ja	 SHORT $LN65@BuildLooku

; 3315 :         return FallbackGlyph;

  00227	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0022b	4c 8b c8	 mov	 r9, rax
  0022e	48 8b d0	 mov	 rdx, rax
  00231	eb 25		 jmp	 SHORT $LN64@BuildLooku
$LN65@BuildLooku:

; 3316 :     const ImWchar i = IndexLookup.Data[c];

  00233	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00237	48 8b 53 38	 mov	 rdx, QWORD PTR [rbx+56]

; 3317 :     if (i == (ImWchar)-1)

  0023b	4c 8b ca	 mov	 r9, rdx
  0023e	0f b7 48 40	 movzx	 ecx, WORD PTR [rax+64]
  00242	66 3b cf	 cmp	 cx, di
  00245	75 05		 jne	 SHORT $LN66@BuildLooku

; 3318 :         return FallbackGlyph;

  00247	48 8b c2	 mov	 rax, rdx
  0024a	eb 0c		 jmp	 SHORT $LN64@BuildLooku
$LN66@BuildLooku:

; 3319 :     return &Glyphs.Data[i];

  0024c	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00250	48 8d 0c 89	 lea	 rcx, QWORD PTR [rcx+rcx*4]
  00254	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
$LN64@BuildLooku:

; 3172 :     }
; 3173 : 
; 3174 :     // Create a glyph to handle TAB
; 3175 :     // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
; 3176 :     if (FindGlyph((ImWchar)' '))

  00258	48 85 c0	 test	 rax, rax
  0025b	0f 84 4f 01 00
	00		 je	 $LN11@BuildLooku
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00261	45 85 c0	 test	 r8d, r8d
  00264	7f 1e		 jg	 SHORT $LN70@BuildLooku
  00266	41 b8 0b 07 00
	00		 mov	 r8d, 1803		; 0000070bH
  0026c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00280	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
$LN70@BuildLooku:
  00284	49 63 c0	 movsxd	 rax, r8d
  00287	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3178 :         if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times (FIXME: Flaky)

  0028b	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0028f	8b 54 c8 d8	 mov	 edx, DWORD PTR [rax+rcx*8-40]
  00293	83 e2 fc	 and	 edx, -4			; fffffffcH
  00296	83 fa 24	 cmp	 edx, 36			; 00000024H
  00299	74 0d		 je	 SHORT $LN12@BuildLooku

; 3179 :             Glyphs.resize(Glyphs.Size + 1);

  0029b	41 8d 50 01	 lea	 edx, DWORD PTR [r8+1]
  0029f	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
  002a3	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ; ImVector<ImFontGlyph>::resize
$LN12@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  002a8	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  002ab	85 c0		 test	 eax, eax
  002ad	7f 1d		 jg	 SHORT $LN73@BuildLooku
  002af	41 b8 0b 07 00
	00		 mov	 r8d, 1803		; 0000070bH
  002b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  002c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002c9	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
$LN73@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3314 :     if (c >= (size_t)IndexLookup.Size)

  002cc	83 7b 18 20	 cmp	 DWORD PTR [rbx+24], 32	; 00000020H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  002d0	4c 8b 73 30	 mov	 r14, QWORD PTR [rbx+48]
  002d4	48 98		 cdqe
  002d6	48 8d 34 80	 lea	 rsi, QWORD PTR [rax+rax*4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3314 :     if (c >= (size_t)IndexLookup.Size)

  002da	77 06		 ja	 SHORT $LN75@BuildLooku

; 3315 :         return FallbackGlyph;

  002dc	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  002e0	eb 1f		 jmp	 SHORT $LN74@BuildLooku
$LN75@BuildLooku:

; 3316 :     const ImWchar i = IndexLookup.Data[c];

  002e2	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  002e6	0f b7 48 40	 movzx	 ecx, WORD PTR [rax+64]

; 3317 :     if (i == (ImWchar)-1)

  002ea	66 3b cf	 cmp	 cx, di
  002ed	75 06		 jne	 SHORT $LN76@BuildLooku

; 3318 :         return FallbackGlyph;

  002ef	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  002f3	eb 0c		 jmp	 SHORT $LN74@BuildLooku
$LN76@BuildLooku:

; 3319 :     return &Glyphs.Data[i];

  002f5	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  002f9	48 8d 0c 89	 lea	 rcx, QWORD PTR [rcx+rcx*4]
  002fd	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
$LN74@BuildLooku:

; 3180 :         ImFontGlyph& tab_glyph = Glyphs.back();
; 3181 :         tab_glyph = *FindGlyph((ImWchar)' ');

  00301	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00304	41 0f 11 44 f6
	d8		 movups	 XMMWORD PTR [r14+rsi*8-40], xmm0
  0030a	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0030e	41 0f 11 4c f6
	e8		 movups	 XMMWORD PTR [r14+rsi*8-24], xmm1
  00314	f2 0f 10 40 20	 movsd	 xmm0, QWORD PTR [rax+32]
  00319	f2 41 0f 11 44
	f6 f8		 movsd	 QWORD PTR [r14+rsi*8-8], xmm0

; 3182 :         tab_glyph.Codepoint = '\t';

  00320	41 8b 7c f6 d8	 mov	 edi, DWORD PTR [r14+rsi*8-40]

; 3183 :         tab_glyph.AdvanceX *= IM_TABSIZE;

  00325	f3 41 0f 10 74
	f6 dc		 movss	 xmm6, DWORD PTR [r14+rsi*8-36]
  0032c	83 e7 03	 and	 edi, 3
  0032f	f3 0f 59 35 00
	00 00 00	 mulss	 xmm6, DWORD PTR __real@40800000
  00337	83 cf 24	 or	 edi, 36			; 00000024H
  0033a	41 89 7c f6 d8	 mov	 DWORD PTR [r14+rsi*8-40], edi

; 3184 :         IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;

  0033f	c1 ef 02	 shr	 edi, 2
  00342	f3 41 0f 11 74
	f6 dc		 movss	 DWORD PTR [r14+rsi*8-36], xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00349	3b 3b		 cmp	 edi, DWORD PTR [rbx]
  0034b	7c 1a		 jl	 SHORT $LN81@BuildLooku
  0034d	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00353	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN81@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3184 :         IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;

  00367	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0036b	f3 0f 11 34 b8	 movss	 DWORD PTR [rax+rdi*4], xmm6

; 3185 :         IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);

  00370	44 0f b7 7b 28	 movzx	 r15d, WORD PTR [rbx+40]
  00375	41 8b 7c f6 d8	 mov	 edi, DWORD PTR [r14+rsi*8-40]
  0037a	66 41 ff cf	 dec	 r15w
  0037e	c1 ef 02	 shr	 edi, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00381	3b 7b 18	 cmp	 edi, DWORD PTR [rbx+24]
  00384	7c 1a		 jl	 SHORT $LN85@BuildLooku
  00386	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0038c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00393	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0039a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN85@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3185 :         IndexLookup[(int)tab_glyph.Codepoint] = (ImWchar)(Glyphs.Size - 1);

  003a0	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  003a4	66 44 89 3c 78	 mov	 WORD PTR [rax+rdi*2], r15w
  003a9	4c 8b 4b 38	 mov	 r9, QWORD PTR [rbx+56]
  003ad	49 8b d1	 mov	 rdx, r9
$LN11@BuildLooku:

; 3314 :     if (c >= (size_t)IndexLookup.Size)

  003b0	44 8b 43 18	 mov	 r8d, DWORD PTR [rbx+24]
  003b4	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  003b9	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]
  003be	4c 8b b4 24 a8
	00 00 00	 mov	 r14, QWORD PTR [rsp+168]
  003c6	41 83 f8 20	 cmp	 r8d, 32			; 00000020H
  003ca	77 08		 ja	 SHORT $LN90@BuildLooku

; 3315 :         return FallbackGlyph;

  003cc	48 8b c2	 mov	 rax, rdx
  003cf	4c 8b ca	 mov	 r9, rdx
  003d2	eb 21		 jmp	 SHORT $LN89@BuildLooku
$LN90@BuildLooku:

; 3316 :     const ImWchar i = IndexLookup.Data[c];

  003d4	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  003d8	0f b7 48 40	 movzx	 ecx, WORD PTR [rax+64]

; 3317 :     if (i == (ImWchar)-1)

  003dc	66 3b ce	 cmp	 cx, si
  003df	75 08		 jne	 SHORT $LN91@BuildLooku

; 3318 :         return FallbackGlyph;

  003e1	48 8b c2	 mov	 rax, rdx
  003e4	4c 8b ca	 mov	 r9, rdx
  003e7	eb 0c		 jmp	 SHORT $LN89@BuildLooku
$LN91@BuildLooku:

; 3319 :     return &Glyphs.Data[i];

  003e9	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003ed	48 8d 0c 89	 lea	 rcx, QWORD PTR [rcx+rcx*4]
  003f1	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
$LN89@BuildLooku:

; 3237 :     if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))

  003f5	48 85 c0	 test	 rax, rax
  003f8	74 0e		 je	 SHORT $LN87@BuildLooku

; 3238 :         glyph->Visible = visible ? 1 : 0;

  003fa	83 20 fd	 and	 DWORD PTR [rax], -3	; fffffffdH
  003fd	4c 8b 4b 38	 mov	 r9, QWORD PTR [rbx+56]
  00401	44 8b 43 18	 mov	 r8d, DWORD PTR [rbx+24]
  00405	49 8b d1	 mov	 rdx, r9
$LN87@BuildLooku:

; 3314 :     if (c >= (size_t)IndexLookup.Size)

  00408	41 83 f8 09	 cmp	 r8d, 9
  0040c	76 1e		 jbe	 SHORT $LN96@BuildLooku

; 3316 :     const ImWchar i = IndexLookup.Data[c];

  0040e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00412	0f b7 48 12	 movzx	 ecx, WORD PTR [rax+18]

; 3317 :     if (i == (ImWchar)-1)

  00416	66 3b ce	 cmp	 cx, si
  00419	75 05		 jne	 SHORT $LN98@BuildLooku

; 3318 :         return FallbackGlyph;

  0041b	49 8b d1	 mov	 rdx, r9
  0041e	eb 0c		 jmp	 SHORT $LN96@BuildLooku
$LN98@BuildLooku:

; 3319 :     return &Glyphs.Data[i];

  00420	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00424	48 8d 0c 89	 lea	 rcx, QWORD PTR [rcx+rcx*4]
  00428	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
$LN96@BuildLooku:

; 3237 :     if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))

  0042c	48 85 d2	 test	 rdx, rdx
  0042f	74 03		 je	 SHORT $LN94@BuildLooku

; 3238 :         glyph->Visible = visible ? 1 : 0;

  00431	83 22 fd	 and	 DWORD PTR [rdx], -3	; fffffffdH
$LN94@BuildLooku:

; 3186 :     }
; 3187 : 
; 3188 :     // Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
; 3189 :     SetGlyphVisible((ImWchar)' ', false);
; 3190 :     SetGlyphVisible((ImWchar)'\t', false);
; 3191 : 
; 3192 :     // Ellipsis character is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
; 3193 :     // However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
; 3194 :     // FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
; 3195 :     const ImWchar ellipsis_chars[] = { (ImWchar)0x2026, (ImWchar)0x0085 };

  00434	c7 44 24 20 26
	20 85 00	 mov	 DWORD PTR ellipsis_chars$[rsp], 8724518 ; 00852026H

; 3196 :     const ImWchar dots_chars[] = { (ImWchar)'.', (ImWchar)0xFF0E };

  0043c	c7 44 24 24 2e
	00 0e ff	 mov	 DWORD PTR dots_chars$[rsp], -15859666 ; ff0e002eH

; 3197 :     if (EllipsisChar == (ImWchar)-1)

  00444	66 39 73 54	 cmp	 WORD PTR [rbx+84], si
  00448	75 43		 jne	 SHORT $LN13@BuildLooku
  0044a	4c 63 53 18	 movsxd	 r10, DWORD PTR [rbx+24]

; 3329 :     return &Glyphs.Data[i];

  0044e	48 8b d5	 mov	 rdx, rbp
$LL103@BuildLooku:

; 3145 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

  00451	44 0f b7 4c 54
	20		 movzx	 r9d, WORD PTR ellipsis_chars$[rsp+rdx*2]

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  00457	4d 3b ca	 cmp	 r9, r10
  0045a	73 20		 jae	 SHORT $LN179@BuildLooku

; 3326 :     const ImWchar i = IndexLookup.Data[c];

  0045c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00460	46 0f b7 04 48	 movzx	 r8d, WORD PTR [rax+r9*2]

; 3327 :     if (i == (ImWchar)-1)

  00465	66 44 3b c6	 cmp	 r8w, si
  00469	74 11		 je	 SHORT $LN179@BuildLooku

; 3329 :     return &Glyphs.Data[i];

  0046b	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0046f	4b 8d 0c 80	 lea	 rcx, QWORD PTR [r8+r8*4]
  00473	48 8d 0c c8	 lea	 rcx, QWORD PTR [rax+rcx*8]

; 3145 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

  00477	48 85 c9	 test	 rcx, rcx
  0047a	75 0c		 jne	 SHORT $LN100@BuildLooku
$LN179@BuildLooku:

; 3144 :     for (int n = 0; n < candidate_chars_count; n++)

  0047c	48 ff c2	 inc	 rdx
  0047f	48 83 fa 02	 cmp	 rdx, 2
  00483	7c cc		 jl	 SHORT $LL103@BuildLooku

; 3146 :             return candidate_chars[n];
; 3147 :     return (ImWchar)-1;

  00485	44 8b ce	 mov	 r9d, esi
$LN100@BuildLooku:

; 3198 :         EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars, IM_ARRAYSIZE(ellipsis_chars));

  00488	66 44 89 4b 54	 mov	 WORD PTR [rbx+84], r9w
$LN13@BuildLooku:

; 3199 :     if (DotChar == (ImWchar)-1)

  0048d	66 39 73 56	 cmp	 WORD PTR [rbx+86], si
  00491	75 49		 jne	 SHORT $LN14@BuildLooku
  00493	4c 63 53 18	 movsxd	 r10, DWORD PTR [rbx+24]

; 3329 :     return &Glyphs.Data[i];

  00497	48 8b d5	 mov	 rdx, rbp
  0049a	66 0f 1f 44 00
	00		 npad	 6
$LL113@BuildLooku:

; 3145 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

  004a0	44 0f b7 4c 54
	24		 movzx	 r9d, WORD PTR dots_chars$[rsp+rdx*2]

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  004a6	4d 3b ca	 cmp	 r9, r10
  004a9	73 20		 jae	 SHORT $LN180@BuildLooku

; 3326 :     const ImWchar i = IndexLookup.Data[c];

  004ab	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  004af	46 0f b7 04 48	 movzx	 r8d, WORD PTR [rax+r9*2]

; 3327 :     if (i == (ImWchar)-1)

  004b4	66 44 3b c6	 cmp	 r8w, si
  004b8	74 11		 je	 SHORT $LN180@BuildLooku

; 3329 :     return &Glyphs.Data[i];

  004ba	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004be	4b 8d 0c 80	 lea	 rcx, QWORD PTR [r8+r8*4]
  004c2	48 8d 0c c8	 lea	 rcx, QWORD PTR [rax+rcx*8]

; 3145 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

  004c6	48 85 c9	 test	 rcx, rcx
  004c9	75 0c		 jne	 SHORT $LN110@BuildLooku
$LN180@BuildLooku:

; 3144 :     for (int n = 0; n < candidate_chars_count; n++)

  004cb	48 ff c2	 inc	 rdx
  004ce	48 83 fa 02	 cmp	 rdx, 2
  004d2	7c cc		 jl	 SHORT $LL113@BuildLooku

; 3146 :             return candidate_chars[n];
; 3147 :     return (ImWchar)-1;

  004d4	44 8b ce	 mov	 r9d, esi
$LN110@BuildLooku:

; 3200 :         DotChar = FindFirstExistingGlyph(this, dots_chars, IM_ARRAYSIZE(dots_chars));

  004d7	66 44 89 4b 56	 mov	 WORD PTR [rbx+86], r9w
$LN14@BuildLooku:

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  004dc	4c 63 53 18	 movsxd	 r10, DWORD PTR [rbx+24]
  004e0	48 8d 7b 38	 lea	 rdi, QWORD PTR [rbx+56]
  004e4	0f b7 4b 52	 movzx	 ecx, WORD PTR [rbx+82]

; 3201 : 
; 3202 :     // Setup fallback character
; 3203 :     const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };

  004e8	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  004ed	c7 44 24 24 fd
	ff 3f 00	 mov	 DWORD PTR fallback_chars$[rsp], 4194301 ; 003ffffdH

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  004f5	4c 8b df	 mov	 r11, rdi

; 3201 : 
; 3202 :     // Setup fallback character
; 3203 :     const ImWchar fallback_chars[] = { (ImWchar)IM_UNICODE_CODEPOINT_INVALID, (ImWchar)'?', (ImWchar)' ' };

  004f8	66 89 44 24 28	 mov	 WORD PTR fallback_chars$[rsp+4], ax

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  004fd	49 3b ca	 cmp	 rcx, r10
  00500	72 05		 jb	 SHORT $LN121@BuildLooku

; 3325 :         return NULL;

  00502	48 89 2f	 mov	 QWORD PTR [rdi], rbp
  00505	eb 2a		 jmp	 SHORT $LN188@BuildLooku
$LN121@BuildLooku:

; 3326 :     const ImWchar i = IndexLookup.Data[c];

  00507	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0050b	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]

; 3327 :     if (i == (ImWchar)-1)

  0050f	66 3b ce	 cmp	 cx, si
  00512	75 05		 jne	 SHORT $LN122@BuildLooku

; 3328 :         return NULL;

  00514	48 89 2f	 mov	 QWORD PTR [rdi], rbp
  00517	eb 18		 jmp	 SHORT $LN188@BuildLooku
$LN122@BuildLooku:

; 3329 :     return &Glyphs.Data[i];

  00519	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0051d	48 8d 0c 89	 lea	 rcx, QWORD PTR [rcx+rcx*4]
  00521	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]

; 3204 :     FallbackGlyph = FindGlyphNoFallback(FallbackChar);

  00525	48 89 17	 mov	 QWORD PTR [rdi], rdx

; 3205 :     if (FallbackGlyph == NULL)

  00528	48 85 d2	 test	 rdx, rdx
  0052b	0f 85 b0 00 00
	00		 jne	 $LN16@BuildLooku
$LN188@BuildLooku:

; 3329 :     return &Glyphs.Data[i];

  00531	48 8b d5	 mov	 rdx, rbp
$LL127@BuildLooku:

; 3145 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

  00534	44 0f b7 4c 54
	24		 movzx	 r9d, WORD PTR fallback_chars$[rsp+rdx*2]

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  0053a	4d 3b ca	 cmp	 r9, r10
  0053d	73 20		 jae	 SHORT $LN181@BuildLooku

; 3326 :     const ImWchar i = IndexLookup.Data[c];

  0053f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00543	46 0f b7 04 48	 movzx	 r8d, WORD PTR [rax+r9*2]

; 3327 :     if (i == (ImWchar)-1)

  00548	66 44 3b c6	 cmp	 r8w, si
  0054c	74 11		 je	 SHORT $LN181@BuildLooku

; 3329 :     return &Glyphs.Data[i];

  0054e	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00552	4b 8d 0c 80	 lea	 rcx, QWORD PTR [r8+r8*4]
  00556	48 8d 0c c8	 lea	 rcx, QWORD PTR [rax+rcx*8]

; 3145 :         if (font->FindGlyphNoFallback(candidate_chars[n]) != NULL)

  0055a	48 85 c9	 test	 rcx, rcx
  0055d	75 0c		 jne	 SHORT $LN124@BuildLooku
$LN181@BuildLooku:

; 3144 :     for (int n = 0; n < candidate_chars_count; n++)

  0055f	48 ff c2	 inc	 rdx
  00562	48 83 fa 03	 cmp	 rdx, 3
  00566	7c cc		 jl	 SHORT $LL127@BuildLooku

; 3146 :             return candidate_chars[n];
; 3147 :     return (ImWchar)-1;

  00568	44 8b ce	 mov	 r9d, esi
$LN124@BuildLooku:

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  0056b	41 0f b7 c9	 movzx	 ecx, r9w

; 3206 :     {
; 3207 :         FallbackChar = FindFirstExistingGlyph(this, fallback_chars, IM_ARRAYSIZE(fallback_chars));

  0056f	66 44 89 4b 52	 mov	 WORD PTR [rbx+82], r9w

; 3324 :     if (c >= (size_t)IndexLookup.Size)

  00574	49 3b ca	 cmp	 rcx, r10
  00577	73 23		 jae	 SHORT $LN189@BuildLooku

; 3326 :     const ImWchar i = IndexLookup.Data[c];

  00579	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0057d	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]

; 3327 :     if (i == (ImWchar)-1)

  00581	66 3b d6	 cmp	 dx, si
  00584	74 16		 je	 SHORT $LN189@BuildLooku

; 3329 :     return &Glyphs.Data[i];

  00586	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0058a	48 8d 0c 92	 lea	 rcx, QWORD PTR [rdx+rdx*4]
  0058e	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]

; 3208 :         FallbackGlyph = FindGlyphNoFallback(FallbackChar);

  00592	48 89 17	 mov	 QWORD PTR [rdi], rdx

; 3209 :         if (FallbackGlyph == NULL)

  00595	48 85 d2	 test	 rdx, rdx
  00598	75 47		 jne	 SHORT $LN16@BuildLooku
  0059a	eb 03		 jmp	 SHORT $LN187@BuildLooku
$LN189@BuildLooku:

; 3328 :         return NULL;

  0059c	49 89 2b	 mov	 QWORD PTR [r11], rbp
$LN187@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  0059f	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  005a2	85 c0		 test	 eax, eax
  005a4	7f 1d		 jg	 SHORT $LN140@BuildLooku
  005a6	41 b8 0b 07 00
	00		 mov	 r8d, 1803		; 0000070bH
  005ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  005b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  005ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005c0	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
$LN140@BuildLooku:
  005c3	48 98		 cdqe
  005c5	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]
  005c9	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  005cd	48 8d 52 fb	 lea	 rdx, QWORD PTR [rdx-5]
  005d1	48 8d 14 d0	 lea	 rdx, QWORD PTR [rax+rdx*8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3211 :             FallbackGlyph = &Glyphs.back();

  005d5	48 89 17	 mov	 QWORD PTR [rdi], rdx

; 3212 :             FallbackChar = (ImWchar)FallbackGlyph->Codepoint;

  005d8	8b 02		 mov	 eax, DWORD PTR [rdx]
  005da	c1 e8 02	 shr	 eax, 2
  005dd	66 89 43 52	 mov	 WORD PTR [rbx+82], ax
$LN16@BuildLooku:

; 3213 :         }
; 3214 :     }
; 3215 : 
; 3216 :     FallbackAdvanceX = FallbackGlyph->AdvanceX;

  005e1	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]

; 3217 :     for (int i = 0; i < max_codepoint + 1; i++)

  005e4	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR [rsp+152]
  005ec	49 63 f5	 movsxd	 rsi, r13d
  005ef	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR [rsp+160]
  005f7	89 43 10	 mov	 DWORD PTR [rbx+16], eax
  005fa	48 85 f6	 test	 rsi, rsi
  005fd	7e 74		 jle	 SHORT $LN9@BuildLooku

; 3219 :             IndexAdvanceX[i] = FallbackAdvanceX;

  005ff	0f 29 7c 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm7
  00604	48 8b fd	 mov	 rdi, rbp
  00607	0f 57 ff	 xorps	 xmm7, xmm7
  0060a	66 0f 1f 44 00
	00		 npad	 6
$LL10@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  00610	3b 2b		 cmp	 ebp, DWORD PTR [rbx]
  00612	7c 1a		 jl	 SHORT $LN144@BuildLooku
  00614	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0061a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00621	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00628	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN144@BuildLooku:
  0062e	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3218 :         if (IndexAdvanceX[i] < 0.0f)

  00632	0f 2f 3c b8	 comiss	 xmm7, DWORD PTR [rax+rdi*4]
  00636	76 2c		 jbe	 SHORT $LN8@BuildLooku

; 3219 :             IndexAdvanceX[i] = FallbackAdvanceX;

  00638	f3 0f 10 73 10	 movss	 xmm6, DWORD PTR [rbx+16]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  0063d	3b 2b		 cmp	 ebp, DWORD PTR [rbx]
  0063f	7c 1e		 jl	 SHORT $LN185@BuildLooku
  00641	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00647	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0064e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00655	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0065b	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
$LN185@BuildLooku:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3219 :             IndexAdvanceX[i] = FallbackAdvanceX;

  0065f	f3 0f 11 34 b8	 movss	 DWORD PTR [rax+rdi*4], xmm6
$LN8@BuildLooku:

; 3217 :     for (int i = 0; i < max_codepoint + 1; i++)

  00664	ff c5		 inc	 ebp
  00666	48 ff c7	 inc	 rdi
  00669	48 3b fe	 cmp	 rdi, rsi
  0066c	7c a2		 jl	 SHORT $LL10@BuildLooku
  0066e	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]
$LN9@BuildLooku:
  00673	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]

; 3220 : }

  00678	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0067d	48 33 cc	 xor	 rcx, rsp
  00680	e8 00 00 00 00	 call	 __security_check_cookie
  00685	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00689	5f		 pop	 rdi
  0068a	5e		 pop	 rsi
  0068b	5d		 pop	 rbp
  0068c	5b		 pop	 rbx
  0068d	c3		 ret	 0
?BuildLookupTable@ImFont@@QEAAXXZ ENDP			; ImFont::BuildLookupTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 8
c$ = 16
visible$dead$ = 24
?SetGlyphVisible@ImFont@@QEAAXG_N@Z PROC		; ImFont::SetGlyphVisible

; 3236 : {

  00000	4c 8b c1	 mov	 r8, rcx

; 3314 :     if (c >= (size_t)IndexLookup.Size)

  00003	0f b7 ca	 movzx	 ecx, dx
  00006	49 63 40 18	 movsxd	 rax, DWORD PTR [r8+24]
  0000a	48 3b c8	 cmp	 rcx, rax
  0000d	72 06		 jb	 SHORT $LN5@SetGlyphVi

; 3315 :         return FallbackGlyph;

  0000f	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00013	eb 24		 jmp	 SHORT $LN4@SetGlyphVi
$LN5@SetGlyphVi:

; 3316 :     const ImWchar i = IndexLookup.Data[c];

  00015	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00019	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]

; 3317 :     if (i == (ImWchar)-1)

  0001d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00022	66 3b c8	 cmp	 cx, ax
  00025	75 06		 jne	 SHORT $LN6@SetGlyphVi

; 3318 :         return FallbackGlyph;

  00027	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  0002b	eb 0c		 jmp	 SHORT $LN4@SetGlyphVi
$LN6@SetGlyphVi:

; 3319 :     return &Glyphs.Data[i];

  0002d	49 8b 40 30	 mov	 rax, QWORD PTR [r8+48]
  00031	48 8d 0c 89	 lea	 rcx, QWORD PTR [rcx+rcx*4]
  00035	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
$LN4@SetGlyphVi:

; 3237 :     if (ImFontGlyph* glyph = (ImFontGlyph*)(void*)FindGlyph((ImWchar)c))

  00039	48 85 c0	 test	 rax, rax
  0003c	74 03		 je	 SHORT $LN2@SetGlyphVi

; 3238 :         glyph->Visible = visible ? 1 : 0;

  0003e	83 20 fd	 and	 DWORD PTR [rax], -3	; fffffffdH
$LN2@SetGlyphVi:

; 3239 : }

  00041	c3		 ret	 0
?SetGlyphVisible@ImFont@@QEAAXG_N@Z ENDP		; ImFont::SetGlyphVisible
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
$T1 = 72
new_size$ = 72
?GrowIndex@ImFont@@QEAAXH@Z PROC			; ImFont::GrowIndex

; 3242 : {

$LN36:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3243 :     IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);

  00008	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000b	48 8b f9	 mov	 rdi, rcx
  0000e	48 63 da	 movsxd	 rbx, edx
  00011	39 01		 cmp	 DWORD PTR [rcx], eax
  00013	74 1d		 je	 SHORT $LN4@GrowIndex
  00015	41 b8 ab 0c 00
	00		 mov	 r8d, 3243		; 00000cabH
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@HLFAHELG@?$AAI?$AAn?$AAd?$AAe?$AAx?$AAA?$AAd?$AAv?$AAa?$AAn?$AAc?$AAe?$AAX?$AA?4?$AAS@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
$LN4@GrowIndex:

; 3244 :     if (new_size <= IndexLookup.Size)

  00032	3b d8		 cmp	 ebx, eax
  00034	0f 8e de 00 00
	00		 jle	 $LN1@GrowIndex

; 3246 :     IndexAdvanceX.resize(new_size, -1.0f);

  0003a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  00042	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3246 :     IndexAdvanceX.resize(new_size, -1.0f);

  00045	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0004a	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  0004f	41 be 08 00 00
	00		 mov	 r14d, 8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3246 :     IndexAdvanceX.resize(new_size, -1.0f);

  00055	f3 0f 11 44 24
	48		 movss	 DWORD PTR $T1[rsp], xmm0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  0005b	3b d9		 cmp	 ebx, ecx
  0005d	7e 21		 jle	 SHORT $LN9@GrowIndex

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0005f	85 c9		 test	 ecx, ecx
  00061	74 0b		 je	 SHORT $LN14@GrowIndex
  00063	8b c1		 mov	 eax, ecx
  00065	99		 cdq
  00066	2b c2		 sub	 eax, edx
  00068	d1 f8		 sar	 eax, 1
  0006a	03 c1		 add	 eax, ecx
  0006c	eb 03		 jmp	 SHORT $LN15@GrowIndex
$LN14@GrowIndex:
  0006e	41 8b c6	 mov	 eax, r14d
$LN15@GrowIndex:
  00071	3b c3		 cmp	 eax, ebx
  00073	8b d3		 mov	 edx, ebx

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  00075	48 8b cf	 mov	 rcx, rdi

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00078	0f 4f d0	 cmovg	 edx, eax

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  0007b	e8 00 00 00 00	 call	 ?reserve@?$ImVector@M@@QEAAXH@Z ; ImVector<float>::reserve
$LN9@GrowIndex:
  00080	48 63 07	 movsxd	 rax, DWORD PTR [rdi]
  00083	3b d8		 cmp	 ebx, eax
  00085	7e 28		 jle	 SHORT $LN7@GrowIndex
  00087	48 8b d0	 mov	 rdx, rax
  0008a	48 3b c3	 cmp	 rax, rbx
  0008d	7d 20		 jge	 SHORT $LN7@GrowIndex
  0008f	8b 44 24 48	 mov	 eax, DWORD PTR $T1[rsp]
  00093	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL8@GrowIndex:
  000a0	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  000a4	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  000a7	48 ff c2	 inc	 rdx
  000aa	48 3b d3	 cmp	 rdx, rbx
  000ad	7c f1		 jl	 SHORT $LL8@GrowIndex
$LN7@GrowIndex:
  000af	89 1f		 mov	 DWORD PTR [rdi], ebx
  000b1	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  000b4	3b d9		 cmp	 ebx, ecx
  000b6	7e 21		 jle	 SHORT $LN20@GrowIndex

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000b8	85 c9		 test	 ecx, ecx
  000ba	74 0b		 je	 SHORT $LN25@GrowIndex
  000bc	8b c1		 mov	 eax, ecx
  000be	99		 cdq
  000bf	2b c2		 sub	 eax, edx
  000c1	d1 f8		 sar	 eax, 1
  000c3	44 8d 34 01	 lea	 r14d, DWORD PTR [rcx+rax]
$LN25@GrowIndex:
  000c7	44 3b f3	 cmp	 r14d, ebx

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  000ca	48 8d 4f 18	 lea	 rcx, QWORD PTR [rdi+24]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  000ce	8b d3		 mov	 edx, ebx
  000d0	41 0f 4f d6	 cmovg	 edx, r14d

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  000d4	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QEAAXH@Z ; ImVector<unsigned short>::reserve
$LN20@GrowIndex:
  000d9	48 63 47 18	 movsxd	 rax, DWORD PTR [rdi+24]
  000dd	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]
  000e2	3b d8		 cmp	 ebx, eax
  000e4	7e 2a		 jle	 SHORT $LN18@GrowIndex
  000e6	48 8b c8	 mov	 rcx, rax
  000e9	48 3b c3	 cmp	 rax, rbx
  000ec	7d 22		 jge	 SHORT $LN18@GrowIndex
  000ee	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000f3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL19@GrowIndex:
  00100	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00104	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
  00108	48 ff c1	 inc	 rcx
  0010b	48 3b cb	 cmp	 rcx, rbx
  0010e	7c f0		 jl	 SHORT $LL19@GrowIndex
$LN18@GrowIndex:
  00110	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00115	89 5f 18	 mov	 DWORD PTR [rdi+24], ebx
$LN1@GrowIndex:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3248 : }

  00118	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011c	5f		 pop	 rdi
  0011d	5e		 pop	 rsi
  0011e	5b		 pop	 rbx
  0011f	c3		 ret	 0
?GrowIndex@ImFont@@QEAAXH@Z ENDP			; ImFont::GrowIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 96
cfg$ = 104
codepoint$ = 112
x0$ = 120
y0$ = 128
x1$ = 136
y1$ = 144
u0$ = 152
v0$ = 160
u1$ = 168
v1$ = 176
advance_x$ = 184
?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z PROC ; ImFont::AddGlyph

; 3254 : {

$LN27:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  00014	48 8b f9	 mov	 rdi, rcx
  00017	0f 29 7c 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm7
  0001c	44 0f 29 44 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm8
  00022	44 0f 28 c3	 movaps	 xmm8, xmm3
  00026	41 0f b7 f0	 movzx	 esi, r8w

; 3255 :     if (cfg != NULL)

  0002a	48 85 d2	 test	 rdx, rdx
  0002d	0f 84 84 00 00
	00		 je	 $LN25@AddGlyph

; 3256 :     {
; 3257 :         // Clamp & recenter if needed
; 3258 :         const float advance_x_original = advance_x;

  00033	f3 0f 10 8c 24
	b8 00 00 00	 movss	 xmm1, DWORD PTR advance_x$[rsp]

; 3259 :         advance_x = ImClamp(advance_x, cfg->GlyphMinAdvanceX, cfg->GlyphMaxAdvanceX);

  0003c	f3 0f 10 72 40	 movss	 xmm6, DWORD PTR [rdx+64]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 426  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00041	0f 2f f1	 comiss	 xmm6, xmm1
  00044	77 09		 ja	 SHORT $LN12@AddGlyph
  00046	f3 0f 10 72 44	 movss	 xmm6, DWORD PTR [rdx+68]
  0004b	f3 0f 5d f1	 minss	 xmm6, xmm1
$LN12@AddGlyph:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3260 :         if (advance_x != advance_x_original)

  0004f	0f 2e f1	 ucomiss xmm6, xmm1
  00052	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f000000
  0005a	7a 11		 jp	 SHORT $LN24@AddGlyph
  0005c	75 0f		 jne	 SHORT $LN24@AddGlyph

; 3264 :             x1 += char_off_x;

  0005e	0f b6 4a 20	 movzx	 ecx, BYTE PTR [rdx+32]
  00062	f3 0f 10 bc 24
	88 00 00 00	 movss	 xmm7, DWORD PTR x1$[rsp]
  0006b	eb 30		 jmp	 SHORT $LN3@AddGlyph
$LN24@AddGlyph:

; 3261 :         {
; 3262 :             float char_off_x = cfg->PixelSnapH ? ImFloor((advance_x - advance_x_original) * 0.5f) : (advance_x - advance_x_original) * 0.5f;

  0006d	0f b6 4a 20	 movzx	 ecx, BYTE PTR [rdx+32]
  00071	0f 28 c6	 movaps	 xmm0, xmm6
  00074	f3 0f 5c c1	 subss	 xmm0, xmm1
  00078	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0007c	84 c9		 test	 cl, cl
  0007e	74 0b		 je	 SHORT $LN6@AddGlyph
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 442  : static inline float  ImFloor(float f) { return (float)(int)(f); }

  00080	f3 0f 2c c0	 cvttss2si eax, xmm0
  00084	66 0f 6e c0	 movd	 xmm0, eax
  00088	0f 5b c0	 cvtdq2ps xmm0, xmm0
$LN6@AddGlyph:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3264 :             x1 += char_off_x;

  0008b	f3 0f 10 bc 24
	88 00 00 00	 movss	 xmm7, DWORD PTR x1$[rsp]
  00094	f3 44 0f 58 c0	 addss	 xmm8, xmm0
  00099	f3 0f 58 f8	 addss	 xmm7, xmm0
$LN3@AddGlyph:

; 3265 :         }
; 3266 : 
; 3267 :         // Snap to pixel
; 3268 :         if (cfg->PixelSnapH)

  0009d	84 c9		 test	 cl, cl
  0009f	74 0f		 je	 SHORT $LN4@AddGlyph

; 3269 :             advance_x = IM_ROUND(advance_x);

  000a1	f3 0f 58 f2	 addss	 xmm6, xmm2
  000a5	f3 0f 2c c6	 cvttss2si eax, xmm6
  000a9	66 0f 6e f0	 movd	 xmm6, eax
  000ad	0f 5b f6	 cvtdq2ps xmm6, xmm6
$LN4@AddGlyph:

; 3270 : 
; 3271 :         // Bake spacing
; 3272 :         advance_x += cfg->GlyphExtraSpacing.x;

  000b0	f3 0f 58 72 24	 addss	 xmm6, DWORD PTR [rdx+36]
  000b5	eb 12		 jmp	 SHORT $LN2@AddGlyph
$LN25@AddGlyph:

; 3255 :     if (cfg != NULL)

  000b7	f3 0f 10 b4 24
	b8 00 00 00	 movss	 xmm6, DWORD PTR advance_x$[rsp]
  000c0	f3 0f 10 bc 24
	88 00 00 00	 movss	 xmm7, DWORD PTR x1$[rsp]
$LN2@AddGlyph:

; 3273 :     }
; 3274 : 
; 3275 :     Glyphs.resize(Glyphs.Size + 1);

  000c9	8b 57 28	 mov	 edx, DWORD PTR [rdi+40]
  000cc	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  000d0	ff c2		 inc	 edx
  000d2	e8 00 00 00 00	 call	 ?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ; ImVector<ImFontGlyph>::resize
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  000d7	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  000da	85 c0		 test	 eax, eax
  000dc	7f 1d		 jg	 SHORT $LN20@AddGlyph
  000de	41 b8 0b 07 00
	00		 mov	 r8d, 1803		; 0000070bH
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f8	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
$LN20@AddGlyph:
  000fb	4c 8b 47 30	 mov	 r8, QWORD PTR [rdi+48]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3277 :     glyph.Codepoint = (unsigned int)codepoint;

  000ff	8b ce		 mov	 ecx, esi

; 3278 :     glyph.Visible = (x0 != x1) && (y0 != y1);

  00101	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR y1$[rsp]
  0010a	f3 0f 10 8c 24
	80 00 00 00	 movss	 xmm1, DWORD PTR y0$[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00113	48 98		 cdqe
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3277 :     glyph.Codepoint = (unsigned int)codepoint;

  00115	c1 e1 02	 shl	 ecx, 2
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

  00118	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3277 :     glyph.Codepoint = (unsigned int)codepoint;

  0011c	41 8b 44 d0 d8	 mov	 eax, DWORD PTR [r8+rdx*8-40]
  00121	83 e0 03	 and	 eax, 3
  00124	0b c8		 or	 ecx, eax

; 3278 :     glyph.Visible = (x0 != x1) && (y0 != y1);

  00126	44 0f 2e c7	 ucomiss xmm8, xmm7
  0012a	7a 02		 jp	 SHORT $LN23@AddGlyph
  0012c	74 07		 je	 SHORT $LN8@AddGlyph
$LN23@AddGlyph:
  0012e	0f 2e c8	 ucomiss xmm1, xmm0
  00131	7a 06		 jp	 SHORT $LN22@AddGlyph
  00133	75 04		 jne	 SHORT $LN22@AddGlyph
$LN8@AddGlyph:
  00135	33 c0		 xor	 eax, eax
  00137	eb 05		 jmp	 SHORT $LN9@AddGlyph
$LN22@AddGlyph:
  00139	b8 02 00 00 00	 mov	 eax, 2
$LN9@AddGlyph:

; 3279 :     glyph.Colored = false;
; 3280 :     glyph.X0 = x0;
; 3281 :     glyph.Y0 = y0;
; 3282 :     glyph.X1 = x1;
; 3283 :     glyph.Y1 = y1;
; 3284 :     glyph.U0 = u0;
; 3285 :     glyph.V0 = v0;
; 3286 :     glyph.U1 = u1;
; 3287 :     glyph.V1 = v1;
; 3288 :     glyph.AdvanceX = advance_x;
; 3289 : 
; 3290 :     // Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
; 3291 :     // We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
; 3292 :     float pad = ContainerAtlas->TexGlyphPadding + 0.99f;
; 3293 :     DirtyLookupTables = true;
; 3294 :     MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + pad) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + pad);
; 3295 : }

  0013e	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00143	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00146	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0014b	0b c8		 or	 ecx, eax
  0014d	f3 41 0f 11 4c
	d0 e4		 movss	 DWORD PTR [r8+rdx*8-28], xmm1
  00154	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00157	f3 0f 10 8c 24
	a0 00 00 00	 movss	 xmm1, DWORD PTR v0$[rsp]
  00160	f3 41 0f 11 44
	d0 ec		 movss	 DWORD PTR [r8+rdx*8-20], xmm0
  00167	f3 0f 10 84 24
	98 00 00 00	 movss	 xmm0, DWORD PTR u0$[rsp]
  00170	f3 41 0f 11 44
	d0 f0		 movss	 DWORD PTR [r8+rdx*8-16], xmm0
  00177	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR u1$[rsp]
  00180	f3 41 0f 11 4c
	d0 f4		 movss	 DWORD PTR [r8+rdx*8-12], xmm1
  00187	f3 0f 10 8c 24
	b0 00 00 00	 movss	 xmm1, DWORD PTR v1$[rsp]
  00190	f3 41 0f 11 44
	d0 f8		 movss	 DWORD PTR [r8+rdx*8-8], xmm0
  00197	f3 41 0f 11 4c
	d0 fc		 movss	 DWORD PTR [r8+rdx*8-4], xmm1
  0019e	41 89 4c d0 d8	 mov	 DWORD PTR [r8+rdx*8-40], ecx
  001a3	f3 45 0f 11 44
	d0 e0		 movss	 DWORD PTR [r8+rdx*8-32], xmm8
  001aa	44 0f 28 44 24
	20		 movaps	 xmm8, XMMWORD PTR [rsp+32]
  001b0	f3 41 0f 11 7c
	d0 e8		 movss	 DWORD PTR [r8+rdx*8-24], xmm7
  001b7	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  001bc	f3 41 0f 11 74
	d0 dc		 movss	 DWORD PTR [r8+rdx*8-36], xmm6
  001c3	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  001c7	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  001cc	66 0f 6e 58 14	 movd	 xmm3, DWORD PTR [rax+20]
  001d1	c6 47 58 01	 mov	 BYTE PTR [rdi+88], 1
  001d5	66 0f 6e 48 34	 movd	 xmm1, DWORD PTR [rax+52]
  001da	f3 41 0f 10 44
	d0 fc		 movss	 xmm0, DWORD PTR [r8+rdx*8-4]
  001e1	f3 41 0f 5c 44
	d0 f4		 subss	 xmm0, DWORD PTR [r8+rdx*8-12]
  001e8	f3 41 0f 10 54
	d0 f8		 movss	 xmm2, DWORD PTR [r8+rdx*8-8]
  001ef	f3 41 0f 5c 54
	d0 f0		 subss	 xmm2, DWORD PTR [r8+rdx*8-16]
  001f6	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001f9	0f 5b db	 cvtdq2ps xmm3, xmm3
  001fc	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00200	66 0f 6e 40 30	 movd	 xmm0, DWORD PTR [rax+48]
  00205	f3 0f 58 1d 00
	00 00 00	 addss	 xmm3, DWORD PTR __real@3f7d70a4
  0020d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00210	f3 0f 58 cb	 addss	 xmm1, xmm3
  00214	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00218	f3 0f 58 d3	 addss	 xmm2, xmm3
  0021c	f3 0f 2c c9	 cvttss2si ecx, xmm1
  00220	f3 0f 2c c2	 cvttss2si eax, xmm2
  00224	0f af c8	 imul	 ecx, eax
  00227	01 4f 68	 add	 DWORD PTR [rdi+104], ecx
  0022a	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0022e	5f		 pop	 rdi
  0022f	c3		 ret	 0
?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z ENDP ; ImFont::AddGlyph
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
this$ = 64
scale$ = 72
text$ = 80
text_end$ = 88
c$1 = 96
wrap_width$ = 96
?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z PROC	; ImFont::CalcWordWrapPositionA

; 3333 : {

$LN44:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3334 :     // Simple word-wrapping for English, not full-featured. Please submit failing cases!
; 3335 :     // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)
; 3336 : 
; 3337 :     // For references, possible wrap point marked with ^
; 3338 :     //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
; 3339 :     //      ^    ^    ^   ^   ^__    ^    ^
; 3340 : 
; 3341 :     // List of hardcoded separators: .,;!?'"
; 3342 : 
; 3343 :     // Skip extra blanks after a line returns (that includes not counting them in width computation)
; 3344 :     // e.g. "Hello    world" --> "Hello" "World"
; 3345 : 
; 3346 :     // Cut words that cannot possibly fit within one line.
; 3347 :     // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"
; 3348 : 
; 3349 :     float line_width = 0.0f;
; 3350 :     float word_width = 0.0f;
; 3351 :     float blank_width = 0.0f;
; 3352 :     wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

  00018	f3 0f 10 6c 24
	60		 movss	 xmm5, DWORD PTR wrap_width$[rsp]

; 3353 : 
; 3354 :     const char* word_end = text;
; 3355 :     const char* prev_word_end = NULL;

  0001e	33 ed		 xor	 ebp, ebp
  00020	4d 8b f9	 mov	 r15, r9
  00023	49 8b f0	 mov	 rsi, r8
  00026	4c 8b f1	 mov	 r14, rcx
  00029	0f 57 e4	 xorps	 xmm4, xmm4
  0002c	0f 57 db	 xorps	 xmm3, xmm3
  0002f	0f 57 d2	 xorps	 xmm2, xmm2

; 3356 :     bool inside_word = true;

  00032	b3 01		 mov	 bl, 1

; 3357 : 
; 3358 :     const char* s = text;

  00034	49 8b f8	 mov	 rdi, r8
  00037	f3 0f 5e e9	 divss	 xmm5, xmm1

; 3359 :     while (s < text_end)

  0003b	4d 3b c1	 cmp	 r8, r9
  0003e	0f 83 42 01 00
	00		 jae	 $LN38@CalcWordWr
  00044	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  00049	49 bc 00 00 00
	00 06 50 00 88	 mov	 r12, -8646823297851326464 ; 8800500600000000H
  00053	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@CalcWordWr:

; 3360 :     {
; 3361 :         unsigned int c = (unsigned int)*s;

  00060	0f be 17	 movsx	 edx, BYTE PTR [rdi]
  00063	89 54 24 60	 mov	 DWORD PTR c$1[rsp], edx
  00067	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H

; 3362 :         const char* next_s;
; 3363 :         if (c < 0x80)

  0006d	73 07		 jae	 SHORT $LN4@CalcWordWr

; 3364 :             next_s = s + 1;

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	eb 16		 jmp	 SHORT $LN5@CalcWordWr
$LN4@CalcWordWr:

; 3365 :         else
; 3366 :             next_s = s + ImTextCharFromUtf8(&c, s, text_end);

  00076	4d 8b c7	 mov	 r8, r15
  00079	48 8d 4c 24 60	 lea	 rcx, QWORD PTR c$1[rsp]
  0007e	48 8b d7	 mov	 rdx, rdi
  00081	e8 00 00 00 00	 call	 ?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z ; ImTextCharFromUtf8
  00086	8b 54 24 60	 mov	 edx, DWORD PTR c$1[rsp]
  0008a	48 98		 cdqe
$LN5@CalcWordWr:

; 3367 :         if (c == 0)

  0008c	4c 8d 04 38	 lea	 r8, QWORD PTR [rax+rdi]
  00090	85 d2		 test	 edx, edx
  00092	0f 84 e9 00 00
	00		 je	 $LN39@CalcWordWr

; 3368 :             break;
; 3369 : 
; 3370 :         if (c < 32)

  00098	83 fa 20	 cmp	 edx, 32			; 00000020H
  0009b	73 1e		 jae	 SHORT $LN9@CalcWordWr

; 3371 :         {
; 3372 :             if (c == '\n')

  0009d	83 fa 0a	 cmp	 edx, 10
  000a0	75 10		 jne	 SHORT $LN8@CalcWordWr

; 3373 :             {
; 3374 :                 line_width = word_width = blank_width = 0.0f;
; 3375 :                 inside_word = true;

  000a2	0f 57 d2	 xorps	 xmm2, xmm2
  000a5	0f 57 db	 xorps	 xmm3, xmm3
  000a8	0f 57 e4	 xorps	 xmm4, xmm4
  000ab	b3 01		 mov	 bl, 1

; 3376 :                 s = next_s;
; 3377 :                 continue;

  000ad	e9 91 00 00 00	 jmp	 $LN31@CalcWordWr
$LN8@CalcWordWr:

; 3378 :             }
; 3379 :             if (c == '\r')

  000b2	83 fa 0d	 cmp	 edx, 13
  000b5	0f 84 88 00 00
	00		 je	 $LN31@CalcWordWr
$LN9@CalcWordWr:

; 3380 :             {
; 3381 :                 s = next_s;
; 3382 :                 continue;
; 3383 :             }
; 3384 :         }
; 3385 : 
; 3386 :         const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX.Data[c] : FallbackAdvanceX);

  000bb	41 3b 16	 cmp	 edx, DWORD PTR [r14]
  000be	7d 0d		 jge	 SHORT $LN18@CalcWordWr
  000c0	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  000c4	8b ca		 mov	 ecx, edx
  000c6	f3 0f 10 04 88	 movss	 xmm0, DWORD PTR [rax+rcx*4]
  000cb	eb 06		 jmp	 SHORT $LN19@CalcWordWr
$LN18@CalcWordWr:
  000cd	f3 41 0f 10 46
	10		 movss	 xmm0, DWORD PTR [r14+16]
$LN19@CalcWordWr:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 336  : static inline bool      ImCharIsBlankW(unsigned int c) { return c == ' ' || c == '\t' || c == 0x3000; }

  000d3	83 fa 20	 cmp	 edx, 32			; 00000020H
  000d6	74 42		 je	 SHORT $LN24@CalcWordWr
  000d8	83 fa 09	 cmp	 edx, 9
  000db	74 3d		 je	 SHORT $LN24@CalcWordWr
  000dd	81 fa 00 30 00
	00		 cmp	 edx, 12288		; 00003000H
  000e3	74 35		 je	 SHORT $LN24@CalcWordWr
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3401 :             if (inside_word)

  000e5	f3 0f 58 d8	 addss	 xmm3, xmm0
  000e9	84 db		 test	 bl, bl
  000eb	75 0e		 jne	 SHORT $LN41@CalcWordWr

; 3402 :             {
; 3403 :                 word_end = next_s;
; 3404 :             }
; 3405 :             else
; 3406 :             {
; 3407 :                 prev_word_end = word_end;
; 3408 :                 line_width += word_width + blank_width;

  000ed	f3 0f 58 d3	 addss	 xmm2, xmm3
  000f1	0f 57 db	 xorps	 xmm3, xmm3
  000f4	f3 0f 58 e2	 addss	 xmm4, xmm2
  000f8	0f 57 d2	 xorps	 xmm2, xmm2
$LN41@CalcWordWr:

; 3409 :                 word_width = blank_width = 0.0f;
; 3410 :             }
; 3411 : 
; 3412 :             // Allow wrapping after punctuation.
; 3413 :             inside_word = (c != '.' && c != ',' && c != ';' && c != '!' && c != '?' && c != '\"');

  000fb	48 0f 44 ee	 cmove	 rbp, rsi
  000ff	49 8b c0	 mov	 rax, r8
  00102	84 db		 test	 bl, bl
  00104	48 0f 44 c6	 cmove	 rax, rsi
  00108	48 8b f0	 mov	 rsi, rax
  0010b	83 fa 3f	 cmp	 edx, 63			; 0000003fH
  0010e	77 06		 ja	 SHORT $LN35@CalcWordWr
  00110	49 0f a3 d4	 bt	 r12, rdx
  00114	72 1f		 jb	 SHORT $LN42@CalcWordWr
$LN35@CalcWordWr:
  00116	b3 01		 mov	 bl, 1
  00118	eb 1d		 jmp	 SHORT $LN21@CalcWordWr
$LN24@CalcWordWr:

; 3387 :         if (ImCharIsBlankW(c))
; 3388 :         {
; 3389 :             if (inside_word)

  0011a	84 db		 test	 bl, bl
  0011c	74 07		 je	 SHORT $LN12@CalcWordWr

; 3390 :             {
; 3391 :                 line_width += blank_width;

  0011e	f3 0f 58 e2	 addss	 xmm4, xmm2
  00122	0f 57 d2	 xorps	 xmm2, xmm2
$LN12@CalcWordWr:

; 3392 :                 blank_width = 0.0f;
; 3393 :                 word_end = s;
; 3394 :             }
; 3395 :             blank_width += char_width;

  00125	84 db		 test	 bl, bl
  00127	f3 0f 58 d0	 addss	 xmm2, xmm0
  0012b	48 8b c7	 mov	 rax, rdi
  0012e	48 0f 44 c6	 cmove	 rax, rsi
  00132	48 8b f0	 mov	 rsi, rax
$LN42@CalcWordWr:

; 3414 :         }
; 3415 : 
; 3416 :         // We ignore blank width at the end of the line (they can be skipped)
; 3417 :         if (line_width + word_width > wrap_width)

  00135	32 db		 xor	 bl, bl
$LN21@CalcWordWr:
  00137	0f 28 c3	 movaps	 xmm0, xmm3
  0013a	f3 0f 58 c4	 addss	 xmm0, xmm4
  0013e	0f 2f c5	 comiss	 xmm0, xmm5
  00141	77 2d		 ja	 SHORT $LN30@CalcWordWr
$LN31@CalcWordWr:

; 3359 :     while (s < text_end)

  00143	49 8b f8	 mov	 rdi, r8
  00146	4d 3b c7	 cmp	 r8, r15
  00149	0f 82 11 ff ff
	ff		 jb	 $LL2@CalcWordWr

; 3422 :             break;
; 3423 :         }
; 3424 : 
; 3425 :         s = next_s;
; 3426 :     }
; 3427 : 
; 3428 :     return s;

  0014f	49 8b c0	 mov	 rax, r8
$LN40@CalcWordWr:
  00152	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
$LN16@CalcWordWr:

; 3429 : }

  00157	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0015c	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00161	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00166	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016a	41 5f		 pop	 r15
  0016c	41 5e		 pop	 r14
  0016e	5f		 pop	 rdi
  0016f	c3		 ret	 0
$LN30@CalcWordWr:

; 3418 :         {
; 3419 :             // Words that cannot possibly fit within an entire line will be cut anywhere.
; 3420 :             if (word_width < wrap_width)

  00170	0f 2f eb	 comiss	 xmm5, xmm3
  00173	76 0c		 jbe	 SHORT $LN39@CalcWordWr

; 3421 :                 s = prev_word_end ? prev_word_end : word_end;

  00175	48 85 ed	 test	 rbp, rbp
  00178	48 0f 45 f5	 cmovne	 rsi, rbp

; 3422 :             break;
; 3423 :         }
; 3424 : 
; 3425 :         s = next_s;
; 3426 :     }
; 3427 : 
; 3428 :     return s;

  0017c	48 8b c6	 mov	 rax, rsi
  0017f	eb d1		 jmp	 SHORT $LN40@CalcWordWr
$LN39@CalcWordWr:
  00181	48 8b c7	 mov	 rax, rdi
  00184	eb cc		 jmp	 SHORT $LN40@CalcWordWr
$LN38@CalcWordWr:
  00186	49 8b c0	 mov	 rax, r8
  00189	eb cc		 jmp	 SHORT $LN16@CalcWordWr
?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ENDP	; ImFont::CalcWordWrapPositionA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
line_height$1$ = 48
col_untinted$1$ = 52
pos$1$ = 56
idx_expected_size$1$ = 64
pos$ = 64
this$ = 304
draw_list$ = 312
size$ = 320
col$ = 336
vtx_current_idx$1$ = 344
c$1 = 344
clip_rect$ = 344
text_begin$ = 352
word_wrap_enabled$1$ = 360
text_end$ = 360
wrap_width$ = 368
cpu_fine_clip$ = 376
?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z PROC ; ImFont::RenderText

; 3544 : {

$LN91:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  00007	53		 push	 rbx
  00008	55		 push	 rbp
  00009	57		 push	 rdi
  0000a	41 54		 push	 r12
  0000c	41 57		 push	 r15
  0000e	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H

; 3545 :     if (!text_end)

  00015	48 8b bc 24 68
	01 00 00	 mov	 rdi, QWORD PTR text_end$[rsp]
  0001d	4c 8b e2	 mov	 r12, rdx
  00020	48 8b 9c 24 60
	01 00 00	 mov	 rbx, QWORD PTR text_begin$[rsp]
  00028	48 8b e9	 mov	 rbp, rcx
  0002b	0f 29 78 a8	 movaps	 XMMWORD PTR [rax-88], xmm7
  0002f	44 0f 29 90 78
	ff ff ff	 movaps	 XMMWORD PTR [rax-136], xmm10
  00037	44 0f 28 d2	 movaps	 xmm10, xmm2
  0003b	44 0f 29 98 68
	ff ff ff	 movaps	 XMMWORD PTR [rax-152], xmm11
  00043	4c 89 4c 24 40	 mov	 QWORD PTR pos$[rsp], r9
  00048	48 85 ff	 test	 rdi, rdi
  0004b	75 13		 jne	 SHORT $LN10@RenderText

; 3546 :         text_end = text_begin + strlen(text_begin); // ImGui:: functions generally already provides a valid text_end, so this is merely to handle direct calls.

  0004d	48 c7 c7 ff ff
	ff ff		 mov	 rdi, -1
$LL81@RenderText:
  00054	48 ff c7	 inc	 rdi
  00057	80 3c 3b 00	 cmp	 BYTE PTR [rbx+rdi], 0
  0005b	75 f7		 jne	 SHORT $LL81@RenderText
  0005d	48 03 fb	 add	 rdi, rbx
$LN10@RenderText:

; 3547 : 
; 3548 :     // Align to be pixel perfect
; 3549 :     pos.x = IM_FLOOR(pos.x);

  00060	f3 0f 2c 44 24
	40		 cvttss2si eax, DWORD PTR pos$[rsp]

; 3550 :     pos.y = IM_FLOOR(pos.y);
; 3551 :     float x = pos.x;
; 3552 :     float y = pos.y;
; 3553 :     if (y > clip_rect.w)

  00066	4c 8b bc 24 58
	01 00 00	 mov	 r15, QWORD PTR clip_rect$[rsp]
  0006e	f3 41 0f 10 7f
	0c		 movss	 xmm7, DWORD PTR [r15+12]
  00074	66 44 0f 6e d8	 movd	 xmm11, eax
  00079	f3 0f 2c 44 24
	44		 cvttss2si eax, DWORD PTR pos$[rsp+4]
  0007f	45 0f 5b db	 cvtdq2ps xmm11, xmm11
  00083	66 0f 6e c8	 movd	 xmm1, eax
  00087	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0008a	f3 44 0f 11 5c
	24 38		 movss	 DWORD PTR pos$1$[rsp], xmm11
  00091	0f 2f cf	 comiss	 xmm1, xmm7
  00094	0f 87 11 06 00
	00		 ja	 $LN1@RenderText

; 3554 :         return;
; 3555 : 
; 3556 :     const float scale = size / FontSize;

  0009a	48 89 b4 24 30
	01 00 00	 mov	 QWORD PTR [rsp+304], rsi
  000a2	0f 57 c0	 xorps	 xmm0, xmm0
  000a5	0f 29 b4 24 e0
	00 00 00	 movaps	 XMMWORD PTR [rsp+224], xmm6

; 3557 :     const float line_height = FontSize * scale;
; 3558 :     const bool word_wrap_enabled = (wrap_width > 0.0f);
; 3559 :     const char* word_wrap_eol = NULL;
; 3560 : 
; 3561 :     // Fast-forward to first visible line
; 3562 :     const char* s = text_begin;
; 3563 :     if (y + line_height < clip_rect.y && !word_wrap_enabled)

  000ad	f3 41 0f 10 77
	04		 movss	 xmm6, DWORD PTR [r15+4]
  000b3	44 0f 29 84 24
	c0 00 00 00	 movaps	 XMMWORD PTR [rsp+192], xmm8
  000bc	f3 44 0f 10 41
	14		 movss	 xmm8, DWORD PTR [rcx+20]
  000c2	f3 45 0f 5e d0	 divss	 xmm10, xmm8
  000c7	44 0f 29 8c 24
	b0 00 00 00	 movaps	 XMMWORD PTR [rsp+176], xmm9
  000d0	44 0f 28 c9	 movaps	 xmm9, xmm1
  000d4	f3 45 0f 59 c2	 mulss	 xmm8, xmm10
  000d9	44 0f 29 a4 24
	80 00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm12
  000e2	f3 44 0f 10 a4
	24 70 01 00 00	 movss	 xmm12, DWORD PTR wrap_width$[rsp]
  000ec	44 0f 2f e0	 comiss	 xmm12, xmm0
  000f0	0f 28 c1	 movaps	 xmm0, xmm1
  000f3	f3 44 0f 11 94
	24 40 01 00 00	 movss	 DWORD PTR size$[rsp], xmm10
  000fd	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  00102	f3 44 0f 11 44
	24 30		 movss	 DWORD PTR line_height$1$[rsp], xmm8
  00109	0f 97 c1	 seta	 cl
  0010c	33 f6		 xor	 esi, esi
  0010e	88 8c 24 68 01
	00 00		 mov	 BYTE PTR word_wrap_enabled$1$[rsp], cl
  00115	0f 2f f0	 comiss	 xmm6, xmm0
  00118	76 49		 jbe	 SHORT $LN3@RenderText
  0011a	84 c9		 test	 cl, cl
  0011c	75 45		 jne	 SHORT $LN3@RenderText
  0011e	66 90		 npad	 2
$LL2@RenderText:

; 3564 :         while (y + line_height < clip_rect.y && s < text_end)

  00120	48 3b df	 cmp	 rbx, rdi
  00123	73 36		 jae	 SHORT $LN82@RenderText

; 3565 :         {
; 3566 :             s = (const char*)memchr(s, '\n', text_end - s);

  00125	4c 8b c7	 mov	 r8, rdi
  00128	ba 0a 00 00 00	 mov	 edx, 10
  0012d	4c 2b c3	 sub	 r8, rbx
  00130	48 8b cb	 mov	 rcx, rbx
  00133	e8 00 00 00 00	 call	 memchr
  00138	48 8b d8	 mov	 rbx, rax

; 3567 :             s = s ? s + 1 : text_end;

  0013b	48 85 c0	 test	 rax, rax
  0013e	74 05		 je	 SHORT $LN40@RenderText
  00140	48 ff c3	 inc	 rbx
  00143	eb 03		 jmp	 SHORT $LN41@RenderText
$LN40@RenderText:
  00145	48 8b df	 mov	 rbx, rdi
$LN41@RenderText:

; 3568 :             y += line_height;

  00148	f3 45 0f 58 c8	 addss	 xmm9, xmm8
  0014d	41 0f 28 c0	 movaps	 xmm0, xmm8
  00151	f3 41 0f 58 c1	 addss	 xmm0, xmm9
  00156	0f 2f f0	 comiss	 xmm6, xmm0
  00159	77 c5		 ja	 SHORT $LL2@RenderText
$LN82@RenderText:
  0015b	0f b6 8c 24 68
	01 00 00	 movzx	 ecx, BYTE PTR word_wrap_enabled$1$[rsp]
$LN3@RenderText:

; 3569 :         }
; 3570 : 
; 3571 :     // For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
; 3572 :     // Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
; 3573 :     if (text_end - s > 10000 && !word_wrap_enabled)

  00163	48 8b c7	 mov	 rax, rdi
  00166	48 2b c3	 sub	 rax, rbx
  00169	48 3d 10 27 00
	00		 cmp	 rax, 10000		; 00002710H
  0016f	7e 43		 jle	 SHORT $LN13@RenderText
  00171	84 c9		 test	 cl, cl
  00173	75 3f		 jne	 SHORT $LN13@RenderText

; 3574 :     {
; 3575 :         const char* s_end = s;
; 3576 :         float y_end = y;
; 3577 :         while (y_end < clip_rect.w && s_end < text_end)

  00175	41 0f 2f f9	 comiss	 xmm7, xmm9
  00179	48 8b c3	 mov	 rax, rbx
  0017c	41 0f 28 f1	 movaps	 xmm6, xmm9
  00180	76 2f		 jbe	 SHORT $LN83@RenderText
$LL4@RenderText:
  00182	48 3b c7	 cmp	 rax, rdi
  00185	73 2a		 jae	 SHORT $LN83@RenderText

; 3578 :         {
; 3579 :             s_end = (const char*)memchr(s_end, '\n', text_end - s_end);

  00187	4c 8b c7	 mov	 r8, rdi
  0018a	ba 0a 00 00 00	 mov	 edx, 10
  0018f	4c 2b c0	 sub	 r8, rax
  00192	48 8b c8	 mov	 rcx, rax
  00195	e8 00 00 00 00	 call	 memchr

; 3580 :             s_end = s_end ? s_end + 1 : text_end;

  0019a	48 85 c0	 test	 rax, rax
  0019d	74 05		 je	 SHORT $LN42@RenderText
  0019f	48 ff c0	 inc	 rax
  001a2	eb 03		 jmp	 SHORT $LN43@RenderText
$LN42@RenderText:
  001a4	48 8b c7	 mov	 rax, rdi
$LN43@RenderText:

; 3581 :             y_end += line_height;

  001a7	f3 41 0f 58 f0	 addss	 xmm6, xmm8
  001ac	0f 2f fe	 comiss	 xmm7, xmm6
  001af	77 d1		 ja	 SHORT $LL4@RenderText
$LN83@RenderText:

; 3582 :         }
; 3583 :         text_end = s_end;

  001b1	48 8b f8	 mov	 rdi, rax
$LN13@RenderText:

; 3584 :     }
; 3585 :     if (s == text_end)

  001b4	48 3b df	 cmp	 rbx, rdi
  001b7	0f 84 c3 04 00
	00		 je	 $LN89@RenderText

; 3586 :         return;
; 3587 : 
; 3588 :     // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
; 3589 :     const int vtx_count_max = (int)(text_end - s) * 4;
; 3590 :     const int idx_count_max = (int)(text_end - s) * 6;
; 3591 :     const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;

  001bd	41 8b 4c 24 10	 mov	 ecx, DWORD PTR [r12+16]
  001c2	44 8b c7	 mov	 r8d, edi
  001c5	44 2b c3	 sub	 r8d, ebx
  001c8	4c 89 ac 24 f8
	00 00 00	 mov	 QWORD PTR [rsp+248], r13
  001d0	4c 89 b4 24 f0
	00 00 00	 mov	 QWORD PTR [rsp+240], r14
  001d8	43 8d 14 40	 lea	 edx, DWORD PTR [r8+r8*2]
  001dc	03 d2		 add	 edx, edx
  001de	46 8d 04 85 00
	00 00 00	 lea	 r8d, DWORD PTR [r8*4]
  001e6	03 ca		 add	 ecx, edx
  001e8	89 4c 24 40	 mov	 DWORD PTR idx_expected_size$1$[rsp], ecx

; 3592 :     draw_list->PrimReserve(idx_count_max, vtx_count_max);

  001ec	49 8b cc	 mov	 rcx, r12
  001ef	e8 00 00 00 00	 call	 ?PrimReserve@ImDrawList@@QEAAXHH@Z ; ImDrawList::PrimReserve

; 3593 : 
; 3594 :     ImDrawVert* vtx_write = draw_list->_VtxWritePtr;
; 3595 :     ImDrawIdx* idx_write = draw_list->_IdxWritePtr;
; 3596 :     unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;

  001f4	41 8b 44 24 34	 mov	 eax, DWORD PTR [r12+52]
  001f9	4d 8b 74 24 48	 mov	 r14, QWORD PTR [r12+72]
  001fe	4d 8b 6c 24 50	 mov	 r13, QWORD PTR [r12+80]
  00203	89 84 24 58 01
	00 00		 mov	 DWORD PTR vtx_current_idx$1$[rsp], eax

; 3597 : 
; 3598 :     const ImU32 col_untinted = col | ~IM_COL32_A_MASK;

  0020a	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR col$[rsp]
  00211	0d ff ff ff 00	 or	 eax, 16777215		; 00ffffffH
  00216	89 44 24 34	 mov	 DWORD PTR col_untinted$1$[rsp], eax

; 3599 : 
; 3600 :     while (s < text_end)

  0021a	48 3b df	 cmp	 rbx, rdi
  0021d	0f 83 cc 03 00
	00		 jae	 $LN80@RenderText
  00223	44 8b a4 24 58
	01 00 00	 mov	 r12d, DWORD PTR vtx_current_idx$1$[rsp]
  0022b	44 0f 29 7c 24
	50		 movaps	 XMMWORD PTR [rsp+80], xmm15
  00231	45 0f 28 fb	 movaps	 xmm15, xmm11
  00235	44 0f 29 6c 24
	70		 movaps	 XMMWORD PTR [rsp+112], xmm13
  0023b	44 0f 29 74 24
	60		 movaps	 XMMWORD PTR [rsp+96], xmm14
$LL6@RenderText:

; 3601 :     {
; 3602 :         if (word_wrap_enabled)

  00241	80 bc 24 68 01
	00 00 00	 cmp	 BYTE PTR word_wrap_enabled$1$[rsp], 0
  00249	74 7d		 je	 SHORT $LN18@RenderText

; 3603 :         {
; 3604 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 3605 :             if (!word_wrap_eol)

  0024b	48 85 f6	 test	 rsi, rsi
  0024e	75 34		 jne	 SHORT $LN17@RenderText

; 3606 :             {
; 3607 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));

  00250	41 0f 28 cf	 movaps	 xmm1, xmm15
  00254	41 0f 28 c4	 movaps	 xmm0, xmm12
  00258	f3 41 0f 5c cb	 subss	 xmm1, xmm11
  0025d	4c 8b cf	 mov	 r9, rdi
  00260	4c 8b c3	 mov	 r8, rbx
  00263	48 8b cd	 mov	 rcx, rbp
  00266	f3 0f 5c c1	 subss	 xmm0, xmm1
  0026a	41 0f 28 ca	 movaps	 xmm1, xmm10
  0026e	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00274	e8 00 00 00 00	 call	 ?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z ; ImFont::CalcWordWrapPositionA
  00279	48 8b f0	 mov	 rsi, rax

; 3608 :                 if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.

  0027c	48 3b c3	 cmp	 rax, rbx
  0027f	75 03		 jne	 SHORT $LN17@RenderText

; 3609 :                     word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below

  00281	48 ff c6	 inc	 rsi
$LN17@RenderText:

; 3610 :             }
; 3611 : 
; 3612 :             if (s >= word_wrap_eol)

  00284	48 3b de	 cmp	 rbx, rsi
  00287	72 3f		 jb	 SHORT $LN18@RenderText

; 3613 :             {
; 3614 :                 x = pos.x;
; 3615 :                 y += line_height;
; 3616 :                 word_wrap_eol = NULL;

  00289	33 f6		 xor	 esi, esi
  0028b	f3 45 0f 58 c8	 addss	 xmm9, xmm8
  00290	45 0f 28 fb	 movaps	 xmm15, xmm11

; 3617 : 
; 3618 :                 // Wrapping skips upcoming blanks
; 3619 :                 while (s < text_end)

  00294	48 3b df	 cmp	 rbx, rdi
  00297	0f 83 30 03 00
	00		 jae	 $LN84@RenderText
  0029d	0f 1f 00	 npad	 3
$LL8@RenderText:

; 3620 :                 {
; 3621 :                     const char c = *s;

  002a0	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 335  : static inline bool      ImCharIsBlankA(char c) { return c == ' ' || c == '\t'; }

  002a3	3c 20		 cmp	 al, 32			; 00000020H
  002a5	74 04		 je	 SHORT $LN46@RenderText
  002a7	3c 09		 cmp	 al, 9
  002a9	75 0d		 jne	 SHORT $LN79@RenderText
$LN46@RenderText:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3622 :                     if (ImCharIsBlankA(c)) { s++; }

  002ab	48 ff c3	 inc	 rbx
  002ae	48 3b df	 cmp	 rbx, rdi
  002b1	72 ed		 jb	 SHORT $LL8@RenderText

; 3617 : 
; 3618 :                 // Wrapping skips upcoming blanks
; 3619 :                 while (s < text_end)

  002b3	e9 15 03 00 00	 jmp	 $LN84@RenderText
$LN79@RenderText:

; 3623 :                     else if (c == '\n') { s++; break; }

  002b8	3c 0a		 cmp	 al, 10
  002ba	0f 85 e9 02 00
	00		 jne	 $LN69@RenderText
  002c0	48 ff c3	 inc	 rbx

; 3624 :                     else { break; }
; 3625 :                 }
; 3626 :                 continue;

  002c3	e9 e1 02 00 00	 jmp	 $LN69@RenderText
$LN18@RenderText:

; 3627 :             }
; 3628 :         }
; 3629 : 
; 3630 :         // Decode and advance source
; 3631 :         unsigned int c = (unsigned int)*s;

  002c8	0f be 03	 movsx	 eax, BYTE PTR [rbx]
  002cb	89 84 24 58 01
	00 00		 mov	 DWORD PTR c$1[rsp], eax

; 3632 :         if (c < 0x80)

  002d2	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002d7	73 05		 jae	 SHORT $LN23@RenderText

; 3633 :         {
; 3634 :             s += 1;

  002d9	48 ff c3	 inc	 rbx

; 3635 :         }

  002dc	eb 28		 jmp	 SHORT $LN25@RenderText
$LN23@RenderText:

; 3636 :         else
; 3637 :         {
; 3638 :             s += ImTextCharFromUtf8(&c, s, text_end);

  002de	4c 8b c7	 mov	 r8, rdi
  002e1	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR c$1[rsp]
  002e9	48 8b d3	 mov	 rdx, rbx
  002ec	e8 00 00 00 00	 call	 ?ImTextCharFromUtf8@@YAHPEAIPEBD1@Z ; ImTextCharFromUtf8
  002f1	48 63 c8	 movsxd	 rcx, eax

; 3639 :             if (c == 0) // Malformed UTF-8?

  002f4	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR c$1[rsp]
  002fb	48 03 d9	 add	 rbx, rcx
  002fe	85 c0		 test	 eax, eax
  00300	0f 84 c7 02 00
	00		 je	 $LN84@RenderText
$LN25@RenderText:

; 3640 :                 break;
; 3641 :         }
; 3642 : 
; 3643 :         if (c < 32)

  00306	83 f8 20	 cmp	 eax, 32			; 00000020H
  00309	73 27		 jae	 SHORT $LN29@RenderText

; 3644 :         {
; 3645 :             if (c == '\n')

  0030b	83 f8 0a	 cmp	 eax, 10
  0030e	75 19		 jne	 SHORT $LN27@RenderText

; 3646 :             {
; 3647 :                 x = pos.x;
; 3648 :                 y += line_height;

  00310	f3 45 0f 58 c8	 addss	 xmm9, xmm8
  00315	45 0f 28 fb	 movaps	 xmm15, xmm11

; 3649 :                 if (y > clip_rect.w)

  00319	45 0f 2f 4f 0c	 comiss	 xmm9, DWORD PTR [r15+12]
  0031e	0f 87 a9 02 00
	00		 ja	 $LN84@RenderText

; 3650 :                     break; // break out of main loop
; 3651 :                 continue;

  00324	e9 80 02 00 00	 jmp	 $LN69@RenderText
$LN27@RenderText:

; 3652 :             }
; 3653 :             if (c == '\r')

  00329	83 f8 0d	 cmp	 eax, 13
  0032c	0f 84 77 02 00
	00		 je	 $LN69@RenderText
$LN29@RenderText:

; 3314 :     if (c >= (size_t)IndexLookup.Size)

  00332	0f b7 c8	 movzx	 ecx, ax
  00335	48 63 45 18	 movsxd	 rax, DWORD PTR [rbp+24]
  00339	48 3b c8	 cmp	 rcx, rax
  0033c	72 06		 jb	 SHORT $LN49@RenderText

; 3315 :         return FallbackGlyph;

  0033e	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]
  00342	eb 24		 jmp	 SHORT $LN48@RenderText
$LN49@RenderText:

; 3316 :     const ImWchar i = IndexLookup.Data[c];

  00344	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00348	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]

; 3317 :     if (i == (ImWchar)-1)

  0034c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00351	66 3b d0	 cmp	 dx, ax
  00354	75 06		 jne	 SHORT $LN50@RenderText

; 3318 :         return FallbackGlyph;

  00356	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]
  0035a	eb 0c		 jmp	 SHORT $LN48@RenderText
$LN50@RenderText:

; 3319 :     return &Glyphs.Data[i];

  0035c	48 8b 45 30	 mov	 rax, QWORD PTR [rbp+48]
  00360	48 8d 0c 92	 lea	 rcx, QWORD PTR [rdx+rdx*4]
  00364	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
$LN48@RenderText:

; 3654 :                 continue;
; 3655 :         }
; 3656 : 
; 3657 :         const ImFontGlyph* glyph = FindGlyph((ImWchar)c);
; 3658 :         if (glyph == NULL)

  00368	48 85 c0	 test	 rax, rax
  0036b	0f 84 38 02 00
	00		 je	 $LN69@RenderText

; 3659 :             continue;
; 3660 : 
; 3661 :         float char_width = glyph->AdvanceX * scale;
; 3662 :         if (glyph->Visible)

  00371	8b 08		 mov	 ecx, DWORD PTR [rax]
  00373	45 0f 28 c2	 movaps	 xmm8, xmm10
  00377	f3 44 0f 59 40
	04		 mulss	 xmm8, DWORD PTR [rax+4]
  0037d	f6 c1 02	 test	 cl, 2
  00380	0f 84 17 02 00
	00		 je	 $LN32@RenderText

; 3663 :         {
; 3664 :             // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
; 3665 :             float x1 = x + glyph->X0 * scale;
; 3666 :             float x2 = x + glyph->X1 * scale;
; 3667 :             float y1 = y + glyph->Y0 * scale;
; 3668 :             float y2 = y + glyph->Y1 * scale;
; 3669 :             if (x1 <= clip_rect.z && x2 >= clip_rect.x)

  00386	f3 45 0f 10 67
	08		 movss	 xmm12, DWORD PTR [r15+8]
  0038c	41 0f 28 fa	 movaps	 xmm7, xmm10
  00390	f3 0f 59 78 08	 mulss	 xmm7, DWORD PTR [rax+8]
  00395	41 0f 28 da	 movaps	 xmm3, xmm10
  00399	f3 0f 59 58 10	 mulss	 xmm3, DWORD PTR [rax+16]
  0039e	41 0f 28 f2	 movaps	 xmm6, xmm10
  003a2	f3 0f 59 70 0c	 mulss	 xmm6, DWORD PTR [rax+12]
  003a7	f3 41 0f 58 ff	 addss	 xmm7, xmm15
  003ac	41 0f 28 e2	 movaps	 xmm4, xmm10
  003b0	f3 41 0f 58 df	 addss	 xmm3, xmm15
  003b5	f3 0f 59 60 14	 mulss	 xmm4, DWORD PTR [rax+20]
  003ba	44 0f 2f e7	 comiss	 xmm12, xmm7
  003be	f3 41 0f 58 f1	 addss	 xmm6, xmm9
  003c3	f3 41 0f 58 e1	 addss	 xmm4, xmm9
  003c8	0f 82 cf 01 00
	00		 jb	 $LN32@RenderText
  003ce	f3 41 0f 10 2f	 movss	 xmm5, DWORD PTR [r15]
  003d3	0f 2f dd	 comiss	 xmm3, xmm5
  003d6	0f 82 c1 01 00
	00		 jb	 $LN32@RenderText

; 3670 :             {
; 3671 :                 // Render a character
; 3672 :                 float u1 = glyph->U0;
; 3673 :                 float v1 = glyph->V0;
; 3674 :                 float u2 = glyph->U1;
; 3675 :                 float v2 = glyph->V1;
; 3676 : 
; 3677 :                 // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
; 3678 :                 if (cpu_fine_clip)

  003dc	80 bc 24 78 01
	00 00 00	 cmp	 BYTE PTR cpu_fine_clip$[rsp], 0
  003e4	f3 44 0f 10 68
	18		 movss	 xmm13, DWORD PTR [rax+24]
  003ea	f3 44 0f 10 70
	1c		 movss	 xmm14, DWORD PTR [rax+28]
  003f0	f3 44 0f 10 50
	20		 movss	 xmm10, DWORD PTR [rax+32]
  003f6	f3 44 0f 10 58
	24		 movss	 xmm11, DWORD PTR [rax+36]
  003fc	0f 84 e4 00 00
	00		 je	 $LN38@RenderText

; 3679 :                 {
; 3680 :                     if (x1 < clip_rect.x)

  00402	0f 2f ef	 comiss	 xmm5, xmm7
  00405	76 33		 jbe	 SHORT $LN34@RenderText

; 3681 :                     {
; 3682 :                         u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);

  00407	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0040f	0f 28 c3	 movaps	 xmm0, xmm3
  00412	f3 0f 5c c7	 subss	 xmm0, xmm7
  00416	0f 28 d3	 movaps	 xmm2, xmm3
  00419	f3 0f 5c d5	 subss	 xmm2, xmm5

; 3683 :                         x1 = clip_rect.x;

  0041d	0f 28 fd	 movaps	 xmm7, xmm5
  00420	f3 0f 5e d0	 divss	 xmm2, xmm0
  00424	41 0f 28 c2	 movaps	 xmm0, xmm10
  00428	f3 41 0f 5c c5	 subss	 xmm0, xmm13
  0042d	f3 0f 5c ca	 subss	 xmm1, xmm2
  00431	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00435	f3 44 0f 58 e9	 addss	 xmm13, xmm1
$LN34@RenderText:

; 3684 :                     }
; 3685 :                     if (y1 < clip_rect.y)

  0043a	f3 41 0f 10 6f
	04		 movss	 xmm5, DWORD PTR [r15+4]
  00440	0f 2f ee	 comiss	 xmm5, xmm6
  00443	76 33		 jbe	 SHORT $LN35@RenderText

; 3686 :                     {
; 3687 :                         v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);

  00445	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0044d	0f 28 c4	 movaps	 xmm0, xmm4
  00450	f3 0f 5c c6	 subss	 xmm0, xmm6
  00454	0f 28 d4	 movaps	 xmm2, xmm4
  00457	f3 0f 5c d5	 subss	 xmm2, xmm5

; 3688 :                         y1 = clip_rect.y;

  0045b	0f 28 f5	 movaps	 xmm6, xmm5
  0045e	f3 0f 5e d0	 divss	 xmm2, xmm0
  00462	41 0f 28 c3	 movaps	 xmm0, xmm11
  00466	f3 41 0f 5c c6	 subss	 xmm0, xmm14
  0046b	f3 0f 5c ca	 subss	 xmm1, xmm2
  0046f	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00473	f3 44 0f 58 f1	 addss	 xmm14, xmm1
$LN35@RenderText:

; 3689 :                     }
; 3690 :                     if (x2 > clip_rect.z)

  00478	41 0f 2f dc	 comiss	 xmm3, xmm12
  0047c	76 2b		 jbe	 SHORT $LN36@RenderText

; 3691 :                     {
; 3692 :                         u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);

  0047e	41 0f 28 c2	 movaps	 xmm0, xmm10
  00482	f3 0f 5c df	 subss	 xmm3, xmm7
  00486	41 0f 28 cc	 movaps	 xmm1, xmm12
  0048a	f3 41 0f 5c c5	 subss	 xmm0, xmm13
  0048f	f3 0f 5c cf	 subss	 xmm1, xmm7
  00493	f3 0f 5e cb	 divss	 xmm1, xmm3

; 3693 :                         x2 = clip_rect.z;

  00497	41 0f 28 dc	 movaps	 xmm3, xmm12
  0049b	44 0f 28 d1	 movaps	 xmm10, xmm1
  0049f	f3 44 0f 59 d0	 mulss	 xmm10, xmm0
  004a4	f3 45 0f 58 d5	 addss	 xmm10, xmm13
$LN36@RenderText:

; 3694 :                     }
; 3695 :                     if (y2 > clip_rect.w)

  004a9	f3 41 0f 10 57
	0c		 movss	 xmm2, DWORD PTR [r15+12]
  004af	0f 2f e2	 comiss	 xmm4, xmm2
  004b2	76 29		 jbe	 SHORT $LN37@RenderText

; 3696 :                     {
; 3697 :                         v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);

  004b4	41 0f 28 c3	 movaps	 xmm0, xmm11
  004b8	f3 0f 5c e6	 subss	 xmm4, xmm6
  004bc	0f 28 ca	 movaps	 xmm1, xmm2
  004bf	f3 41 0f 5c c6	 subss	 xmm0, xmm14
  004c4	f3 0f 5c ce	 subss	 xmm1, xmm6
  004c8	f3 0f 5e cc	 divss	 xmm1, xmm4

; 3698 :                         y2 = clip_rect.w;

  004cc	0f 28 e2	 movaps	 xmm4, xmm2
  004cf	44 0f 28 d9	 movaps	 xmm11, xmm1
  004d3	f3 44 0f 59 d8	 mulss	 xmm11, xmm0
  004d8	f3 45 0f 58 de	 addss	 xmm11, xmm14
$LN37@RenderText:

; 3699 :                     }
; 3700 :                     if (y1 >= y2)

  004dd	0f 2f f4	 comiss	 xmm6, xmm4
  004e0	0f 83 b7 00 00
	00		 jae	 $LN32@RenderText
$LN38@RenderText:

; 3701 :                     {
; 3702 :                         x += char_width;
; 3703 :                         continue;
; 3704 :                     }
; 3705 :                 }
; 3706 : 
; 3707 :                 // Support for untinted glyphs
; 3708 :                 ImU32 glyph_col = glyph->Colored ? col_untinted : col;
; 3709 : 
; 3710 :                 // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
; 3711 :                 {
; 3712 :                     idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx + 1); idx_write[2] = (ImDrawIdx)(vtx_current_idx + 2);

  004e6	66 45 89 65 00	 mov	 WORD PTR [r13], r12w
  004eb	41 8d 44 24 01	 lea	 eax, DWORD PTR [r12+1]
  004f0	66 41 89 45 02	 mov	 WORD PTR [r13+2], ax
  004f5	f6 c1 01	 test	 cl, 1
  004f8	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR col$[rsp]
  004ff	41 8d 44 24 02	 lea	 eax, DWORD PTR [r12+2]
  00504	0f 45 4c 24 34	 cmovne	 ecx, DWORD PTR col_untinted$1$[rsp]
  00509	66 41 89 45 04	 mov	 WORD PTR [r13+4], ax

; 3713 :                     idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx + 2); idx_write[5] = (ImDrawIdx)(vtx_current_idx + 3);

  0050e	66 41 89 45 08	 mov	 WORD PTR [r13+8], ax
  00513	41 8d 44 24 03	 lea	 eax, DWORD PTR [r12+3]
  00518	66 45 89 65 06	 mov	 WORD PTR [r13+6], r12w

; 3714 :                     vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
; 3715 :                     vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
; 3716 :                     vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
; 3717 :                     vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
; 3718 :                     vtx_write += 4;
; 3719 :                     vtx_current_idx += 4;

  0051d	41 83 c4 04	 add	 r12d, 4
  00521	66 41 89 45 0a	 mov	 WORD PTR [r13+10], ax
  00526	f3 41 0f 11 3e	 movss	 DWORD PTR [r14], xmm7
  0052b	f3 41 0f 11 76
	04		 movss	 DWORD PTR [r14+4], xmm6
  00531	f3 45 0f 11 6e
	08		 movss	 DWORD PTR [r14+8], xmm13
  00537	f3 45 0f 11 76
	0c		 movss	 DWORD PTR [r14+12], xmm14
  0053d	f3 41 0f 11 5e
	14		 movss	 DWORD PTR [r14+20], xmm3
  00543	f3 41 0f 11 76
	18		 movss	 DWORD PTR [r14+24], xmm6
  00549	f3 45 0f 11 56
	1c		 movss	 DWORD PTR [r14+28], xmm10
  0054f	f3 45 0f 11 76
	20		 movss	 DWORD PTR [r14+32], xmm14
  00555	f3 41 0f 11 5e
	28		 movss	 DWORD PTR [r14+40], xmm3
  0055b	f3 41 0f 11 66
	2c		 movss	 DWORD PTR [r14+44], xmm4
  00561	f3 45 0f 11 56
	30		 movss	 DWORD PTR [r14+48], xmm10
  00567	f3 45 0f 11 5e
	34		 movss	 DWORD PTR [r14+52], xmm11
  0056d	f3 41 0f 11 7e
	3c		 movss	 DWORD PTR [r14+60], xmm7
  00573	f3 41 0f 11 66
	40		 movss	 DWORD PTR [r14+64], xmm4
  00579	f3 45 0f 11 6e
	44		 movss	 DWORD PTR [r14+68], xmm13
  0057f	f3 45 0f 11 5e
	48		 movss	 DWORD PTR [r14+72], xmm11
  00585	41 89 4e 10	 mov	 DWORD PTR [r14+16], ecx
  00589	41 89 4e 24	 mov	 DWORD PTR [r14+36], ecx
  0058d	41 89 4e 38	 mov	 DWORD PTR [r14+56], ecx
  00591	41 89 4e 4c	 mov	 DWORD PTR [r14+76], ecx
  00595	49 83 c6 50	 add	 r14, 80			; 00000050H

; 3720 :                     idx_write += 6;

  00599	49 83 c5 0c	 add	 r13, 12
$LN32@RenderText:

; 3599 : 
; 3600 :     while (s < text_end)

  0059d	f3 45 0f 58 f8	 addss	 xmm15, xmm8
  005a2	f3 44 0f 10 44
	24 30		 movss	 xmm8, DWORD PTR line_height$1$[rsp]
$LN69@RenderText:
  005a9	f3 44 0f 10 94
	24 40 01 00 00	 movss	 xmm10, DWORD PTR size$[rsp]
  005b3	f3 44 0f 10 5c
	24 38		 movss	 xmm11, DWORD PTR pos$1$[rsp]
  005ba	f3 44 0f 10 a4
	24 70 01 00 00	 movss	 xmm12, DWORD PTR wrap_width$[rsp]
  005c4	48 3b df	 cmp	 rbx, rdi
  005c7	0f 82 74 fc ff
	ff		 jb	 $LL6@RenderText
$LN84@RenderText:
  005cd	44 0f 28 7c 24
	50		 movaps	 xmm15, XMMWORD PTR [rsp+80]
  005d3	44 0f 28 74 24
	60		 movaps	 xmm14, XMMWORD PTR [rsp+96]
  005d9	44 0f 28 6c 24
	70		 movaps	 xmm13, XMMWORD PTR [rsp+112]
  005df	44 89 a4 24 58
	01 00 00	 mov	 DWORD PTR vtx_current_idx$1$[rsp], r12d
  005e7	4c 8b a4 24 38
	01 00 00	 mov	 r12, QWORD PTR draw_list$[rsp]
$LN80@RenderText:

; 3730 :     draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);

  005ef	49 63 1c 24	 movsxd	 rbx, DWORD PTR [r12]
  005f3	49 8b c6	 mov	 rax, r14
  005f6	49 2b 44 24 28	 sub	 rax, QWORD PTR [r12+40]
  005fb	48 b9 cd cc cc
	cc cc cc cc cc	 mov	 rcx, -3689348814741910323 ; cccccccccccccccdH
  00605	8b 7c 24 40	 mov	 edi, DWORD PTR idx_expected_size$1$[rsp]
  00609	48 c1 f8 02	 sar	 rax, 2
  0060d	48 0f af c1	 imul	 rax, rcx
  00611	41 89 44 24 20	 mov	 DWORD PTR [r12+32], eax
  00616	49 8b c5	 mov	 rax, r13
  00619	49 2b 44 24 18	 sub	 rax, QWORD PTR [r12+24]
  0061e	48 d1 f8	 sar	 rax, 1
  00621	2b f8		 sub	 edi, eax
  00623	41 89 44 24 10	 mov	 DWORD PTR [r12+16], eax
  00628	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

  0062b	85 c0		 test	 eax, eax
  0062d	78 04		 js	 SHORT $LN54@RenderText
  0062f	3b c3		 cmp	 eax, ebx
  00631	7c 1a		 jl	 SHORT $LN55@RenderText
$LN54@RenderText:
  00633	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  00639	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00640	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  00647	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN55@RenderText:
  0064d	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  00652	48 6b cb 38	 imul	 rcx, rbx, 56		; 00000038H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3730 :     draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);

  00656	29 7c 01 e8	 sub	 DWORD PTR [rcx+rax-24], edi

; 3731 :     draw_list->_VtxWritePtr = vtx_write;
; 3732 :     draw_list->_IdxWritePtr = idx_write;
; 3733 :     draw_list->_VtxCurrentIdx = vtx_current_idx;

  0065a	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR vtx_current_idx$1$[rsp]
  00661	4d 89 74 24 48	 mov	 QWORD PTR [r12+72], r14
  00666	4c 8b b4 24 f0
	00 00 00	 mov	 r14, QWORD PTR [rsp+240]
  0066e	4d 89 6c 24 50	 mov	 QWORD PTR [r12+80], r13
  00673	4c 8b ac 24 f8
	00 00 00	 mov	 r13, QWORD PTR [rsp+248]
  0067b	41 89 44 24 34	 mov	 DWORD PTR [r12+52], eax
$LN89@RenderText:
  00680	44 0f 28 8c 24
	b0 00 00 00	 movaps	 xmm9, XMMWORD PTR [rsp+176]
  00689	44 0f 28 84 24
	c0 00 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+192]
  00692	0f 28 b4 24 e0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+224]
  0069a	48 8b b4 24 30
	01 00 00	 mov	 rsi, QWORD PTR [rsp+304]
  006a2	44 0f 28 a4 24
	80 00 00 00	 movaps	 xmm12, XMMWORD PTR [rsp+128]
$LN1@RenderText:

; 3734 : }

  006ab	4c 8d 9c 24 00
	01 00 00	 lea	 r11, QWORD PTR [rsp+256]
  006b3	41 0f 28 7b d0	 movaps	 xmm7, XMMWORD PTR [r11-48]
  006b8	45 0f 28 53 a0	 movaps	 xmm10, XMMWORD PTR [r11-96]
  006bd	45 0f 28 5b 90	 movaps	 xmm11, XMMWORD PTR [r11-112]
  006c2	49 8b e3	 mov	 rsp, r11
  006c5	41 5f		 pop	 r15
  006c7	41 5c		 pop	 r12
  006c9	5f		 pop	 rdi
  006ca	5d		 pop	 rbp
  006cb	5b		 pop	 rbx
  006cc	c3		 ret	 0
?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z ENDP ; ImFont::RenderText
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 208
draw_list$ = 208
pos$ = 208
col$ = 224
dir$ = 232
scale$ = 240
?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z PROC ; ImGui::RenderArrow

; 3754 : {

$LN76:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx
  00007	57		 push	 rdi
  00008	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  0000f	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  00013	41 8b f8	 mov	 edi, r8d
  00016	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	44 0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm8
  00022	0f 57 f6	 xorps	 xmm6, xmm6
  00025	44 0f 29 48 b8	 movaps	 XMMWORD PTR [rax-72], xmm9
  0002a	0f 57 ff	 xorps	 xmm7, xmm7
  0002d	44 0f 29 50 a8	 movaps	 XMMWORD PTR [rax-88], xmm10
  00032	45 0f 57 c9	 xorps	 xmm9, xmm9
  00036	44 0f 29 58 98	 movaps	 XMMWORD PTR [rax-104], xmm11
  0003b	45 0f 57 c0	 xorps	 xmm8, xmm8
  0003f	44 0f 29 60 88	 movaps	 XMMWORD PTR [rax-120], xmm12
  00044	45 0f 57 db	 xorps	 xmm11, xmm11

; 3755 :     const float h = draw_list->_Data->FontSize * 1.00f;

  00048	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0004c	45 0f 57 e4	 xorps	 xmm12, xmm12
  00050	44 0f 29 6c 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm13
  00056	48 89 94 24 d0
	00 00 00	 mov	 QWORD PTR pos$[rsp], rdx
  0005e	f3 44 0f 10 50
	10		 movss	 xmm10, DWORD PTR [rax+16]

; 3760 :     switch (dir)

  00064	41 8d 41 01	 lea	 eax, DWORD PTR [r9+1]
  00068	41 0f 28 ca	 movaps	 xmm1, xmm10
  0006c	f3 44 0f 59 15
	00 00 00 00	 mulss	 xmm10, DWORD PTR __real@3f000000
  00075	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3ecccccd
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0007d	45 0f 28 ea	 movaps	 xmm13, xmm10
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3757 :     ImVec2 center = pos + ImVec2(h * 0.50f, h * 0.50f * scale);

  00081	f3 44 0f 59 94
	24 f0 00 00 00	 mulss	 xmm10, DWORD PTR scale$[rsp]
  0008b	f3 0f 59 8c 24
	f0 00 00 00	 mulss	 xmm1, DWORD PTR scale$[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00094	f3 44 0f 58 94
	24 d4 00 00 00	 addss	 xmm10, DWORD PTR pos$[rsp+4]
  0009e	f3 44 0f 58 ac
	24 d0 00 00 00	 addss	 xmm13, DWORD PTR pos$[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3760 :     switch (dir)

  000a8	83 f8 05	 cmp	 eax, 5
  000ab	0f 87 c9 00 00
	00		 ja	 $LN13@RenderArro
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  000b8	48 98		 cdqe
  000ba	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN74@RenderArro[rdx+rax*4]
  000c1	48 03 ca	 add	 rcx, rdx
  000c4	ff e1		 jmp	 rcx
$LN4@RenderArro:

; 3761 :     {
; 3762 :     case ImGuiDir_Up:
; 3763 :     case ImGuiDir_Down:
; 3764 :         if (dir == ImGuiDir_Up) r = -r;

  000c6	41 83 f9 02	 cmp	 r9d, 2
  000ca	75 07		 jne	 SHORT $LN6@RenderArro
  000cc	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
$LN6@RenderArro:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  000d3	0f 28 f9	 movaps	 xmm7, xmm1
  000d6	44 0f 28 c9	 movaps	 xmm9, xmm1
  000da	f3 0f 59 3d 00
	00 00 00	 mulss	 xmm7, DWORD PTR __real@bf400000
  000e2	44 0f 28 c1	 movaps	 xmm8, xmm1
  000e6	f3 44 0f 59 05
	00 00 00 00	 mulss	 xmm8, DWORD PTR __real@bf5db22d
  000ef	44 0f 28 e1	 movaps	 xmm12, xmm1
  000f3	f3 44 0f 59 25
	00 00 00 00	 mulss	 xmm12, DWORD PTR __real@3f5db22d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3767 :         c = ImVec2(+0.866f, -0.750f) * r;

  000fc	44 0f 28 df	 movaps	 xmm11, xmm7
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00100	f3 44 0f 59 ce	 mulss	 xmm9, xmm6
  00105	0f 28 f1	 movaps	 xmm6, xmm1
  00108	f3 0f 59 35 00
	00 00 00	 mulss	 xmm6, DWORD PTR __real@3f400000
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3768 :         break;

  00110	eb 68		 jmp	 SHORT $LN13@RenderArro
$LN7@RenderArro:

; 3769 :     case ImGuiDir_Left:
; 3770 :     case ImGuiDir_Right:
; 3771 :         if (dir == ImGuiDir_Left) r = -r;

  00112	45 85 c9	 test	 r9d, r9d
  00115	75 07		 jne	 SHORT $LN9@RenderArro
  00117	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
$LN9@RenderArro:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0011e	0f 28 c1	 movaps	 xmm0, xmm1
  00121	44 0f 28 c1	 movaps	 xmm8, xmm1
  00125	f3 44 0f 59 05
	00 00 00 00	 mulss	 xmm8, DWORD PTR __real@bf400000
  0012e	44 0f 28 c9	 movaps	 xmm9, xmm1
  00132	f3 44 0f 59 0d
	00 00 00 00	 mulss	 xmm9, DWORD PTR __real@3f400000
  0013b	0f 28 f9	 movaps	 xmm7, xmm1
  0013e	f3 0f 59 3d 00
	00 00 00	 mulss	 xmm7, DWORD PTR __real@3f5db22d
  00146	44 0f 28 d9	 movaps	 xmm11, xmm1
  0014a	f3 44 0f 59 1d
	00 00 00 00	 mulss	 xmm11, DWORD PTR __real@bf5db22d
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3774 :         c = ImVec2(-0.750f, -0.866f) * r;

  00153	45 0f 28 e0	 movaps	 xmm12, xmm8
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00157	f3 0f 59 c6	 mulss	 xmm0, xmm6
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3774 :         c = ImVec2(-0.750f, -0.866f) * r;

  0015b	0f 28 f0	 movaps	 xmm6, xmm0

; 3775 :         break;

  0015e	eb 1a		 jmp	 SHORT $LN13@RenderArro
$LN10@RenderArro:

; 3776 :     case ImGuiDir_None:
; 3777 :     case ImGuiDir_COUNT:
; 3778 :         IM_ASSERT(0);

  00160	41 b8 c2 0e 00
	00		 mov	 r8d, 3778		; 00000ec2H
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN13@RenderArro:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  0017a	41 0f 28 c5	 movaps	 xmm0, xmm13
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3781 :     draw_list->AddTriangleFilled(center + a, center + b, center + c, col);

  0017e	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  00182	41 0f 28 ca	 movaps	 xmm1, xmm10
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h

; 354  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }

  00186	f3 41 0f 58 c4	 addss	 xmm0, xmm12
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  0018b	f3 41 0f 58 cb	 addss	 xmm1, xmm11
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3781 :     draw_list->AddTriangleFilled(center + a, center + b, center + c, col);

  00190	48 8b cb	 mov	 rcx, rbx
  00193	4c 8d 8c 24 d0
	00 00 00	 lea	 r9, QWORD PTR $T3[rsp]
  0019b	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T1[rsp]
  001a0	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T2[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 253  :     ImVec2(float _x, float _y) { x = _x; y = _y; }

  001a5	f3 0f 11 84 24
	d0 00 00 00	 movss	 DWORD PTR $T3[rsp], xmm0
  001ae	41 0f 28 c5	 movaps	 xmm0, xmm13
  001b2	f3 0f 11 8c 24
	d4 00 00 00	 movss	 DWORD PTR $T3[rsp+4], xmm1
  001bb	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  001c0	41 0f 28 ca	 movaps	 xmm1, xmm10
  001c4	f3 45 0f 58 e9	 addss	 xmm13, xmm9
  001c9	f3 0f 58 cf	 addss	 xmm1, xmm7
  001cd	f3 44 0f 58 d6	 addss	 xmm10, xmm6
  001d2	f3 0f 11 44 24
	30		 movss	 DWORD PTR $T1[rsp], xmm0
  001d8	f3 44 0f 11 6c
	24 38		 movss	 DWORD PTR $T2[rsp], xmm13
  001df	f3 0f 11 4c 24
	34		 movss	 DWORD PTR $T1[rsp+4], xmm1
  001e5	f3 44 0f 11 54
	24 3c		 movss	 DWORD PTR $T2[rsp+4], xmm10
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3781 :     draw_list->AddTriangleFilled(center + a, center + b, center + c, col);

  001ec	e8 00 00 00 00	 call	 ?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled

; 3782 : }

  001f1	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  001f9	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  001fd	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00202	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  00207	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  0020c	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  00211	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  00216	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  0021b	45 0f 28 63 90	 movaps	 xmm12, XMMWORD PTR [r11-112]
  00220	45 0f 28 6b 80	 movaps	 xmm13, XMMWORD PTR [r11-128]
  00225	49 8b e3	 mov	 rsp, r11
  00228	5f		 pop	 rdi
  00229	c3		 ret	 0
  0022a	66 90		 npad	 2
$LN74@RenderArro:
  0022c	00 00 00 00	 DD	 $LN10@RenderArro
  00230	00 00 00 00	 DD	 $LN7@RenderArro
  00234	00 00 00 00	 DD	 $LN7@RenderArro
  00238	00 00 00 00	 DD	 $LN4@RenderArro
  0023c	00 00 00 00	 DD	 $LN4@RenderArro
  00240	00 00 00 00	 DD	 $LN10@RenderArro
?RenderArrow@ImGui@@YAXPEAUImDrawList@@UImVec2@@IHM@Z ENDP ; ImGui::RenderArrow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
input$ = 8
?stb_decompress_length@@YAIPEBE@Z PROC			; stb_decompress_length

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00000	0f b6 51 09	 movzx	 edx, BYTE PTR [rcx+9]
  00004	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]
  00008	c1 e0 08	 shl	 eax, 8
  0000b	03 c2		 add	 eax, edx
  0000d	0f b6 51 0a	 movzx	 edx, BYTE PTR [rcx+10]
  00011	0f b6 49 0b	 movzx	 ecx, BYTE PTR [rcx+11]
  00015	c1 e0 08	 shl	 eax, 8
  00018	03 c2		 add	 eax, edx
  0001a	c1 e0 08	 shl	 eax, 8
  0001d	03 c1		 add	 eax, ecx

; 3976 : }

  0001f	c3		 ret	 0
?stb_decompress_length@@YAIPEBE@Z ENDP			; stb_decompress_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
data$ = 48
length$ = 56
?stb__match@@YAXPEBEI@Z PROC				; stb__match

; 3982 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3983 :     // INVERSE of memmove... write each byte before copying the next...
; 3984 :     IM_ASSERT(stb__dout + length <= stb__barrier_out_e);

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?stb__dout@@3PEAEEA
  00016	48 8b f9	 mov	 rdi, rcx
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
  00020	8b da		 mov	 ebx, edx
  00022	4c 8d 04 03	 lea	 r8, QWORD PTR [rbx+rax]
  00026	4c 3b c1	 cmp	 r8, rcx
  00029	76 28		 jbe	 SHORT $LN7@stb__match
  0002b	41 b8 90 0f 00
	00		 mov	 r8d, 3984		; 00000f90H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?stb__dout@@3PEAEEA
  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
$LN7@stb__match:

; 3985 :     if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }

  00053	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  00057	48 3b d1	 cmp	 rdx, rcx
  0005a	76 17		 jbe	 SHORT $LN4@stb__match
  0005c	48 89 15 00 00
	00 00		 mov	 QWORD PTR ?stb__dout@@3PEAEEA, rdx

; 3988 : }

  00063	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00068	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
$LN4@stb__match:

; 3986 :     if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e + 1; return; }

  00073	48 3b 3d 00 00
	00 00		 cmp	 rdi, QWORD PTR ?stb__barrier_out_b@@3PEAEEA
  0007a	73 06		 jae	 SHORT $LN8@stb__match
  0007c	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00080	eb 1c		 jmp	 SHORT $LN13@stb__match
$LN8@stb__match:

; 3987 :     while (length--) *stb__dout++ = *data++;

  00082	85 db		 test	 ebx, ebx
  00084	74 1f		 je	 SHORT $LN9@stb__match
  00086	48 2b f8	 sub	 rdi, rax
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@stb__match:
  00090	0f b6 0c 07	 movzx	 ecx, BYTE PTR [rdi+rax]
  00094	88 08		 mov	 BYTE PTR [rax], cl
  00096	48 ff c0	 inc	 rax
  00099	83 c3 ff	 add	 ebx, -1			; ffffffffH
  0009c	75 f2		 jne	 SHORT $LL2@stb__match
$LN13@stb__match:

; 3988 : }

  0009e	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?stb__dout@@3PEAEEA, rax
$LN9@stb__match:
  000a5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000aa	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	5f		 pop	 rdi
  000b4	c3		 ret	 0
?stb__match@@YAXPEBEI@Z ENDP				; stb__match
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
data$ = 48
length$ = 56
?stb__lit@@YAXPEBEI@Z PROC				; stb__lit

; 3991 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3992 :     IM_ASSERT(stb__dout + length <= stb__barrier_out_e);

  0000f	8b fa		 mov	 edi, edx
  00011	48 8b f1	 mov	 rsi, rcx
  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__dout@@3PEAEEA
  0001b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
  00022	48 8d 04 0f	 lea	 rax, QWORD PTR [rdi+rcx]
  00026	48 3b c2	 cmp	 rax, rdx
  00029	76 28		 jbe	 SHORT $LN5@stb__lit
  0002b	41 b8 98 0f 00
	00		 mov	 r8d, 3992		; 00000f98H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@IADGHEAH@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$CL?$AA?5?$AAl?$AAe?$AAn@
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__dout@@3PEAEEA
  0004c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?stb__barrier_out_e@@3PEAEEA
$LN5@stb__lit:

; 3993 :     if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }

  00053	48 8d 1c 0f	 lea	 rbx, QWORD PTR [rdi+rcx]
  00057	48 3b da	 cmp	 rbx, rdx
  0005a	77 2f		 ja	 SHORT $LN6@stb__lit

; 3994 :     if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e + 1; return; }

  0005c	48 3b 35 00 00
	00 00		 cmp	 rsi, QWORD PTR ?stb__barrier_in_b@@3PEBEEB
  00063	73 1b		 jae	 SHORT $LN3@stb__lit
  00065	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]

; 3996 :     stb__dout += length;
; 3997 : }

  00069	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?stb__dout@@3PEAEEA, rax
  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
$LN3@stb__lit:

; 3995 :     memcpy(stb__dout, data, length);

  00080	4c 8b c7	 mov	 r8, rdi
  00083	48 8b d6	 mov	 rdx, rsi
  00086	e8 00 00 00 00	 call	 memcpy
$LN6@stb__lit:

; 3996 :     stb__dout += length;
; 3997 : }

  0008b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00090	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?stb__dout@@3PEAEEA, rbx
  00097	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
?stb__lit@@YAXPEBEI@Z ENDP				; stb__lit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
i$ = 48
?stb_decompress_token@@YAPEBEPEBE@Z PROC		; stb_decompress_token

; 4004 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4005 :     if (*i >= 0x20) { // use fewer if's for cases that expand small

  00006	44 0f b6 01	 movzx	 r8d, BYTE PTR [rcx]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	41 80 f8 20	 cmp	 r8b, 32			; 00000020H
  00011	0f 82 89 00 00
	00		 jb	 $LN2@stb_decomp

; 4006 :         if (*i >= 0x80)       stb__match(stb__dout - i[1] - 1, i[0] - 0x80 + 1), i += 2;

  00017	41 80 f8 80	 cmp	 r8b, 128		; 00000080H
  0001b	72 27		 jb	 SHORT $LN4@stb_decomp
  0001d	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00021	41 8d 50 81	 lea	 edx, DWORD PTR [r8-127]
  00025	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__dout@@3PEAEEA
  0002c	48 2b c8	 sub	 rcx, rax
  0002f	48 ff c9	 dec	 rcx
  00032	e8 00 00 00 00	 call	 ?stb__match@@YAXPEBEI@Z	; stb__match
  00037	48 83 c3 02	 add	 rbx, 2

; 4017 :     }
; 4018 :     return i;

  0003b	48 8b c3	 mov	 rax, rbx

; 4019 : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
$LN4@stb_decomp:

; 4007 :         else if (*i >= 0x40)  stb__match(stb__dout - (stb__in2(0) - 0x4000 + 1), i[2] + 1), i += 3;

  00044	41 80 f8 40	 cmp	 r8b, 64			; 00000040H
  00048	72 37		 jb	 SHORT $LN6@stb_decomp
  0004a	0f b6 51 02	 movzx	 edx, BYTE PTR [rcx+2]
  0004e	49 8b c0	 mov	 rax, r8
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__dout@@3PEAEEA
  00058	ff c2		 inc	 edx
  0005a	48 c1 e0 08	 shl	 rax, 8
  0005e	48 2b c8	 sub	 rcx, rax
  00061	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  00065	48 2b c8	 sub	 rcx, rax
  00068	48 81 c1 ff 3f
	00 00		 add	 rcx, 16383		; 00003fffH
  0006f	e8 00 00 00 00	 call	 ?stb__match@@YAXPEBEI@Z	; stb__match
  00074	48 83 c3 03	 add	 rbx, 3

; 4017 :     }
; 4018 :     return i;

  00078	48 8b c3	 mov	 rax, rbx

; 4019 : }

  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
$LN6@stb_decomp:

; 4008 :         else /* *i >= 0x20 */ stb__lit(i + 1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);

  00081	41 8d 50 e1	 lea	 edx, DWORD PTR [r8-31]
  00085	48 ff c1	 inc	 rcx
  00088	e8 00 00 00 00	 call	 ?stb__lit@@YAXPEBEI@Z	; stb__lit
  0008d	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00090	48 83 c3 e2	 add	 rbx, -30
  00094	48 03 d8	 add	 rbx, rax

; 4017 :     }
; 4018 :     return i;

  00097	48 8b c3	 mov	 rax, rbx

; 4019 : }

  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5b		 pop	 rbx
  0009f	c3		 ret	 0
$LN2@stb_decomp:

; 4009 :     }
; 4010 :     else { // more ifs for cases that expand large, since overhead is amortized
; 4011 :         if (*i >= 0x18)       stb__match(stb__dout - (stb__in3(0) - 0x180000 + 1), i[3] + 1), i += 4;

  000a0	41 80 f8 18	 cmp	 r8b, 24
  000a4	72 3f		 jb	 SHORT $LN8@stb_decomp
  000a6	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000aa	0f b6 51 03	 movzx	 edx, BYTE PTR [rcx+3]
  000ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__dout@@3PEAEEA
  000b5	ff c2		 inc	 edx
  000b7	49 c1 e0 08	 shl	 r8, 8
  000bb	4c 03 c0	 add	 r8, rax
  000be	0f b6 43 02	 movzx	 eax, BYTE PTR [rbx+2]
  000c2	49 c1 e0 08	 shl	 r8, 8
  000c6	49 2b c8	 sub	 rcx, r8
  000c9	48 2b c8	 sub	 rcx, rax
  000cc	48 81 c1 ff ff
	17 00		 add	 rcx, 1572863		; 0017ffffH
  000d3	e8 00 00 00 00	 call	 ?stb__match@@YAXPEBEI@Z	; stb__match
  000d8	48 83 c3 04	 add	 rbx, 4

; 4017 :     }
; 4018 :     return i;

  000dc	48 8b c3	 mov	 rax, rbx

; 4019 : }

  000df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e3	5b		 pop	 rbx
  000e4	c3		 ret	 0
$LN8@stb_decomp:

; 4012 :         else if (*i >= 0x10)  stb__match(stb__dout - (stb__in3(0) - 0x100000 + 1), stb__in2(3) + 1), i += 5;

  000e5	41 80 f8 10	 cmp	 r8b, 16
  000e9	72 48		 jb	 SHORT $LN10@stb_decomp
  000eb	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  000ef	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  000f3	0f b6 53 04	 movzx	 edx, BYTE PTR [rbx+4]
  000f7	c1 e1 08	 shl	 ecx, 8
  000fa	ff c1		 inc	 ecx
  000fc	49 c1 e0 08	 shl	 r8, 8
  00100	03 d1		 add	 edx, ecx
  00102	4c 03 c0	 add	 r8, rax
  00105	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__dout@@3PEAEEA
  0010c	0f b6 43 02	 movzx	 eax, BYTE PTR [rbx+2]
  00110	49 c1 e0 08	 shl	 r8, 8
  00114	49 2b c8	 sub	 rcx, r8
  00117	48 2b c8	 sub	 rcx, rax
  0011a	48 81 c1 ff ff
	0f 00		 add	 rcx, 1048575		; 000fffffH
  00121	e8 00 00 00 00	 call	 ?stb__match@@YAXPEBEI@Z	; stb__match
  00126	48 83 c3 05	 add	 rbx, 5

; 4017 :     }
; 4018 :     return i;

  0012a	48 8b c3	 mov	 rax, rbx

; 4019 : }

  0012d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00131	5b		 pop	 rbx
  00132	c3		 ret	 0
$LN10@stb_decomp:

; 4013 :         else if (*i >= 0x08)  stb__lit(i + 2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);

  00133	41 80 f8 08	 cmp	 r8b, 8
  00137	72 3c		 jb	 SHORT $LN12@stb_decomp
  00139	0f b6 53 01	 movzx	 edx, BYTE PTR [rbx+1]
  0013d	41 8b c8	 mov	 ecx, r8d
  00140	c1 e1 08	 shl	 ecx, 8
  00143	81 c2 01 f8 ff
	ff		 add	 edx, -2047		; fffff801H
  00149	03 d1		 add	 edx, ecx
  0014b	48 8d 4b 02	 lea	 rcx, QWORD PTR [rbx+2]
  0014f	e8 00 00 00 00	 call	 ?stb__lit@@YAXPEBEI@Z	; stb__lit
  00154	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00157	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  0015b	48 03 c3	 add	 rax, rbx
  0015e	48 c1 e1 08	 shl	 rcx, 8
  00162	48 8d 99 03 f8
	ff ff		 lea	 rbx, QWORD PTR [rcx-2045]
  00169	48 03 d8	 add	 rbx, rax

; 4017 :     }
; 4018 :     return i;

  0016c	48 8b c3	 mov	 rax, rbx

; 4019 : }

  0016f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00173	5b		 pop	 rbx
  00174	c3		 ret	 0
$LN12@stb_decomp:

; 4014 :         else if (*i == 0x07)  stb__lit(i + 3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);

  00175	41 80 f8 07	 cmp	 r8b, 7
  00179	75 37		 jne	 SHORT $LN14@stb_decomp
  0017b	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0017f	0f b6 53 02	 movzx	 edx, BYTE PTR [rbx+2]
  00183	c1 e1 08	 shl	 ecx, 8
  00186	ff c1		 inc	 ecx
  00188	03 d1		 add	 edx, ecx
  0018a	48 8d 4b 03	 lea	 rcx, QWORD PTR [rbx+3]
  0018e	e8 00 00 00 00	 call	 ?stb__lit@@YAXPEBEI@Z	; stb__lit
  00193	0f b6 4b 01	 movzx	 ecx, BYTE PTR [rbx+1]
  00197	0f b6 43 02	 movzx	 eax, BYTE PTR [rbx+2]
  0019b	48 03 c3	 add	 rax, rbx
  0019e	48 c1 e1 08	 shl	 rcx, 8
  001a2	48 8d 59 04	 lea	 rbx, QWORD PTR [rcx+4]
  001a6	48 03 d8	 add	 rbx, rax

; 4017 :     }
; 4018 :     return i;

  001a9	48 8b c3	 mov	 rax, rbx

; 4019 : }

  001ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b0	5b		 pop	 rbx
  001b1	c3		 ret	 0
$LN14@stb_decomp:

; 4015 :         else if (*i == 0x06)  stb__match(stb__dout - (stb__in3(1) + 1), i[4] + 1), i += 5;

  001b2	41 80 f8 06	 cmp	 r8b, 6
  001b6	75 40		 jne	 SHORT $LN16@stb_decomp
  001b8	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  001bc	44 0f b6 41 01	 movzx	 r8d, BYTE PTR [rcx+1]
  001c1	0f b6 51 04	 movzx	 edx, BYTE PTR [rcx+4]
  001c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__dout@@3PEAEEA
  001cc	ff c2		 inc	 edx
  001ce	49 c1 e0 08	 shl	 r8, 8
  001d2	4c 03 c0	 add	 r8, rax
  001d5	0f b6 43 03	 movzx	 eax, BYTE PTR [rbx+3]
  001d9	49 c1 e0 08	 shl	 r8, 8
  001dd	49 2b c8	 sub	 rcx, r8
  001e0	48 2b c8	 sub	 rcx, rax
  001e3	48 ff c9	 dec	 rcx
  001e6	e8 00 00 00 00	 call	 ?stb__match@@YAXPEBEI@Z	; stb__match
  001eb	48 83 c3 05	 add	 rbx, 5

; 4017 :     }
; 4018 :     return i;

  001ef	48 8b c3	 mov	 rax, rbx

; 4019 : }

  001f2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f6	5b		 pop	 rbx
  001f7	c3		 ret	 0
$LN16@stb_decomp:

; 4016 :         else if (*i == 0x04)  stb__match(stb__dout - (stb__in3(1) + 1), stb__in2(4) + 1), i += 6;

  001f8	41 80 f8 04	 cmp	 r8b, 4
  001fc	75 40		 jne	 SHORT $LN18@stb_decomp
  001fe	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00202	0f b6 43 02	 movzx	 eax, BYTE PTR [rbx+2]
  00206	44 0f b6 43 01	 movzx	 r8d, BYTE PTR [rbx+1]
  0020b	0f b6 53 05	 movzx	 edx, BYTE PTR [rbx+5]
  0020f	c1 e1 08	 shl	 ecx, 8
  00212	ff c1		 inc	 ecx
  00214	49 c1 e0 08	 shl	 r8, 8
  00218	03 d1		 add	 edx, ecx
  0021a	4c 03 c0	 add	 r8, rax
  0021d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?stb__dout@@3PEAEEA
  00224	0f b6 43 03	 movzx	 eax, BYTE PTR [rbx+3]
  00228	49 c1 e0 08	 shl	 r8, 8
  0022c	49 2b c8	 sub	 rcx, r8
  0022f	48 2b c8	 sub	 rcx, rax
  00232	48 ff c9	 dec	 rcx
  00235	e8 00 00 00 00	 call	 ?stb__match@@YAXPEBEI@Z	; stb__match
  0023a	48 83 c3 06	 add	 rbx, 6
$LN18@stb_decomp:

; 4017 :     }
; 4018 :     return i;

  0023e	48 8b c3	 mov	 rax, rbx

; 4019 : }

  00241	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00245	5b		 pop	 rbx
  00246	c3		 ret	 0
?stb_decompress_token@@YAPEBEPEBE@Z ENDP		; stb_decompress_token
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
adler32$dead$ = 16
buffer$ = 24
buflen$ = 32
?stb_adler32@@YAIIPEAEI@Z PROC				; stb_adler32

; 4022 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	4c 8b d2	 mov	 r10, rdx

; 4023 :     const unsigned long ADLER_MOD = 65521;
; 4024 :     unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
; 4025 :     unsigned long blocklen = buflen % 5552;

  00009	b8 af a9 6e 5e	 mov	 eax, 1584310703		; 5e6ea9afH
  0000e	41 f7 e0	 mul	 r8d
  00011	41 8b d8	 mov	 ebx, r8d
  00014	45 33 c9	 xor	 r9d, r9d
  00017	c1 ea 0b	 shr	 edx, 11
  0001a	41 8b f0	 mov	 esi, r8d
  0001d	69 c2 b0 15 00
	00		 imul	 eax, edx, 5552		; 000015b0H
  00023	b9 01 00 00 00	 mov	 ecx, 1
  00028	2b d8		 sub	 ebx, eax

; 4026 : 
; 4027 :     unsigned long i;
; 4028 :     while (buflen) {

  0002a	45 85 c0	 test	 r8d, r8d
  0002d	0f 84 09 01 00
	00		 je	 $LN3@stb_adler3
  00033	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
$LL2@stb_adler3:

; 4029 :         for (i = 0; i + 7 < blocklen; i += 8) {

  00038	33 d2		 xor	 edx, edx
  0003a	83 fb 07	 cmp	 ebx, 7
  0003d	76 63		 jbe	 SHORT $LN5@stb_adler3
  0003f	44 8d 42 07	 lea	 r8d, QWORD PTR [rdx+7]
$LL6@stb_adler3:

; 4030 :             s1 += buffer[0], s2 += s1;

  00043	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00047	83 c2 08	 add	 edx, 8
  0004a	03 c8		 add	 ecx, eax
  0004c	41 83 c0 08	 add	 r8d, 8

; 4031 :             s1 += buffer[1], s2 += s1;

  00050	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  00055	44 03 c9	 add	 r9d, ecx
  00058	03 c8		 add	 ecx, eax

; 4032 :             s1 += buffer[2], s2 += s1;

  0005a	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]
  0005f	44 03 c9	 add	 r9d, ecx
  00062	03 c8		 add	 ecx, eax

; 4033 :             s1 += buffer[3], s2 += s1;

  00064	41 0f b6 42 03	 movzx	 eax, BYTE PTR [r10+3]
  00069	44 03 c9	 add	 r9d, ecx
  0006c	03 c8		 add	 ecx, eax

; 4034 :             s1 += buffer[4], s2 += s1;

  0006e	41 0f b6 42 04	 movzx	 eax, BYTE PTR [r10+4]
  00073	44 03 c9	 add	 r9d, ecx
  00076	03 c8		 add	 ecx, eax

; 4035 :             s1 += buffer[5], s2 += s1;

  00078	41 0f b6 42 05	 movzx	 eax, BYTE PTR [r10+5]
  0007d	44 03 c9	 add	 r9d, ecx
  00080	03 c8		 add	 ecx, eax

; 4036 :             s1 += buffer[6], s2 += s1;

  00082	41 0f b6 42 06	 movzx	 eax, BYTE PTR [r10+6]
  00087	44 03 c9	 add	 r9d, ecx
  0008a	03 c8		 add	 ecx, eax

; 4037 :             s1 += buffer[7], s2 += s1;

  0008c	41 0f b6 42 07	 movzx	 eax, BYTE PTR [r10+7]
  00091	44 03 c9	 add	 r9d, ecx
  00094	03 c8		 add	 ecx, eax

; 4038 : 
; 4039 :             buffer += 8;

  00096	49 83 c2 08	 add	 r10, 8
  0009a	44 03 c9	 add	 r9d, ecx
  0009d	44 3b c3	 cmp	 r8d, ebx
  000a0	72 a1		 jb	 SHORT $LL6@stb_adler3
$LN5@stb_adler3:
  000a2	45 33 c0	 xor	 r8d, r8d
  000a5	45 33 db	 xor	 r11d, r11d

; 4040 :         }
; 4041 : 
; 4042 :         for (; i < blocklen; ++i)

  000a8	3b d3		 cmp	 edx, ebx
  000aa	73 58		 jae	 SHORT $LN22@stb_adler3
  000ac	8b c3		 mov	 eax, ebx
  000ae	2b c2		 sub	 eax, edx
  000b0	83 f8 02	 cmp	 eax, 2
  000b3	72 3c		 jb	 SHORT $LN29@stb_adler3
  000b5	8b c3		 mov	 eax, ebx
  000b7	2b c2		 sub	 eax, edx
  000b9	83 e8 02	 sub	 eax, 2
  000bc	d1 e8		 shr	 eax, 1
  000be	ff c0		 inc	 eax
  000c0	8b f8		 mov	 edi, eax
  000c2	8d 14 42	 lea	 edx, DWORD PTR [rdx+rax*2]
  000c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL25@stb_adler3:

; 4043 :             s1 += *buffer++, s2 += s1;

  000d0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  000d4	03 c8		 add	 ecx, eax
  000d6	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  000db	44 03 c1	 add	 r8d, ecx
  000de	49 83 c2 02	 add	 r10, 2
  000e2	03 c8		 add	 ecx, eax
  000e4	44 03 d9	 add	 r11d, ecx
  000e7	48 83 ef 01	 sub	 rdi, 1
  000eb	75 e3		 jne	 SHORT $LL25@stb_adler3

; 4040 :         }
; 4041 : 
; 4042 :         for (; i < blocklen; ++i)

  000ed	3b d3		 cmp	 edx, ebx
  000ef	73 0c		 jae	 SHORT $LN24@stb_adler3
$LN29@stb_adler3:

; 4043 :             s1 += *buffer++, s2 += s1;

  000f1	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  000f5	03 c8		 add	 ecx, eax
  000f7	44 03 c9	 add	 r9d, ecx
  000fa	49 ff c2	 inc	 r10
$LN24@stb_adler3:
  000fd	43 8d 04 03	 lea	 eax, DWORD PTR [r11+r8]
  00101	44 03 c8	 add	 r9d, eax
$LN22@stb_adler3:

; 4044 : 
; 4045 :         s1 %= ADLER_MOD, s2 %= ADLER_MOD;

  00104	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00109	f7 e1		 mul	 ecx
  0010b	c1 ea 0f	 shr	 edx, 15
  0010e	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  00114	03 c8		 add	 ecx, eax
  00116	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  0011b	41 f7 e1	 mul	 r9d
  0011e	c1 ea 0f	 shr	 edx, 15
  00121	69 d2 0f 00 ff
	ff		 imul	 edx, edx, -65521	; ffff000fH
  00127	44 03 ca	 add	 r9d, edx

; 4046 :         buflen -= blocklen;

  0012a	2b f3		 sub	 esi, ebx

; 4047 :         blocklen = 5552;

  0012c	bb b0 15 00 00	 mov	 ebx, 5552		; 000015b0H
  00131	0f 85 01 ff ff
	ff		 jne	 $LL2@stb_adler3

; 4026 : 
; 4027 :     unsigned long i;
; 4028 :     while (buflen) {

  00137	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
$LN3@stb_adler3:

; 4048 :     }
; 4049 :     return (unsigned int)(s2 << 16) + (unsigned int)s1;
; 4050 : }

  0013c	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  00141	41 c1 e1 10	 shl	 r9d, 16
  00145	42 8d 04 09	 lea	 eax, DWORD PTR [rcx+r9]
  00149	5e		 pop	 rsi
  0014a	c3		 ret	 0
?stb_adler32@@YAIIPEAEI@Z ENDP				; stb_adler32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
output$ = 48
i$ = 56
__formal$dead$ = 64
?stb_decompress@@YAIPEAEPEBEI@Z PROC			; stb_decompress

; 4053 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4054 :     if (stb__in4(0) != 0x57bC0000) return 0;

  0001a	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  0001e	48 8b da	 mov	 rbx, rdx
  00021	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00025	4c 8b f1	 mov	 r14, rcx
  00028	41 c1 e0 08	 shl	 r8d, 8
  0002c	44 03 c0	 add	 r8d, eax
  0002f	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  00033	41 c1 e0 08	 shl	 r8d, 8
  00037	44 03 c0	 add	 r8d, eax
  0003a	0f b6 42 03	 movzx	 eax, BYTE PTR [rdx+3]
  0003e	41 c1 e0 08	 shl	 r8d, 8
  00042	44 03 c0	 add	 r8d, eax
  00045	41 81 f8 00 00
	bc 57		 cmp	 r8d, 1471938560		; 57bc0000H
  0004c	0f 85 49 01 00
	00		 jne	 $LN22@stb_decomp

; 4055 :     if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB

  00052	0f b6 42 05	 movzx	 eax, BYTE PTR [rdx+5]
  00056	0f b6 4a 04	 movzx	 ecx, BYTE PTR [rdx+4]
  0005a	c1 e1 08	 shl	 ecx, 8
  0005d	03 c8		 add	 ecx, eax
  0005f	0f b6 42 06	 movzx	 eax, BYTE PTR [rdx+6]
  00063	c1 e1 08	 shl	 ecx, 8
  00066	03 c8		 add	 ecx, eax
  00068	0f b6 42 07	 movzx	 eax, BYTE PTR [rdx+7]
  0006c	c1 e1 08	 shl	 ecx, 8
  0006f	03 c8		 add	 ecx, eax
  00071	0f 85 24 01 00
	00		 jne	 $LN22@stb_decomp

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00077	0f b6 6a 08	 movzx	 ebp, BYTE PTR [rdx+8]

; 4060 :     i += 16;

  0007b	48 83 c3 10	 add	 rbx, 16

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  0007f	0f b6 42 09	 movzx	 eax, BYTE PTR [rdx+9]

; 4063 :     for (;;) {
; 4064 :         const unsigned char* old_i = i;
; 4065 :         i = stb_decompress_token(i);

  00083	48 8b cb	 mov	 rcx, rbx

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00086	c1 e0 10	 shl	 eax, 16
  00089	c1 e5 18	 shl	 ebp, 24
  0008c	03 e8		 add	 ebp, eax

; 4056 :     const unsigned int olen = stb_decompress_length(i);
; 4057 :     stb__barrier_in_b = i;

  0008e	48 89 15 00 00
	00 00		 mov	 QWORD PTR ?stb__barrier_in_b@@3PEBEEB, rdx

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  00095	0f b6 42 0a	 movzx	 eax, BYTE PTR [rdx+10]
  00099	c1 e0 08	 shl	 eax, 8
  0009c	03 e8		 add	 ebp, eax

; 4058 :     stb__barrier_out_e = output + olen;
; 4059 :     stb__barrier_out_b = output;

  0009e	4c 89 35 00 00
	00 00		 mov	 QWORD PTR ?stb__barrier_out_b@@3PEAEEA, r14

; 3975 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

  000a5	0f b6 42 0b	 movzx	 eax, BYTE PTR [rdx+11]
  000a9	03 e8		 add	 ebp, eax

; 4061 : 
; 4062 :     stb__dout = output;

  000ab	4c 89 35 00 00
	00 00		 mov	 QWORD PTR ?stb__dout@@3PEAEEA, r14
  000b2	8b f5		 mov	 esi, ebp
  000b4	49 03 f6	 add	 rsi, r14
  000b7	48 89 35 00 00
	00 00		 mov	 QWORD PTR ?stb__barrier_out_e@@3PEAEEA, rsi

; 4063 :     for (;;) {
; 4064 :         const unsigned char* old_i = i;
; 4065 :         i = stb_decompress_token(i);

  000be	e8 00 00 00 00	 call	 ?stb_decompress_token@@YAPEBEPEBE@Z ; stb_decompress_token
  000c3	48 8b f8	 mov	 rdi, rax

; 4066 :         if (i == old_i) {

  000c6	48 3b c3	 cmp	 rax, rbx
  000c9	74 48		 je	 SHORT $LN24@stb_decomp
  000cb	0f 1f 44 00 00	 npad	 5
$LL2@stb_decomp:

; 4076 :                 return 0;
; 4077 :             }
; 4078 :         }
; 4079 :         IM_ASSERT(stb__dout <= output + olen);

  000d0	48 39 35 00 00
	00 00		 cmp	 QWORD PTR ?stb__dout@@3PEAEEA, rsi
  000d7	76 27		 jbe	 SHORT $LN26@stb_decomp
  000d9	41 b8 ef 0f 00
	00		 mov	 r8d, 4079		; 00000fefH
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@EGIPGKEG@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAo?$AAu@
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 4080 :         if (stb__dout > output + olen)

  000f3	48 39 35 00 00
	00 00		 cmp	 QWORD PTR ?stb__dout@@3PEAEEA, rsi
  000fa	0f 87 9b 00 00
	00		 ja	 $LN22@stb_decomp
$LN26@stb_decomp:

; 4063 :     for (;;) {
; 4064 :         const unsigned char* old_i = i;
; 4065 :         i = stb_decompress_token(i);

  00100	48 8b cf	 mov	 rcx, rdi
  00103	48 8b df	 mov	 rbx, rdi
  00106	e8 00 00 00 00	 call	 ?stb_decompress_token@@YAPEBEPEBE@Z ; stb_decompress_token
  0010b	48 8b f8	 mov	 rdi, rax

; 4066 :         if (i == old_i) {

  0010e	48 3b c3	 cmp	 rax, rbx
  00111	75 bd		 jne	 SHORT $LL2@stb_decomp
$LN24@stb_decomp:

; 4067 :             if (*i == 0x05 && i[1] == 0xfa) {

  00113	80 3f 05	 cmp	 BYTE PTR [rdi], 5
  00116	75 69		 jne	 SHORT $LN8@stb_decomp
  00118	80 7f 01 fa	 cmp	 BYTE PTR [rdi+1], 250	; 000000faH
  0011c	75 63		 jne	 SHORT $LN8@stb_decomp
  0011e	8b dd		 mov	 ebx, ebp

; 4068 :                 IM_ASSERT(stb__dout == output + olen);

  00120	49 03 de	 add	 rbx, r14
  00123	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR ?stb__dout@@3PEAEEA, rbx
  0012a	74 23		 je	 SHORT $LN10@stb_decomp
  0012c	41 b8 e4 0f 00
	00		 mov	 r8d, 4068		; 00000fe4H
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@GCANDLHA@?$AAs?$AAt?$AAb?$AA_?$AA_?$AAd?$AAo?$AAu?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAo?$AAu@
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 4069 :                 if (stb__dout != output + olen) return 0;

  00146	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR ?stb__dout@@3PEAEEA, rbx
  0014d	75 4c		 jne	 SHORT $LN22@stb_decomp
$LN10@stb_decomp:

; 4070 :                 if (stb_adler32(1, output, olen) != (unsigned int)stb__in4(2))

  0014f	44 8b c5	 mov	 r8d, ebp
  00152	49 8b d6	 mov	 rdx, r14
  00155	e8 00 00 00 00	 call	 ?stb_adler32@@YAIIPEAEI@Z ; stb_adler32
  0015a	0f b6 57 02	 movzx	 edx, BYTE PTR [rdi+2]
  0015e	0f b6 4f 03	 movzx	 ecx, BYTE PTR [rdi+3]
  00162	c1 e1 10	 shl	 ecx, 16
  00165	c1 e2 18	 shl	 edx, 24
  00168	03 d1		 add	 edx, ecx
  0016a	0f b6 4f 04	 movzx	 ecx, BYTE PTR [rdi+4]
  0016e	c1 e1 08	 shl	 ecx, 8
  00171	03 d1		 add	 edx, ecx
  00173	0f b6 4f 05	 movzx	 ecx, BYTE PTR [rdi+5]
  00177	03 d1		 add	 edx, ecx
  00179	3b c2		 cmp	 eax, edx
  0017b	75 1e		 jne	 SHORT $LN22@stb_decomp

; 4071 :                     return 0;
; 4072 :                 return olen;

  0017d	8b c5		 mov	 eax, ebp
  0017f	eb 1c		 jmp	 SHORT $LN3@stb_decomp
$LN8@stb_decomp:

; 4073 :             }
; 4074 :             else {
; 4075 :                 IM_ASSERT(0); /* NOTREACHED */

  00181	41 b8 eb 0f 00
	00		 mov	 r8d, 4075		; 00000febH
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1LA@MKCOMCEK@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0@
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN22@stb_decomp:

; 4081 :             return 0;
; 4082 :     }
; 4083 : }

  0019b	33 c0		 xor	 eax, eax
$LN3@stb_decomp:
  0019d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001a2	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  001a7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001ac	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  001b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b5	41 5e		 pop	 r14
  001b7	c3		 ret	 0
?stb_decompress@@YAIPEAEPEBEI@Z ENDP			; stb_decompress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
_TEXT	SEGMENT
?GetDefaultCompressedFontDataTTFBase85@@YAPEBDXZ PROC	; GetDefaultCompressedFontDataTTFBase85

; 4187 :     return proggy_clean_ttf_compressed_data_base85;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?proggy_clean_ttf_compressed_data_base85@@3QBDB

; 4188 : }

  00007	c3		 ret	 0
?GetDefaultCompressedFontDataTTFBase85@@YAPEBDXZ ENDP	; GetDefaultCompressedFontDataTTFBase85
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z PROC	; ImVector<stbtt_packedchar>::resize, COMDAT

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN31:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	8b fa		 mov	 edi, edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00012	3b d1		 cmp	 edx, ecx
  00014	0f 8e b4 00 00
	00		 jle	 $LN27@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001a	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0001f	85 c9		 test	 ecx, ecx
  00021	74 0b		 je	 SHORT $LN6@resize
  00023	8b c1		 mov	 eax, ecx
  00025	99		 cdq
  00026	2b c2		 sub	 eax, edx
  00028	d1 f8		 sar	 eax, 1
  0002a	03 c1		 add	 eax, ecx
  0002c	eb 05		 jmp	 SHORT $LN7@resize
$LN6@resize:
  0002e	b8 08 00 00 00	 mov	 eax, 8
$LN7@resize:
  00033	3b c7		 cmp	 eax, edi
  00035	8b f7		 mov	 esi, edi
  00037	0f 4f f0	 cmovg	 esi, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0003a	3b f1		 cmp	 esi, ecx
  0003c	7e 7e		 jle	 SHORT $LN28@resize
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00045	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0004a	48 85 c0	 test	 rax, rax
  0004d	74 06		 je	 SHORT $LN13@resize

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  0004f	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN13@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00055	48 63 c6	 movsxd	 rax, esi
  00058	48 6b c8 1c	 imul	 rcx, rax, 28
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00062	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00066	48 8b e8	 mov	 rbp, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00069	48 85 d2	 test	 rdx, rdx
  0006c	74 30		 je	 SHORT $LN23@resize
  0006e	48 63 0b	 movsxd	 rcx, DWORD PTR [rbx]
  00071	4c 6b c1 1c	 imul	 r8, rcx, 28
  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 memcpy
  0007d	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00081	48 85 c9	 test	 rcx, rcx
  00084	74 12		 je	 SHORT $LN21@resize

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00086	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0008d	48 85 c0	 test	 rax, rax
  00090	74 06		 je	 SHORT $LN21@resize

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00092	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN21@resize:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0009e	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000a2	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  000a7	89 73 04	 mov	 DWORD PTR [rbx+4], esi
  000aa	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000af	89 3b		 mov	 DWORD PTR [rbx], edi
  000b1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
$LN28@resize:
  000bc	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c1	89 3b		 mov	 DWORD PTR [rbx], edi
  000c3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
$LN27@resize:
  000ce	89 3b		 mov	 DWORD PTR [rbx], edi
  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
?resize@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ENDP	; ImVector<stbtt_packedchar>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z PROC ; ImVector<stbtt_packedchar>::operator[], COMDAT

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	85 d2		 test	 edx, edx
  00012	78 04		 js	 SHORT $LN3@operator
  00014	3b 19		 cmp	 ebx, DWORD PTR [rcx]
  00016	7c 1a		 jl	 SHORT $LN4@operator
$LN3@operator:
  00018	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@operator:
  00032	48 6b c3 1c	 imul	 rax, rbx, 28
  00036	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003b	48 03 47 08	 add	 rax, QWORD PTR [rdi+8]
  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
??A?$ImVector@Ustbtt_packedchar@@@@QEAAAEAUstbtt_packedchar@@H@Z ENDP ; ImVector<stbtt_packedchar>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ PROC ; ImVector<stbtt_packedchar>::size_in_bytes, COMDAT

; 1791 :     inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

  00000	6b 01 1c	 imul	 eax, DWORD PTR [rcx], 28
  00003	c3		 ret	 0
?size_in_bytes@?$ImVector@Ustbtt_packedchar@@@@QEBAHXZ ENDP ; ImVector<stbtt_packedchar>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ PROC		; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>, COMDAT

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
  00000	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 19		 je	 SHORT $LN8@ImVector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00010	48 85 c0	 test	 rax, rax
  00013	74 06		 je	 SHORT $LN6@ImVector

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00015	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@ImVector:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0001b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
$LN8@ImVector:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00022	c3		 ret	 0
??1?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ENDP		; ImVector<stbtt_packedchar>::~ImVector<stbtt_packedchar>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ PROC		; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>, COMDAT

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$ImVector@Ustbtt_packedchar@@@@QEAA@XZ ENDP		; ImVector<stbtt_packedchar>::ImVector<stbtt_packedchar>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z PROC		; ImVector<stbrp_rect>::resize, COMDAT

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN31:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	8b fa		 mov	 edi, edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00012	3b d1		 cmp	 edx, ecx
  00014	0f 8e b4 00 00
	00		 jle	 $LN27@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001a	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0001f	85 c9		 test	 ecx, ecx
  00021	74 0b		 je	 SHORT $LN6@resize
  00023	8b c1		 mov	 eax, ecx
  00025	99		 cdq
  00026	2b c2		 sub	 eax, edx
  00028	d1 f8		 sar	 eax, 1
  0002a	03 c1		 add	 eax, ecx
  0002c	eb 05		 jmp	 SHORT $LN7@resize
$LN6@resize:
  0002e	b8 08 00 00 00	 mov	 eax, 8
$LN7@resize:
  00033	3b c7		 cmp	 eax, edi
  00035	8b f7		 mov	 esi, edi
  00037	0f 4f f0	 cmovg	 esi, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0003a	3b f1		 cmp	 esi, ecx
  0003c	7e 7e		 jle	 SHORT $LN28@resize
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00045	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0004a	48 85 c0	 test	 rax, rax
  0004d	74 06		 je	 SHORT $LN13@resize

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  0004f	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN13@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00055	48 63 ce	 movsxd	 rcx, esi
  00058	48 c1 e1 04	 shl	 rcx, 4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00062	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00066	48 8b e8	 mov	 rbp, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00069	48 85 d2	 test	 rdx, rdx
  0006c	74 30		 je	 SHORT $LN23@resize
  0006e	4c 63 03	 movsxd	 r8, DWORD PTR [rbx]
  00071	48 8b c8	 mov	 rcx, rax
  00074	49 c1 e0 04	 shl	 r8, 4
  00078	e8 00 00 00 00	 call	 memcpy
  0007d	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00081	48 85 c9	 test	 rcx, rcx
  00084	74 12		 je	 SHORT $LN21@resize

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00086	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0008d	48 85 c0	 test	 rax, rax
  00090	74 06		 je	 SHORT $LN21@resize

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00092	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN21@resize:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0009e	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000a2	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  000a7	89 73 04	 mov	 DWORD PTR [rbx+4], esi
  000aa	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000af	89 3b		 mov	 DWORD PTR [rbx], edi
  000b1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
$LN28@resize:
  000bc	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c1	89 3b		 mov	 DWORD PTR [rbx], edi
  000c3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
$LN27@resize:
  000ce	89 3b		 mov	 DWORD PTR [rbx], edi
  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
?resize@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z ENDP		; ImVector<stbrp_rect>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z PROC ; ImVector<stbrp_rect>::operator[], COMDAT

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	85 d2		 test	 edx, edx
  00012	78 04		 js	 SHORT $LN3@operator
  00014	3b 19		 cmp	 ebx, DWORD PTR [rcx]
  00016	7c 1a		 jl	 SHORT $LN4@operator
$LN3@operator:
  00018	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@operator:
  00032	48 8b c3	 mov	 rax, rbx
  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 c1 e0 04	 shl	 rax, 4
  0003e	48 03 47 08	 add	 rax, QWORD PTR [rdi+8]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??A?$ImVector@Ustbrp_rect@@@@QEAAAEAUstbrp_rect@@H@Z ENDP ; ImVector<stbrp_rect>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ PROC	; ImVector<stbrp_rect>::size_in_bytes, COMDAT

; 1791 :     inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	c1 e0 04	 shl	 eax, 4
  00005	c3		 ret	 0
?size_in_bytes@?$ImVector@Ustbrp_rect@@@@QEBAHXZ ENDP	; ImVector<stbrp_rect>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ PROC		; ImVector<stbrp_rect>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@Ustbrp_rect@@@@QEAAXXZ ENDP		; ImVector<stbrp_rect>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ PROC		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>, COMDAT

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
  00000	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 19		 je	 SHORT $LN8@ImVector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00010	48 85 c0	 test	 rax, rax
  00013	74 06		 je	 SHORT $LN6@ImVector

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00015	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@ImVector:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0001b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
$LN8@ImVector:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00022	c3		 ret	 0
??1?$ImVector@Ustbrp_rect@@@@QEAA@XZ ENDP		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ PROC		; ImVector<stbrp_rect>::ImVector<stbrp_rect>, COMDAT

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$ImVector@Ustbrp_rect@@@@QEAA@XZ ENDP		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z PROC	; ImVector<ImFontBuildDstData>::resize, COMDAT

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN31:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	8b fa		 mov	 edi, edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00012	3b d1		 cmp	 edx, ecx
  00014	0f 8e b4 00 00
	00		 jle	 $LN27@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001a	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0001f	85 c9		 test	 ecx, ecx
  00021	74 0b		 je	 SHORT $LN6@resize
  00023	8b c1		 mov	 eax, ecx
  00025	99		 cdq
  00026	2b c2		 sub	 eax, edx
  00028	d1 f8		 sar	 eax, 1
  0002a	03 c1		 add	 eax, ecx
  0002c	eb 05		 jmp	 SHORT $LN7@resize
$LN6@resize:
  0002e	b8 08 00 00 00	 mov	 eax, 8
$LN7@resize:
  00033	3b c7		 cmp	 eax, edi
  00035	8b f7		 mov	 esi, edi
  00037	0f 4f f0	 cmovg	 esi, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0003a	3b f1		 cmp	 esi, ecx
  0003c	7e 7e		 jle	 SHORT $LN28@resize
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00045	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0004a	48 85 c0	 test	 rax, rax
  0004d	74 06		 je	 SHORT $LN13@resize

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  0004f	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN13@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00055	48 63 ce	 movsxd	 rcx, esi
  00058	48 c1 e1 05	 shl	 rcx, 5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00062	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00066	48 8b e8	 mov	 rbp, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00069	48 85 d2	 test	 rdx, rdx
  0006c	74 30		 je	 SHORT $LN23@resize
  0006e	4c 63 03	 movsxd	 r8, DWORD PTR [rbx]
  00071	48 8b c8	 mov	 rcx, rax
  00074	49 c1 e0 05	 shl	 r8, 5
  00078	e8 00 00 00 00	 call	 memcpy
  0007d	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00081	48 85 c9	 test	 rcx, rcx
  00084	74 12		 je	 SHORT $LN21@resize

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00086	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0008d	48 85 c0	 test	 rax, rax
  00090	74 06		 je	 SHORT $LN21@resize

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00092	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN21@resize:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0009e	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000a2	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  000a7	89 73 04	 mov	 DWORD PTR [rbx+4], esi
  000aa	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000af	89 3b		 mov	 DWORD PTR [rbx], edi
  000b1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
$LN28@resize:
  000bc	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c1	89 3b		 mov	 DWORD PTR [rbx], edi
  000c3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
$LN27@resize:
  000ce	89 3b		 mov	 DWORD PTR [rbx], edi
  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
?resize@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ENDP	; ImVector<ImFontBuildDstData>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z PROC ; ImVector<ImFontBuildDstData>::operator[], COMDAT

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	85 d2		 test	 edx, edx
  00012	78 04		 js	 SHORT $LN3@operator
  00014	3b 19		 cmp	 ebx, DWORD PTR [rcx]
  00016	7c 1a		 jl	 SHORT $LN4@operator
$LN3@operator:
  00018	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@operator:
  00032	48 8b c3	 mov	 rax, rbx
  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 c1 e0 05	 shl	 rax, 5
  0003e	48 03 47 08	 add	 rax, QWORD PTR [rdi+8]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??A?$ImVector@UImFontBuildDstData@@@@QEAAAEAUImFontBuildDstData@@H@Z ENDP ; ImVector<ImFontBuildDstData>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ PROC ; ImVector<ImFontBuildDstData>::size_in_bytes, COMDAT

; 1791 :     inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	c1 e0 05	 shl	 eax, 5
  00005	c3		 ret	 0
?size_in_bytes@?$ImVector@UImFontBuildDstData@@@@QEBAHXZ ENDP ; ImVector<ImFontBuildDstData>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ PROC	; ImVector<ImFontBuildDstData>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@UImFontBuildDstData@@@@QEAAXXZ ENDP	; ImVector<ImFontBuildDstData>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>, COMDAT

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
  00000	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 19		 je	 SHORT $LN8@ImVector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00010	48 85 c0	 test	 rax, rax
  00013	74 06		 je	 SHORT $LN6@ImVector

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00015	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@ImVector:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0001b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
$LN8@ImVector:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00022	c3		 ret	 0
??1?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildDstData>::~ImVector<ImFontBuildDstData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>, COMDAT

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$ImVector@UImFontBuildDstData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildDstData>::ImVector<ImFontBuildDstData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z PROC	; ImVector<ImFontBuildSrcData>::resize, COMDAT

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN31:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	8b fa		 mov	 edi, edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00012	3b d1		 cmp	 edx, ecx
  00014	0f 8e be 00 00
	00		 jle	 $LN27@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001a	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0001f	85 c9		 test	 ecx, ecx
  00021	74 0b		 je	 SHORT $LN6@resize
  00023	8b c1		 mov	 eax, ecx
  00025	99		 cdq
  00026	2b c2		 sub	 eax, edx
  00028	d1 f8		 sar	 eax, 1
  0002a	03 c1		 add	 eax, ecx
  0002c	eb 05		 jmp	 SHORT $LN7@resize
$LN6@resize:
  0002e	b8 08 00 00 00	 mov	 eax, 8
$LN7@resize:
  00033	3b c7		 cmp	 eax, edi
  00035	8b f7		 mov	 esi, edi
  00037	0f 4f f0	 cmovg	 esi, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0003a	3b f1		 cmp	 esi, ecx
  0003c	0f 8e 84 00 00
	00		 jle	 $LN28@resize
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00049	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0004e	48 85 c0	 test	 rax, rax
  00051	74 06		 je	 SHORT $LN13@resize

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00053	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN13@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00059	48 63 c6	 movsxd	 rax, esi
  0005c	48 69 c8 10 01
	00 00		 imul	 rcx, rax, 272		; 00000110H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00069	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0006d	48 8b e8	 mov	 rbp, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00070	48 85 d2	 test	 rdx, rdx
  00073	74 33		 je	 SHORT $LN23@resize
  00075	48 63 0b	 movsxd	 rcx, DWORD PTR [rbx]
  00078	4c 69 c1 10 01
	00 00		 imul	 r8, rcx, 272		; 00000110H
  0007f	48 8b c8	 mov	 rcx, rax
  00082	e8 00 00 00 00	 call	 memcpy
  00087	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  0008b	48 85 c9	 test	 rcx, rcx
  0008e	74 12		 je	 SHORT $LN21@resize

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00090	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00097	48 85 c0	 test	 rax, rax
  0009a	74 06		 je	 SHORT $LN21@resize

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0009c	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN21@resize:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  000a8	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000ac	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  000b1	89 73 04	 mov	 DWORD PTR [rbx+4], esi
  000b4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000b9	89 3b		 mov	 DWORD PTR [rbx], edi
  000bb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	5f		 pop	 rdi
  000c5	c3		 ret	 0
$LN28@resize:
  000c6	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000cb	89 3b		 mov	 DWORD PTR [rbx], edi
  000cd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
$LN27@resize:
  000d8	89 3b		 mov	 DWORD PTR [rbx], edi
  000da	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e3	5f		 pop	 rdi
  000e4	c3		 ret	 0
?resize@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ENDP	; ImVector<ImFontBuildSrcData>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z PROC ; ImVector<ImFontBuildSrcData>::operator[], COMDAT

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	85 d2		 test	 edx, edx
  00012	78 04		 js	 SHORT $LN3@operator
  00014	3b 19		 cmp	 ebx, DWORD PTR [rcx]
  00016	7c 1a		 jl	 SHORT $LN4@operator
$LN3@operator:
  00018	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@operator:
  00032	48 69 c3 10 01
	00 00		 imul	 rax, rbx, 272		; 00000110H
  00039	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003e	48 03 47 08	 add	 rax, QWORD PTR [rdi+8]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??A?$ImVector@UImFontBuildSrcData@@@@QEAAAEAUImFontBuildSrcData@@H@Z ENDP ; ImVector<ImFontBuildSrcData>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ PROC ; ImVector<ImFontBuildSrcData>::size_in_bytes, COMDAT

; 1791 :     inline int          size_in_bytes() const { return Size * (int)sizeof(T); }

  00000	69 01 10 01 00
	00		 imul	 eax, DWORD PTR [rcx], 272 ; 00000110H
  00006	c3		 ret	 0
?size_in_bytes@?$ImVector@UImFontBuildSrcData@@@@QEBAHXZ ENDP ; ImVector<ImFontBuildSrcData>::size_in_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ PROC ; ImVector<ImFontBuildSrcData>::clear_destruct, COMDAT

; 1787 :     inline void         clear_destruct() { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.

$LN56:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b d9	 mov	 rbx, rcx
  00017	33 ff		 xor	 edi, edi
  00019	39 39		 cmp	 DWORD PTR [rcx], edi
  0001b	7e 60		 jle	 SHORT $LN3@clear_dest
  0001d	33 f6		 xor	 esi, esi
  0001f	90		 npad	 1
$LL4@clear_dest:
  00020	48 8b 6b 08	 mov	 rbp, QWORD PTR [rbx+8]

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00024	48 8b 8c 35 08
	01 00 00	 mov	 rcx, QWORD PTR [rbp+rsi+264]
  0002c	48 85 c9	 test	 rcx, rcx
  0002f	74 19		 je	 SHORT $LN20@clear_dest
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00038	48 85 c0	 test	 rax, rax
  0003b	74 06		 je	 SHORT $LN18@clear_dest

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0003d	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN18@clear_dest:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00049	90		 npad	 1
$LN20@clear_dest:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0004a	48 8b 8c 35 f8
	00 00 00	 mov	 rcx, QWORD PTR [rbp+rsi+248]
  00052	48 85 c9	 test	 rcx, rcx
  00055	74 19		 je	 SHORT $LN35@clear_dest
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00057	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0005e	48 85 c0	 test	 rax, rax
  00061	74 06		 je	 SHORT $LN33@clear_dest

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00063	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN33@clear_dest:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0006f	90		 npad	 1
$LN35@clear_dest:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1787 :     inline void         clear_destruct() { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.

  00070	ff c7		 inc	 edi
  00072	48 81 c6 10 01
	00 00		 add	 rsi, 272		; 00000110H
  00079	3b 3b		 cmp	 edi, DWORD PTR [rbx]
  0007b	7c a3		 jl	 SHORT $LL4@clear_dest
$LN3@clear_dest:

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  0007d	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00081	48 85 c9	 test	 rcx, rcx
  00084	74 27		 je	 SHORT $LN40@clear_dest
  00086	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0008d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00094	48 85 c0	 test	 rax, rax
  00097	74 06		 je	 SHORT $LN44@clear_dest

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00099	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN44@clear_dest:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000a5	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN40@clear_dest:

; 1787 :     inline void         clear_destruct() { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }           // Important: never called automatically! always explicit.

  000ad	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b2	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
?clear_destruct@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ ENDP ; ImVector<ImFontBuildSrcData>::clear_destruct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>, COMDAT

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
  00000	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 19		 je	 SHORT $LN8@ImVector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00010	48 85 c0	 test	 rax, rax
  00013	74 06		 je	 SHORT $LN6@ImVector

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00015	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@ImVector:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0001b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
$LN8@ImVector:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00022	c3		 ret	 0
??1?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildSrcData>::~ImVector<ImFontBuildSrcData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ PROC	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>, COMDAT

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$ImVector@UImFontBuildSrcData@@@@QEAA@XZ ENDP	; ImVector<ImFontBuildSrcData>::ImVector<ImFontBuildSrcData>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z PROC	; ImVector<ImFontGlyph>::resize, COMDAT

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN31:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	8b fa		 mov	 edi, edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00012	3b d1		 cmp	 edx, ecx
  00014	0f 8e c0 00 00
	00		 jle	 $LN27@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001a	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0001f	85 c9		 test	 ecx, ecx
  00021	74 0b		 je	 SHORT $LN6@resize
  00023	8b c1		 mov	 eax, ecx
  00025	99		 cdq
  00026	2b c2		 sub	 eax, edx
  00028	d1 f8		 sar	 eax, 1
  0002a	03 c1		 add	 eax, ecx
  0002c	eb 05		 jmp	 SHORT $LN7@resize
$LN6@resize:
  0002e	b8 08 00 00 00	 mov	 eax, 8
$LN7@resize:
  00033	3b c7		 cmp	 eax, edi
  00035	8b f7		 mov	 esi, edi
  00037	0f 4f f0	 cmovg	 esi, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0003a	3b f1		 cmp	 esi, ecx
  0003c	0f 8e 86 00 00
	00		 jle	 $LN28@resize
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00049	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0004e	48 85 c0	 test	 rax, rax
  00051	74 06		 je	 SHORT $LN13@resize

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00053	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN13@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00059	48 63 c6	 movsxd	 rax, esi
  0005c	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00060	48 c1 e1 03	 shl	 rcx, 3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0006a	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0006e	48 8b e8	 mov	 rbp, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00071	48 85 d2	 test	 rdx, rdx
  00074	74 34		 je	 SHORT $LN23@resize
  00076	48 63 0b	 movsxd	 rcx, DWORD PTR [rbx]
  00079	4c 8d 04 89	 lea	 r8, QWORD PTR [rcx+rcx*4]
  0007d	48 8b c8	 mov	 rcx, rax
  00080	49 c1 e0 03	 shl	 r8, 3
  00084	e8 00 00 00 00	 call	 memcpy
  00089	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  0008d	48 85 c9	 test	 rcx, rcx
  00090	74 12		 je	 SHORT $LN21@resize

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00092	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00099	48 85 c0	 test	 rax, rax
  0009c	74 06		 je	 SHORT $LN21@resize

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0009e	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN21@resize:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@resize:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  000aa	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000ae	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  000b3	89 73 04	 mov	 DWORD PTR [rbx+4], esi
  000b6	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  000bb	89 3b		 mov	 DWORD PTR [rbx], edi
  000bd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
$LN28@resize:
  000c8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000cd	89 3b		 mov	 DWORD PTR [rbx], edi
  000cf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d8	5f		 pop	 rdi
  000d9	c3		 ret	 0
$LN27@resize:
  000da	89 3b		 mov	 DWORD PTR [rbx], edi
  000dc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0
?resize@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ENDP	; ImVector<ImFontGlyph>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ
_TEXT	SEGMENT
this$ = 48
?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ PROC ; ImVector<ImFontGlyph>::back, COMDAT

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b 01		 mov	 eax, DWORD PTR [rcx]
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	85 c0		 test	 eax, eax
  0000d	7f 1c		 jg	 SHORT $LN3@back
  0000f	41 b8 0b 07 00
	00		 mov	 r8d, 1803		; 0000070bH
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00029	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN3@back:
  0002b	ff c8		 dec	 eax
  0002d	48 63 c8	 movsxd	 rcx, eax
  00030	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00034	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]
  00038	48 8d 04 d0	 lea	 rax, QWORD PTR [rax+rdx*8]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5b		 pop	 rbx
  00041	c3		 ret	 0
?back@?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@XZ ENDP ; ImVector<ImFontGlyph>::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z PROC ; ImVector<ImFontGlyph>::operator[], COMDAT

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	85 d2		 test	 edx, edx
  00012	78 04		 js	 SHORT $LN3@operator
  00014	3b 19		 cmp	 ebx, DWORD PTR [rcx]
  00016	7c 1a		 jl	 SHORT $LN4@operator
$LN3@operator:
  00018	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@operator:
  00032	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00036	48 8d 0c 9b	 lea	 rcx, QWORD PTR [rbx+rbx*4]
  0003a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003f	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
??A?$ImVector@UImFontGlyph@@@@QEAAAEAUImFontGlyph@@H@Z ENDP ; ImVector<ImFontGlyph>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ PROC		; ImVector<ImFontGlyph>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@UImFontGlyph@@@@QEAAXXZ ENDP		; ImVector<ImFontGlyph>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontGlyph@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontGlyph@@@@QEAA@XZ PROC		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>, COMDAT

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
  00000	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 19		 je	 SHORT $LN8@ImVector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00010	48 85 c0	 test	 rax, rax
  00013	74 06		 je	 SHORT $LN6@ImVector

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00015	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@ImVector:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0001b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
$LN8@ImVector:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00022	c3		 ret	 0
??1?$ImVector@UImFontGlyph@@@@QEAA@XZ ENDP		; ImVector<ImFontGlyph>::~ImVector<ImFontGlyph>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontGlyph@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontGlyph@@@@QEAA@XZ PROC		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>, COMDAT

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$ImVector@UImFontGlyph@@@@QEAA@XZ ENDP		; ImVector<ImFontGlyph>::ImVector<ImFontGlyph>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@M@@QEAAXHAEBM@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
v$ = 64
?resize@?$ImVector@M@@QEAAXHAEBM@Z PROC			; ImVector<float>::resize, COMDAT

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 63 fa	 movsxd	 rdi, edx
  00012	48 8b d9	 mov	 rbx, rcx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00018	49 8b f0	 mov	 rsi, r8
  0001b	3b f9		 cmp	 edi, ecx
  0001d	7e 23		 jle	 SHORT $LN5@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001f	85 c9		 test	 ecx, ecx
  00021	74 0b		 je	 SHORT $LN10@resize
  00023	8b c1		 mov	 eax, ecx
  00025	99		 cdq
  00026	2b c2		 sub	 eax, edx
  00028	d1 f8		 sar	 eax, 1
  0002a	03 c1		 add	 eax, ecx
  0002c	eb 05		 jmp	 SHORT $LN11@resize
$LN10@resize:
  0002e	b8 08 00 00 00	 mov	 eax, 8
$LN11@resize:
  00033	3b c7		 cmp	 eax, edi
  00035	8b d7		 mov	 edx, edi

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  00037	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0003a	0f 4f d0	 cmovg	 edx, eax

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  0003d	e8 00 00 00 00	 call	 ?reserve@?$ImVector@M@@QEAAXH@Z ; ImVector<float>::reserve
$LN5@resize:
  00042	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  00045	3b f8		 cmp	 edi, eax
  00047	7e 19		 jle	 SHORT $LN16@resize
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 3b c7	 cmp	 rax, rdi
  0004f	7d 11		 jge	 SHORT $LN16@resize
$LL4@resize:
  00051	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00055	8b 06		 mov	 eax, DWORD PTR [rsi]
  00057	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  0005a	48 ff c2	 inc	 rdx
  0005d	48 3b d7	 cmp	 rdx, rdi
  00060	7c ef		 jl	 SHORT $LL4@resize
$LN16@resize:
  00062	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00067	89 3b		 mov	 DWORD PTR [rbx], edi
  00069	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
?resize@?$ImVector@M@@QEAAXHAEBM@Z ENDP			; ImVector<float>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z PROC ; ImVector<ImFontConfig>::push_back, COMDAT

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN28:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b 39		 mov	 edi, DWORD PTR [rcx]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	3b f9		 cmp	 edi, ecx
  0001c	0f 85 91 00 00
	00		 jne	 $LN8@push_back
  00022	ff c7		 inc	 edi

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00024	85 c9		 test	 ecx, ecx
  00026	74 0b		 je	 SHORT $LN6@push_back
  00028	8b c1		 mov	 eax, ecx
  0002a	99		 cdq
  0002b	2b c2		 sub	 eax, edx
  0002d	d1 f8		 sar	 eax, 1
  0002f	03 c1		 add	 eax, ecx
  00031	eb 05		 jmp	 SHORT $LN7@push_back
$LN6@push_back:
  00033	b8 08 00 00 00	 mov	 eax, 8
$LN7@push_back:
  00038	3b c7		 cmp	 eax, edi
  0003a	0f 4f f8	 cmovg	 edi, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0003d	3b f9		 cmp	 edi, ecx
  0003f	7e 72		 jle	 SHORT $LN8@push_back
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00048	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0004d	48 85 c0	 test	 rax, rax
  00050	74 06		 je	 SHORT $LN13@push_back

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00052	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN13@push_back:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00058	48 63 c7	 movsxd	 rax, edi
  0005b	48 69 c8 88 00
	00 00		 imul	 rcx, rax, 136		; 00000088H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00068	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0006c	48 8b e8	 mov	 rbp, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0006f	48 85 d2	 test	 rdx, rdx
  00072	74 33		 je	 SHORT $LN23@push_back
  00074	48 63 0b	 movsxd	 rcx, DWORD PTR [rbx]
  00077	4c 69 c1 88 00
	00 00		 imul	 r8, rcx, 136		; 00000088H
  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 memcpy
  00086	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  0008a	48 85 c9	 test	 rcx, rcx
  0008d	74 12		 je	 SHORT $LN21@push_back

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0008f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00096	48 85 c0	 test	 rax, rax
  00099	74 06		 je	 SHORT $LN21@push_back

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0009b	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN21@push_back:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@push_back:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  000a7	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp
  000ab	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000b0	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN8@push_back:

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000b3	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  000b6	0f 28 06	 movaps	 xmm0, XMMWORD PTR [rsi]
  000b9	0f 28 4e 10	 movaps	 xmm1, XMMWORD PTR [rsi+16]
  000bd	48 69 c8 88 00
	00 00		 imul	 rcx, rax, 136		; 00000088H
  000c4	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000c8	0f 11 04 01	 movups	 XMMWORD PTR [rcx+rax], xmm0
  000cc	0f 28 46 20	 movaps	 xmm0, XMMWORD PTR [rsi+32]
  000d0	0f 11 4c 01 10	 movups	 XMMWORD PTR [rcx+rax+16], xmm1
  000d5	0f 28 4e 30	 movaps	 xmm1, XMMWORD PTR [rsi+48]
  000d9	0f 11 44 01 20	 movups	 XMMWORD PTR [rcx+rax+32], xmm0
  000de	0f 28 46 40	 movaps	 xmm0, XMMWORD PTR [rsi+64]
  000e2	0f 11 4c 01 30	 movups	 XMMWORD PTR [rcx+rax+48], xmm1
  000e7	0f 28 4e 50	 movaps	 xmm1, XMMWORD PTR [rsi+80]
  000eb	0f 11 44 01 40	 movups	 XMMWORD PTR [rcx+rax+64], xmm0
  000f0	0f 28 46 60	 movaps	 xmm0, XMMWORD PTR [rsi+96]
  000f4	0f 11 4c 01 50	 movups	 XMMWORD PTR [rcx+rax+80], xmm1
  000f9	0f 28 4e 70	 movaps	 xmm1, XMMWORD PTR [rsi+112]
  000fd	0f 11 44 01 60	 movups	 XMMWORD PTR [rcx+rax+96], xmm0
  00102	f2 0f 10 86 80
	00 00 00	 movsd	 xmm0, QWORD PTR [rsi+128]
  0010a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0010f	0f 11 4c 01 70	 movups	 XMMWORD PTR [rcx+rax+112], xmm1
  00114	f2 0f 11 84 01
	80 00 00 00	 movsd	 QWORD PTR [rcx+rax+128], xmm0
  0011d	ff 03		 inc	 DWORD PTR [rbx]
  0011f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00124	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00128	5f		 pop	 rdi
  00129	c3		 ret	 0
?push_back@?$ImVector@UImFontConfig@@@@QEAAXAEBUImFontConfig@@@Z ENDP ; ImVector<ImFontConfig>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ
_TEXT	SEGMENT
this$ = 48
?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ PROC ; ImVector<ImFontConfig>::back, COMDAT

; 1803 :     inline T& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b 01		 mov	 eax, DWORD PTR [rcx]
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	85 c0		 test	 eax, eax
  0000d	7f 1c		 jg	 SHORT $LN3@back
  0000f	41 b8 0b 07 00
	00		 mov	 r8d, 1803		; 0000070bH
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00029	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN3@back:
  0002b	ff c8		 dec	 eax
  0002d	48 63 c8	 movsxd	 rcx, eax
  00030	48 69 c1 88 00
	00 00		 imul	 rax, rcx, 136		; 00000088H
  00037	48 03 43 08	 add	 rax, QWORD PTR [rbx+8]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
?back@?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@XZ ENDP ; ImVector<ImFontConfig>::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z PROC ; ImVector<ImFontConfig>::operator[], COMDAT

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	85 d2		 test	 edx, edx
  00012	78 04		 js	 SHORT $LN3@operator
  00014	3b 19		 cmp	 ebx, DWORD PTR [rcx]
  00016	7c 1a		 jl	 SHORT $LN4@operator
$LN3@operator:
  00018	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@operator:
  00032	48 69 c3 88 00
	00 00		 imul	 rax, rbx, 136		; 00000088H
  00039	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003e	48 03 47 08	 add	 rax, QWORD PTR [rdi+8]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??A?$ImVector@UImFontConfig@@@@QEAAAEAUImFontConfig@@H@Z ENDP ; ImVector<ImFontConfig>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ PROC		; ImVector<ImFontConfig>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@UImFontConfig@@@@QEAAXXZ ENDP		; ImVector<ImFontConfig>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontConfig@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontConfig@@@@QEAA@XZ PROC		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>, COMDAT

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
  00000	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 19		 je	 SHORT $LN8@ImVector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00010	48 85 c0	 test	 rax, rax
  00013	74 06		 je	 SHORT $LN6@ImVector

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00015	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@ImVector:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0001b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
$LN8@ImVector:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00022	c3		 ret	 0
??1?$ImVector@UImFontConfig@@@@QEAA@XZ ENDP		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontConfig@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontConfig@@@@QEAA@XZ PROC		; ImVector<ImFontConfig>::ImVector<ImFontConfig>, COMDAT

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$ImVector@UImFontConfig@@@@QEAA@XZ ENDP		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z PROC ; ImVector<ImFontAtlasCustomRect>::push_back, COMDAT

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN28:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b 39		 mov	 edi, DWORD PTR [rcx]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00017	48 8b ea	 mov	 rbp, rdx
  0001a	3b f9		 cmp	 edi, ecx
  0001c	0f 85 8b 00 00
	00		 jne	 $LN8@push_back
  00022	ff c7		 inc	 edi

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00024	85 c9		 test	 ecx, ecx
  00026	74 0b		 je	 SHORT $LN6@push_back
  00028	8b c1		 mov	 eax, ecx
  0002a	99		 cdq
  0002b	2b c2		 sub	 eax, edx
  0002d	d1 f8		 sar	 eax, 1
  0002f	03 c1		 add	 eax, ecx
  00031	eb 05		 jmp	 SHORT $LN7@push_back
$LN6@push_back:
  00033	b8 08 00 00 00	 mov	 eax, 8
$LN7@push_back:
  00038	3b c7		 cmp	 eax, edi
  0003a	0f 4f f8	 cmovg	 edi, eax

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0003d	3b f9		 cmp	 edi, ecx
  0003f	7e 6c		 jle	 SHORT $LN8@push_back
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00048	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0004d	48 85 c0	 test	 rax, rax
  00050	74 06		 je	 SHORT $LN13@push_back

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00052	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN13@push_back:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00058	48 63 cf	 movsxd	 rcx, edi
  0005b	48 c1 e1 05	 shl	 rcx, 5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00065	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00069	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0006c	48 85 d2	 test	 rdx, rdx
  0006f	74 30		 je	 SHORT $LN23@push_back
  00071	4c 63 03	 movsxd	 r8, DWORD PTR [rbx]
  00074	48 8b c8	 mov	 rcx, rax
  00077	49 c1 e0 05	 shl	 r8, 5
  0007b	e8 00 00 00 00	 call	 memcpy
  00080	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00084	48 85 c9	 test	 rcx, rcx
  00087	74 12		 je	 SHORT $LN21@push_back

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00089	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00090	48 85 c0	 test	 rax, rax
  00093	74 06		 je	 SHORT $LN21@push_back

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00095	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN21@push_back:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@push_back:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  000a1	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  000a5	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000aa	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN8@push_back:

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  000ad	48 63 0b	 movsxd	 rcx, DWORD PTR [rbx]
  000b0	0f 10 45 00	 movups	 xmm0, XMMWORD PTR [rbp]
  000b4	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000b8	48 c1 e1 05	 shl	 rcx, 5
  000bc	0f 11 04 01	 movups	 XMMWORD PTR [rcx+rax], xmm0
  000c0	0f 10 4d 10	 movups	 xmm1, XMMWORD PTR [rbp+16]
  000c4	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000c9	0f 11 4c 01 10	 movups	 XMMWORD PTR [rcx+rax+16], xmm1
  000ce	ff 03		 inc	 DWORD PTR [rbx]
  000d0	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
?push_back@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXAEBUImFontAtlasCustomRect@@@Z ENDP ; ImVector<ImFontAtlasCustomRect>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z PROC ; ImVector<ImFontAtlasCustomRect>::operator[], COMDAT

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	85 d2		 test	 edx, edx
  00012	78 04		 js	 SHORT $LN3@operator
  00014	3b 19		 cmp	 ebx, DWORD PTR [rcx]
  00016	7c 1a		 jl	 SHORT $LN4@operator
$LN3@operator:
  00018	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@operator:
  00032	48 8b c3	 mov	 rax, rbx
  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 c1 e0 05	 shl	 rax, 5
  0003e	48 03 47 08	 add	 rax, QWORD PTR [rdi+8]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??A?$ImVector@UImFontAtlasCustomRect@@@@QEAAAEAUImFontAtlasCustomRect@@H@Z ENDP ; ImVector<ImFontAtlasCustomRect>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ PROC ; ImVector<ImFontAtlasCustomRect>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXXZ ENDP ; ImVector<ImFontAtlasCustomRect>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ PROC	; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>, COMDAT

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN14:
  00000	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 19		 je	 SHORT $LN8@ImVector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00010	48 85 c0	 test	 rax, rax
  00013	74 06		 je	 SHORT $LN6@ImVector

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00015	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@ImVector:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0001b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
$LN8@ImVector:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00022	c3		 ret	 0
??1?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ ENDP	; ImVector<ImFontAtlasCustomRect>::~ImVector<ImFontAtlasCustomRect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ PROC	; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>, COMDAT

; 1780 :     inline ImVector() { Size = Capacity = 0; Data = NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$ImVector@UImFontAtlasCustomRect@@@@QEAA@XZ ENDP	; ImVector<ImFontAtlasCustomRect>::ImVector<ImFontAtlasCustomRect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ PROC	; ImVector<ImFont *>::clear_delete, COMDAT

; 1786 :     inline void         clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

$LN76:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	48 8b f9	 mov	 rdi, rcx
  00018	33 f6		 xor	 esi, esi
  0001a	39 31		 cmp	 DWORD PTR [rcx], esi
  0001c	0f 8e ac 00 00
	00		 jle	 $LN3@clear_dele
  00022	45 33 f6	 xor	 r14d, r14d
$LL4@clear_dele:
  00025	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00029	49 8b 1c 06	 mov	 rbx, QWORD PTR [r14+rax]

; 1753 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

  0002d	48 85 db	 test	 rbx, rbx
  00030	0f 84 8a 00 00
	00		 je	 $LN2@clear_dele
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_draw.cpp

; 3125 :     ClearOutputData();

  00036	48 8b cb	 mov	 rcx, rbx
  00039	e8 00 00 00 00	 call	 ?ClearOutputData@ImFont@@QEAAXXZ ; ImFont::ClearOutputData
  0003e	90		 npad	 1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0003f	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00043	48 85 c9	 test	 rcx, rcx
  00046	74 19		 je	 SHORT $LN23@clear_dele
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00048	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0004f	48 85 c0	 test	 rax, rax
  00052	74 06		 je	 SHORT $LN21@clear_dele

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00054	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN21@clear_dele:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00060	90		 npad	 1
$LN23@clear_dele:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00061	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00065	48 85 c9	 test	 rcx, rcx
  00068	74 19		 je	 SHORT $LN35@clear_dele
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0006a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00071	48 85 c0	 test	 rax, rax
  00074	74 06		 je	 SHORT $LN33@clear_dele

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00076	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN33@clear_dele:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00082	90		 npad	 1
$LN35@clear_dele:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00083	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00087	48 85 c9	 test	 rcx, rcx
  0008a	74 19		 je	 SHORT $LN47@clear_dele
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00093	48 85 c0	 test	 rax, rax
  00096	74 06		 je	 SHORT $LN45@clear_dele

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00098	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN45@clear_dele:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000a4	90		 npad	 1
$LN47@clear_dele:

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000ac	48 85 c0	 test	 rax, rax
  000af	74 06		 je	 SHORT $LN53@clear_dele

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000b1	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN53@clear_dele:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@clear_dele:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1786 :     inline void         clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

  000c0	ff c6		 inc	 esi
  000c2	49 83 c6 08	 add	 r14, 8
  000c6	3b 37		 cmp	 esi, DWORD PTR [rdi]
  000c8	0f 8c 57 ff ff
	ff		 jl	 $LL4@clear_dele
$LN3@clear_dele:

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000ce	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  000d2	48 85 c9	 test	 rcx, rcx
  000d5	74 27		 je	 SHORT $LN60@clear_dele
  000d7	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  000de	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  000e5	48 85 c0	 test	 rax, rax
  000e8	74 06		 je	 SHORT $LN64@clear_dele

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  000ea	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN64@clear_dele:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  000f6	48 c7 47 08 00
	00 00 00	 mov	 QWORD PTR [rdi+8], 0
$LN60@clear_dele:

; 1786 :     inline void         clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }     // Important: never called automatically! always explicit.

  000fe	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00103	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00108	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0010d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00111	41 5e		 pop	 r14
  00113	c3		 ret	 0
?clear_delete@?$ImVector@PEAUImFont@@@@QEAAXXZ ENDP	; ImVector<ImFont *>::clear_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?end@?$ImVector@I@@QEBAPEBIXZ
_TEXT	SEGMENT
this$ = 8
?end@?$ImVector@I@@QEBAPEBIXZ PROC			; ImVector<unsigned int>::end, COMDAT

; 1800 :     inline const T* end() const { return Data + Size; }

  00000	48 63 11	 movsxd	 rdx, DWORD PTR [rcx]
  00003	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00007	48 8d 04 90	 lea	 rax, QWORD PTR [rax+rdx*4]
  0000b	c3		 ret	 0
?end@?$ImVector@I@@QEBAPEBIXZ ENDP			; ImVector<unsigned int>::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?begin@?$ImVector@I@@QEBAPEBIXZ
_TEXT	SEGMENT
this$ = 8
?begin@?$ImVector@I@@QEBAPEBIXZ PROC			; ImVector<unsigned int>::begin, COMDAT

; 1798 :     inline const T* begin() const { return Data; }

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	c3		 ret	 0
?begin@?$ImVector@I@@QEBAPEBIXZ ENDP			; ImVector<unsigned int>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@I@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$ImVector@I@@QEBA_NXZ PROC			; ImVector<unsigned int>::empty, COMDAT

; 1789 :     inline bool         empty() const { return Size == 0; }

  00000	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00003	0f 94 c0	 sete	 al
  00006	c3		 ret	 0
?empty@?$ImVector@I@@QEBA_NXZ ENDP			; ImVector<unsigned int>::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PEAX@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?pop_back@?$ImVector@PEAX@@QEAAXXZ PROC			; ImVector<void *>::pop_back, COMDAT

; 1815 :     inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b 01		 mov	 eax, DWORD PTR [rcx]
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	85 c0		 test	 eax, eax
  0000d	7f 22		 jg	 SHORT $LN4@pop_back
  0000f	41 b8 17 07 00
	00		 mov	 r8d, 1815		; 00000717H
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00029	ff 0b		 dec	 DWORD PTR [rbx]
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
$LN4@pop_back:
  00031	ff c8		 dec	 eax
  00033	89 01		 mov	 DWORD PTR [rcx], eax
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
?pop_back@?$ImVector@PEAX@@QEAAXXZ ENDP			; ImVector<void *>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z PROC		; ImVector<void *>::push_back, COMDAT

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0000c	48 8b d9	 mov	 rbx, rcx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00012	48 8b fa	 mov	 rdi, rdx
  00015	3b c1		 cmp	 eax, ecx
  00017	75 2c		 jne	 SHORT $LN2@push_back
  00019	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001d	85 c9		 test	 ecx, ecx
  0001f	74 0b		 je	 SHORT $LN6@push_back
  00021	8b c1		 mov	 eax, ecx
  00023	99		 cdq
  00024	2b c2		 sub	 eax, edx
  00026	d1 f8		 sar	 eax, 1
  00028	03 c1		 add	 eax, ecx
  0002a	eb 05		 jmp	 SHORT $LN7@push_back
$LN6@push_back:
  0002c	b8 08 00 00 00	 mov	 eax, 8
$LN7@push_back:
  00031	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00034	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00037	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0003b	41 8b d0	 mov	 edx, r8d
  0003e	e8 00 00 00 00	 call	 ?reserve@?$ImVector@PEAX@@QEAAXH@Z ; ImVector<void *>::reserve
  00043	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN2@push_back:
  00045	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00049	48 63 d0	 movsxd	 rdx, eax
  0004c	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0004f	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00053	ff 03		 inc	 DWORD PTR [rbx]
  00055	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
?push_back@?$ImVector@PEAX@@QEAAXAEBQEAX@Z ENDP		; ImVector<void *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@PEAX@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$dead$ = 56
?resize@?$ImVector@PEAX@@QEAAXH@Z PROC			; ImVector<void *>::resize, COMDAT

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0000c	85 c9		 test	 ecx, ecx
  0000e	79 18		 jns	 SHORT $LN8@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00010	8b c1		 mov	 eax, ecx
  00012	99		 cdq
  00013	2b c2		 sub	 eax, edx
  00015	33 d2		 xor	 edx, edx
  00017	d1 f8		 sar	 eax, 1
  00019	03 c1		 add	 eax, ecx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0001b	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001e	85 c0		 test	 eax, eax
  00020	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00023	e8 00 00 00 00	 call	 ?reserve@?$ImVector@PEAX@@QEAAXH@Z ; ImVector<void *>::reserve
$LN8@resize:
  00028	c7 03 00 00 00
	00		 mov	 DWORD PTR [rbx], 0
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
?resize@?$ImVector@PEAX@@QEAAXH@Z ENDP			; ImVector<void *>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PEAX@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@PEAX@@QEAAXXZ PROC			; ImVector<void *>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@PEAX@@QEAAXXZ ENDP			; ImVector<void *>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ PROC		; ImVector<ImVec4>::pop_back, COMDAT

; 1815 :     inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b 01		 mov	 eax, DWORD PTR [rcx]
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	85 c0		 test	 eax, eax
  0000d	7f 22		 jg	 SHORT $LN4@pop_back
  0000f	41 b8 17 07 00
	00		 mov	 r8d, 1815		; 00000717H
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@KCECIPDP@?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0@
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00029	ff 0b		 dec	 DWORD PTR [rbx]
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
$LN4@pop_back:
  00031	ff c8		 dec	 eax
  00033	89 01		 mov	 DWORD PTR [rcx], eax
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
?pop_back@?$ImVector@UImVec4@@@@QEAAXXZ ENDP		; ImVector<ImVec4>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z
_TEXT	SEGMENT
this$ = 48
v$ = 56
?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z PROC ; ImVector<ImVec4>::push_back, COMDAT

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0000c	48 8b d9	 mov	 rbx, rcx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00012	48 8b fa	 mov	 rdi, rdx
  00015	3b c1		 cmp	 eax, ecx
  00017	75 2c		 jne	 SHORT $LN2@push_back
  00019	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001d	85 c9		 test	 ecx, ecx
  0001f	74 0b		 je	 SHORT $LN6@push_back
  00021	8b c1		 mov	 eax, ecx
  00023	99		 cdq
  00024	2b c2		 sub	 eax, edx
  00026	d1 f8		 sar	 eax, 1
  00028	03 c1		 add	 eax, ecx
  0002a	eb 05		 jmp	 SHORT $LN7@push_back
$LN6@push_back:
  0002c	b8 08 00 00 00	 mov	 eax, 8
$LN7@push_back:
  00031	41 3b c0	 cmp	 eax, r8d

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  00034	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00037	44 0f 4f c0	 cmovg	 r8d, eax

; 1814 :     inline void         push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }

  0003b	41 8b d0	 mov	 edx, r8d
  0003e	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z ; ImVector<ImVec4>::reserve
  00043	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN2@push_back:
  00045	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
  00048	48 63 c8	 movsxd	 rcx, eax
  0004b	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0004f	48 03 c9	 add	 rcx, rcx
  00052	0f 11 04 c8	 movups	 XMMWORD PTR [rax+rcx*8], xmm0
  00056	ff 03		 inc	 DWORD PTR [rbx]
  00058	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
?push_back@?$ImVector@UImVec4@@@@QEAAXAEBUImVec4@@@Z ENDP ; ImVector<ImVec4>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImVec4@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$dead$ = 56
?resize@?$ImVector@UImVec4@@@@QEAAXH@Z PROC		; ImVector<ImVec4>::resize, COMDAT

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0000c	85 c9		 test	 ecx, ecx
  0000e	79 18		 jns	 SHORT $LN8@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00010	8b c1		 mov	 eax, ecx
  00012	99		 cdq
  00013	2b c2		 sub	 eax, edx
  00015	33 d2		 xor	 edx, edx
  00017	d1 f8		 sar	 eax, 1
  00019	03 c1		 add	 eax, ecx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0001b	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001e	85 c0		 test	 eax, eax
  00020	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00023	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z ; ImVector<ImVec4>::reserve
$LN8@resize:
  00028	c7 03 00 00 00
	00		 mov	 DWORD PTR [rbx], 0
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
?resize@?$ImVector@UImVec4@@@@QEAAXH@Z ENDP		; ImVector<ImVec4>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImVec4@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImVec4@@@@QEAAXXZ PROC		; ImVector<ImVec4>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@UImVec4@@@@QEAAXXZ ENDP		; ImVector<ImVec4>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z PROC		; ImVector<ImDrawVert>::resize, COMDAT

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	8b da		 mov	 ebx, edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00012	3b d1		 cmp	 edx, ecx
  00014	7e 23		 jle	 SHORT $LN8@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00016	85 c9		 test	 ecx, ecx
  00018	74 0b		 je	 SHORT $LN6@resize
  0001a	8b c1		 mov	 eax, ecx
  0001c	99		 cdq
  0001d	2b c2		 sub	 eax, edx
  0001f	d1 f8		 sar	 eax, 1
  00021	03 c1		 add	 eax, ecx
  00023	eb 05		 jmp	 SHORT $LN7@resize
$LN6@resize:
  00025	b8 08 00 00 00	 mov	 eax, 8
$LN7@resize:
  0002a	3b c3		 cmp	 eax, ebx
  0002c	8b d3		 mov	 edx, ebx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0002e	48 8b cf	 mov	 rcx, rdi

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00031	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00034	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawVert@@@@QEAAXH@Z ; ImVector<ImDrawVert>::reserve
$LN8@resize:
  00039	89 1f		 mov	 DWORD PTR [rdi], ebx
  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
?resize@?$ImVector@UImDrawVert@@@@QEAAXH@Z ENDP		; ImVector<ImDrawVert>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ PROC		; ImVector<ImDrawVert>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@UImDrawVert@@@@QEAAXXZ ENDP		; ImVector<ImDrawVert>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z
_TEXT	SEGMENT
this$ = 48
i$ = 56
??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z PROC ; ImVector<ImDrawChannel>::operator[], COMDAT

; 1794 :     inline T& operator[](int i) { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	85 d2		 test	 edx, edx
  00012	78 04		 js	 SHORT $LN3@operator
  00014	3b 19		 cmp	 ebx, DWORD PTR [rcx]
  00016	7c 1a		 jl	 SHORT $LN4@operator
$LN3@operator:
  00018	41 b8 02 07 00
	00		 mov	 r8d, 1794		; 00000702H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GPMNJCJ@?$AAi?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?5?$AA?$DM?$AA?5?$AAS@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN4@operator:
  00032	48 8b c3	 mov	 rax, rbx
  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 c1 e0 05	 shl	 rax, 5
  0003e	48 03 47 08	 add	 rax, QWORD PTR [rdi+8]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??A?$ImVector@UImDrawChannel@@@@QEAAAEAUImDrawChannel@@H@Z ENDP ; ImVector<ImDrawChannel>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z
_TEXT	SEGMENT
this$ = 48
it$ = 56
?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z PROC ; ImVector<ImDrawCmd>::erase, COMDAT

; 1817 :     inline T* erase(const T* it) { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00014	48 3b d1	 cmp	 rdx, rcx
  00017	72 0f		 jb	 SHORT $LN6@erase
  00019	4c 63 0f	 movsxd	 r9, DWORD PTR [rdi]
  0001c	4d 6b c1 38	 imul	 r8, r9, 56		; 00000038H
  00020	4c 03 c1	 add	 r8, rcx
  00023	49 3b d0	 cmp	 rdx, r8
  00026	72 21		 jb	 SHORT $LN4@erase
$LN6@erase:
  00028	41 b8 19 07 00
	00		 mov	 r8d, 1817		; 00000719H
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1KC@GNKKHKIA@?$AAC?$AA?3?$AA?2?$AAU?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAv?$AAi?$AAn?$AA?2?$AAD?$AAo@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@NPHOAPAC@?$AAi?$AAt?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00042	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00046	44 8b 0f	 mov	 r9d, DWORD PTR [rdi]
$LN4@erase:
  00049	48 2b d9	 sub	 rbx, rcx
  0004c	48 b8 25 49 92
	24 49 92 24 49	 mov	 rax, 5270498306774157605 ; 4924924924924925H
  00056	48 f7 eb	 imul	 rbx
  00059	48 c1 fa 04	 sar	 rdx, 4
  0005d	48 8b c2	 mov	 rax, rdx
  00060	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00064	48 03 d0	 add	 rdx, rax
  00067	49 63 c1	 movsxd	 rax, r9d
  0006a	48 6b da 38	 imul	 rbx, rdx, 56		; 00000038H
  0006e	48 2b c2	 sub	 rax, rdx
  00071	4c 6b c0 38	 imul	 r8, rax, 56		; 00000038H
  00075	48 03 cb	 add	 rcx, rbx
  00078	49 83 e8 38	 sub	 r8, 56			; 00000038H
  0007c	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00080	e8 00 00 00 00	 call	 memmove
  00085	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00089	ff 0f		 dec	 DWORD PTR [rdi]
  0008b	48 03 c3	 add	 rax, rbx
  0008e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00093	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
?erase@?$ImVector@UImDrawCmd@@@@QEAAPEAUImDrawCmd@@PEBU2@@Z ENDP ; ImVector<ImDrawCmd>::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z PROC		; ImVector<ImDrawCmd>::resize, COMDAT

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	8b da		 mov	 ebx, edx
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00012	3b d1		 cmp	 edx, ecx
  00014	7e 23		 jle	 SHORT $LN8@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00016	85 c9		 test	 ecx, ecx
  00018	74 0b		 je	 SHORT $LN6@resize
  0001a	8b c1		 mov	 eax, ecx
  0001c	99		 cdq
  0001d	2b c2		 sub	 eax, edx
  0001f	d1 f8		 sar	 eax, 1
  00021	03 c1		 add	 eax, ecx
  00023	eb 05		 jmp	 SHORT $LN7@resize
$LN6@resize:
  00025	b8 08 00 00 00	 mov	 eax, 8
$LN7@resize:
  0002a	3b c3		 cmp	 eax, ebx
  0002c	8b d3		 mov	 edx, ebx

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  0002e	48 8b cf	 mov	 rcx, rdi

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00031	0f 4f d0	 cmovg	 edx, eax

; 1808 :     inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

  00034	e8 00 00 00 00	 call	 ?reserve@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ; ImVector<ImDrawCmd>::reserve
$LN8@resize:
  00039	89 1f		 mov	 DWORD PTR [rdi], ebx
  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
?resize@?$ImVector@UImDrawCmd@@@@QEAAXH@Z ENDP		; ImVector<ImDrawCmd>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ PROC		; ImVector<ImDrawCmd>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@UImDrawCmd@@@@QEAAXXZ ENDP		; ImVector<ImDrawCmd>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QEAAXHAEBG@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
v$ = 64
?resize@?$ImVector@G@@QEAAXHAEBG@Z PROC			; ImVector<unsigned short>::resize, COMDAT

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 63 fa	 movsxd	 rdi, edx
  00012	48 8b d9	 mov	 rbx, rcx
  00015	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00018	49 8b f0	 mov	 rsi, r8
  0001b	3b f9		 cmp	 edi, ecx
  0001d	7e 23		 jle	 SHORT $LN5@resize

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0001f	85 c9		 test	 ecx, ecx
  00021	74 0b		 je	 SHORT $LN10@resize
  00023	8b c1		 mov	 eax, ecx
  00025	99		 cdq
  00026	2b c2		 sub	 eax, edx
  00028	d1 f8		 sar	 eax, 1
  0002a	03 c1		 add	 eax, ecx
  0002c	eb 05		 jmp	 SHORT $LN11@resize
$LN10@resize:
  0002e	b8 08 00 00 00	 mov	 eax, 8
$LN11@resize:
  00033	3b c7		 cmp	 eax, edi
  00035	8b d7		 mov	 edx, edi

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  00037	48 8b cb	 mov	 rcx, rbx

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  0003a	0f 4f d0	 cmovg	 edx, eax

; 1809 :     inline void         resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }

  0003d	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QEAAXH@Z ; ImVector<unsigned short>::reserve
$LN5@resize:
  00042	48 63 03	 movsxd	 rax, DWORD PTR [rbx]
  00045	3b f8		 cmp	 edi, eax
  00047	7e 1b		 jle	 SHORT $LN16@resize
  00049	48 8b d0	 mov	 rdx, rax
  0004c	48 3b c7	 cmp	 rax, rdi
  0004f	7d 13		 jge	 SHORT $LN16@resize
$LL4@resize:
  00051	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00055	0f b7 06	 movzx	 eax, WORD PTR [rsi]
  00058	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  0005c	48 ff c2	 inc	 rdx
  0005f	48 3b d7	 cmp	 rdx, rdi
  00062	7c ed		 jl	 SHORT $LL4@resize
$LN16@resize:
  00064	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00069	89 3b		 mov	 DWORD PTR [rbx], edi
  0006b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
?resize@?$ImVector@G@@QEAAXHAEBG@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?empty@?$ImVector@G@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$ImVector@G@@QEBA_NXZ PROC			; ImVector<unsigned short>::empty, COMDAT

; 1789 :     inline bool         empty() const { return Size == 0; }

  00000	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00003	0f 94 c0	 sete	 al
  00006	c3		 ret	 0
?empty@?$ImVector@G@@QEBA_NXZ ENDP			; ImVector<unsigned short>::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
;	COMDAT ??_GImFontBuildSrcData@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GImFontBuildSrcData@@QEAAPEAXI@Z PROC		; ImFontBuildSrcData::`scalar deleting destructor', COMDAT
$LN37:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00009	48 8b 89 08 01
	00 00		 mov	 rcx, QWORD PTR [rcx+264]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 19		 je	 SHORT $LN15@scalar
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 06		 je	 SHORT $LN13@scalar

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00021	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN13@scalar:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0002d	90		 npad	 1
$LN15@scalar:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0002e	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  00035	48 85 c9	 test	 rcx, rcx
  00038	74 19		 je	 SHORT $LN34@scalar
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00041	48 85 c0	 test	 rax, rax
  00044	74 06		 je	 SHORT $LN28@scalar

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00046	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN28@scalar:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00052	90		 npad	 1
$LN34@scalar:
  00053	48 8b c3	 mov	 rax, rbx
  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
??_GImFontBuildSrcData@@QEAAPEAXI@Z ENDP		; ImFontBuildSrcData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
;	COMDAT ??1ImFontBuildSrcData@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImFontBuildSrcData@@QEAA@XZ PROC			; ImFontBuildSrcData::~ImFontBuildSrcData, COMDAT
$LN33:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00009	48 8b 89 08 01
	00 00		 mov	 rcx, QWORD PTR [rcx+264]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 19		 je	 SHORT $LN11@ImFontBuil
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 06		 je	 SHORT $LN9@ImFontBuil

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00021	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN9@ImFontBuil:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0002d	90		 npad	 1
$LN11@ImFontBuil:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  0002e	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  00035	48 85 c9	 test	 rcx, rcx
  00038	74 19		 je	 SHORT $LN30@ImFontBuil
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00041	48 85 c0	 test	 rax, rax
  00044	74 06		 je	 SHORT $LN24@ImFontBuil

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00046	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN24@ImFontBuil:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00052	90		 npad	 1
$LN30@ImFontBuil:
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
??1ImFontBuildSrcData@@QEAA@XZ ENDP			; ImFontBuildSrcData::~ImFontBuildSrcData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
;	COMDAT ??1ImBitVector@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImBitVector@@QEAA@XZ PROC				; ImBitVector::~ImBitVector, COMDAT
$LN18:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1783 :     inline ~ImVector() { if (Data) IM_FREE(Data); } // Important: does not destruct anything

  00004	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00008	48 85 c9	 test	 rcx, rcx
  0000b	74 19		 je	 SHORT $LN15@ImBitVecto
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00014	48 85 c0	 test	 rax, rax
  00017	74 06		 je	 SHORT $LN9@ImBitVecto

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00019	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN9@ImBitVecto:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00025	90		 npad	 1
$LN15@ImBitVecto:
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
??1ImBitVector@@QEAA@XZ ENDP				; ImBitVector::~ImBitVector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z PROC	; ImVector<stbtt_packedchar>::reserve, COMDAT

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN21:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00013	7e 69		 jle	 SHORT $LN1@reserve
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00021	48 85 c0	 test	 rax, rax
  00024	74 06		 je	 SHORT $LN6@reserve

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00026	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN6@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0002c	48 6b cf 1c	 imul	 rcx, rdi, 28
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00036	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0003a	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0003d	48 85 d2	 test	 rdx, rdx
  00040	74 30		 je	 SHORT $LN16@reserve
  00042	48 63 0b	 movsxd	 rcx, DWORD PTR [rbx]
  00045	4c 6b c1 1c	 imul	 r8, rcx, 28
  00049	48 8b c8	 mov	 rcx, rax
  0004c	e8 00 00 00 00	 call	 memcpy
  00051	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00055	48 85 c9	 test	 rcx, rcx
  00058	74 12		 je	 SHORT $LN14@reserve

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0005a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00061	48 85 c0	 test	 rax, rax
  00064	74 06		 je	 SHORT $LN14@reserve

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00066	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN14@reserve:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00072	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  00076	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0007b	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN1@reserve:
  0007e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
?reserve@?$ImVector@Ustbtt_packedchar@@@@QEAAXH@Z ENDP	; ImVector<stbtt_packedchar>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z PROC ; ImVector<stbtt_packedchar>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@Ustbtt_packedchar@@@@QEBAHH@Z ENDP ; ImVector<stbtt_packedchar>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z PROC	; ImVector<stbrp_rect>::reserve, COMDAT

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN21:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00013	7e 6c		 jle	 SHORT $LN1@reserve
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00021	48 85 c0	 test	 rax, rax
  00024	74 06		 je	 SHORT $LN6@reserve

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00026	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN6@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	48 c1 e1 04	 shl	 rcx, 4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00039	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0003d	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00040	48 85 d2	 test	 rdx, rdx
  00043	74 30		 je	 SHORT $LN16@reserve
  00045	4c 63 03	 movsxd	 r8, DWORD PTR [rbx]
  00048	48 8b c8	 mov	 rcx, rax
  0004b	49 c1 e0 04	 shl	 r8, 4
  0004f	e8 00 00 00 00	 call	 memcpy
  00054	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00058	48 85 c9	 test	 rcx, rcx
  0005b	74 12		 je	 SHORT $LN14@reserve

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00064	48 85 c0	 test	 rax, rax
  00067	74 06		 je	 SHORT $LN14@reserve

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00069	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN14@reserve:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00075	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  00079	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0007e	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN1@reserve:
  00081	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
?reserve@?$ImVector@Ustbrp_rect@@@@QEAAXH@Z ENDP	; ImVector<stbrp_rect>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z PROC	; ImVector<stbrp_rect>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QEBAHH@Z ENDP	; ImVector<stbrp_rect>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z PROC ; ImVector<ImFontBuildDstData>::reserve, COMDAT

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN21:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00013	7e 6c		 jle	 SHORT $LN1@reserve
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00021	48 85 c0	 test	 rax, rax
  00024	74 06		 je	 SHORT $LN6@reserve

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00026	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN6@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	48 c1 e1 05	 shl	 rcx, 5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00039	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0003d	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00040	48 85 d2	 test	 rdx, rdx
  00043	74 30		 je	 SHORT $LN16@reserve
  00045	4c 63 03	 movsxd	 r8, DWORD PTR [rbx]
  00048	48 8b c8	 mov	 rcx, rax
  0004b	49 c1 e0 05	 shl	 r8, 5
  0004f	e8 00 00 00 00	 call	 memcpy
  00054	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00058	48 85 c9	 test	 rcx, rcx
  0005b	74 12		 je	 SHORT $LN14@reserve

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00064	48 85 c0	 test	 rax, rax
  00067	74 06		 je	 SHORT $LN14@reserve

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00069	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN14@reserve:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00075	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  00079	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0007e	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN1@reserve:
  00081	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
?reserve@?$ImVector@UImFontBuildDstData@@@@QEAAXH@Z ENDP ; ImVector<ImFontBuildDstData>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z PROC ; ImVector<ImFontBuildDstData>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@UImFontBuildDstData@@@@QEBAHH@Z ENDP ; ImVector<ImFontBuildDstData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z PROC ; ImVector<ImFontBuildSrcData>::reserve, COMDAT

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN21:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00013	7e 6f		 jle	 SHORT $LN1@reserve
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00021	48 85 c0	 test	 rax, rax
  00024	74 06		 je	 SHORT $LN6@reserve

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00026	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN6@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0002c	48 69 cf 10 01
	00 00		 imul	 rcx, rdi, 272		; 00000110H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00039	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0003d	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00040	48 85 d2	 test	 rdx, rdx
  00043	74 33		 je	 SHORT $LN16@reserve
  00045	48 63 0b	 movsxd	 rcx, DWORD PTR [rbx]
  00048	4c 69 c1 10 01
	00 00		 imul	 r8, rcx, 272		; 00000110H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 memcpy
  00057	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  0005b	48 85 c9	 test	 rcx, rcx
  0005e	74 12		 je	 SHORT $LN14@reserve

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00060	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00067	48 85 c0	 test	 rax, rax
  0006a	74 06		 je	 SHORT $LN14@reserve

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0006c	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN14@reserve:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00078	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  0007c	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00081	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN1@reserve:
  00084	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
?reserve@?$ImVector@UImFontBuildSrcData@@@@QEAAXH@Z ENDP ; ImVector<ImFontBuildSrcData>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z PROC ; ImVector<ImFontBuildSrcData>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@UImFontBuildSrcData@@@@QEBAHH@Z ENDP ; ImVector<ImFontBuildSrcData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ PROC	; ImVector<ImFontBuildSrcData>::clear, COMDAT

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 27		 je	 SHORT $LN2@clear
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00019	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00020	48 85 c0	 test	 rax, rax
  00023	74 06		 je	 SHORT $LN6@clear

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00025	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN6@clear:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1785 :     inline void         clear() { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

  00031	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN2@clear:
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
?clear@?$ImVector@UImFontBuildSrcData@@@@QEAAXXZ ENDP	; ImVector<ImFontBuildSrcData>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z PROC	; ImVector<ImFontGlyph>::reserve, COMDAT

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN21:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00013	7e 71		 jle	 SHORT $LN1@reserve
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00021	48 85 c0	 test	 rax, rax
  00024	74 06		 je	 SHORT $LN6@reserve

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00026	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN6@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0002c	48 8d 0c bf	 lea	 rcx, QWORD PTR [rdi+rdi*4]
  00030	48 c1 e1 03	 shl	 rcx, 3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0003a	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0003e	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00041	48 85 d2	 test	 rdx, rdx
  00044	74 34		 je	 SHORT $LN16@reserve
  00046	48 63 0b	 movsxd	 rcx, DWORD PTR [rbx]
  00049	4c 8d 04 89	 lea	 r8, QWORD PTR [rcx+rcx*4]
  0004d	48 8b c8	 mov	 rcx, rax
  00050	49 c1 e0 03	 shl	 r8, 3
  00054	e8 00 00 00 00	 call	 memcpy
  00059	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  0005d	48 85 c9	 test	 rcx, rcx
  00060	74 12		 je	 SHORT $LN14@reserve

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00062	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00069	48 85 c0	 test	 rax, rax
  0006c	74 06		 je	 SHORT $LN14@reserve

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0006e	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN14@reserve:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0007a	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  0007e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00083	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN1@reserve:
  00086	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
?reserve@?$ImVector@UImFontGlyph@@@@QEAAXH@Z ENDP	; ImVector<ImFontGlyph>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z PROC ; ImVector<ImFontGlyph>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@UImFontGlyph@@@@QEBAHH@Z ENDP ; ImVector<ImFontGlyph>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z PROC	; ImVector<ImFontConfig>::reserve, COMDAT

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN21:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00013	7e 6f		 jle	 SHORT $LN1@reserve
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00021	48 85 c0	 test	 rax, rax
  00024	74 06		 je	 SHORT $LN6@reserve

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00026	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN6@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0002c	48 69 cf 88 00
	00 00		 imul	 rcx, rdi, 136		; 00000088H
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00039	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0003d	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00040	48 85 d2	 test	 rdx, rdx
  00043	74 33		 je	 SHORT $LN16@reserve
  00045	48 63 0b	 movsxd	 rcx, DWORD PTR [rbx]
  00048	4c 69 c1 88 00
	00 00		 imul	 r8, rcx, 136		; 00000088H
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 memcpy
  00057	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  0005b	48 85 c9	 test	 rcx, rcx
  0005e	74 12		 je	 SHORT $LN14@reserve

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00060	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00067	48 85 c0	 test	 rax, rax
  0006a	74 06		 je	 SHORT $LN14@reserve

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0006c	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN14@reserve:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00078	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  0007c	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00081	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN1@reserve:
  00084	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
?reserve@?$ImVector@UImFontConfig@@@@QEAAXH@Z ENDP	; ImVector<ImFontConfig>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z PROC ; ImVector<ImFontConfig>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@UImFontConfig@@@@QEBAHH@Z ENDP ; ImVector<ImFontConfig>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z PROC ; ImVector<ImFontAtlasCustomRect>::reserve, COMDAT

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN21:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00013	7e 6c		 jle	 SHORT $LN1@reserve
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00021	48 85 c0	 test	 rax, rax
  00024	74 06		 je	 SHORT $LN6@reserve

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00026	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN6@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	48 c1 e1 05	 shl	 rcx, 5
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00039	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0003d	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00040	48 85 d2	 test	 rdx, rdx
  00043	74 30		 je	 SHORT $LN16@reserve
  00045	4c 63 03	 movsxd	 r8, DWORD PTR [rbx]
  00048	48 8b c8	 mov	 rcx, rax
  0004b	49 c1 e0 05	 shl	 r8, 5
  0004f	e8 00 00 00 00	 call	 memcpy
  00054	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00058	48 85 c9	 test	 rcx, rcx
  0005b	74 12		 je	 SHORT $LN14@reserve

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00064	48 85 c0	 test	 rax, rax
  00067	74 06		 je	 SHORT $LN14@reserve

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00069	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN14@reserve:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00075	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  00079	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0007e	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN1@reserve:
  00081	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
?reserve@?$ImVector@UImFontAtlasCustomRect@@@@QEAAXH@Z ENDP ; ImVector<ImFontAtlasCustomRect>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QEBAHH@Z PROC ; ImVector<ImFontAtlasCustomRect>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@UImFontAtlasCustomRect@@@@QEBAHH@Z ENDP ; ImVector<ImFontAtlasCustomRect>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PEAX@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@PEAX@@QEAAXH@Z PROC			; ImVector<void *>::reserve, COMDAT

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN21:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00013	7e 6c		 jle	 SHORT $LN1@reserve
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00021	48 85 c0	 test	 rax, rax
  00024	74 06		 je	 SHORT $LN6@reserve

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00026	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN6@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	48 c1 e1 03	 shl	 rcx, 3
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00039	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0003d	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00040	48 85 d2	 test	 rdx, rdx
  00043	74 30		 je	 SHORT $LN16@reserve
  00045	4c 63 03	 movsxd	 r8, DWORD PTR [rbx]
  00048	48 8b c8	 mov	 rcx, rax
  0004b	49 c1 e0 03	 shl	 r8, 3
  0004f	e8 00 00 00 00	 call	 memcpy
  00054	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00058	48 85 c9	 test	 rcx, rcx
  0005b	74 12		 je	 SHORT $LN14@reserve

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00064	48 85 c0	 test	 rax, rax
  00067	74 06		 je	 SHORT $LN14@reserve

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00069	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN14@reserve:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00075	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  00079	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0007e	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN1@reserve:
  00081	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
?reserve@?$ImVector@PEAX@@QEAAXH@Z ENDP			; ImVector<void *>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z PROC		; ImVector<void *>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@PEAX@@QEBAHH@Z ENDP		; ImVector<void *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_capacity$ = 56
?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z PROC		; ImVector<ImVec4>::reserve, COMDAT

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN21:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	3b 79 04	 cmp	 edi, DWORD PTR [rcx+4]
  00013	7e 6c		 jle	 SHORT $LN1@reserve
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3601 :     if (ImGuiContext* ctx = GImGui)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00021	48 85 c0	 test	 rax, rax
  00024	74 06		 je	 SHORT $LN6@reserve

; 3602 :         ctx->IO.MetricsActiveAllocations++;

  00026	ff 80 ec 00 00
	00		 inc	 DWORD PTR [rax+236]
$LN6@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	48 c1 e1 04	 shl	 rcx, 4
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00039	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 1019 : static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }

  0003d	48 8b f0	 mov	 rsi, rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00040	48 85 d2	 test	 rdx, rdx
  00043	74 30		 je	 SHORT $LN16@reserve
  00045	4c 63 03	 movsxd	 r8, DWORD PTR [rbx]
  00048	48 8b c8	 mov	 rcx, rax
  0004b	49 c1 e0 04	 shl	 r8, 4
  0004f	e8 00 00 00 00	 call	 memcpy
  00054	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3609 :     if (ptr)

  00058	48 85 c9	 test	 rcx, rcx
  0005b	74 12		 je	 SHORT $LN14@reserve

; 3610 :         if (ImGuiContext* ctx = GImGui)

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00064	48 85 c0	 test	 rax, rax
  00067	74 06		 je	 SHORT $LN14@reserve

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  00069	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN14@reserve:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@reserve:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1811 :     inline void         reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

  00075	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  00079	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0007e	89 7b 04	 mov	 DWORD PTR [rbx+4], edi
$LN1@reserve:
  00081	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
?reserve@?$ImVector@UImVec4@@@@QEAAXH@Z ENDP		; ImVector<ImVec4>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z PROC	; ImVector<ImVec4>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@UImVec4@@@@QEBAHH@Z ENDP	; ImVector<ImVec4>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z
_TEXT	SEGMENT
this$ = 8
sz$ = 16
?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z PROC	; ImVector<ImDrawVert>::_grow_capacity, COMDAT

; 1807 :     inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

  00000	44 8b 49 04	 mov	 r9d, DWORD PTR [rcx+4]
  00004	44 8b c2	 mov	 r8d, edx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 16		 je	 SHORT $LN3@grow_capac
  0000c	41 8b c1	 mov	 eax, r9d
  0000f	99		 cdq
  00010	2b c2		 sub	 eax, edx
  00012	d1 f8		 sar	 eax, 1
  00014	41 03 c1	 add	 eax, r9d
  00017	41 3b c0	 cmp	 eax, r8d
  0001a	44 0f 4f c0	 cmovg	 r8d, eax
  0001e	41 8b c0	 mov	 eax, r8d
  00021	c3		 ret	 0
$LN3@grow_capac:
  00022	b8 08 00 00 00	 mov	 eax, 8
  00027	41 3b c0	 cmp	 eax, r8d
  0002a	44 0f 4f c0	 cmovg	 r8d, eax
  0002e	41 8b c0	 mov	 eax, r8d
  00031	c3		 ret	 0
?_grow_capacity@?$ImVector@UImDrawVert@@@@QEBAHH@Z ENDP	; ImVector<ImDrawVert>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMin@M@@YAMMM@Z PROC				; ImMin<float>

; 424  : template<typename T> static inline T ImMin(T lhs, T rhs) { return lhs < rhs ? lhs : rhs; }

  00000	f3 0f 5d c1	 minss	 xmm0, xmm1
  00004	c3		 ret	 0
??$ImMin@M@@YAMMM@Z ENDP				; ImMin<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@M@@YAMMM@Z PROC				; ImMax<float>

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  00000	f3 0f 5f c1	 maxss	 xmm0, xmm1
  00004	c3		 ret	 0
??$ImMax@M@@YAMMM@Z ENDP				; ImMax<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@H@@YAHHHH@Z PROC				; ImClamp<int>

; 426  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	3b ca		 cmp	 ecx, edx
  00002	7d 03		 jge	 SHORT $LN3@ImClamp
  00004	8b c2		 mov	 eax, edx
  00006	c3		 ret	 0
$LN3@ImClamp:
  00007	41 3b c8	 cmp	 ecx, r8d
  0000a	41 0f 4f c8	 cmovg	 ecx, r8d
  0000e	8b c1		 mov	 eax, ecx
  00010	c3		 ret	 0
??$ImClamp@H@@YAHHHH@Z ENDP				; ImClamp<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
lhs$ = 8
rhs$ = 16
??$ImMax@H@@YAHHH@Z PROC				; ImMax<int>

; 425  : template<typename T> static inline T ImMax(T lhs, T rhs) { return lhs >= rhs ? lhs : rhs; }

  00000	3b ca		 cmp	 ecx, edx
  00002	0f 4d d1	 cmovge	 edx, ecx
  00005	8b c2		 mov	 eax, edx
  00007	c3		 ret	 0
??$ImMax@H@@YAHHH@Z ENDP				; ImMax<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui_internal.h
_TEXT	SEGMENT
v$ = 8
mn$ = 16
mx$ = 24
??$ImClamp@M@@YAMMMM@Z PROC				; ImClamp<float>

; 426  : template<typename T> static inline T ImClamp(T v, T mn, T mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }

  00000	0f 2f c8	 comiss	 xmm1, xmm0
  00003	76 04		 jbe	 SHORT $LN5@ImClamp
  00005	0f 28 c1	 movaps	 xmm0, xmm1
  00008	c3		 ret	 0
$LN5@ImClamp:
  00009	f3 0f 5d d0	 minss	 xmm2, xmm0
  0000d	0f 28 c2	 movaps	 xmm0, xmm2
  00010	c3		 ret	 0
??$ImClamp@M@@YAMMMM@Z ENDP				; ImClamp<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h
;	COMDAT ??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z
_TEXT	SEGMENT
p$ = 48
??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z PROC		; IM_DELETE<ImFont>, COMDAT

; 1753 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

$LN18:
  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2d		 je	 SHORT $LN15@IM_DELETE
  00005	53		 push	 rbx
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	e8 00 00 00 00	 call	 ??1ImFont@@QEAA@XZ	; ImFont::~ImFont
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.cpp

; 3610 :         if (ImGuiContext* ctx = GImGui)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?GImGui@@3PEAUImGuiContext@@EA ; GImGui
  00019	48 85 c0	 test	 rax, rax
  0001c	74 06		 je	 SHORT $LN9@IM_DELETE

; 3611 :             ctx->IO.MetricsActiveAllocations--;

  0001e	ff 88 ec 00 00
	00		 dec	 DWORD PTR [rax+236]
$LN9@IM_DELETE:

; 1020 : static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }

  00024	48 8b cb	 mov	 rcx, rbx
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\Imgui\imgui.h

; 1753 : template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5b		 pop	 rbx
$LN15@IM_DELETE:
  00032	c3		 ret	 0
??$IM_DELETE@UImFont@@@@YAXPEAUImFont@@@Z ENDP		; IM_DELETE<ImFont>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GImFont@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GImFont@@QEAAPEAXI@Z PROC				; ImFont::`scalar deleting destructor', COMDAT
$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	e8 00 00 00 00	 call	 ??1ImFont@@QEAA@XZ	; ImFont::~ImFont
  0000e	48 8b c3	 mov	 rax, rbx
  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
  00016	c3		 ret	 0
??_GImFont@@QEAAPEAXI@Z ENDP				; ImFont::`scalar deleting destructor'
_TEXT	ENDS
END
