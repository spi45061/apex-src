; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30147.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@CLNGBNDK@SYSTEMROOT@			; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_0N@BDPNIACE@?2SystemRoot?2@		; `string'
PUBLIC	??_C@_0CA@IOOJHFBM@imported?5module?5?$FL?$CFs?$FN?5not?5found?6@ ; `string'
PUBLIC	??_C@_0CD@IMFAMML@?$FL?9?$FN?5failed?5to?5resolve?5import?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0BL@IJFHCNGM@?$FL?$CL?$FN?5resolved?5?$FL?$CFi?$FN?5imports?6@ ; `string'
EXTRN	__imp_getenv:PROC
;	COMDAT ??_C@_0BL@IJFHCNGM@?$FL?$CL?$FN?5resolved?5?$FL?$CFi?$FN?5imports?6@
CONST	SEGMENT
??_C@_0BL@IJFHCNGM@?$FL?$CL?$FN?5resolved?5?$FL?$CFi?$FN?5imports?6@ DB '['
	DB	'+] resolved [%i] imports', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IMFAMML@?$FL?9?$FN?5failed?5to?5resolve?5import?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CD@IMFAMML@?$FL?9?$FN?5failed?5to?5resolve?5import?5?$FL?$CF@ DB '['
	DB	'-] failed to resolve import [%s]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IOOJHFBM@imported?5module?5?$FL?$CFs?$FN?5not?5found?6@
CONST	SEGMENT
??_C@_0CA@IOOJHFBM@imported?5module?5?$FL?$CFs?$FN?5not?5found?6@ DB 'imp'
	DB	'orted module [%s] not found', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BDPNIACE@?2SystemRoot?2@
CONST	SEGMENT
??_C@_0N@BDPNIACE@?2SystemRoot?2@ DB '\SystemRoot\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CLNGBNDK@SYSTEMROOT@
CONST	SEGMENT
??_C@_0L@CLNGBNDK@SYSTEMROOT@ DB 'SYSTEMROOT', 00H	; `string'
PUBLIC	??$forward@PEAUImportFunctionInfo@portable_executable@@@std@@YA$$QEAPEAUImportFunctionInfo@portable_executable@@AEAPEAU12@@Z ; std::forward<portable_executable::ImportFunctionInfo *>
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportFunctionInfo@portable_executable@@00@Z ; std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >
PUBLIC	??$?0V?$allocator@UImportFunctionInfo@portable_executable@@@std@@PEAUImportFunctionInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@$$QEAPEAUImportFunctionInfo@portable_executable@@22@Z ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1><std::allocator<portable_executable::ImportFunctionInfo>,portable_executable::ImportFunctionInfo *,portable_executable::ImportFunctionInfo *,portable_executable::ImportFunctionInfo *>
PUBLIC	??$exchange@PEAUImportFunctionInfo@portable_executable@@$$T@std@@YAPEAUImportFunctionInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<portable_executable::ImportFunctionInfo *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@AEAV10@@Z ; std::move<std::allocator<portable_executable::ImportFunctionInfo> &>
PUBLIC	??$construct@UImportFunctionInfo@portable_executable@@AEAU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEAU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::construct<portable_executable::ImportFunctionInfo,portable_executable::ImportFunctionInfo &>
PUBLIC	??$forward@AEAUImportFunctionInfo@portable_executable@@@std@@YAAEAUImportFunctionInfo@portable_executable@@AEAU12@@Z ; std::forward<portable_executable::ImportFunctionInfo &>
PUBLIC	??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >
PUBLIC	??0ImportFunctionInfo@portable_executable@@QEAA@$$QEAU01@@Z ; portable_executable::ImportFunctionInfo::ImportFunctionInfo
PUBLIC	??0ImportInfo@portable_executable@@QEAA@$$QEAU01@@Z ; portable_executable::ImportInfo::ImportInfo
PUBLIC	??$_Emplace_back@AEAUImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEAUImportFunctionInfo@portable_executable@@@Z ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_back<portable_executable::ImportFunctionInfo &>
PUBLIC	??$construct@UImportFunctionInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::construct<portable_executable::ImportFunctionInfo,portable_executable::ImportFunctionInfo>
PUBLIC	??$forward@UImportFunctionInfo@portable_executable@@@std@@YA$$QEAUImportFunctionInfo@portable_executable@@AEAU12@@Z ; std::forward<portable_executable::ImportFunctionInfo>
PUBLIC	??$construct@URelocInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@URelocInfo@portable_executable@@@1@QEAURelocInfo@portable_executable@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::RelocInfo> >::construct<portable_executable::RelocInfo,portable_executable::RelocInfo>
PUBLIC	??$forward@URelocInfo@portable_executable@@@std@@YA$$QEAURelocInfo@portable_executable@@AEAU12@@Z ; std::forward<portable_executable::RelocInfo>
PUBLIC	??$construct@UImportInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@$$QEAU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo>
PUBLIC	??$forward@UImportInfo@portable_executable@@@std@@YA$$QEAUImportInfo@portable_executable@@AEAU12@@Z ; std::forward<portable_executable::ImportInfo>
PUBLIC	??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Uninitialized_copy<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >
PUBLIC	??$forward@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@AEAV10@@Z ; std::forward<std::allocator<portable_executable::ImportFunctionInfo> >
PUBLIC	??$_Emplace_back@UImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAX$$QEAUImportFunctionInfo@portable_executable@@@Z ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_back<portable_executable::ImportFunctionInfo>
PUBLIC	??$move@AEAUImportFunctionInfo@portable_executable@@@std@@YA$$QEAUImportFunctionInfo@portable_executable@@AEAU12@@Z ; std::move<portable_executable::ImportFunctionInfo &>
PUBLIC	??$_Emplace_back@URelocInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAX$$QEAURelocInfo@portable_executable@@@Z ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::_Emplace_back<portable_executable::RelocInfo>
PUBLIC	??$_To_address@PEAURelocInfo@portable_executable@@@std@@YA?A_PAEBQEAURelocInfo@portable_executable@@@Z ; std::_To_address<portable_executable::RelocInfo *>
PUBLIC	??$_Copy_memmove@PEAURelocInfo@portable_executable@@PEAU12@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@00@Z ; std::_Copy_memmove<portable_executable::RelocInfo *,portable_executable::RelocInfo *>
PUBLIC	??$move@AEAURelocInfo@portable_executable@@@std@@YA$$QEAURelocInfo@portable_executable@@AEAU12@@Z ; std::move<portable_executable::RelocInfo &>
PUBLIC	??$_Emplace_back@UImportInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAX$$QEAUImportInfo@portable_executable@@@Z ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::_Emplace_back<portable_executable::ImportInfo>
PUBLIC	??$move@AEAUImportInfo@portable_executable@@@std@@YA$$QEAUImportInfo@portable_executable@@AEAU12@@Z ; std::move<portable_executable::ImportInfo &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportInfo@portable_executable@@AEAV?$allocator@UImportInfo@portable_executable@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@PEAURelocInfo@portable_executable@@AEAV?$allocator@URelocInfo@portable_executable@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::_Release
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportFunctionInfo@portable_executable@@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Release
PUBLIC	??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z		; std::_Get_size_of_n<40>
PUBLIC	??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Ucopy<portable_executable::ImportFunctionInfo *>
PUBLIC	??$?0V?$allocator@UImportFunctionInfo@portable_executable@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@@Z ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1><std::allocator<portable_executable::ImportFunctionInfo> >
PUBLIC	??$_Get_unwrapped@AEBQEAUImportFunctionInfo@portable_executable@@@std@@YA?A_TAEBQEAUImportFunctionInfo@portable_executable@@@Z ; std::_Get_unwrapped<portable_executable::ImportFunctionInfo * const &>
PUBLIC	??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >
PUBLIC	??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z		; std::_Get_size_of_n<24>
PUBLIC	??$_Get_unwrapped@AEBQEAURelocInfo@portable_executable@@@std@@YA?A_TAEBQEAURelocInfo@portable_executable@@@Z ; std::_Get_unwrapped<portable_executable::RelocInfo * const &>
PUBLIC	??$_Uninitialized_move@PEAURelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YAPEAURelocInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@URelocInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::RelocInfo *,std::allocator<portable_executable::RelocInfo> >
PUBLIC	??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z		; std::_Get_size_of_n<56>
PUBLIC	??$_Get_unwrapped@AEBQEAUImportInfo@portable_executable@@@std@@YA?A_TAEBQEAUImportInfo@portable_executable@@@Z ; std::_Get_unwrapped<portable_executable::ImportInfo * const &>
PUBLIC	??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportInfo *,std::allocator<portable_executable::ImportInfo> >
PUBLIC	??$_Voidify_iter@PEAUImportFunctionInfo@portable_executable@@@std@@YAPEAXPEAUImportFunctionInfo@portable_executable@@@Z ; std::_Voidify_iter<portable_executable::ImportFunctionInfo *>
PUBLIC	??$forward@PEAURelocInfo@portable_executable@@@std@@YA$$QEAPEAURelocInfo@portable_executable@@AEAPEAU12@@Z ; std::forward<portable_executable::RelocInfo *>
PUBLIC	??$forward@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@URelocInfo@portable_executable@@@0@AEAV10@@Z ; std::forward<std::allocator<portable_executable::RelocInfo> >
PUBLIC	??$_Voidify_iter@PEAURelocInfo@portable_executable@@@std@@YAPEAXPEAURelocInfo@portable_executable@@@Z ; std::_Voidify_iter<portable_executable::RelocInfo *>
PUBLIC	??$forward@PEAUImportInfo@portable_executable@@@std@@YA$$QEAPEAUImportInfo@portable_executable@@AEAPEAU12@@Z ; std::forward<portable_executable::ImportInfo *>
PUBLIC	??$forward@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportInfo@portable_executable@@@0@AEAV10@@Z ; std::forward<std::allocator<portable_executable::ImportInfo> >
PUBLIC	??$_Voidify_iter@PEAUImportInfo@portable_executable@@@std@@YAPEAXPEAUImportInfo@portable_executable@@@Z ; std::_Voidify_iter<portable_executable::ImportInfo *>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@XZ ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@URelocInfo@portable_executable@@@2@XZ ; std::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImportInfo@portable_executable@@@2@XZ ; std::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1>::_Get_first
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SA?AV?$allocator@UImportFunctionInfo@portable_executable@@@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::select_on_container_copy_construction
PUBLIC	?capacity@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBA_KXZ ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Umove_if_noexcept1
PUBLIC	?_Buy_raw@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAX_K@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Buy_raw
PUBLIC	?_Getal@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@XZ ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@URelocInfo@portable_executable@@@2@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::RelocInfo> >::max_size
PUBLIC	?capacity@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEBA_KXZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXPEAURelocInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@URelocInfo@portable_executable@@@2@XZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Getal
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@UImportInfo@portable_executable@@@2@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::max_size
PUBLIC	?capacity@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEBA_KXZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@UImportInfo@portable_executable@@@2@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Getal
PUBLIC	??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	??0?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAA@XZ ; std::allocator<portable_executable::ImportFunctionInfo>::allocator<portable_executable::ImportFunctionInfo>
PUBLIC	?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportFunctionInfo>::allocate
PUBLIC	??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >
PUBLIC	?max_size@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBA_KXZ ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::max_size
PUBLIC	?_Umove@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU34@00@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@00@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportFunctionInfo@portable_executable@@_K1@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Change_array
PUBLIC	?_Xlength@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@CAXXZ ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >
PUBLIC	??0?$allocator@URelocInfo@portable_executable@@@std@@QEAA@XZ ; std::allocator<portable_executable::RelocInfo>::allocator<portable_executable::RelocInfo>
PUBLIC	?allocate@?$allocator@URelocInfo@portable_executable@@@std@@QEAAPEAURelocInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::RelocInfo>::allocate
PUBLIC	?max_size@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEBA_KXZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::max_size
PUBLIC	?_Umove@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAPEAURelocInfo@portable_executable@@PEAU34@00@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXPEAURelocInfo@portable_executable@@00@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXQEAURelocInfo@portable_executable@@_K1@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Change_array
PUBLIC	?_Xlength@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@CAXXZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@std@@QEAA@PEAURelocInfo@portable_executable@@00@Z ; std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >
PUBLIC	??0?$allocator@UImportInfo@portable_executable@@@std@@QEAA@XZ ; std::allocator<portable_executable::ImportInfo>::allocator<portable_executable::ImportInfo>
PUBLIC	?allocate@?$allocator@UImportInfo@portable_executable@@@std@@QEAAPEAUImportInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportInfo>::allocate
PUBLIC	?max_size@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEBA_KXZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::max_size
PUBLIC	?_Umove@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAPEAUImportInfo@portable_executable@@PEAU34@00@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@00@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Change_array
PUBLIC	?_Xlength@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@CAXXZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportInfo@portable_executable@@00@Z ; std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >
PUBLIC	??0ImportFunctionInfo@portable_executable@@QEAA@AEBU01@@Z ; portable_executable::ImportFunctionInfo::ImportFunctionInfo
PUBLIC	??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z ; portable_executable::ImportInfo::ImportInfo
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_55b0f89b53a0342680e40398a0d39887>,unsigned __int64,unsigned __int64,char const *,unsigned __int64>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1><>
PUBLIC	??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>
PUBLIC	??$construct@UImportFunctionInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::construct<portable_executable::ImportFunctionInfo,portable_executable::ImportFunctionInfo const &>
PUBLIC	??$forward@AEBUImportFunctionInfo@portable_executable@@@std@@YAAEBUImportFunctionInfo@portable_executable@@AEBU12@@Z ; std::forward<portable_executable::ImportFunctionInfo const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1><>
PUBLIC	??$?0V?$allocator@URelocInfo@portable_executable@@@std@@PEAURelocInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@URelocInfo@portable_executable@@@1@$$QEAPEAURelocInfo@portable_executable@@22@Z ; std::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1><std::allocator<portable_executable::RelocInfo>,portable_executable::RelocInfo *,portable_executable::RelocInfo *,portable_executable::RelocInfo *>
PUBLIC	??$exchange@PEAURelocInfo@portable_executable@@$$T@std@@YAPEAURelocInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<portable_executable::RelocInfo *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@URelocInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@URelocInfo@portable_executable@@@0@AEAV10@@Z ; std::move<std::allocator<portable_executable::RelocInfo> &>
PUBLIC	??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Emplace_reallocate<portable_executable::RelocInfo const &>
PUBLIC	??$construct@URelocInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@URelocInfo@portable_executable@@@1@QEAURelocInfo@portable_executable@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::RelocInfo> >::construct<portable_executable::RelocInfo,portable_executable::RelocInfo const &>
PUBLIC	??$_Unfancy@URelocInfo@portable_executable@@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@@Z ; std::_Unfancy<portable_executable::RelocInfo>
PUBLIC	??$forward@AEBURelocInfo@portable_executable@@@std@@YAAEBURelocInfo@portable_executable@@AEBU12@@Z ; std::forward<portable_executable::RelocInfo const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1><>
PUBLIC	??$?0V?$allocator@UImportInfo@portable_executable@@@std@@PEAUImportInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportInfo@portable_executable@@@1@$$QEAPEAUImportInfo@portable_executable@@22@Z ; std::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1><std::allocator<portable_executable::ImportInfo>,portable_executable::ImportInfo *,portable_executable::ImportInfo *,portable_executable::ImportInfo *>
PUBLIC	??$exchange@PEAUImportInfo@portable_executable@@$$T@std@@YAPEAUImportInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z ; std::exchange<portable_executable::ImportInfo *,std::nullptr_t>
PUBLIC	??$move@AEAV?$allocator@UImportInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportInfo@portable_executable@@@0@AEAV10@@Z ; std::move<std::allocator<portable_executable::ImportInfo> &>
PUBLIC	??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>
PUBLIC	??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>
PUBLIC	??$forward@AEBUImportInfo@portable_executable@@@std@@YAAEBUImportInfo@portable_executable@@AEBU12@@Z ; std::forward<portable_executable::ImportInfo const &>
PUBLIC	?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
PUBLIC	??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z ; <lambda_55b0f89b53a0342680e40398a0d39887>::operator()
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?_Orphan_range@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBAXPEAUImportFunctionInfo@portable_executable@@0@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Orphan_range
PUBLIC	?_Orphan_range@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBAXPEAURelocInfo@portable_executable@@0@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Orphan_range
PUBLIC	?_Orphan_range@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBAXPEAUImportInfo@portable_executable@@0@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Orphan_range
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_back_with_unused_capacity<portable_executable::ImportFunctionInfo const &>
PUBLIC	??$emplace_back@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::emplace_back<portable_executable::ImportFunctionInfo const &>
PUBLIC	?push_back@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportFunctionInfo@portable_executable@@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::push_back
PUBLIC	?_Unchecked_begin@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBAPEBUImportFunctionInfo@portable_executable@@XZ ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBAPEBUImportFunctionInfo@portable_executable@@XZ ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Unchecked_end
PUBLIC	??0?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >
PUBLIC	??0?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBURelocInfo@portable_executable@@@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Emplace_back_with_unused_capacity<portable_executable::RelocInfo const &>
PUBLIC	??$emplace_back@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBURelocInfo@portable_executable@@@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::emplace_back<portable_executable::RelocInfo const &>
PUBLIC	?push_back@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAXAEBURelocInfo@portable_executable@@@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::push_back
PUBLIC	?_Unchecked_begin@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Unchecked_end
PUBLIC	??0?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
PUBLIC	??0?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportInfo@portable_executable@@@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_back_with_unused_capacity<portable_executable::ImportInfo const &>
PUBLIC	??$emplace_back@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportInfo@portable_executable@@@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::emplace_back<portable_executable::ImportInfo const &>
PUBLIC	?push_back@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportInfo@portable_executable@@@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::push_back
PUBLIC	?_Unchecked_begin@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Unchecked_end
PUBLIC	??0ImportFunctionInfo@portable_executable@@QEAA@XZ ; portable_executable::ImportFunctionInfo::ImportFunctionInfo
PUBLIC	??0ImportInfo@portable_executable@@QEAA@XZ	; portable_executable::ImportInfo::ImportInfo
PUBLIC	?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z ; portable_executable::get_imports
PUBLIC	?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z ; portable_executable::relocate_image_by_delta
PUBLIC	?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z ; portable_executable::get_relocations
PUBLIC	?get_nt_headers@portable_executable@@YAPEAU_IMAGE_NT_HEADERS64@@PEAX@Z ; portable_executable::get_nt_headers
PUBLIC	?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z ; portable_executable::resolve_imports
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UImportFunctionInfo@portable_executable@@AEAU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEAU34@@Z DD imagerel $LN8
	DD	imagerel $LN8+46
	DD	imagerel $unwind$??$construct@UImportFunctionInfo@portable_executable@@AEAU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEAU34@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@AEAUImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEAUImportFunctionInfo@portable_executable@@@Z DD imagerel $LN10
	DD	imagerel $LN10+62
	DD	imagerel $unwind$??$_Emplace_back@AEAUImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEAUImportFunctionInfo@portable_executable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z DD imagerel $LN26
	DD	imagerel $LN26+115
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAURelocInfo@portable_executable@@PEAU12@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEAURelocInfo@portable_executable@@PEAU12@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ DD imagerel $LN19
	DD	imagerel $LN19+50
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z DD imagerel $LN28
	DD	imagerel $LN28+115
	DD	imagerel $unwind$??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z DD imagerel $LN50
	DD	imagerel $LN50+123
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+38
	DD	imagerel $unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAURelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YAPEAURelocInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@URelocInfo@portable_executable@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+79
	DD	imagerel $unwind$??$_Uninitialized_move@PEAURelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YAPEAURelocInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@URelocInfo@portable_executable@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z DD imagerel $LN7
	DD	imagerel $LN7+34
	DD	imagerel $unwind$??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z DD imagerel $LN77
	DD	imagerel $LN77+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z DD imagerel $LN77+18
	DD	imagerel $LN77+138
	DD	imagerel $chain$0$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z DD imagerel $LN77+138
	DD	imagerel $LN77+143
	DD	imagerel $chain$1$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$?_Buy_raw@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+116
	DD	imagerel $unwind$?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z DD imagerel $LN94
	DD	imagerel $LN94+191
	DD	imagerel $unwind$??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportFunctionInfo@portable_executable@@_K1@Z DD imagerel $LN27
	DD	imagerel $LN27+180
	DD	imagerel $unwind$?_Change_array@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportFunctionInfo@portable_executable@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@URelocInfo@portable_executable@@@std@@QEAAPEAURelocInfo@portable_executable@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+116
	DD	imagerel $unwind$?allocate@?$allocator@URelocInfo@portable_executable@@@std@@QEAAPEAURelocInfo@portable_executable@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAPEAURelocInfo@portable_executable@@PEAU34@00@Z DD imagerel $LN20
	DD	imagerel $LN20+76
	DD	imagerel $unwind$?_Umove@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAPEAURelocInfo@portable_executable@@PEAU34@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXQEAURelocInfo@portable_executable@@_K1@Z DD imagerel $LN25
	DD	imagerel $LN25+168
	DD	imagerel $unwind$?_Change_array@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXQEAURelocInfo@portable_executable@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@UImportInfo@portable_executable@@@std@@QEAAPEAUImportInfo@portable_executable@@_K@Z DD imagerel $LN30
	DD	imagerel $LN30+108
	DD	imagerel $unwind$?allocate@?$allocator@UImportInfo@portable_executable@@@std@@QEAAPEAUImportInfo@portable_executable@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z DD imagerel $LN41
	DD	imagerel $LN41+39
	DD	imagerel $unwind$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z DD imagerel $LN41+39
	DD	imagerel $LN41+116
	DD	imagerel $chain$0$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z DD imagerel $LN41+116
	DD	imagerel $LN41+200
	DD	imagerel $chain$1$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImportFunctionInfo@portable_executable@@QEAA@AEBU01@@Z DD imagerel $LN6
	DD	imagerel $LN6+43
	DD	imagerel $unwind$??0ImportFunctionInfo@portable_executable@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z DD imagerel $LN99
	DD	imagerel $LN99+207
	DD	imagerel $unwind$??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD imagerel $LN82
	DD	imagerel $LN82+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD imagerel $LN82+46
	DD	imagerel $LN82+436
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD imagerel $LN82+436
	DD	imagerel $LN82+442
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD imagerel $LN82+442
	DD	imagerel $LN82+448
	DD	imagerel $chain$5$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN23
	DD	imagerel $LN23+169
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z DD imagerel $LN59
	DD	imagerel $LN59+432
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA DD imagerel ?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA
	DD	imagerel ?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA+52
	DD	imagerel $unwind$?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UImportFunctionInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEBU34@@Z DD imagerel $LN8
	DD	imagerel $LN8+46
	DD	imagerel $unwind$??$construct@UImportFunctionInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEBU34@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD imagerel $LN132
	DD	imagerel $LN132+111
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD imagerel $LN132+111
	DD	imagerel $LN132+484
	DD	imagerel $chain$3$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD imagerel $LN132+484
	DD	imagerel $LN132+491
	DD	imagerel $chain$5$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD imagerel $LN132+491
	DD	imagerel $LN132+497
	DD	imagerel $chain$6$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD imagerel $LN132+497
	DD	imagerel $LN132+503
	DD	imagerel $chain$7$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z DD imagerel $LN98
	DD	imagerel $LN98+538
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA+52
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z DD imagerel $LN102
	DD	imagerel $LN102+200
	DD	imagerel $unwind$??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z DD imagerel $LN44
	DD	imagerel $LN44+132
	DD	imagerel $unwind$?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z DD imagerel $LN11
	DD	imagerel $LN11+135
	DD	imagerel $unwind$??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN55
	DD	imagerel $LN55+27
	DD	imagerel $unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN55+27
	DD	imagerel $LN55+115
	DD	imagerel $chain$2$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN55+115
	DD	imagerel $LN55+195
	DD	imagerel $chain$3$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN55+195
	DD	imagerel $LN55+221
	DD	imagerel $chain$4$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN55+221
	DD	imagerel $LN55+353
	DD	imagerel $chain$5$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN55+353
	DD	imagerel $LN55+387
	DD	imagerel $chain$6$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN55+387
	DD	imagerel $LN55+392
	DD	imagerel $chain$7$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN55+392
	DD	imagerel $LN55+418
	DD	imagerel $chain$8$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD imagerel $LN55+418
	DD	imagerel $LN55+424
	DD	imagerel $chain$9$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN48
	DD	imagerel $LN48+140
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0AEBV12@@Z DD imagerel $LN10
	DD	imagerel $LN10+33
	DD	imagerel $unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN35
	DD	imagerel $LN35+93
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN35+93
	DD	imagerel $LN35+227
	DD	imagerel $chain$1$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN35+227
	DD	imagerel $LN35+235
	DD	imagerel $chain$3$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN35+235
	DD	imagerel $LN35+259
	DD	imagerel $chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z DD imagerel $LN10
	DD	imagerel $LN10+69
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z DD imagerel $LN13
	DD	imagerel $LN13+101
	DD	imagerel $unwind$??$emplace_back@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportFunctionInfo@portable_executable@@@Z DD imagerel $LN15
	DD	imagerel $LN15+94
	DD	imagerel $unwind$?push_back@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportFunctionInfo@portable_executable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportInfo@portable_executable@@@Z DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportInfo@portable_executable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportInfo@portable_executable@@@Z DD imagerel $LN7
	DD	imagerel $LN7+55
	DD	imagerel $unwind$??$emplace_back@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportInfo@portable_executable@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportInfo@portable_executable@@@Z DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$?push_back@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportInfo@portable_executable@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?get_kernel_export@util@@YAPEAXPEBD0_N@Z DD imagerel ?get_kernel_export@util@@YAPEAXPEBD0_N@Z
	DD	imagerel ?get_kernel_export@util@@YAPEAXPEBD0_N@Z+1337
	DD	imagerel $unwind$?get_kernel_export@util@@YAPEAXPEBD0_N@Z
$pdata$?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z DD imagerel $LN504
	DD	imagerel $LN504+1156
	DD	imagerel $unwind$?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z
$pdata$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z DD imagerel $LN48
	DD	imagerel $LN48+21
	DD	imagerel $unwind$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z
$pdata$1$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z DD imagerel $LN48+21
	DD	imagerel $LN48+130
	DD	imagerel $chain$1$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z
$pdata$2$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z DD imagerel $LN48+130
	DD	imagerel $LN48+242
	DD	imagerel $chain$2$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z
$pdata$?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z DD imagerel $LN80
	DD	imagerel $LN80+269
	DD	imagerel $unwind$?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z
$pdata$?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z DD imagerel $LN170
	DD	imagerel $LN170+745
	DD	imagerel $unwind$?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z
xdata	SEGMENT
$unwind$?get_kernel_export@util@@YAPEAXPEBD0_N@Z DD 0d3219H
	DD	01f7424H
	DD	01e6424H
	DD	01d3424H
	DD	0160124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?get_kernel_export@util@@YAPEAXPEBD0_N@Z
	DD	0a2H
$cppxdata$?get_kernel_export@util@@YAPEAXPEBD0_N@Z DB 028H
	DD	imagerel $stateUnwindMap$?get_kernel_export@util@@YAPEAXPEBD0_N@Z
	DD	imagerel $ip2state$?get_kernel_export@util@@YAPEAXPEBD0_N@Z
$stateUnwindMap$?get_kernel_export@util@@YAPEAXPEBD0_N@Z DB 06H
	DB	0aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	080H
	DB	032H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
$ip2state$?get_kernel_export@util@@YAPEAXPEBD0_N@Z DB 0cH
	DB	'9', 04H
	DB	00H
	DB	0a2H
	DB	02H
	DB	084H
	DB	04H
	DB	0a8H
	DB	06H
	DB	0d1H, 02H
	DB	04H
	DB	'9', 06H
	DB	00H
$cppxdata$?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z
	DD	imagerel $ip2state$?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z
$stateUnwindMap$?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z DB 0cH
	DB	0aH
	DD	imagerel ??1?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ
	DB	050H
	DB	032H
	DD	imagerel ??1ImportInfo@portable_executable@@QEAA@XZ
	DB	021H
	DB	02H
	DB	03aH
	DD	imagerel ??1ImportFunctionInfo@portable_executable@@QEAA@XZ
	DB	0c0H
	DB	06cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a0H
	DB	032H
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ
	DB	0b0H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ
	DB	0c0H
$unwind$?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z DD 0b2a19H
	DD	024341cH
	DD	01a011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z
	DD	0c2H
$ip2state$?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z DB 012H
	DB	'y', 03H
	DB	04H
	DB	0c4H
	DB	06H
	DB	098H
	DB	04H
	DB	0ceH
	DB	08H
	DB	0c1H, 02H
	DB	0aH
	DB	'0'
	DB	0cH
	DB	090H
	DB	04H
	DB	'm', 05H
	DB	00H
	DB	'@'
	DB	08H
$cppxdata$?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z
	DD	imagerel $ip2state$?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z
$cppxdata$?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z
	DD	imagerel $ip2state$?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z
$unwind$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z DD 020601H
	DD	030023206H
$chain$1$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z DD 040f21H
	DD	07740fH
	DD	066405H
	DD	imagerel $LN48
	DD	imagerel $LN48+21
	DD	imagerel $unwind$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z
$chain$2$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z DD 021H
	DD	imagerel $LN48
	DD	imagerel $LN48+21
	DD	imagerel $unwind$?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z
$unwind$?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z DD 060f11H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z
$stateUnwindMap$?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ
	DB	040H
$ip2state$?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z DB 02H
	DB	0bdH, 02H
	DB	02H
	ORG $+1
$unwind$?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z DD 0c2b19H
	DD	015641cH
	DD	014541cH
	DD	013341cH
	DD	0f018b21cH
	DD	0d014e016H
	DD	07010c012H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z
	DD	052H
$stateUnwindMap$?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z DB 02H
	DB	0cH
	DD	imagerel ??1?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ
	DB	050H
$ip2state$?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z DB 04H
	DB	085H, 04H
	DB	02H
	DB	01H, 05H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportInfo@portable_executable@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportInfo@portable_executable@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportInfo@portable_executable@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportFunctionInfo@portable_executable@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+93
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN35
	DD	imagerel $LN35+93
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 040f21H
	DD	07740fH
	DD	065405H
	DD	imagerel $LN35
	DD	imagerel $LN35+93
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 061001H
	DD	096410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0AEBV12@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 021H
	DD	imagerel $LN55
	DD	imagerel $LN55+27
	DD	imagerel $unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 021H
	DD	imagerel $LN55+27
	DD	imagerel $LN55+115
	DD	imagerel $chain$2$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 021H
	DD	imagerel $LN55+115
	DD	imagerel $LN55+195
	DD	imagerel $chain$3$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 021H
	DD	imagerel $LN55+195
	DD	imagerel $LN55+221
	DD	imagerel $chain$4$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 020521H
	DD	09d405H
	DD	imagerel $LN55+195
	DD	imagerel $LN55+221
	DD	imagerel $chain$4$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 020521H
	DD	0ac405H
	DD	imagerel $LN55+115
	DD	imagerel $LN55+195
	DD	imagerel $chain$3$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 020521H
	DD	0e3405H
	DD	imagerel $LN55+27
	DD	imagerel $LN55+115
	DD	imagerel $chain$2$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 061f21H
	DD	08f41fH
	DD	0106412H
	DD	0f5405H
	DD	imagerel $LN55
	DD	imagerel $LN55+27
	DD	imagerel $unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z DD 030801H
	DD	0e004a208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z DB 06H
	DB	'F'
	DB	00H
	DB	'~'
	DB	02H
	DB	'j'
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ
	DB	0d0H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z
	DD	imagerel $ip2state$??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z DD 061211H
	DD	0e3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z DB 06H
	DB	'M', 03H
	DB	00H
	DB	0c4H
	DB	02H
	DB	'x'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z DD 081419H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD 080021H
	DD	04e400H
	DD	0c6400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN132
	DD	imagerel $LN132+111
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD 021H
	DD	imagerel $LN132
	DD	imagerel $LN132+111
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD 080021H
	DD	04e400H
	DD	0c6400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel $LN132
	DD	imagerel $LN132+111
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD 082221H
	DD	04e422H
	DD	0c6417H
	DD	0b5412H
	DD	0a3405H
	DD	imagerel $LN132
	DD	imagerel $LN132+111
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z DD 050c01H
	DD	0f008420cH
	DD	0c004d006H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UImportFunctionInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEBU34@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z DB 06H
	DB	08dH, 02H
	DB	00H
	DB	'b'
	DB	02H
	DB	'Y', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z DD 081419H
	DD	0f0105214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	030066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD 080021H
	DD	04d400H
	DD	0dc400H
	DD	0c7400H
	DD	0b5400H
	DD	imagerel $LN82
	DD	imagerel $LN82+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD 021H
	DD	imagerel $LN82
	DD	imagerel $LN82+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD 081f21H
	DD	04d41fH
	DD	0dc413H
	DD	0c740eH
	DD	0b5405H
	DD	imagerel $LN82
	DD	imagerel $LN82+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z DD 050b01H
	DD	0f007420bH
	DD	06003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z DB 06H
	DB	':'
	DB	00H
	DB	'~'
	DB	02H
	DB	't'
	DB	06H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z DB 06H
	DB	0cH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ
	DB	0d0H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z
	DD	imagerel $ip2state$??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z DD 081711H
	DD	0f5417H
	DD	0e3417H
	DD	0e0137217H
	DD	060107011H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImportFunctionInfo@portable_executable@@QEAA@AEBU01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+39
	DD	imagerel $unwind$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z DD 020521H
	DD	086405H
	DD	imagerel $LN41
	DD	imagerel $LN41+39
	DD	imagerel $unwind$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z DD 081301H
	DD	0a5413H
	DD	093413H
	DD	0f00f3213H
	DD	0700be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UImportInfo@portable_executable@@@std@@QEAAPEAUImportInfo@portable_executable@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXQEAURelocInfo@portable_executable@@_K1@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAPEAURelocInfo@portable_executable@@PEAU34@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@URelocInfo@portable_executable@@@std@@QEAAPEAURelocInfo@portable_executable@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportFunctionInfo@portable_executable@@_K1@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z DB 04H
	DB	092H
	DB	00H
	DB	'z'
	DB	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z DB 04H
	DB	0aH
	DD	imagerel ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ
	DB	0c0H
	DB	032H
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z DD 081211H
	DD	0e5412H
	DD	0d3412H
	DD	0e00e7212H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z DD 020421H
	DD	03404H
	DD	imagerel $LN77
	DD	imagerel $LN77+18
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAURelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YAPEAURelocInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@URelocInfo@portable_executable@@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z DB 02H
	DB	'l'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z
	DD	imagerel $ip2state$??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z DD 060f11H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAURelocInfo@portable_executable@@PEAU12@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z DB 02H
	DB	'l'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z DB 02H
	DB	0aH
	DD	imagerel ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ
	DB	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z DD 060f11H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@AEAUImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEAUImportFunctionInfo@portable_executable@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@UImportFunctionInfo@portable_executable@@AEAU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEAU34@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
_TEXT	SEGMENT
buffer_size$1 = 32
imports$GSCopy$ = 40
current_module_name$2 = 48
__$ArrayPad$ = 80
imports$ = 144
?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z PROC ; portable_executable::resolve_imports

; 21   : 	{

$LN170:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0002b	4c 8b e1	 mov	 r12, rcx
  0002e	48 89 4c 24 28	 mov	 QWORD PTR imports$GSCopy$[rsp], rcx

; 22   : 		int import_count = 0;

  00033	45 33 f6	 xor	 r14d, r14d

; 23   : 		for (const auto& current_import : imports)

  00036	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  00039	4c 8b 69 08	 mov	 r13, QWORD PTR [rcx+8]
$LN167@resolve_im:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

  0003d	49 3b fd	 cmp	 rdi, r13
  00040	0f 84 5e 02 00
	00		 je	 $LN3@resolve_im
  00046	4c 8b ff	 mov	 r15, rdi

; 2273 :         if (_Large_string_engaged()) {

  00049	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16
  0004e	72 03		 jb	 SHORT $LN162@resolve_im

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  00050	4c 8b 3f	 mov	 r15, QWORD PTR [rdi]
$LN162@resolve_im:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 265  : 		void* buffer = nullptr;

  00053	33 db		 xor	 ebx, ebx

; 266  : 		DWORD buffer_size = NULL;

  00055	89 5c 24 20	 mov	 DWORD PTR buffer_size$1[rsp], ebx

; 267  : 
; 268  : 		NTSTATUS status = NtQuerySystemInformation(

  00059	4c 8d 4c 24 20	 lea	 r9, QWORD PTR buffer_size$1[rsp]
  0005e	45 33 c0	 xor	 r8d, r8d
  00061	33 d2		 xor	 edx, edx
  00063	8d 4b 0b	 lea	 ecx, QWORD PTR [rbx+11]
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NtQuerySystemInformation

; 269  : 			static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation),
; 270  : 			buffer,
; 271  : 			buffer_size, 
; 272  : 			&buffer_size
; 273  : 		);
; 274  : 
; 275  : 		while (status == STATUS_INFO_LENGTH_MISMATCH)

  0006c	3d 04 00 00 c0	 cmp	 eax, -1073741820	; ffffffffc0000004H
  00071	75 49		 jne	 SHORT $LN21@resolve_im
$LL20@resolve_im:

; 276  : 		{
; 277  : 			VirtualFree(buffer, NULL, MEM_RELEASE);

  00073	33 d2		 xor	 edx, edx
  00075	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree

; 278  : 			buffer = VirtualAlloc(nullptr, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  00084	8b 54 24 20	 mov	 edx, DWORD PTR buffer_size$1[rsp]
  00088	33 c9		 xor	 ecx, ecx
  0008a	44 8d 49 04	 lea	 r9d, QWORD PTR [rcx+4]
  0008e	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  0009a	48 8b d8	 mov	 rbx, rax

; 279  : 			status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation), buffer, buffer_size, &buffer_size);

  0009d	4c 8d 4c 24 20	 lea	 r9, QWORD PTR buffer_size$1[rsp]
  000a2	44 8b 44 24 20	 mov	 r8d, DWORD PTR buffer_size$1[rsp]
  000a7	48 8b d0	 mov	 rdx, rax
  000aa	b9 0b 00 00 00	 mov	 ecx, 11
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NtQuerySystemInformation

; 269  : 			static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation),
; 270  : 			buffer,
; 271  : 			buffer_size, 
; 272  : 			&buffer_size
; 273  : 		);
; 274  : 
; 275  : 		while (status == STATUS_INFO_LENGTH_MISMATCH)

  000b5	3d 04 00 00 c0	 cmp	 eax, -1073741820	; ffffffffc0000004H
  000ba	74 b7		 je	 SHORT $LL20@resolve_im
$LN21@resolve_im:

; 280  : 		}
; 281  : 
; 282  : 		if (!NT_SUCCESS(status))

  000bc	85 c0		 test	 eax, eax
  000be	0f 88 a9 01 00
	00		 js	 $LN158@resolve_im

; 289  : 		for (auto idx = 0u; idx < modules->NumberOfModules; ++idx)

  000c4	45 33 c0	 xor	 r8d, r8d
  000c7	41 8b f0	 mov	 esi, r8d
  000ca	44 39 03	 cmp	 DWORD PTR [rbx], r8d
  000cd	0f 86 9a 01 00
	00		 jbe	 $LN158@resolve_im
  000d3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL24@resolve_im:

; 290  : 		{
; 291  : 			const std::string current_module_name = std::string(reinterpret_cast<char*>(modules->Modules[idx].FullPathName) + modules->Modules[idx].OffsetToFileName);

  000e0	8b ee		 mov	 ebp, esi
  000e2	48 69 c5 28 01
	00 00		 imul	 rax, rbp, 296		; 00000128H
  000e9	0f b7 4c 18 2e	 movzx	 ecx, WORD PTR [rax+rbx+46]
  000ee	48 03 c8	 add	 rcx, rax
  000f1	48 8d 53 30	 lea	 rdx, QWORD PTR [rbx+48]
  000f5	48 03 d1	 add	 rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  000f8	4c 89 44 24 30	 mov	 QWORD PTR current_module_name$2[rsp], r8

; 4562 :         _My_data._Mysize = 0;

  000fd	4c 89 44 24 40	 mov	 QWORD PTR current_module_name$2[rsp+16], r8

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00102	48 c7 44 24 48
	0f 00 00 00	 mov	 QWORD PTR current_module_name$2[rsp+24], 15

; 401  :             return __builtin_strlen(_First);

  0010b	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
$LL164@resolve_im:
  00112	49 ff c0	 inc	 r8
  00115	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  0011a	75 f6		 jne	 SHORT $LL164@resolve_im

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0011c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR current_module_name$2[rsp]
  00121	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2272 :         const value_type* _Result = _Bx._Buf;

  00126	48 8d 4c 24 30	 lea	 rcx, QWORD PTR current_module_name$2[rsp]

; 2273 :         if (_Large_string_engaged()) {

  0012b	48 83 7c 24 48
	10		 cmp	 QWORD PTR current_module_name$2[rsp+24], 16
  00131	48 0f 43 4c 24
	30		 cmovae	 rcx, QWORD PTR current_module_name$2[rsp]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 292  : 			if (!_stricmp(current_module_name.c_str(), module_name))

  00137	49 8b d7	 mov	 rdx, r15
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00140	85 c0		 test	 eax, eax
  00142	74 4f		 je	 SHORT $LN140@resolve_im
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00144	48 8b 54 24 48	 mov	 rdx, QWORD PTR current_module_name$2[rsp+24]
  00149	48 83 fa 10	 cmp	 rdx, 16
  0014d	72 32		 jb	 SHORT $LN92@resolve_im

; 4585 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0014f	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00152	48 8b 4c 24 30	 mov	 rcx, QWORD PTR current_module_name$2[rsp]
  00157	48 8b c1	 mov	 rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0015a	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00161	72 19		 jb	 SHORT $LN102@resolve_im

; 147  :     _Bytes += _Non_user_size;

  00163	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00167	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0016b	48 2b c1	 sub	 rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0016e	48 83 c0 f8	 add	 rax, -8
  00172	48 83 f8 1f	 cmp	 rax, 31
  00176	0f 87 c4 00 00
	00		 ja	 $LN99@resolve_im
$LN102@resolve_im:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0017c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN92@resolve_im:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 289  : 		for (auto idx = 0u; idx < modules->NumberOfModules; ++idx)

  00181	ff c6		 inc	 esi
  00183	3b 33		 cmp	 esi, DWORD PTR [rbx]
  00185	0f 83 e2 00 00
	00		 jae	 $LN158@resolve_im
  0018b	45 33 c0	 xor	 r8d, r8d
  0018e	e9 4d ff ff ff	 jmp	 $LL24@resolve_im
$LN140@resolve_im:

; 293  : 			{
; 294  : 				const uint64_t result = reinterpret_cast<uint64_t>(modules->Modules[idx].ImageBase);

  00193	48 69 c5 28 01
	00 00		 imul	 rax, rbp, 296		; 00000128H
  0019a	48 8b 74 18 18	 mov	 rsi, QWORD PTR [rax+rbx+24]

; 295  : 				VirtualFree(buffer, NULL, MEM_RELEASE);

  0019f	33 d2		 xor	 edx, edx
  001a1	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  001a7	48 8b cb	 mov	 rcx, rbx
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001b0	48 8b 54 24 48	 mov	 rdx, QWORD PTR current_module_name$2[rsp+24]
  001b5	48 83 fa 10	 cmp	 rdx, 16
  001b9	72 2e		 jb	 SHORT $LN64@resolve_im

; 4585 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001bb	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR current_module_name$2[rsp]
  001c3	48 8b c1	 mov	 rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001c6	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  001cd	72 15		 jb	 SHORT $LN74@resolve_im

; 147  :     _Bytes += _Non_user_size;

  001cf	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001d3	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  001d7	48 2b c1	 sub	 rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001da	48 83 c0 f8	 add	 rax, -8
  001de	48 83 f8 1f	 cmp	 rax, 31
  001e2	77 5c		 ja	 SHORT $LN99@resolve_im
$LN74@resolve_im:

; 255  :         ::operator delete(_Ptr, _Bytes);

  001e4	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN64@resolve_im:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 25   : 			if (!util::get_module_base(current_import.module_name.c_str()))

  001e9	48 85 f6	 test	 rsi, rsi
  001ec	0f 84 8c 00 00
	00		 je	 $LN142@resolve_im

; 29   : 			}
; 30   : 
; 31   : 			for (auto& current_function_data : current_import.function_datas)

  001f2	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]
  001f6	48 8b 77 28	 mov	 rsi, QWORD PTR [rdi+40]
  001fa	48 3b de	 cmp	 rbx, rsi
  001fd	74 38		 je	 SHORT $LN2@resolve_im
  001ff	90		 npad	 1
$LL7@resolve_im:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

  00200	48 8b d3	 mov	 rdx, rbx

; 2273 :         if (_Large_string_engaged()) {

  00203	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16
  00208	72 03		 jb	 SHORT $LN163@resolve_im

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0020a	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
$LN163@resolve_im:

; 2272 :         const value_type* _Result = _Bx._Buf;

  0020d	48 8b cf	 mov	 rcx, rdi

; 2273 :         if (_Large_string_engaged()) {

  00210	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16
  00215	72 03		 jb	 SHORT $LN161@resolve_im

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  00217	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
$LN161@resolve_im:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 33   : 				const uint64_t function_address = (uint64_t)util::get_kernel_export(current_import.module_name.c_str(), current_function_data.name.c_str());

  0021a	e8 00 00 00 00	 call	 ?get_kernel_export@util@@YAPEAXPEBD0_N@Z ; util::get_kernel_export

; 34   : 
; 35   : 				if (!function_address)

  0021f	48 85 c0	 test	 rax, rax
  00222	74 23		 je	 SHORT $LN141@resolve_im

; 39   : 				}
; 40   : 
; 41   : 				import_count++;

  00224	41 ff c6	 inc	 r14d

; 42   : 				*current_function_data.address = function_address;

  00227	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0022b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 29   : 			}
; 30   : 
; 31   : 			for (auto& current_function_data : current_import.function_datas)

  0022e	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00232	48 3b de	 cmp	 rbx, rsi
  00235	75 c9		 jne	 SHORT $LL7@resolve_im
$LN2@resolve_im:

; 23   : 		for (const auto& current_import : imports)

  00237	48 83 c7 38	 add	 rdi, 56			; 00000038H
  0023b	e9 fd fd ff ff	 jmp	 $LN167@resolve_im
$LN99@resolve_im:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00246	cc		 int	 3
$LN141@resolve_im:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

  00247	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16
  0024c	72 03		 jb	 SHORT $LN132@resolve_im

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0024e	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN132@resolve_im:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 37   : 					std::printf("[-] failed to resolve import [%s]\n", current_function_data.name.c_str());

  00251	48 8b d3	 mov	 rdx, rbx
  00254	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@IMFAMML@?$FL?9?$FN?5failed?5to?5resolve?5import?5?$FL?$CF@
  0025b	e8 00 00 00 00	 call	 printf
  00260	90		 npad	 1

; 38   : 					return false;

  00261	49 8b cc	 mov	 rcx, r12
  00264	e8 00 00 00 00	 call	 ??1?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::~vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
  00269	32 c0		 xor	 al, al
  0026b	eb 51		 jmp	 SHORT $LN1@resolve_im
$LN158@resolve_im:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2273 :         if (_Large_string_engaged()) {

  0026d	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00273	33 d2		 xor	 edx, edx
  00275	48 8b cb	 mov	 rcx, rbx
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree
$LN142@resolve_im:
  0027e	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16
  00283	72 03		 jb	 SHORT $LN111@resolve_im

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  00285	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
$LN111@resolve_im:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 27   : 				std::printf("imported module [%s] not found\n", current_import.module_name.c_str());

  00288	48 8b d7	 mov	 rdx, rdi
  0028b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@IOOJHFBM@imported?5module?5?$FL?$CFs?$FN?5not?5found?6@
  00292	e8 00 00 00 00	 call	 printf
  00297	90		 npad	 1

; 28   : 				return false;

  00298	49 8b cc	 mov	 rcx, r12
  0029b	e8 00 00 00 00	 call	 ??1?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::~vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
  002a0	32 c0		 xor	 al, al
  002a2	eb 1a		 jmp	 SHORT $LN1@resolve_im
$LN3@resolve_im:

; 43   : 			}
; 44   : 		}
; 45   : 
; 46   : 		std::printf("[+] resolved [%i] imports\n", import_count);

  002a4	41 8b d6	 mov	 edx, r14d
  002a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@IJFHCNGM@?$FL?$CL?$FN?5resolved?5?$FL?$CFi?$FN?5imports?6@
  002ae	e8 00 00 00 00	 call	 printf
  002b3	90		 npad	 1

; 47   : 
; 48   : 		return true;

  002b4	49 8b cc	 mov	 rcx, r12
  002b7	e8 00 00 00 00	 call	 ??1?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::~vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
  002bc	b0 01		 mov	 al, 1
$LN1@resolve_im:

; 49   : 	}

  002be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002c3	48 33 cc	 xor	 rcx, rsp
  002c6	e8 00 00 00 00	 call	 __security_check_cookie
  002cb	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  002d0	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  002d4	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  002d8	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  002dc	49 8b e3	 mov	 rsp, r11
  002df	41 5f		 pop	 r15
  002e1	41 5e		 pop	 r14
  002e3	41 5d		 pop	 r13
  002e5	41 5c		 pop	 r12
  002e7	5f		 pop	 rdi
  002e8	c3		 ret	 0
$LN165@resolve_im:
?resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z ENDP ; portable_executable::resolve_imports
_TEXT	ENDS
text$x	SEGMENT
buffer_size$1 = 32
imports$GSCopy$ = 40
current_module_name$2 = 48
__$ArrayPad$ = 80
imports$ = 144
?dtor$0@?0??resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z@4HA PROC ; `portable_executable::resolve_imports'::`1'::dtor$0
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR imports$GSCopy$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::~vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
?dtor$0@?0??resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z@4HA ENDP ; `portable_executable::resolve_imports'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
buffer_size$1 = 32
imports$GSCopy$ = 40
current_module_name$2 = 48
__$ArrayPad$ = 80
imports$ = 144
?dtor$0@?0??resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z@4HA PROC ; `portable_executable::resolve_imports'::`1'::dtor$0
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR imports$GSCopy$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::~vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
?dtor$0@?0??resolve_imports@portable_executable@@YA_NV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@@Z@4HA ENDP ; `portable_executable::resolve_imports'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
_TEXT	SEGMENT
image_base$ = 8
?get_nt_headers@portable_executable@@YAPEAU_IMAGE_NT_HEADERS64@@PEAX@Z PROC ; portable_executable::get_nt_headers

; 53   : 		const auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(image_base);
; 54   : 
; 55   : 		if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)

  00000	b8 4d 5a 00 00	 mov	 eax, 23117		; 00005a4dH
  00005	66 39 01	 cmp	 WORD PTR [rcx], ax
  00008	75 0f		 jne	 SHORT $LN5@get_nt_hea

; 56   : 			return nullptr;
; 57   : 
; 58   : 		const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<uint64_t>(image_base) + dos_header->e_lfanew);

  0000a	48 63 41 3c	 movsxd	 rax, DWORD PTR [rcx+60]
  0000e	48 03 c1	 add	 rax, rcx

; 59   : 
; 60   : 		if (nt_headers->Signature != IMAGE_NT_SIGNATURE)

  00011	81 38 50 45 00
	00		 cmp	 DWORD PTR [rax], 17744	; 00004550H
  00017	74 02		 je	 SHORT $LN1@get_nt_hea
$LN5@get_nt_hea:

; 61   : 			return nullptr;

  00019	33 c0		 xor	 eax, eax
$LN1@get_nt_hea:

; 62   : 
; 63   : 		return nt_headers;
; 64   : 	}

  0001b	c3		 ret	 0
?get_nt_headers@portable_executable@@YAPEAU_IMAGE_NT_HEADERS64@@PEAX@Z ENDP ; portable_executable::get_nt_headers
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
_TEXT	SEGMENT
relocs$ = 32
reloc_info$1 = 56
__$ReturnUdt$ = 96
image_base$ = 104
?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z PROC ; portable_executable::get_relocations

; 67   : 	{

$LN80:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b f2	 mov	 rsi, rdx
  00012	48 8b f9	 mov	 rdi, rcx

; 55   : 		if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)

  00015	b8 4d 5a 00 00	 mov	 eax, 23117		; 00005a4dH
  0001a	66 39 02	 cmp	 WORD PTR [rdx], ax
  0001d	0f 85 ca 00 00
	00		 jne	 $LN75@get_reloca

; 56   : 			return nullptr;
; 57   : 
; 58   : 		const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<uint64_t>(image_base) + dos_header->e_lfanew);

  00023	48 63 42 3c	 movsxd	 rax, DWORD PTR [rdx+60]

; 59   : 
; 60   : 		if (nt_headers->Signature != IMAGE_NT_SIGNATURE)

  00027	81 3c 10 50 45
	00 00		 cmp	 DWORD PTR [rax+rdx], 17744 ; 00004550H
  0002e	0f 85 b9 00 00
	00		 jne	 $LN75@get_reloca
  00034	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00037	f3 0f 7f 44 24
	20		 movdqu	 XMMWORD PTR relocs$[rsp], xmm0
  0003d	33 d2		 xor	 edx, edx
  0003f	48 89 54 24 30	 mov	 QWORD PTR relocs$[rsp+16], rdx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 75   : 		auto current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(image_base) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

  00044	8b 9c 30 b0 00
	00 00		 mov	 ebx, DWORD PTR [rax+rsi+176]
  0004b	48 03 de	 add	 rbx, rsi

; 76   : 
; 77   : 		while (current_base_relocation->VirtualAddress)

  0004e	8b 03		 mov	 eax, DWORD PTR [rbx]
  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR relocs$[rsp+8]
  00055	85 c0		 test	 eax, eax
  00057	74 71		 je	 SHORT $LN3@get_reloca
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@get_reloca:

; 78   : 		{
; 79   : 			RelocInfo reloc_info;
; 80   : 
; 81   : 			reloc_info.address = reinterpret_cast<uint64_t>(image_base) + current_base_relocation->VirtualAddress;

  00060	48 03 c6	 add	 rax, rsi
  00063	48 89 44 24 38	 mov	 QWORD PTR reloc_info$1[rsp], rax

; 82   : 			reloc_info.item = reinterpret_cast<uint16_t*>(reinterpret_cast<uint64_t>(current_base_relocation) + sizeof(IMAGE_BASE_RELOCATION));

  00068	48 8d 43 08	 lea	 rax, QWORD PTR [rbx+8]
  0006c	48 89 44 24 40	 mov	 QWORD PTR reloc_info$1[rsp+8], rax

; 83   : 			reloc_info.count = (current_base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(uint16_t);

  00071	8b 43 04	 mov	 eax, DWORD PTR [rbx+4]
  00074	48 83 e8 08	 sub	 rax, 8
  00078	48 d1 e8	 shr	 rax, 1
  0007b	89 44 24 48	 mov	 DWORD PTR reloc_info$1[rsp+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

  0007f	48 3b ca	 cmp	 rcx, rdx
  00082	74 1e		 je	 SHORT $LN28@get_reloca
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00084	0f 10 44 24 38	 movups	 xmm0, XMMWORD PTR reloc_info$1[rsp]
  00089	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  0008c	f2 0f 10 4c 24
	48		 movsd	 xmm1, QWORD PTR reloc_info$1[rsp+16]
  00092	f2 0f 11 49 10	 movsd	 QWORD PTR [rcx+16], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

  00097	48 83 c1 18	 add	 rcx, 24
  0009b	48 89 4c 24 28	 mov	 QWORD PTR relocs$[rsp+8], rcx

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  000a0	eb 1c		 jmp	 SHORT $LN27@get_reloca
$LN28@get_reloca:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  000a2	4c 8d 44 24 38	 lea	 r8, QWORD PTR reloc_info$1[rsp]
  000a7	48 8b d1	 mov	 rdx, rcx
  000aa	48 8d 4c 24 20	 lea	 rcx, QWORD PTR relocs$[rsp]
  000af	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Emplace_reallocate<portable_executable::RelocInfo const &>
  000b4	48 8b 54 24 30	 mov	 rdx, QWORD PTR relocs$[rsp+16]
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR relocs$[rsp+8]
$LN27@get_reloca:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 87   : 			current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(current_base_relocation) + current_base_relocation->SizeOfBlock);

  000be	8b 43 04	 mov	 eax, DWORD PTR [rbx+4]
  000c1	48 03 d8	 add	 rbx, rax

; 76   : 
; 77   : 		while (current_base_relocation->VirtualAddress)

  000c4	8b 03		 mov	 eax, DWORD PTR [rbx]
  000c6	85 c0		 test	 eax, eax
  000c8	75 96		 jne	 SHORT $LL2@get_reloca
$LN3@get_reloca:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR relocs$[rsp]
  000cf	48 89 07	 mov	 QWORD PTR [rdi], rax
  000d2	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  000d6	48 89 57 10	 mov	 QWORD PTR [rdi+16], rdx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 91   : 	}

  000da	48 8b c7	 mov	 rax, rdi
  000dd	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000e2	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000e7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000eb	5f		 pop	 rdi
  000ec	c3		 ret	 0
$LN75@get_reloca:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000ed	33 d2		 xor	 edx, edx
  000ef	48 89 11	 mov	 QWORD PTR [rcx], rdx
  000f2	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  000f6	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 91   : 	}

  000fa	48 8b c7	 mov	 rax, rdi
  000fd	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00102	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00107	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
?get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z ENDP ; portable_executable::get_relocations
_TEXT	ENDS
text$x	SEGMENT
relocs$ = 32
reloc_info$1 = 56
__$ReturnUdt$ = 96
image_base$ = 104
?dtor$1@?0??get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_relocations'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR relocs$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::~vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >
?dtor$1@?0??get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_relocations'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
relocs$ = 32
reloc_info$1 = 56
__$ReturnUdt$ = 96
image_base$ = 104
?dtor$1@?0??get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_relocations'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR relocs$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::~vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >
?dtor$1@?0??get_relocations@portable_executable@@YA?AV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_relocations'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
_TEXT	SEGMENT
relocs$ = 48
delta$ = 56
?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z PROC ; portable_executable::relocate_image_by_delta

; 6    : 	{

$LN48:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 7    : 		for (const auto& current_reloc : relocs)

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	4c 8b 5b 08	 mov	 r11, QWORD PTR [rbx+8]
  00010	49 3b cb	 cmp	 rcx, r11
  00013	74 6d		 je	 SHORT $LN3@relocate_i
  00015	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0001a	be 00 a0 00 00	 mov	 esi, 40960		; 0000a000H
  0001f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00024	bf 00 f0 00 00	 mov	 edi, 61440		; 0000f000H
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@relocate_i:

; 8    : 		{
; 9    : 			for (auto i = 0u; i < current_reloc.count; ++i)

  00030	45 33 c0	 xor	 r8d, r8d
  00033	44 39 41 10	 cmp	 DWORD PTR [rcx+16], r8d
  00037	76 33		 jbe	 SHORT $LN2@relocate_i
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@relocate_i:

; 10   : 			{
; 11   : 				const uint16_t type = current_reloc.item[i] >> 12;
; 12   : 				const uint16_t offset = current_reloc.item[i] & 0xFFF;

  00040	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00044	46 0f b7 0c 40	 movzx	 r9d, WORD PTR [rax+r8*2]

; 13   : 
; 14   : 				if (type == IMAGE_REL_BASED_DIR64)

  00049	41 0f b7 c1	 movzx	 eax, r9w
  0004d	66 23 c7	 and	 ax, di
  00050	66 3b c6	 cmp	 ax, si
  00053	75 0e		 jne	 SHORT $LN5@relocate_i

; 15   : 					*reinterpret_cast<uint64_t*>(current_reloc.address + offset) += delta;

  00055	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00058	41 81 e1 ff 0f
	00 00		 and	 r9d, 4095		; 00000fffH
  0005f	49 01 14 01	 add	 QWORD PTR [r9+rax], rdx
$LN5@relocate_i:

; 8    : 		{
; 9    : 			for (auto i = 0u; i < current_reloc.count; ++i)

  00063	41 ff c0	 inc	 r8d
  00066	44 3b 41 10	 cmp	 r8d, DWORD PTR [rcx+16]
  0006a	72 d4		 jb	 SHORT $LL7@relocate_i
$LN2@relocate_i:

; 7    : 		for (const auto& current_reloc : relocs)

  0006c	48 83 c1 18	 add	 rcx, 24
  00070	49 3b cb	 cmp	 rcx, r11
  00073	75 bb		 jne	 SHORT $LL4@relocate_i
  00075	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00078	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0007d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN3@relocate_i:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

  00082	48 85 c9	 test	 rcx, rcx
  00085	74 5e		 je	 SHORT $LN13@relocate_i

; 1751 :             _Destroy(_Myfirst, _Mylast);
; 1752 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00087	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0008b	48 ba ab aa aa
	aa aa aa aa aa	 mov	 rdx, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  00095	48 2b c1	 sub	 rax, rcx
  00098	48 c1 f8 03	 sar	 rax, 3
  0009c	48 0f af c2	 imul	 rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  000a4	48 c1 e2 03	 shl	 rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000a8	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  000af	72 18		 jb	 SHORT $LN29@relocate_i

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b1	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]
  000b5	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000b9	48 2b c8	 sub	 rcx, rax

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000bc	48 83 c1 f8	 add	 rcx, -8
  000c0	48 83 f9 1f	 cmp	 rcx, 31
  000c4	77 25		 ja	 SHORT $LN26@relocate_i

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000c6	48 8b c8	 mov	 rcx, rax
$LN29@relocate_i:

; 255  :         ::operator delete(_Ptr, _Bytes);

  000c9	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1754 :             _Myfirst = nullptr;

  000ce	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 1755 :             _Mylast  = nullptr;

  000d5	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0

; 1756 :             _Myend   = nullptr;

  000dd	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0
$LN13@relocate_i:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 18   : 	}

  000e5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e9	5b		 pop	 rbx
  000ea	c3		 ret	 0
$LN26@relocate_i:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000f1	cc		 int	 3
$LN45@relocate_i:
?relocate_image_by_delta@portable_executable@@YAXV?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@_K@Z ENDP ; portable_executable::relocate_image_by_delta
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp
_TEXT	SEGMENT
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z PROC ; portable_executable::get_imports

; 94   : 	{

$LN504:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8d 6c 24 d9	 lea	 rbp, QWORD PTR [rsp-39]
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 45 17	 mov	 QWORD PTR __$ArrayPad$[rbp-169], rax
  0002a	4c 8b fa	 mov	 r15, rdx
  0002d	48 89 55 97	 mov	 QWORD PTR image_base$GSCopy$1$[rbp-169], rdx
  00031	48 8b d1	 mov	 rdx, rcx
  00034	48 89 4d 9f	 mov	 QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-169], rcx
  00038	48 89 4c 24 20	 mov	 QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx

; 55   : 		if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)

  0003d	b8 4d 5a 00 00	 mov	 eax, 23117		; 00005a4dH
  00042	66 41 39 07	 cmp	 WORD PTR [r15], ax
  00046	0f 85 fa 03 00
	00		 jne	 $LN494@get_import

; 56   : 			return nullptr;
; 57   : 
; 58   : 		const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<uint64_t>(image_base) + dos_header->e_lfanew);

  0004c	49 63 47 3c	 movsxd	 rax, DWORD PTR [r15+60]

; 59   : 
; 60   : 		if (nt_headers->Signature != IMAGE_NT_SIGNATURE)

  00050	42 81 3c 38 50
	45 00 00	 cmp	 DWORD PTR [rax+r15], 17744 ; 00004550H
  00058	0f 85 e8 03 00
	00		 jne	 $LN494@get_import
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00061	f3 0f 7f 44 24
	28		 movdqu	 XMMWORD PTR imports$[rsp], xmm0
  00067	45 33 e4	 xor	 r12d, r12d
  0006a	4c 89 65 8f	 mov	 QWORD PTR imports$[rbp-153], r12
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 102  : 		auto current_import_descriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(reinterpret_cast<uint64_t>(image_base) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

  0006e	42 8b 9c 38 90
	00 00 00	 mov	 ebx, DWORD PTR [rax+r15+144]
  00076	49 03 df	 add	 rbx, r15
  00079	48 89 5c 24 20	 mov	 QWORD PTR current_import_descriptor$1$[rsp], rbx

; 104  : 		while (current_import_descriptor->FirstThunk)

  0007e	4c 8b 6d 87	 mov	 r13, QWORD PTR imports$[rbp-161]
  00082	44 39 63 10	 cmp	 DWORD PTR [rbx+16], r12d
  00086	0f 84 a4 03 00
	00		 je	 $LN495@get_import
  0008c	0f 1f 40 00	 npad	 4
$LL2@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00090	4c 89 65 df	 mov	 QWORD PTR import_info$6[rbp-169], r12

; 4562 :         _My_data._Mysize = 0;

  00094	4c 89 65 ef	 mov	 QWORD PTR import_info$6[rbp-153], r12

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00098	48 c7 45 f7 0f
	00 00 00	 mov	 QWORD PTR import_info$6[rbp-145], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000a0	c6 45 df 00	 mov	 BYTE PTR import_info$6[rbp-169], 0
  000a4	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000a7	f3 0f 7f 45 ff	 movdqu	 XMMWORD PTR import_info$6[rbp-137], xmm0
  000ac	4d 8b f4	 mov	 r14, r12
  000af	4c 89 65 0f	 mov	 QWORD PTR import_info$6[rbp-121], r12
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 108  : 			import_info.module_name = std::string(reinterpret_cast<char*>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->Name));

  000b3	8b 53 0c	 mov	 edx, DWORD PTR [rbx+12]
  000b6	49 03 d7	 add	 rdx, r15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  000b9	4c 89 65 b7	 mov	 QWORD PTR $T5[rbp-169], r12

; 4562 :         _My_data._Mysize = 0;

  000bd	4c 89 65 c7	 mov	 QWORD PTR $T5[rbp-153], r12

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  000c1	48 c7 45 cf 0f
	00 00 00	 mov	 QWORD PTR $T5[rbp-145], 15

; 401  :             return __builtin_strlen(_First);

  000c9	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
$LL497@get_import:
  000d0	49 ff c0	 inc	 r8
  000d3	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  000d8	75 f6		 jne	 SHORT $LL497@get_import

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000da	48 8d 4d b7	 lea	 rcx, QWORD PTR $T5[rbp-169]
  000de	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000e3	0f 10 45 b7	 movups	 xmm0, XMMWORD PTR $T5[rbp-169]
  000e7	0f 11 45 df	 movups	 XMMWORD PTR import_info$6[rbp-169], xmm0
  000eb	0f 10 4d c7	 movups	 xmm1, XMMWORD PTR $T5[rbp-153]
  000ef	0f 11 4d ef	 movups	 XMMWORD PTR import_info$6[rbp-153], xmm1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 110  : 			auto current_first_thunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->FirstThunk);

  000f3	8b 73 10	 mov	 esi, DWORD PTR [rbx+16]
  000f6	49 03 f7	 add	 rsi, r15

; 111  : 			auto current_originalFirstThunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->OriginalFirstThunk);

  000f9	8b 3b		 mov	 edi, DWORD PTR [rbx]
  000fb	49 03 ff	 add	 rdi, r15

; 113  : 			while (current_originalFirstThunk->u1.Function)

  000fe	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00101	48 85 c0	 test	 rax, rax
  00104	0f 84 ce 00 00
	00		 je	 $LN5@get_import
  0010a	48 8b 5d 07	 mov	 rbx, QWORD PTR import_info$6[rbp-129]
  0010e	66 90		 npad	 2
$LL4@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00110	4c 89 65 b7	 mov	 QWORD PTR import_function_data$4[rbp-169], r12

; 4562 :         _My_data._Mysize = 0;

  00114	4c 89 65 c7	 mov	 QWORD PTR import_function_data$4[rbp-153], r12

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00118	48 c7 45 cf 0f
	00 00 00	 mov	 QWORD PTR import_function_data$4[rbp-145], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00120	c6 45 b7 00	 mov	 BYTE PTR import_function_data$4[rbp-169], 0
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 119  : 				import_function_data.name = thunk_data->Name;

  00124	49 8d 57 02	 lea	 rdx, QWORD PTR [r15+2]
  00128	48 03 d0	 add	 rdx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 401  :             return __builtin_strlen(_First);

  0012b	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
$LL496@get_import:
  00132	49 ff c0	 inc	 r8
  00135	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  0013a	75 f6		 jne	 SHORT $LL496@get_import

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0013c	48 8d 4d b7	 lea	 rcx, QWORD PTR import_function_data$4[rbp-169]
  00140	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 120  : 				import_function_data.address = &current_first_thunk->u1.Function;

  00145	48 89 75 d7	 mov	 QWORD PTR import_function_data$4[rbp-137], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

  00149	49 3b de	 cmp	 rbx, r14
  0014c	74 1e		 je	 SHORT $LN165@get_import
  0014e	48 8d 55 b7	 lea	 rdx, QWORD PTR import_function_data$4[rbp-169]
  00152	48 8b cb	 mov	 rcx, rbx
  00155	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0015a	48 8b 45 d7	 mov	 rax, QWORD PTR import_function_data$4[rbp-137]
  0015e	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 716  :         ++_Mylast;

  00162	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00166	48 89 5d 07	 mov	 QWORD PTR import_info$6[rbp-129], rbx

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0016a	eb 18		 jmp	 SHORT $LN164@get_import
$LN165@get_import:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0016c	4c 8d 45 b7	 lea	 r8, QWORD PTR import_function_data$4[rbp-169]
  00170	48 8b d3	 mov	 rdx, rbx
  00173	48 8d 4d ff	 lea	 rcx, QWORD PTR import_info$6[rbp-137]
  00177	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>
  0017c	4c 8b 75 0f	 mov	 r14, QWORD PTR import_info$6[rbp-121]
  00180	48 8b 5d 07	 mov	 rbx, QWORD PTR import_info$6[rbp-129]
$LN164@get_import:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 124  : 				++current_originalFirstThunk;

  00184	48 83 c7 08	 add	 rdi, 8

; 125  : 				++current_first_thunk;

  00188	48 83 c6 08	 add	 rsi, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0018c	48 8b 55 cf	 mov	 rdx, QWORD PTR import_function_data$4[rbp-145]
  00190	48 83 fa 10	 cmp	 rdx, 16
  00194	72 31		 jb	 SHORT $LN189@get_import

; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00196	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00199	48 8b 4d b7	 mov	 rcx, QWORD PTR import_function_data$4[rbp-169]
  0019d	48 8b c1	 mov	 rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001a0	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  001a7	72 19		 jb	 SHORT $LN199@get_import

; 147  :     _Bytes += _Non_user_size;

  001a9	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001ad	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  001b1	48 2b c1	 sub	 rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001b4	48 83 c0 f8	 add	 rax, -8
  001b8	48 83 f8 1f	 cmp	 rax, 31
  001bc	0f 87 55 02 00
	00		 ja	 $LN196@get_import
$LN199@get_import:

; 255  :         ::operator delete(_Ptr, _Bytes);

  001c2	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN189@get_import:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 113  : 			while (current_originalFirstThunk->u1.Function)

  001c7	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  001ca	48 85 c0	 test	 rax, rax
  001cd	0f 85 3d ff ff
	ff		 jne	 $LL4@get_import
  001d3	48 8b 5c 24 20	 mov	 rbx, QWORD PTR current_import_descriptor$1$[rsp]
$LN5@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 730  :         if (_Mylast != _My_data._Myend) {

  001d8	4c 3b 6d 8f	 cmp	 r13, QWORD PTR imports$[rbp-153]
  001dc	0f 84 15 01 00
	00		 je	 $LN208@get_import
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  001e2	4c 89 6d a7	 mov	 QWORD PTR $T1[rbp-169], r13
  001e6	48 8d 55 df	 lea	 rdx, QWORD PTR import_info$6[rbp-169]
  001ea	49 8b cd	 mov	 rcx, r13
  001ed	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001f2	90		 npad	 1
  001f3	4d 8d 75 20	 lea	 r14, QWORD PTR [r13+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  001f7	4d 89 26	 mov	 QWORD PTR [r14], r12
  001fa	4d 89 66 08	 mov	 QWORD PTR [r14+8], r12
  001fe	4d 89 66 10	 mov	 QWORD PTR [r14+16], r12

; 549  :         if (_Rightfirst != _Rightlast) {

  00202	4c 8b 7d ff	 mov	 r15, QWORD PTR import_info$6[rbp-137]
  00206	48 8b 75 07	 mov	 rsi, QWORD PTR import_info$6[rbp-129]
  0020a	4c 3b fe	 cmp	 r15, rsi
  0020d	0f 84 d5 00 00
	00		 je	 $LN278@get_import

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00213	48 8b c6	 mov	 rax, rsi
  00216	49 2b c7	 sub	 rax, r15
  00219	48 c1 f8 03	 sar	 rax, 3
  0021d	48 b9 cd cc cc
	cc cc cc cc cc	 mov	 rcx, -3689348814741910323 ; cccccccccccccccdH
  00227	48 0f af c1	 imul	 rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  0022b	48 b9 66 66 66
	66 66 66 66 06	 mov	 rcx, 461168601842738790	; 0666666666666666H
  00235	48 3b c1	 cmp	 rax, rcx
  00238	0f 87 40 02 00
	00		 ja	 $LN478@get_import

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0023e	48 8d 04 80	 lea	 rax, QWORD PTR [rax+rax*4]
  00242	48 8d 1c c5 00
	00 00 00	 lea	 rbx, QWORD PTR [rax*8]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0024a	48 81 fb 00 10
	00 00		 cmp	 rbx, 4096		; 00001000H
  00251	72 2c		 jb	 SHORT $LN235@get_import

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00253	48 8d 4b 27	 lea	 rcx, QWORD PTR [rbx+39]

; 130  :     if (_Block_size <= _Bytes) {

  00257	48 3b cb	 cmp	 rcx, rbx
  0025a	0f 86 1e 02 00
	00		 jbe	 $LN478@get_import

; 79   :         return ::operator new(_Bytes);

  00260	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00265	48 8b c8	 mov	 rcx, rax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00268	48 85 c0	 test	 rax, rax
  0026b	0f 84 ad 01 00
	00		 je	 $LN244@get_import

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00271	48 83 c0 27	 add	 rax, 39			; 00000027H
  00275	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00279	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0027d	eb 12		 jmp	 SHORT $LN234@get_import
$LN235@get_import:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  0027f	48 85 db	 test	 rbx, rbx
  00282	74 0a		 je	 SHORT $LN236@get_import

; 79   :         return ::operator new(_Bytes);

  00284	48 8b cb	 mov	 rcx, rbx
  00287	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 235  :         return _Traits::_Allocate(_Bytes);

  0028c	eb 03		 jmp	 SHORT $LN234@get_import
$LN236@get_import:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  0028e	49 8b c4	 mov	 rax, r12
$LN234@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1699 :         _Myfirst           = _Newvec;

  00291	49 89 06	 mov	 QWORD PTR [r14], rax

; 1700 :         _Mylast            = _Newvec;

  00294	49 89 46 08	 mov	 QWORD PTR [r14+8], rax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

  00298	48 03 c3	 add	 rax, rbx
  0029b	49 89 46 10	 mov	 QWORD PTR [r14+16], rax

; 551  :             _Tidy_guard<vector> _Guard{this};

  0029f	4c 89 75 af	 mov	 QWORD PTR _Guard$2[rbp-169], r14

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  002a3	49 8b 1e	 mov	 rbx, QWORD PTR [r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1642 :     auto _UFirst      = _Get_unwrapped(_First);

  002a6	49 8b ff	 mov	 rdi, r15

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  002a9	48 89 5d b7	 mov	 QWORD PTR _Backout$3[rbp-169], rbx
  002ad	48 89 5d bf	 mov	 QWORD PTR _Backout$3[rbp-161], rbx
  002b1	4c 89 75 c7	 mov	 QWORD PTR _Backout$3[rbp-153], r14
$LL261@get_import:
  002b5	48 8b d7	 mov	 rdx, rdi
  002b8	48 8b cb	 mov	 rcx, rbx
  002bb	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002c0	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  002c4	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 1621 :         ++_Last;

  002c8	48 83 c3 28	 add	 rbx, 40			; 00000028H
  002cc	48 89 5d bf	 mov	 QWORD PTR _Backout$3[rbp-161], rbx

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

  002d0	48 83 c7 28	 add	 rdi, 40			; 00000028H
  002d4	48 3b fe	 cmp	 rdi, rsi
  002d7	75 dc		 jne	 SHORT $LL261@get_import

; 1615 :         _Destroy_range(_First, _Last, _Al);

  002d9	48 8b d3	 mov	 rdx, rbx
  002dc	48 8b cb	 mov	 rcx, rbx
  002df	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAXPEAUImportFunctionInfo@portable_executable@@QEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Destroy_range<std::allocator<portable_executable::ImportFunctionInfo> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  002e4	49 89 5e 08	 mov	 QWORD PTR [r14+8], rbx
$LN278@get_import:

; 716  :         ++_Mylast;

  002e8	49 83 c5 38	 add	 r13, 56			; 00000038H
  002ec	4c 89 6d 87	 mov	 QWORD PTR imports$[rbp-161], r13

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  002f0	48 8b 5c 24 20	 mov	 rbx, QWORD PTR current_import_descriptor$1$[rsp]
  002f5	eb 1d		 jmp	 SHORT $LN207@get_import
$LN208@get_import:

; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  002f7	4c 8d 45 df	 lea	 r8, QWORD PTR import_info$6[rbp-169]
  002fb	49 8b d5	 mov	 rdx, r13
  002fe	48 8d 4c 24 28	 lea	 rcx, QWORD PTR imports$[rsp]
  00303	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>
  00308	4c 8b 6d 87	 mov	 r13, QWORD PTR imports$[rbp-161]
  0030c	48 8b 75 07	 mov	 rsi, QWORD PTR import_info$6[rbp-129]
  00310	4c 8b 7d ff	 mov	 r15, QWORD PTR import_info$6[rbp-137]
$LN207@get_import:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 129  : 			++current_import_descriptor;

  00314	48 83 c3 14	 add	 rbx, 20
  00318	48 89 5c 24 20	 mov	 QWORD PTR current_import_descriptor$1$[rsp], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1750 :         if (_Myfirst) { // destroy and deallocate old array

  0031d	4d 85 ff	 test	 r15, r15
  00320	0f 84 ab 00 00
	00		 je	 $LN291@get_import

; 1667 :         _Destroy_range(_First, _Last, _Getal());

  00326	49 8b df	 mov	 rbx, r15
  00329	4c 3b fe	 cmp	 r15, rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 904  :         for (; _First != _Last; ++_First) {

  0032c	74 54		 je	 SHORT $LN297@get_import
  0032e	66 90		 npad	 2
$LL298@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  00330	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00334	48 83 fa 10	 cmp	 rdx, 16
  00338	72 30		 jb	 SHORT $LN320@get_import

; 4585 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0033a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0033d	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00340	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00347	72 1c		 jb	 SHORT $LN330@get_import

; 147  :     _Bytes += _Non_user_size;

  00349	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0034d	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00351	49 2b c8	 sub	 rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00354	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00358	48 83 f8 1f	 cmp	 rax, 31
  0035c	0f 87 c3 00 00
	00		 ja	 $LN379@get_import

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00362	49 8b c8	 mov	 rcx, r8
$LN330@get_import:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00365	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN320@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  0036a	4c 89 63 10	 mov	 QWORD PTR [rbx+16], r12

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0036e	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00376	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 904  :         for (; _First != _Last; ++_First) {

  00379	48 83 c3 28	 add	 rbx, 40			; 00000028H
  0037d	48 3b de	 cmp	 rbx, rsi
  00380	75 ae		 jne	 SHORT $LL298@get_import
$LN297@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1752 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00382	48 8b 45 0f	 mov	 rax, QWORD PTR import_info$6[rbp-121]
  00386	49 2b c7	 sub	 rax, r15
  00389	48 c1 f8 03	 sar	 rax, 3
  0038d	48 b9 cd cc cc
	cc cc cc cc cc	 mov	 rcx, -3689348814741910323 ; cccccccccccccccdH
  00397	48 0f af c1	 imul	 rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0039b	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]
  0039f	48 c1 e2 03	 shl	 rdx, 3
  003a3	49 8b c7	 mov	 rax, r15

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003a6	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  003ad	72 15		 jb	 SHORT $LN355@get_import

; 147  :     _Bytes += _Non_user_size;

  003af	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003b3	4d 8b 7f f8	 mov	 r15, QWORD PTR [r15-8]
  003b7	49 2b c7	 sub	 rax, r15

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003ba	48 83 c0 f8	 add	 rax, -8
  003be	48 83 f8 1f	 cmp	 rax, 31
  003c2	77 61		 ja	 SHORT $LN379@get_import
$LN355@get_import:

; 255  :         ::operator delete(_Ptr, _Bytes);

  003c4	49 8b cf	 mov	 rcx, r15
  003c7	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  003cc	48 8b 5c 24 20	 mov	 rbx, QWORD PTR current_import_descriptor$1$[rsp]
$LN291@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003d1	48 8b 55 f7	 mov	 rdx, QWORD PTR import_info$6[rbp-145]
  003d5	48 83 fa 10	 cmp	 rdx, 16
  003d9	72 2d		 jb	 SHORT $LN372@get_import

; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003db	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003de	48 8b 4d df	 mov	 rcx, QWORD PTR import_info$6[rbp-169]
  003e2	48 8b c1	 mov	 rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003e5	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  003ec	72 15		 jb	 SHORT $LN382@get_import

; 147  :     _Bytes += _Non_user_size;

  003ee	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003f2	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  003f6	48 2b c1	 sub	 rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003f9	48 83 c0 f8	 add	 rax, -8
  003fd	48 83 f8 1f	 cmp	 rax, 31
  00401	77 22		 ja	 SHORT $LN379@get_import
$LN382@get_import:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00403	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN372@get_import:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 104  : 		while (current_import_descriptor->FirstThunk)

  00408	83 7b 10 00	 cmp	 DWORD PTR [rbx+16], 0
  0040c	74 1e		 je	 SHORT $LN499@get_import
  0040e	4c 8b 7d 97	 mov	 r15, QWORD PTR image_base$GSCopy$1$[rbp-169]
  00412	e9 79 fc ff ff	 jmp	 $LL2@get_import
$LN196@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00417	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0041d	90		 npad	 1
$LN244@get_import:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0041e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00424	90		 npad	 1
$LN379@get_import:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00425	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0042b	cc		 int	 3
$LN499@get_import:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 104  : 		while (current_import_descriptor->FirstThunk)

  0042c	48 8b 55 9f	 mov	 rdx, QWORD PTR __$ReturnUdt$GSCopy$1$[rbp-169]
$LN495@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00430	48 8b 4c 24 28	 mov	 rcx, QWORD PTR imports$[rsp]
  00435	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00438	4c 89 6a 08	 mov	 QWORD PTR [rdx+8], r13
  0043c	48 8b 45 8f	 mov	 rax, QWORD PTR imports$[rbp-153]
  00440	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 132  : 		return imports;

  00444	eb 0e		 jmp	 SHORT $LN501@get_import
$LN494@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00446	45 33 e4	 xor	 r12d, r12d
  00449	4c 89 21	 mov	 QWORD PTR [rcx], r12
  0044c	4c 89 61 08	 mov	 QWORD PTR [rcx+8], r12
  00450	4c 89 61 10	 mov	 QWORD PTR [rcx+16], r12
$LN501@get_import:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\drv_image.cpp

; 133  : 	}

  00454	48 8b c2	 mov	 rax, rdx
  00457	48 8b 4d 17	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-169]
  0045b	48 33 cc	 xor	 rcx, rsp
  0045e	e8 00 00 00 00	 call	 __security_check_cookie
  00463	48 8b 9c 24 20
	01 00 00	 mov	 rbx, QWORD PTR [rsp+288]
  0046b	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00472	41 5f		 pop	 r15
  00474	41 5e		 pop	 r14
  00476	41 5d		 pop	 r13
  00478	41 5c		 pop	 r12
  0047a	5f		 pop	 rdi
  0047b	5e		 pop	 rsi
  0047c	5d		 pop	 rbp
  0047d	c3		 ret	 0
$LN478@get_import:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

  0047e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00483	90		 npad	 1
$LN500@get_import:
?get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z ENDP ; portable_executable::get_imports
_TEXT	ENDS
text$x	SEGMENT
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$1@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR imports$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::~vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
?dtor$1@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$1
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$2@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$2
  0000c	48 8d 8a 88 00
	00 00		 lea	 rcx, QWORD PTR import_info$6[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1ImportInfo@portable_executable@@QEAA@XZ
?dtor$2@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$2
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$4@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$4
  00018	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR import_function_data$4[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1ImportFunctionInfo@portable_executable@@QEAA@XZ
?dtor$4@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$4
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$19@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$19
  00024	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR $T1[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$19@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$19
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$21@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$21
  00030	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR _Guard$2[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
?dtor$21@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$21
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$22@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$22
  0003c	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Backout$3[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$22@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$1@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR imports$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::~vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
?dtor$1@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$2@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$2
  0000c	48 8d 8a 88 00
	00 00		 lea	 rcx, QWORD PTR import_info$6[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1ImportInfo@portable_executable@@QEAA@XZ
?dtor$2@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$4@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$4
  00018	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR import_function_data$4[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1ImportFunctionInfo@portable_executable@@QEAA@XZ
?dtor$4@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$19@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$19
  00024	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR $T1[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$19@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$21@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$21
  00030	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR _Guard$2[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
?dtor$21@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
current_import_descriptor$1$ = 32
__$ReturnUdt$GSCopy$ = 32
imports$ = 40
image_base$GSCopy$1$ = 64
__$ReturnUdt$GSCopy$1$ = 72
$T1 = 80
_Guard$2 = 88
_Backout$3 = 96
import_function_data$4 = 96
$T5 = 96
import_info$6 = 136
__$ArrayPad$ = 192
__$ReturnUdt$ = 272
image_base$ = 280
?dtor$22@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA PROC ; `portable_executable::get_imports'::`1'::dtor$22
  0003c	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Backout$3[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$22@?0??get_imports@portable_executable@@YA?AV?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@PEAX@Z@4HA ENDP ; `portable_executable::get_imports'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp
_TEXT	SEGMENT
buffer_size$ = 48
module_name$GSCopy$1$ = 56
full_path$1 = 64
$T2 = 96
current_module_name$3 = 128
__$ArrayPad$ = 160
module_name$ = 224
export_name$ = 232
rva$dead$ = 240
?get_kernel_export@util@@YAPEAXPEBD0_N@Z PROC		; util::get_kernel_export

; 66   : 	{

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  0001d	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002b	48 33 c4	 xor	 rax, rsp
  0002e	48 89 45 27	 mov	 QWORD PTR __$ArrayPad$[rbp-121], rax
  00032	4c 8b ea	 mov	 r13, rdx
  00035	48 8b f9	 mov	 rdi, rcx
  00038	48 89 4d bf	 mov	 QWORD PTR module_name$GSCopy$1$[rbp-121], rcx

; 67   : 		void* buffer = nullptr;

  0003c	45 33 f6	 xor	 r14d, r14d
  0003f	45 8b fe	 mov	 r15d, r14d

; 68   : 		DWORD buffer_size = NULL;

  00042	44 89 75 b7	 mov	 DWORD PTR buffer_size$[rbp-121], r14d

; 69   : 
; 70   : 		NTSTATUS status = NtQuerySystemInformation(

  00046	4c 8d 4d b7	 lea	 r9, QWORD PTR buffer_size$[rbp-121]
  0004a	45 33 c0	 xor	 r8d, r8d
  0004d	33 d2		 xor	 edx, edx
  0004f	8d 4a 0b	 lea	 ecx, QWORD PTR [rdx+11]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NtQuerySystemInformation

; 71   : 			static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation),
; 72   : 			buffer,
; 73   : 			buffer_size,
; 74   : 			&buffer_size
; 75   : 		);
; 76   : 
; 77   : 		while (status == STATUS_INFO_LENGTH_MISMATCH)

  00058	3d 04 00 00 c0	 cmp	 eax, -1073741820	; ffffffffc0000004H
  0005d	75 47		 jne	 SHORT $LN3@get_kernel
  0005f	90		 npad	 1
$LL2@get_kernel:

; 78   : 		{
; 79   : 			VirtualFree(buffer, 0, MEM_RELEASE);

  00060	33 d2		 xor	 edx, edx
  00062	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00068	49 8b cf	 mov	 rcx, r15
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree

; 80   : 			buffer = VirtualAlloc(nullptr, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

  00071	8b 55 b7	 mov	 edx, DWORD PTR buffer_size$[rbp-121]
  00074	33 c9		 xor	 ecx, ecx
  00076	44 8d 49 04	 lea	 r9d, QWORD PTR [rcx+4]
  0007a	41 b8 00 30 00
	00		 mov	 r8d, 12288		; 00003000H
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualAlloc
  00086	4c 8b f8	 mov	 r15, rax

; 81   : 			status = NtQuerySystemInformation(

  00089	4c 8d 4d b7	 lea	 r9, QWORD PTR buffer_size$[rbp-121]
  0008d	44 8b 45 b7	 mov	 r8d, DWORD PTR buffer_size$[rbp-121]
  00091	48 8b d0	 mov	 rdx, rax
  00094	b9 0b 00 00 00	 mov	 ecx, 11
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NtQuerySystemInformation

; 71   : 			static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation),
; 72   : 			buffer,
; 73   : 			buffer_size,
; 74   : 			&buffer_size
; 75   : 		);
; 76   : 
; 77   : 		while (status == STATUS_INFO_LENGTH_MISMATCH)

  0009f	3d 04 00 00 c0	 cmp	 eax, -1073741820	; ffffffffc0000004H
  000a4	74 ba		 je	 SHORT $LL2@get_kernel
$LN3@get_kernel:

; 82   : 				static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation),
; 83   : 				buffer,
; 84   : 				buffer_size,
; 85   : 				&buffer_size
; 86   : 			);
; 87   : 		}
; 88   : 
; 89   : 		if (!NT_SUCCESS(status))

  000a6	85 c0		 test	 eax, eax
  000a8	0f 88 6f 03 00
	00		 js	 $LN506@get_kernel

; 96   : 		for (auto idx = 0u; idx < modules->NumberOfModules; ++idx)

  000ae	45 8b e6	 mov	 r12d, r14d
  000b1	45 39 37	 cmp	 DWORD PTR [r15], r14d
  000b4	0f 86 63 03 00
	00		 jbe	 $LN506@get_kernel
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL6@get_kernel:

; 97   : 		{
; 98   : 			// find module and then load library it
; 99   : 			const std::string current_module_name =

  000c0	41 8b c4	 mov	 eax, r12d
  000c3	48 69 c8 28 01
	00 00		 imul	 rcx, rax, 296		; 00000128H
  000ca	4a 8d 1c 39	 lea	 rbx, QWORD PTR [rcx+r15]
  000ce	0f b7 43 2e	 movzx	 eax, WORD PTR [rbx+46]
  000d2	48 03 c1	 add	 rax, rcx
  000d5	49 8d 57 30	 lea	 rdx, QWORD PTR [r15+48]
  000d9	48 03 d0	 add	 rdx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  000dc	4c 89 75 07	 mov	 QWORD PTR current_module_name$3[rbp-121], r14

; 4562 :         _My_data._Mysize = 0;

  000e0	4c 89 75 17	 mov	 QWORD PTR current_module_name$3[rbp-105], r14

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  000e4	48 c7 45 1f 0f
	00 00 00	 mov	 QWORD PTR current_module_name$3[rbp-97], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000ec	c6 45 07 00	 mov	 BYTE PTR current_module_name$3[rbp-121], 0

; 401  :             return __builtin_strlen(_First);

  000f0	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  000f7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL511@get_kernel:
  00100	49 ff c0	 inc	 r8
  00103	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  00108	75 f6		 jne	 SHORT $LL511@get_kernel

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0010a	48 8d 4d 07	 lea	 rcx, QWORD PTR current_module_name$3[rbp-121]
  0010e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00113	90		 npad	 1

; 2272 :         const value_type* _Result = _Bx._Buf;

  00114	48 8d 4d 07	 lea	 rcx, QWORD PTR current_module_name$3[rbp-121]

; 2273 :         if (_Large_string_engaged()) {

  00118	48 83 7d 1f 10	 cmp	 QWORD PTR current_module_name$3[rbp-97], 16
  0011d	48 0f 43 4d 07	 cmovae	 rcx, QWORD PTR current_module_name$3[rbp-121]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 105  : 			if (!_stricmp(current_module_name.c_str(), module_name))

  00122	48 8b d7	 mov	 rdx, rdi
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0012b	85 c0		 test	 eax, eax
  0012d	0f 85 a3 02 00
	00		 jne	 $LN442@get_kernel

; 106  : 			{
; 107  : 				// had to shoot the tires off of "\\SystemRoot\\"
; 108  : 				std::string full_path = reinterpret_cast<char*>(modules->Modules[idx].FullPathName);

  00133	48 8d 53 30	 lea	 rdx, QWORD PTR [rbx+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00137	4c 89 75 c7	 mov	 QWORD PTR full_path$1[rbp-121], r14

; 4562 :         _My_data._Mysize = 0;

  0013b	4c 89 75 d7	 mov	 QWORD PTR full_path$1[rbp-105], r14

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  0013f	48 c7 45 df 0f
	00 00 00	 mov	 QWORD PTR full_path$1[rbp-97], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00147	88 45 c7	 mov	 BYTE PTR full_path$1[rbp-121], al

; 401  :             return __builtin_strlen(_First);

  0014a	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
$LL510@get_kernel:
  00151	49 ff c0	 inc	 r8
  00154	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  00159	75 f6		 jne	 SHORT $LL510@get_kernel

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0015b	48 8d 4d c7	 lea	 rcx, QWORD PTR full_path$1[rbp-121]
  0015f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00164	90		 npad	 1
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 109  : 				full_path.replace(

  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@CLNGBNDK@SYSTEMROOT@
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00172	4c 89 75 e7	 mov	 QWORD PTR $T2[rbp-121], r14

; 4562 :         _My_data._Mysize = 0;

  00176	4c 89 75 f7	 mov	 QWORD PTR $T2[rbp-105], r14

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  0017a	48 c7 45 ff 0f
	00 00 00	 mov	 QWORD PTR $T2[rbp-97], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00182	c6 45 e7 00	 mov	 BYTE PTR $T2[rbp-121], 0

; 401  :             return __builtin_strlen(_First);

  00186	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0018d	0f 1f 00	 npad	 3
$LL509@get_kernel:
  00190	49 ff c0	 inc	 r8
  00193	42 80 3c 00 00	 cmp	 BYTE PTR [rax+r8], 0
  00198	75 f6		 jne	 SHORT $LL509@get_kernel

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0019a	48 8b d0	 mov	 rdx, rax
  0019d	48 8d 4d e7	 lea	 rcx, QWORD PTR $T2[rbp-121]
  001a1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  001a6	90		 npad	 1

; 3120 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  001a7	48 8b 4d f7	 mov	 rcx, QWORD PTR $T2[rbp-105]
  001ab	48 8b 55 ff	 mov	 rdx, QWORD PTR $T2[rbp-97]
  001af	48 8b c2	 mov	 rax, rdx
  001b2	48 2b c1	 sub	 rax, rcx

; 3121 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  001b5	48 83 f8 01	 cmp	 rax, 1
  001b9	72 21		 jb	 SHORT $LN86@get_kernel

; 3122 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  001bb	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  001bf	48 89 45 f7	 mov	 QWORD PTR $T2[rbp-105], rax

; 2263 :         value_type* _Result = _Bx._Buf;

  001c3	48 8d 45 e7	 lea	 rax, QWORD PTR $T2[rbp-121]

; 2264 :         if (_Large_string_engaged()) {

  001c7	48 83 fa 10	 cmp	 rdx, 16
  001cb	48 0f 43 45 e7	 cmovae	 rax, QWORD PTR $T2[rbp-121]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001d0	66 c7 04 08 5c
	00		 mov	 WORD PTR [rax+rcx], 92	; 0000005cH

; 3126 :             return *this;

  001d6	48 8d 75 e7	 lea	 rsi, QWORD PTR $T2[rbp-121]
  001da	eb 21		 jmp	 SHORT $LN85@get_kernel
$LN86@get_kernel:

; 3127 :         }
; 3128 : 
; 3129 :         return _Reallocate_grow_by(

  001dc	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR [rsp+32], 1
  001e5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01KICIPPFI@?2@
  001ec	ba 01 00 00 00	 mov	 edx, 1
  001f1	48 8d 4d e7	 lea	 rcx, QWORD PTR $T2[rbp-121]
  001f5	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
  001fa	48 8b f0	 mov	 rsi, rax
$LN85@get_kernel:

; 2272 :         const value_type* _Result = _Bx._Buf;

  001fd	48 8d 7d c7	 lea	 rdi, QWORD PTR full_path$1[rbp-121]

; 2273 :         if (_Large_string_engaged()) {

  00201	48 83 7d df 10	 cmp	 QWORD PTR full_path$1[rbp-97], 16
  00206	48 0f 43 7d c7	 cmovae	 rdi, QWORD PTR full_path$1[rbp-121]

; 600  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  0020b	48 8b 45 d7	 mov	 rax, QWORD PTR full_path$1[rbp-105]
  0020f	48 83 f8 0c	 cmp	 rax, 12
  00213	72 6a		 jb	 SHORT $LN109@get_kernel

; 601  :         // xpos cannot exist, report failure
; 602  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 603  :         // 1. _Start_at <= xpos
; 604  :         // 2. xpos + _Needle_size <= _Hay_size;
; 605  :         // therefore:
; 606  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 607  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 608  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 609  :         return static_cast<size_t>(-1);
; 610  :     }
; 611  : 
; 612  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 613  :         return _Start_at;
; 614  :     }
; 615  : 
; 616  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00215	4c 8d 34 38	 lea	 r14, QWORD PTR [rax+rdi]

; 618  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  00219	4d 8d 46 f5	 lea	 r8, QWORD PTR [r14-11]
  0021d	4c 2b c7	 sub	 r8, rdi

; 422  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00220	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00225	48 8b cf	 mov	 rcx, rdi
  00228	e8 00 00 00 00	 call	 memchr
  0022d	48 8b d8	 mov	 rbx, rax

; 619  :         if (!_Match_try) { // didn't find first character; report failure

  00230	48 85 c0	 test	 rax, rax
  00233	74 47		 je	 SHORT $LN488@get_kernel
  00235	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL107@get_kernel:

; 382  :         return __builtin_memcmp(_First1, _First2, _Count);

  00240	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00246	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BDPNIACE@?2SystemRoot?2@
  0024d	48 8b cb	 mov	 rcx, rbx
  00250	e8 00 00 00 00	 call	 memcmp

; 623  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  00255	85 c0		 test	 eax, eax
  00257	0f 84 00 02 00
	00		 je	 $LN489@get_kernel

; 617  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  0025d	48 ff c3	 inc	 rbx

; 618  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  00260	4d 8d 46 f5	 lea	 r8, QWORD PTR [r14-11]
  00264	4c 2b c3	 sub	 r8, rbx

; 422  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00267	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  0026c	48 8b cb	 mov	 rcx, rbx
  0026f	e8 00 00 00 00	 call	 memchr
  00274	48 8b d8	 mov	 rbx, rax

; 619  :         if (!_Match_try) { // didn't find first character; report failure

  00277	48 85 c0	 test	 rax, rax
  0027a	75 c4		 jne	 SHORT $LL107@get_kernel
$LN488@get_kernel:

; 620  :             return static_cast<size_t>(-1);

  0027c	45 33 f6	 xor	 r14d, r14d
$LN109@get_kernel:

; 3471 :         return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0027f	48 c7 c3 ff ff
	ff ff		 mov	 rbx, -1
$LN106@get_kernel:
  00286	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]

; 2273 :         if (_Large_string_engaged()) {

  0028a	48 83 7e 18 10	 cmp	 QWORD PTR [rsi+24], 16
  0028f	72 03		 jb	 SHORT $LN121@get_kernel

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  00291	48 8b 36	 mov	 rsi, QWORD PTR [rsi]
$LN121@get_kernel:

; 3471 :         return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00294	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00299	4c 8b ce	 mov	 r9, rsi
  0029c	48 8b d3	 mov	 rdx, rbx
  0029f	48 8d 4d c7	 lea	 rcx, QWORD PTR full_path$1[rbp-121]
  002a3	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
  002a8	90		 npad	 1

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  002a9	48 8b 55 ff	 mov	 rdx, QWORD PTR $T2[rbp-97]
  002ad	48 83 fa 10	 cmp	 rdx, 16
  002b1	72 31		 jb	 SHORT $LN137@get_kernel

; 4585 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  002b3	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002b6	48 8b 4d e7	 mov	 rcx, QWORD PTR $T2[rbp-121]
  002ba	48 8b c1	 mov	 rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002bd	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  002c4	72 19		 jb	 SHORT $LN147@get_kernel

; 147  :     _Bytes += _Non_user_size;

  002c6	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002ca	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  002ce	48 2b c1	 sub	 rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002d1	48 83 c0 f8	 add	 rax, -8
  002d5	48 83 f8 1f	 cmp	 rax, 31
  002d9	0f 87 89 01 00
	00		 ja	 $LN144@get_kernel
$LN147@get_kernel:

; 255  :         ::operator delete(_Ptr, _Bytes);

  002df	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN137@get_kernel:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2272 :         const value_type* _Result = _Bx._Buf;

  002e4	48 8d 4d c7	 lea	 rcx, QWORD PTR full_path$1[rbp-121]

; 2273 :         if (_Large_string_engaged()) {

  002e8	48 83 7d df 10	 cmp	 QWORD PTR full_path$1[rbp-97], 16
  002ed	48 0f 43 4d c7	 cmovae	 rcx, QWORD PTR full_path$1[rbp-121]
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 115  : 				const auto module_base =

  002f2	33 d2		 xor	 edx, edx
  002f4	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryExA
  002fe	4c 8b d8	 mov	 r11, rax

; 116  : 					LoadLibraryEx(
; 117  : 						full_path.c_str(),
; 118  : 						NULL,
; 119  : 						DONT_RESOLVE_DLL_REFERENCES
; 120  : 					);
; 121  : 
; 122  : 				PIMAGE_DOS_HEADER p_idh;
; 123  : 				PIMAGE_NT_HEADERS p_inh;
; 124  : 				PIMAGE_EXPORT_DIRECTORY p_ied;
; 125  : 
; 126  : 				PDWORD addr, name;
; 127  : 				PWORD ordinal;
; 128  : 
; 129  : 				p_idh = (PIMAGE_DOS_HEADER)module_base;
; 130  : 				if (p_idh->e_magic != IMAGE_DOS_SIGNATURE)

  00301	b8 4d 5a 00 00	 mov	 eax, 23117		; 00005a4dH
  00306	66 41 39 03	 cmp	 WORD PTR [r11], ax
  0030a	0f 85 8b 01 00
	00		 jne	 $LN491@get_kernel

; 131  : 					return NULL;
; 132  : 
; 133  : 				p_inh = (PIMAGE_NT_HEADERS)((LPBYTE)module_base + p_idh->e_lfanew);

  00310	49 63 4b 3c	 movsxd	 rcx, DWORD PTR [r11+60]

; 134  : 				if (p_inh->Signature != IMAGE_NT_SIGNATURE)

  00314	42 81 3c 19 50
	45 00 00	 cmp	 DWORD PTR [rcx+r11], 17744 ; 00004550H
  0031c	0f 85 79 01 00
	00		 jne	 $LN491@get_kernel

; 135  : 					return NULL;
; 136  : 
; 137  : 				if (p_inh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == 0)

  00322	42 8b 94 19 88
	00 00 00	 mov	 edx, DWORD PTR [rcx+r11+136]
  0032a	85 d2		 test	 edx, edx
  0032c	0f 84 69 01 00
	00		 je	 $LN491@get_kernel

; 138  : 					return NULL;
; 139  : 
; 140  : 				p_ied = (PIMAGE_EXPORT_DIRECTORY)((LPBYTE)module_base +
; 141  : 					p_inh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
; 142  : 
; 143  : 				addr = (PDWORD)((LPBYTE)module_base + p_ied->AddressOfFunctions);

  00332	42 8b 5c 1a 1c	 mov	 ebx, DWORD PTR [rdx+r11+28]
  00337	49 8d 3c 1b	 lea	 rdi, QWORD PTR [r11+rbx]

; 144  : 				name = (PDWORD)((LPBYTE)module_base + p_ied->AddressOfNames);

  0033b	46 8b 4c 1a 20	 mov	 r9d, DWORD PTR [rdx+r11+32]
  00340	4d 03 cb	 add	 r9, r11

; 145  : 				ordinal = (PWORD)((LPBYTE)module_base + p_ied->AddressOfNameOrdinals);

  00343	42 8b 74 1a 24	 mov	 esi, DWORD PTR [rdx+r11+36]
  00348	49 03 f3	 add	 rsi, r11

; 146  : 
; 147  : 				// find exported function
; 148  : 				for (auto i = 0; i < p_ied->AddressOfFunctions; i++)

  0034b	45 8b d6	 mov	 r10d, r14d
  0034e	85 db		 test	 ebx, ebx
  00350	74 45		 je	 SHORT $LN8@get_kernel
  00352	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL9@get_kernel:

; 149  : 					if (!strcmp(export_name, (char*)module_base + name[i]))

  00360	45 8b 01	 mov	 r8d, DWORD PTR [r9]
  00363	4d 03 c3	 add	 r8, r11
  00366	49 8b c5	 mov	 rax, r13
  00369	4d 2b c5	 sub	 r8, r13
  0036c	0f 1f 40 00	 npad	 4
$LL507@get_kernel:
  00370	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00373	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  00378	2b d1		 sub	 edx, ecx
  0037a	75 07		 jne	 SHORT $LN508@get_kernel
  0037c	48 ff c0	 inc	 rax
  0037f	85 c9		 test	 ecx, ecx
  00381	75 ed		 jne	 SHORT $LL507@get_kernel
$LN508@get_kernel:
  00383	85 d2		 test	 edx, edx
  00385	0f 84 e4 00 00
	00		 je	 $LN490@get_kernel

; 146  : 
; 147  : 				// find exported function
; 148  : 				for (auto i = 0; i < p_ied->AddressOfFunctions; i++)

  0038b	41 ff c2	 inc	 r10d
  0038e	49 83 c1 04	 add	 r9, 4
  00392	44 3b d3	 cmp	 r10d, ebx
  00395	72 c9		 jb	 SHORT $LL9@get_kernel
$LN8@get_kernel:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00397	48 8b 55 df	 mov	 rdx, QWORD PTR full_path$1[rbp-97]
  0039b	48 83 fa 10	 cmp	 rdx, 16
  0039f	72 31		 jb	 SHORT $LN512@get_kernel

; 4585 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003a1	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003a4	48 8b 4d c7	 mov	 rcx, QWORD PTR full_path$1[rbp-121]
  003a8	48 8b c1	 mov	 rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003ab	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  003b2	72 19		 jb	 SHORT $LN452@get_kernel

; 147  :     _Bytes += _Non_user_size;

  003b4	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003b8	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  003bc	48 2b c1	 sub	 rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003bf	48 83 c0 f8	 add	 rax, -8
  003c3	48 83 f8 1f	 cmp	 rax, 31
  003c7	0f 87 03 01 00
	00		 ja	 $LN449@get_kernel
$LN452@get_kernel:

; 255  :         ::operator delete(_Ptr, _Bytes);

  003cd	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN512@get_kernel:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 165  : 		}

  003d2	48 8b 7d bf	 mov	 rdi, QWORD PTR module_name$GSCopy$1$[rbp-121]
$LN442@get_kernel:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2286 :         return _BUF_SIZE <= _Myres;

  003d6	48 8b 55 1f	 mov	 rdx, QWORD PTR current_module_name$3[rbp-97]
  003da	48 83 fa 10	 cmp	 rdx, 16

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  003de	72 31		 jb	 SHORT $LN469@get_kernel

; 4585 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  003e0	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003e3	48 8b 4d 07	 mov	 rcx, QWORD PTR current_module_name$3[rbp-121]
  003e7	48 8b c1	 mov	 rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003ea	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  003f1	72 19		 jb	 SHORT $LN479@get_kernel

; 147  :     _Bytes += _Non_user_size;

  003f3	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003f7	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  003fb	48 2b c1	 sub	 rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003fe	48 83 c0 f8	 add	 rax, -8
  00402	48 83 f8 1f	 cmp	 rax, 31
  00406	0f 87 26 01 00
	00		 ja	 $LN476@get_kernel
$LN479@get_kernel:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0040c	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN469@get_kernel:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 96   : 		for (auto idx = 0u; idx < modules->NumberOfModules; ++idx)

  00411	41 ff c4	 inc	 r12d
  00414	45 3b 27	 cmp	 r12d, DWORD PTR [r15]
  00417	0f 82 a3 fc ff
	ff		 jb	 $LL6@get_kernel
$LN506@get_kernel:

; 166  : 		VirtualFree(buffer, NULL, MEM_RELEASE);

  0041d	33 d2		 xor	 edx, edx
  0041f	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00425	49 8b cf	 mov	 rcx, r15
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree

; 167  : 		return NULL;

  0042e	33 c0		 xor	 eax, eax
$LN1@get_kernel:

; 168  : 	}

  00430	48 8b 4d 27	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-121]
  00434	48 33 cc	 xor	 rcx, rsp
  00437	e8 00 00 00 00	 call	 __security_check_cookie
  0043c	4c 8d 9c 24 b0
	00 00 00	 lea	 r11, QWORD PTR [rsp+176]
  00444	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00448	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  0044c	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  00450	49 8b e3	 mov	 rsp, r11
  00453	41 5f		 pop	 r15
  00455	41 5e		 pop	 r14
  00457	41 5d		 pop	 r13
  00459	41 5c		 pop	 r12
  0045b	5d		 pop	 rbp
  0045c	c3		 ret	 0
$LN489@get_kernel:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 624  :             return static_cast<size_t>(_Match_try - _Haystack);

  0045d	48 2b df	 sub	 rbx, rdi
  00460	45 33 f6	 xor	 r14d, r14d
  00463	e9 1e fe ff ff	 jmp	 $LN106@get_kernel
$LN144@get_kernel:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00468	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0046e	cc		 int	 3
$LN490@get_kernel:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 151  : 						if (!rva)

  0046f	49 63 c2	 movsxd	 rax, r10d

; 152  : 						{
; 153  : 							auto result = (void*)((std::uintptr_t)modules->Modules[idx].ImageBase + addr[ordinal[i]]);

  00472	0f b7 0c 46	 movzx	 ecx, WORD PTR [rsi+rax*2]
  00476	8b 1c 8f	 mov	 ebx, DWORD PTR [rdi+rcx*4]
  00479	41 8b c4	 mov	 eax, r12d
  0047c	48 69 c8 28 01
	00 00		 imul	 rcx, rax, 296		; 00000128H
  00483	4a 03 5c 39 18	 add	 rbx, QWORD PTR [rcx+r15+24]

; 154  : 							VirtualFree(buffer, NULL, MEM_RELEASE);

  00488	33 d2		 xor	 edx, edx
  0048a	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00490	49 8b cf	 mov	 rcx, r15
  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualFree

; 155  : 							return result;

  00499	eb 03		 jmp	 SHORT $LN24@get_kernel
$LN491@get_kernel:
  0049b	49 8b de	 mov	 rbx, r14
$LN24@get_kernel:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0049e	48 8b 55 df	 mov	 rdx, QWORD PTR full_path$1[rbp-97]
  004a2	48 83 fa 10	 cmp	 rdx, 16
  004a6	72 34		 jb	 SHORT $LN388@get_kernel

; 4585 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  004a8	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004ab	48 8b 4d c7	 mov	 rcx, QWORD PTR full_path$1[rbp-121]
  004af	48 8b c1	 mov	 rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  004b2	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  004b9	72 1c		 jb	 SHORT $LN398@get_kernel

; 147  :     _Bytes += _Non_user_size;

  004bb	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004bf	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  004c3	48 2b c1	 sub	 rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004c6	48 83 c0 f8	 add	 rax, -8
  004ca	48 83 f8 1f	 cmp	 rax, 31
  004ce	76 07		 jbe	 SHORT $LN398@get_kernel
$LN449@get_kernel:
  004d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  004d6	cc		 int	 3
$LN398@get_kernel:

; 255  :         ::operator delete(_Ptr, _Bytes);

  004d7	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN388@get_kernel:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4599 :             _Mypair._Myval2._Mysize = 0;

  004dc	4c 89 75 d7	 mov	 QWORD PTR full_path$1[rbp-105], r14

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  004e0	48 c7 45 df 0f
	00 00 00	 mov	 QWORD PTR full_path$1[rbp-97], 15

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  004e8	c6 45 c7 00	 mov	 BYTE PTR full_path$1[rbp-121], 0

; 2286 :         return _BUF_SIZE <= _Myres;

  004ec	48 8b 55 1f	 mov	 rdx, QWORD PTR current_module_name$3[rbp-97]
  004f0	48 83 fa 10	 cmp	 rdx, 16

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  004f4	72 34		 jb	 SHORT $LN415@get_kernel

; 4585 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4586 :             auto& _Al          = _Getal();
; 4587 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  004f6	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004f9	48 8b 4d 07	 mov	 rcx, QWORD PTR current_module_name$3[rbp-121]
  004fd	48 8b c1	 mov	 rax, rcx

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00500	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00507	72 1c		 jb	 SHORT $LN425@get_kernel

; 147  :     _Bytes += _Non_user_size;

  00509	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0050d	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00511	48 2b c1	 sub	 rax, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00514	48 83 c0 f8	 add	 rax, -8
  00518	48 83 f8 1f	 cmp	 rax, 31
  0051c	76 07		 jbe	 SHORT $LN425@get_kernel
  0051e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00524	cc		 int	 3
$LN425@get_kernel:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00525	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN415@get_kernel:
; File C:\Users\vin\Downloads\ApexIsAssWithEAC-main\ApexIsAssWithEAC-main\sinmapper\util.hpp

; 161  : 							return result;

  0052a	48 8b c3	 mov	 rax, rbx
  0052d	e9 fe fe ff ff	 jmp	 $LN1@get_kernel
$LN476@get_kernel:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00538	cc		 int	 3
$LN513@get_kernel:
?get_kernel_export@util@@YAPEAXPEBD0_N@Z ENDP		; util::get_kernel_export
_TEXT	ENDS
text$x	SEGMENT
buffer_size$ = 48
module_name$GSCopy$1$ = 56
full_path$1 = 64
$T2 = 96
current_module_name$3 = 128
__$ArrayPad$ = 160
module_name$ = 224
export_name$ = 232
rva$dead$ = 240
?dtor$0@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA PROC ; `util::get_kernel_export'::`1'::dtor$0
  00000	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR current_module_name$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA ENDP ; `util::get_kernel_export'::`1'::dtor$0
buffer_size$ = 48
module_name$GSCopy$1$ = 56
full_path$1 = 64
$T2 = 96
current_module_name$3 = 128
__$ArrayPad$ = 160
module_name$ = 224
export_name$ = 232
rva$dead$ = 240
?dtor$1@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA PROC ; `util::get_kernel_export'::`1'::dtor$1
  0000c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR full_path$1[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA ENDP ; `util::get_kernel_export'::`1'::dtor$1
buffer_size$ = 48
module_name$GSCopy$1$ = 56
full_path$1 = 64
$T2 = 96
current_module_name$3 = 128
__$ArrayPad$ = 160
module_name$ = 224
export_name$ = 232
rva$dead$ = 240
?dtor$2@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA PROC ; `util::get_kernel_export'::`1'::dtor$2
  00018	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR $T2[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA ENDP ; `util::get_kernel_export'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
buffer_size$ = 48
module_name$GSCopy$1$ = 56
full_path$1 = 64
$T2 = 96
current_module_name$3 = 128
__$ArrayPad$ = 160
module_name$ = 224
export_name$ = 232
rva$dead$ = 240
?dtor$0@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA PROC ; `util::get_kernel_export'::`1'::dtor$0
  00000	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR current_module_name$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA ENDP ; `util::get_kernel_export'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
buffer_size$ = 48
module_name$GSCopy$1$ = 56
full_path$1 = 64
$T2 = 96
current_module_name$3 = 128
__$ArrayPad$ = 160
module_name$ = 224
export_name$ = 232
rva$dead$ = 240
?dtor$1@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA PROC ; `util::get_kernel_export'::`1'::dtor$1
  0000c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR full_path$1[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA ENDP ; `util::get_kernel_export'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
buffer_size$ = 48
module_name$GSCopy$1$ = 56
full_path$1 = 64
$T2 = 96
current_module_name$3 = 128
__$ArrayPad$ = 160
module_name$ = 224
export_name$ = 232
rva$dead$ = 240
?dtor$2@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA PROC ; `util::get_kernel_export'::`1'::dtor$2
  00018	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR $T2[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??get_kernel_export@util@@YAPEAXPEBD0_N@Z@4HA ENDP ; `util::get_kernel_export'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0ImportInfo@portable_executable@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImportInfo@portable_executable@@QEAA@XZ PROC		; portable_executable::ImportInfo::ImportInfo, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	33 c0		 xor	 eax, eax

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00002	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0000a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4562 :         _My_data._Mysize = 0;

  0000d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00011	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  00015	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
  00019	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  0001d	48 8b c1	 mov	 rax, rcx
  00020	c3		 ret	 0
??0ImportInfo@portable_executable@@QEAA@XZ ENDP		; portable_executable::ImportInfo::ImportInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0ImportFunctionInfo@portable_executable@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0ImportFunctionInfo@portable_executable@@QEAA@XZ PROC	; portable_executable::ImportFunctionInfo::ImportFunctionInfo, COMDAT

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	33 c0		 xor	 eax, eax

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00002	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0000a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4562 :         _My_data._Mysize = 0;

  0000d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00011	48 8b c1	 mov	 rax, rcx
  00014	c3		 ret	 0
??0ImportFunctionInfo@portable_executable@@QEAA@XZ ENDP	; portable_executable::ImportFunctionInfo::ImportFunctionInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Unchecked_end, COMDAT

; 1522 :         return _Mypair._Myval2._Mylast;

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1523 :     }

  00004	c3		 ret	 0
?_Unchecked_end@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Unchecked_begin, COMDAT

; 1514 :         return _Mypair._Myval2._Myfirst;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1515 :     }

  00003	c3		 ret	 0
?_Unchecked_begin@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportInfo@portable_executable@@@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::push_back, COMDAT

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b c2	 mov	 r8, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 730  :         if (_Mylast != _My_data._Myend) {

  0000c	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00010	48 3b 51 10	 cmp	 rdx, QWORD PTR [rcx+16]
  00014	74 10		 je	 SHORT $LN4@push_back

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00016	e8 00 00 00 00	 call	 ??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;
; 716  :         ++_Mylast;

  0001b	48 83 43 08 38	 add	 QWORD PTR [rbx+8], 56	; 00000038H

; 743  :         emplace_back(_Val);
; 744  :     }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN4@push_back:
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002b	e9 00 00 00 00	 jmp	 ??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>
?push_back@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportInfo@portable_executable@@@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$emplace_back@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportInfo@portable_executable@@@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::emplace_back<portable_executable::ImportInfo const &>, COMDAT

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b c2	 mov	 r8, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

  0000c	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00010	48 3b 51 10	 cmp	 rdx, QWORD PTR [rcx+16]
  00014	74 17		 je	 SHORT $LN2@emplace_ba

; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00016	e8 00 00 00 00	 call	 ??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;

  0001b	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 716  :         ++_Mylast;

  0001f	48 8d 50 38	 lea	 rdx, QWORD PTR [rax+56]
  00023	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
$LN2@emplace_ba:
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5b		 pop	 rbx

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00032	e9 00 00 00 00	 jmp	 ??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>
??$emplace_back@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportInfo@portable_executable@@@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::emplace_back<portable_executable::ImportInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_back_with_unused_capacity@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportInfo@portable_executable@@@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_back_with_unused_capacity<portable_executable::ImportInfo const &>, COMDAT

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00006	4c 8b c2	 mov	 r8, rdx
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00010	e8 00 00 00 00	 call	 ??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>

; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;

  00015	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 716  :         ++_Mylast;

  00019	48 8d 50 38	 lea	 rdx, QWORD PTR [rax+56]
  0001d	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
??$_Emplace_back_with_unused_capacity@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportInfo@portable_executable@@@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_back_with_unused_capacity<portable_executable::ImportInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00003	45 33 d2	 xor	 r10d, r10d
  00006	4c 8b 4a 10	 mov	 r9, QWORD PTR [rdx+16]

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000a	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  0000e	4c 89 52 10	 mov	 QWORD PTR [rdx+16], r10
  00012	4c 89 52 08	 mov	 QWORD PTR [rdx+8], r10
  00016	4c 89 12	 mov	 QWORD PTR [rdx], r10
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00019	48 89 01	 mov	 QWORD PTR [rcx], rax

; 609  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 610  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 611  :     }

  0001c	48 8b c1	 mov	 rax, rcx

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  0001f	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  00023	4c 89 49 10	 mov	 QWORD PTR [rcx+16], r9

; 609  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 610  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 611  :     }

  00027	c3		 ret	 0
??0?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >, COMDAT

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_end@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Unchecked_end, COMDAT

; 1522 :         return _Mypair._Myval2._Mylast;

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1523 :     }

  00004	c3		 ret	 0
?_Unchecked_end@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Unchecked_begin, COMDAT

; 1514 :         return _Mypair._Myval2._Myfirst;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1515 :     }

  00003	c3		 ret	 0
?_Unchecked_begin@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAXAEBURelocInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAXAEBURelocInfo@portable_executable@@@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::push_back, COMDAT

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	4c 8b c2	 mov	 r8, rdx

; 730  :         if (_Mylast != _My_data._Myend) {

  00003	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00007	48 3b 51 10	 cmp	 rdx, QWORD PTR [rcx+16]
  0000b	74 18		 je	 SHORT $LN4@push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0000d	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00011	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00014	f2 41 0f 10 48
	10		 movsd	 xmm1, QWORD PTR [r8+16]
  0001a	f2 0f 11 4a 10	 movsd	 QWORD PTR [rdx+16], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 716  :         ++_Mylast;

  0001f	48 83 41 08 18	 add	 QWORD PTR [rcx+8], 24

; 743  :         emplace_back(_Val);
; 744  :     }

  00024	c3		 ret	 0
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00025	e9 00 00 00 00	 jmp	 ??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Emplace_reallocate<portable_executable::RelocInfo const &>
?push_back@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAXAEBURelocInfo@portable_executable@@@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBURelocInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBURelocInfo@portable_executable@@@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::emplace_back<portable_executable::RelocInfo const &>, COMDAT

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	4c 8b c2	 mov	 r8, rdx
  00003	4c 8b c9	 mov	 r9, rcx

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

  00006	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0000a	48 3b 51 10	 cmp	 rdx, QWORD PTR [rcx+16]
  0000e	74 1f		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00010	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00014	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00017	f2 41 0f 10 48
	10		 movsd	 xmm1, QWORD PTR [r8+16]
  0001d	f2 0f 11 4a 10	 movsd	 QWORD PTR [rdx+16], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 715  :         _Ty& _Result = *_Mylast;

  00022	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 716  :         ++_Mylast;

  00026	48 8d 48 18	 lea	 rcx, QWORD PTR [rax+24]
  0002a	49 89 49 08	 mov	 QWORD PTR [r9+8], rcx

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

  0002e	c3		 ret	 0
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002f	e9 00 00 00 00	 jmp	 ??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Emplace_reallocate<portable_executable::RelocInfo const &>
??$emplace_back@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBURelocInfo@portable_executable@@@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::emplace_back<portable_executable::RelocInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBURelocInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBURelocInfo@portable_executable@@@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Emplace_back_with_unused_capacity<portable_executable::RelocInfo const &>, COMDAT

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00004	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00007	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  0000a	f2 0f 10 4a 10	 movsd	 xmm1, QWORD PTR [rdx+16]
  0000f	f2 0f 11 48 10	 movsd	 QWORD PTR [rax+16], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 715  :         _Ty& _Result = *_Mylast;

  00014	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 716  :         ++_Mylast;

  00018	48 8d 50 18	 lea	 rdx, QWORD PTR [rax+24]
  0001c	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

  00020	c3		 ret	 0
??$_Emplace_back_with_unused_capacity@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBURelocInfo@portable_executable@@@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Emplace_back_with_unused_capacity<portable_executable::RelocInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00003	45 33 d2	 xor	 r10d, r10d
  00006	4c 8b 4a 10	 mov	 r9, QWORD PTR [rdx+16]

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000a	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  0000e	4c 89 52 10	 mov	 QWORD PTR [rdx+16], r10
  00012	4c 89 52 08	 mov	 QWORD PTR [rdx+8], r10
  00016	4c 89 12	 mov	 QWORD PTR [rdx], r10
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00019	48 89 01	 mov	 QWORD PTR [rcx], rax

; 609  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 610  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 611  :     }

  0001c	48 8b c1	 mov	 rax, rcx

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  0001f	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  00023	4c 89 49 10	 mov	 QWORD PTR [rcx+16], r9

; 609  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 610  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 611  :     }

  00027	c3		 ret	 0
??0?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >, COMDAT

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_end@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBAPEBUImportFunctionInfo@portable_executable@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBAPEBUImportFunctionInfo@portable_executable@@XZ PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Unchecked_end, COMDAT

; 1526 :         return _Mypair._Myval2._Mylast;

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1527 :     }

  00004	c3		 ret	 0
?_Unchecked_end@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBAPEBUImportFunctionInfo@portable_executable@@XZ ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBAPEBUImportFunctionInfo@portable_executable@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBAPEBUImportFunctionInfo@portable_executable@@XZ PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Unchecked_begin, COMDAT

; 1518 :         return _Mypair._Myval2._Myfirst;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1519 :     }

  00003	c3		 ret	 0
?_Unchecked_begin@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBAPEBUImportFunctionInfo@portable_executable@@XZ ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportFunctionInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportFunctionInfo@portable_executable@@@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::push_back, COMDAT

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 730  :         if (_Mylast != _My_data._Myend) {

  0000f	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]

; 742  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00013	48 8b f2	 mov	 rsi, rdx
  00016	48 8b d9	 mov	 rbx, rcx

; 730  :         if (_Mylast != _My_data._Myend) {

  00019	48 3b 79 10	 cmp	 rdi, QWORD PTR [rcx+16]
  0001d	74 25		 je	 SHORT $LN4@push_back
  0001f	48 8b cf	 mov	 rcx, rdi
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  0002b	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 716  :         ++_Mylast;

  0002f	48 83 43 08 28	 add	 QWORD PTR [rbx+8], 40	; 00000028H

; 743  :         emplace_back(_Val);
; 744  :     }

  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
$LN4@push_back:

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00044	4c 8b c6	 mov	 r8, rsi
  00047	48 8b d7	 mov	 rdx, rdi

; 743  :         emplace_back(_Val);
; 744  :     }

  0004a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi

; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00059	e9 00 00 00 00	 jmp	 ??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>
?push_back@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEBUImportFunctionInfo@portable_executable@@@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$emplace_back@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::emplace_back<portable_executable::ImportFunctionInfo const &>, COMDAT

; 726  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 727  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 728  :         auto& _My_data   = _Mypair._Myval2;
; 729  :         pointer& _Mylast = _My_data._Mylast;
; 730  :         if (_Mylast != _My_data._Myend) {

  0000f	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00013	48 8b f2	 mov	 rsi, rdx
  00016	48 8b d9	 mov	 rbx, rcx
  00019	48 3b 79 10	 cmp	 rdi, QWORD PTR [rcx+16]
  0001d	74 2c		 je	 SHORT $LN2@emplace_ba
  0001f	48 8b cf	 mov	 rcx, rdi
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  0002b	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 715  :         _Ty& _Result = *_Mylast;

  0002f	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 716  :         ++_Mylast;

  00033	48 8d 48 28	 lea	 rcx, QWORD PTR [rax+40]
  00037	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
$LN2@emplace_ba:

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0004b	4c 8b c6	 mov	 r8, rsi
  0004e	48 8b d7	 mov	 rdx, rdi

; 735  : #if _HAS_CXX17
; 736  :         return _Result;
; 737  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 738  :         (void) _Result;
; 739  : #endif // _HAS_CXX17
; 740  :     }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi

; 731  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 732  :         }
; 733  : 
; 734  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00060	e9 00 00 00 00	 jmp	 ??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>
??$emplace_back@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::emplace_back<portable_executable::ImportFunctionInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 48
<_Val_0>$ = 56
??$_Emplace_back_with_unused_capacity@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_back_with_unused_capacity<portable_executable::ImportFunctionInfo const &>, COMDAT

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0000f	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 708  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00013	48 8b f1	 mov	 rsi, rcx
  00016	48 8b cb	 mov	 rcx, rbx
  00019	48 8b fa	 mov	 rdi, rdx
  0001c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00021	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00025	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 709  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 710  :         auto& _My_data   = _Mypair._Myval2;
; 711  :         pointer& _Mylast = _My_data._Mylast;
; 712  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 713  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 714  :         _Orphan_range(_Mylast, _Mylast);
; 715  :         _Ty& _Result = *_Mylast;

  00029	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]

; 716  :         ++_Mylast;
; 717  : #if _HAS_CXX17
; 718  :         return _Result;
; 719  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 720  :         (void) _Result;
; 721  : #endif // _HAS_CXX17
; 722  :     }

  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 8d 50 28	 lea	 rdx, QWORD PTR [rax+40]
  00036	48 89 56 08	 mov	 QWORD PTR [rsi+8], rdx
  0003a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
??$_Emplace_back_with_unused_capacity@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAA?A_TAEBUImportFunctionInfo@portable_executable@@@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_back_with_unused_capacity<portable_executable::ImportFunctionInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >, COMDAT

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 464  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 465  :     }

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$dead$ = 56
_Off$dead$ = 64
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 4110 :         _In_z_ const _Elem* const _Ptr, const size_type _Off = 0) const noexcept /* strengthened */ {

$LN35:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00010	48 8b f1	 mov	 rsi, rcx

; 401  :             return __builtin_strlen(_First);

  00013	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:??_C@_0N@BDPNIACE@?2SystemRoot?2@
  0001a	48 c7 c3 ff ff
	ff ff		 mov	 rbx, -1
$LL30@find:
  00021	48 ff c3	 inc	 rbx
  00024	41 80 3c 1e 00	 cmp	 BYTE PTR [r14+rbx], 0
  00029	75 f6		 jne	 SHORT $LL30@find

; 2286 :         return _BUF_SIZE <= _Myres;

  0002b	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 4111 :         // look for [_Ptr, <null>) beginning at or after _Off
; 4112 :         return static_cast<size_type>(_Traits_find<_Traits>(

  00030	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 2273 :         if (_Large_string_engaged()) {

  00034	72 03		 jb	 SHORT $LN6@find

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  00036	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN6@find:

; 600  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00039	48 3b d8	 cmp	 rbx, rax
  0003c	0f 87 a9 00 00
	00		 ja	 $LN15@find

; 601  :         // xpos cannot exist, report failure
; 602  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 603  :         // 1. _Start_at <= xpos
; 604  :         // 2. xpos + _Needle_size <= _Hay_size;
; 605  :         // therefore:
; 606  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 607  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 608  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 609  :         return static_cast<size_t>(-1);
; 610  :     }
; 611  : 
; 612  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  00042	48 85 db	 test	 rbx, rbx
  00045	75 13		 jne	 SHORT $LN16@find

; 4111 :         // look for [_Ptr, <null>) beginning at or after _Off
; 4112 :         return static_cast<size_type>(_Traits_find<_Traits>(

  00047	33 c0		 xor	 eax, eax

; 4113 :             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
; 4114 :     }

  00049	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	41 5e		 pop	 r14
  00059	c3		 ret	 0
$LN16@find:

; 616  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0005a	48 2b c3	 sub	 rax, rbx
  0005d	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 422  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00062	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00067	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0006c	48 8b ce	 mov	 rcx, rsi

; 616  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0006f	48 8d 2c 30	 lea	 rbp, QWORD PTR [rax+rsi]

; 617  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 618  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  00073	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  00077	4c 2b c6	 sub	 r8, rsi

; 422  :             return __builtin_char_memchr(_First, _Ch, _Count);

  0007a	e8 00 00 00 00	 call	 memchr
  0007f	48 8b f8	 mov	 rdi, rax

; 619  :         if (!_Match_try) { // didn't find first character; report failure

  00082	48 85 c0	 test	 rax, rax
  00085	74 3a		 je	 SHORT $LN25@find
  00087	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL13@find:

; 382  :         return __builtin_memcmp(_First1, _First2, _Count);

  00090	4c 8b c3	 mov	 r8, rbx
  00093	49 8b d6	 mov	 rdx, r14
  00096	48 8b cf	 mov	 rcx, rdi
  00099	e8 00 00 00 00	 call	 memcmp

; 623  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  0009e	85 c0		 test	 eax, eax
  000a0	74 41		 je	 SHORT $LN26@find

; 617  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 618  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  000a2	48 ff c7	 inc	 rdi
  000a5	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  000a9	4c 2b c7	 sub	 r8, rdi

; 422  :             return __builtin_char_memchr(_First, _Ch, _Count);

  000ac	48 8b cf	 mov	 rcx, rdi
  000af	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  000b4	e8 00 00 00 00	 call	 memchr
  000b9	48 8b f8	 mov	 rdi, rax

; 619  :         if (!_Match_try) { // didn't find first character; report failure

  000bc	48 85 c0	 test	 rax, rax
  000bf	75 cf		 jne	 SHORT $LL13@find
$LN25@find:

; 4111 :         // look for [_Ptr, <null>) beginning at or after _Off
; 4112 :         return static_cast<size_type>(_Traits_find<_Traits>(

  000c1	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN32@find:
  000c8	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000cd	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 4113 :             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
; 4114 :     }

  000d2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000dc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e0	41 5e		 pop	 r14
  000e2	c3		 ret	 0
$LN26@find:

; 624  :             return static_cast<size_t>(_Match_try - _Haystack);

  000e3	48 2b fe	 sub	 rdi, rsi

; 4111 :         // look for [_Ptr, <null>) beginning at or after _Off
; 4112 :         return static_cast<size_type>(_Traits_find<_Traits>(

  000e6	48 8b c7	 mov	 rax, rdi

; 624  :             return static_cast<size_t>(_Match_try - _Haystack);

  000e9	eb dd		 jmp	 SHORT $LN32@find
$LN15@find:

; 4113 :             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
; 4114 :     }

  000eb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f0	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000f7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000fc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00100	41 5e		 pop	 r14
  00102	c3		 ret	 0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0AEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Off$ = 72
_Nx$dead$ = 80
_Right$ = 88
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT

; 3469 :         const size_type _Off, const size_type _Nx, const basic_string& _Right) {

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2286 :         return _BUF_SIZE <= _Myres;

  00004	49 83 79 18 10	 cmp	 QWORD PTR [r9+24], 16

; 3470 :         // replace [_Off, _Off + _Nx) with _Right
; 3471 :         return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00009	49 8b 41 10	 mov	 rax, QWORD PTR [r9+16]

; 2273 :         if (_Large_string_engaged()) {

  0000d	72 03		 jb	 SHORT $LN4@replace

; 2274 :             _Result = _Unfancy(_Bx._Ptr);

  0000f	4d 8b 09	 mov	 r9, QWORD PTR [r9]
$LN4@replace:

; 3470 :         // replace [_Off, _Off + _Nx) with _Right
; 3471 :         return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00012	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00017	e8 00 00 00 00	 call	 ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 3472 :     }

  0001c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00020	c3		 ret	 0
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 401  :             return __builtin_strlen(_First);

  00000	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  00007	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@operator:
  00010	49 ff c0	 inc	 r8
  00013	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  00018	75 f6		 jne	 SHORT $LL7@operator

; 3230 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001a	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2815 :         noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{}))) {

$LN48:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 2816 :         if (this != _STD addressof(_Right)) {

  00010	48 3b ca	 cmp	 rcx, rdx
  00013	74 62		 je	 SHORT $LN43@operator

; 2286 :         return _BUF_SIZE <= _Myres;

  00015	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  00019	48 83 fa 10	 cmp	 rdx, 16

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  0001d	72 2c		 jb	 SHORT $LN15@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  00022	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00025	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0002c	72 18		 jb	 SHORT $LN25@operator

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002e	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00032	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00036	49 2b c8	 sub	 rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00039	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0003d	48 83 f8 1f	 cmp	 rax, 31
  00041	77 42		 ja	 SHORT $LN22@operator

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00043	49 8b c8	 mov	 rcx, r8
$LN25@operator:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00046	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN15@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0004b	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
  00053	33 c0		 xor	 eax, eax
  00055	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00059	88 03		 mov	 BYTE PTR [rbx], al

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0005b	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
  0005e	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00061	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  00065	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 4562 :         _My_data._Mysize = 0;

  00069	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  0006d	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00075	88 07		 mov	 BYTE PTR [rdi], al
$LN43@operator:

; 2817 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});
; 2818 :         }
; 2819 : 
; 2820 :         return *this;

  00077	48 8b c3	 mov	 rax, rbx

; 2821 :     }

  0007a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
$LN22@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0008b	cc		 int	 3
$LN45@operator:
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBAXPEAUImportInfo@portable_executable@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBAXPEAUImportInfo@portable_executable@@0@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Orphan_range, COMDAT

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

  00000	c2 00 00	 ret	 0
?_Orphan_range@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBAXPEAUImportInfo@portable_executable@@0@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBAXPEAURelocInfo@portable_executable@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBAXPEAURelocInfo@portable_executable@@0@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Orphan_range, COMDAT

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

  00000	c2 00 00	 ret	 0
?_Orphan_range@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBAXPEAURelocInfo@portable_executable@@0@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBAXPEAUImportFunctionInfo@portable_executable@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBAXPEAUImportFunctionInfo@portable_executable@@0@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Orphan_range, COMDAT

; 1801 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}

  00000	c2 00 00	 ret	 0
?_Orphan_range@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBAXPEAUImportFunctionInfo@portable_executable@@0@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z
_TEXT	SEGMENT
this$ = 112
_Off$ = 120
_Nx$dead$ = 128
_Ptr$ = 136
_Count$ = 144
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT

; 3501 :         const size_type _Off, size_type _Nx, _In_reads_(_Count) const _Elem* const _Ptr, const size_type _Count) {

$LN55:
  00000	40 57		 push	 rdi
  00002	41 56		 push	 r14
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00008	48 8b f9	 mov	 rdi, rcx
  0000b	4d 8b f1	 mov	 r14, r9

; 2291 :         if (_Mysize < _Off) {

  0000e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00012	48 3b ca	 cmp	 rcx, rdx
  00015	0f 82 87 01 00
	00		 jb	 $LN53@replace
  0001b	48 89 6c 24 78	 mov	 QWORD PTR [rsp+120], rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00020	bd 0c 00 00 00	 mov	 ebp, 12
  00025	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3505 :         if (_Nx == _Count) { // size doesn't change, so a single move does the trick

  0002d	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR _Count$[rsp]
  00035	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15

; 2309 :         return (_STD min)(_Size, _Mysize - _Off);

  0003a	4c 8b f9	 mov	 r15, rcx
  0003d	4c 2b fa	 sub	 r15, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 66   :     return _Right < _Left ? _Right : _Left;

  00040	4c 3b fd	 cmp	 r15, rbp
  00043	49 0f 42 ef	 cmovb	 rbp, r15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 3505 :         if (_Nx == _Count) { // size doesn't change, so a single move does the trick

  00047	48 3b ee	 cmp	 rbp, rsi
  0004a	75 24		 jne	 SHORT $LN2@replace

; 2286 :         return _BUF_SIZE <= _Myres;

  0004c	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 2263 :         value_type* _Result = _Bx._Buf;

  00051	48 8b c7	 mov	 rax, rdi

; 2264 :         if (_Large_string_engaged()) {

  00054	72 03		 jb	 SHORT $LN20@replace

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

  00056	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN20@replace:

; 3506 :             _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);

  00059	48 8d 0c 10	 lea	 rcx, QWORD PTR [rax+rdx]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0005d	4c 8b c6	 mov	 r8, rsi
  00060	49 8b d6	 mov	 rdx, r14
  00063	e8 00 00 00 00	 call	 memmove

; 3507 :             return *this;

  00068	48 8b c7	 mov	 rax, rdi
  0006b	e9 18 01 00 00	 jmp	 $LN48@replace
$LN2@replace:

; 3508 :         }
; 3509 : 
; 3510 :         const size_type _Old_size    = _Mypair._Myval2._Mysize;
; 3511 :         const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;

  00070	4c 2b fd	 sub	 r15, rbp
  00073	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx

; 3512 :         if (_Count < _Nx) { // suffix shifts backwards; we don't have to move anything out of the way

  00078	48 3b f5	 cmp	 rsi, rbp
  0007b	73 42		 jae	 SHORT $LN3@replace

; 3513 :             _Mypair._Myval2._Mysize = _Old_size - (_Nx - _Count);

  0007d	48 2b cd	 sub	 rcx, rbp

; 2263 :         value_type* _Result = _Bx._Buf;

  00080	48 8b c7	 mov	 rax, rdi

; 3513 :             _Mypair._Myval2._Mysize = _Old_size - (_Nx - _Count);

  00083	48 03 ce	 add	 rcx, rsi
  00086	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx

; 2286 :         return _BUF_SIZE <= _Myres;

  0008a	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 2264 :         if (_Large_string_engaged()) {

  0008f	72 03		 jb	 SHORT $LN27@replace

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

  00091	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN27@replace:

; 3514 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3515 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  00094	48 8d 1c 10	 lea	 rbx, QWORD PTR [rax+rdx]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00098	4c 8b c6	 mov	 r8, rsi
  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	49 8b d6	 mov	 rdx, r14
  000a1	e8 00 00 00 00	 call	 memmove

; 3516 :             _Traits::move(_Insert_at, _Ptr, _Count);
; 3517 :             _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Suffix_size);

  000a6	48 8d 14 2b	 lea	 rdx, QWORD PTR [rbx+rbp]
  000aa	48 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+rsi]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000ae	4d 8d 47 01	 lea	 r8, QWORD PTR [r15+1]
  000b2	e8 00 00 00 00	 call	 memmove

; 3518 :             return *this;

  000b7	48 8b c7	 mov	 rax, rdi
  000ba	e9 c4 00 00 00	 jmp	 $LN49@replace
$LN3@replace:

; 3519 :         }
; 3520 : 
; 3521 :         const size_type _Growth = static_cast<size_type>(_Count - _Nx);
; 3522 : 
; 3523 :         // checking for overlapping ranges is technically UB (considering string literals), so just always reallocate
; 3524 :         // and copy to the new buffer if constant evaluated
; 3525 : #ifdef __cpp_lib_constexpr_string
; 3526 :         if (!_STD is_constant_evaluated())
; 3527 : #endif // __cpp_lib_constexpr_string
; 3528 :         {
; 3529 :             if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { // growth fits

  000bf	4c 8b 4f 18	 mov	 r9, QWORD PTR [rdi+24]
  000c3	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  000c8	49 8b c1	 mov	 rax, r9
  000cb	4c 8b e6	 mov	 r12, rsi
  000ce	48 2b c1	 sub	 rax, rcx
  000d1	4c 2b e5	 sub	 r12, rbp
  000d4	4c 3b e0	 cmp	 r12, rax
  000d7	0f 87 84 00 00
	00		 ja	 $LN4@replace

; 3530 :                 _Mypair._Myval2._Mysize = _Old_size + _Growth;

  000dd	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  000e2	49 8d 04 0c	 lea	 rax, QWORD PTR [r12+rcx]
  000e6	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 2263 :         value_type* _Result = _Bx._Buf;

  000ea	4c 8b c7	 mov	 r8, rdi

; 2286 :         return _BUF_SIZE <= _Myres;

  000ed	49 83 f9 10	 cmp	 r9, 16

; 2264 :         if (_Large_string_engaged()) {

  000f1	72 03		 jb	 SHORT $LN36@replace

; 2265 :             _Result = _Unfancy(_Bx._Ptr);

  000f3	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
$LN36@replace:

; 3531 :                 _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3532 :                 _Elem* const _Insert_at = _Old_ptr + _Off;

  000f6	4d 8d 2c 10	 lea	 r13, QWORD PTR [r8+rdx]

; 3533 :                 _Elem* const _Suffix_at = _Insert_at + _Nx;

  000fa	48 8b d5	 mov	 rdx, rbp
  000fd	49 03 d5	 add	 rdx, r13

; 3534 : 
; 3535 :                 size_type _Ptr_shifted_after; // see rationale in insert
; 3536 :                 if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {

  00100	49 8d 04 36	 lea	 rax, QWORD PTR [r14+rsi]
  00104	49 3b c5	 cmp	 rax, r13
  00107	76 1a		 jbe	 SHORT $LN7@replace
  00109	49 8d 04 08	 lea	 rax, QWORD PTR [r8+rcx]
  0010d	4c 3b f0	 cmp	 r14, rax
  00110	77 11		 ja	 SHORT $LN7@replace

; 3538 :                 } else if (_Suffix_at <= _Ptr) {

  00112	49 3b d6	 cmp	 rdx, r14
  00115	77 04		 ja	 SHORT $LN8@replace

; 3539 :                     _Ptr_shifted_after = 0;

  00117	33 db		 xor	 ebx, ebx

; 3540 :                 } else {

  00119	eb 0b		 jmp	 SHORT $LN9@replace
$LN8@replace:

; 3541 :                     _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);

  0011b	48 8b da	 mov	 rbx, rdx
  0011e	49 2b de	 sub	 rbx, r14
  00121	eb 03		 jmp	 SHORT $LN9@replace
$LN7@replace:

; 3537 :                     _Ptr_shifted_after = _Count;

  00123	48 8b de	 mov	 rbx, rsi
$LN9@replace:

; 3542 :                 }
; 3543 : 
; 3544 :                 _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);

  00126	4a 8d 0c 22	 lea	 rcx, QWORD PTR [rdx+r12]

; 121  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0012a	4d 8d 47 01	 lea	 r8, QWORD PTR [r15+1]
  0012e	e8 00 00 00 00	 call	 memmove
  00133	4c 8b c3	 mov	 r8, rbx
  00136	49 8b d6	 mov	 rdx, r14
  00139	49 8b cd	 mov	 rcx, r13
  0013c	e8 00 00 00 00	 call	 memmove

; 3545 :                 // next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
; 3546 :                 // this case doesn't occur in insert because the new content must come from outside the removed
; 3547 :                 // content there (because in insert there is no removed content)
; 3548 :                 _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3549 :                 // the next case can be copy, because it comes from the chunk moved out of the way in the
; 3550 :                 // first move, and the hole we're filling can't alias the chunk we moved out of the way
; 3551 :                 _Traits::copy(

  00141	48 2b f3	 sub	 rsi, rbx
  00144	4a 8d 14 23	 lea	 rdx, QWORD PTR [rbx+r12]
  00148	49 03 d6	 add	 rdx, r14
  0014b	4a 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+r13]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0014f	4c 8b c6	 mov	 r8, rsi
  00152	e8 00 00 00 00	 call	 memcpy

; 3552 :                     _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3553 :                 return *this;

  00157	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]
  0015c	48 8b c7	 mov	 rax, rdi
  0015f	eb 1d		 jmp	 SHORT $LN50@replace
$LN4@replace:

; 3554 :             }
; 3555 :         }
; 3556 : 
; 3557 :         return _Reallocate_grow_by(

  00161	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00166	4c 8b ca	 mov	 r9, rdx
  00169	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  0016e	49 8b d4	 mov	 rdx, r12
  00171	48 8b cf	 mov	 rcx, rdi
  00174	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00179	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_55b0f89b53a0342680e40398a0d39887>,unsigned __int64,unsigned __int64,char const *,unsigned __int64>
$LN50@replace:
  0017e	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
$LN49@replace:
  00183	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
$LN48@replace:
  00188	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  0018d	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  00195	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]

; 3558 :             _Growth,
; 3559 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3560 :                 const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) {
; 3561 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3562 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3563 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
; 3564 :             },
; 3565 :             _Off, _Nx, _Ptr, _Count);
; 3566 :     }

  0019a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0019e	41 5e		 pop	 r14
  001a0	5f		 pop	 rdi
  001a1	c3		 ret	 0
$LN53@replace:

; 2292 :             _Xran();

  001a2	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  001a7	cc		 int	 3
$LN51@replace:
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_KQEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Off$ = 80
_Nx$ = 88
_Ptr$ = 96
_Count$ = 104
??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z PROC ; <lambda_55b0f89b53a0342680e40398a0d39887>::operator(), COMDAT

; 3560 :                 const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0001a	48 8b 74 24 50	 mov	 rsi, QWORD PTR _Off$[rsp]

; 3560 :                 const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) {

  0001f	4d 8b f0	 mov	 r14, r8
  00022	48 8b da	 mov	 rbx, rdx

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00025	4c 8b c6	 mov	 r8, rsi
  00028	49 8b d6	 mov	 rdx, r14
  0002b	48 8b cb	 mov	 rcx, rbx

; 3560 :                 const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) {

  0002e	49 8b e9	 mov	 rbp, r9

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00031	e8 00 00 00 00	 call	 memcpy
  00036	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Ptr$[rsp]

; 3561 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3562 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);

  0003b	48 8d 3c 33	 lea	 rdi, QWORD PTR [rbx+rsi]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003f	48 8b 5c 24 68	 mov	 rbx, QWORD PTR _Count$[rsp]
  00044	48 8b cf	 mov	 rcx, rdi
  00047	4c 8b c3	 mov	 r8, rbx
  0004a	e8 00 00 00 00	 call	 memcpy

; 3563 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);

  0004f	48 2b ee	 sub	 rbp, rsi
  00052	49 8d 14 36	 lea	 rdx, QWORD PTR [r14+rsi]
  00056	48 2b 6c 24 58	 sub	 rbp, QWORD PTR _Nx$[rsp]
  0005b	48 8d 0c 1f	 lea	 rcx, QWORD PTR [rdi+rbx]
  0005f	48 03 54 24 58	 add	 rdx, QWORD PTR _Nx$[rsp]
  00064	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]

; 3564 :             },

  00068	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00072	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00077	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	41 5e		 pop	 r14

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00082	e9 00 00 00 00	 jmp	 memcpy
??R<lambda_55b0f89b53a0342680e40398a0d39887>@@QEBA@QEADQEBD_K2212@Z ENDP ; <lambda_55b0f89b53a0342680e40398a0d39887>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
__formal$dead$ = 64
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign, COMDAT

; 2741 :     _CONSTEXPR20_CONTAINER void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {

$LN44:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 2286 :         return _BUF_SIZE <= _Myres;

  00010	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  00014	48 83 fa 10	 cmp	 rdx, 16

; 4584 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00018	72 2c		 jb	 SHORT $LN12@Move_assig
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4588 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001d	48 ff c2	 inc	 rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00020	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00027	72 18		 jb	 SHORT $LN22@Move_assig

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00029	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  0002d	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	49 2b c8	 sub	 rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00034	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00038	48 83 f8 1f	 cmp	 rax, 31
  0003c	77 3f		 ja	 SHORT $LN19@Move_assig

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003e	49 8b c8	 mov	 rcx, r8
$LN22@Move_assig:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00041	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN12@Move_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4600 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00046	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
  0004e	33 c0		 xor	 eax, eax
  00050	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 4601 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4602 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00054	88 03		 mov	 BYTE PTR [rbx], al

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00056	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
  00059	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  0005c	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  00060	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 2745 :     }

  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4562 :         _My_data._Mysize = 0;

  00069	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  0006d	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00075	88 07		 mov	 BYTE PTR [rdi], al

; 2745 :     }

  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN19@Move_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00083	cc		 int	 3
$LN41@Move_assig:
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U_Equal_allocators@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AEBUImportInfo@portable_executable@@@std@@YAAEBUImportInfo@portable_executable@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUImportInfo@portable_executable@@@std@@YAAEBUImportInfo@portable_executable@@AEBU12@@Z PROC ; std::forward<portable_executable::ImportInfo const &>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@AEBUImportInfo@portable_executable@@@std@@YAAEBUImportInfo@portable_executable@@AEBU12@@Z ENDP ; std::forward<portable_executable::ImportInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z
_TEXT	SEGMENT
_Backout$1 = 32
__formal$dead$ = 96
$T2 = 96
_Guard$3 = 104
_Ptr$ = 104
<_Args_0>$ = 112
??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>, COMDAT

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN102:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00012	49 8b f8	 mov	 rdi, r8
  00015	48 8b da	 mov	 rbx, rdx
  00018	48 89 54 24 60	 mov	 QWORD PTR $T2[rsp], rdx
  0001d	49 8b d0	 mov	 rdx, r8
  00020	48 8b cb	 mov	 rcx, rbx
  00023	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00028	90		 npad	 1
  00029	4c 8d 73 20	 lea	 r14, QWORD PTR [rbx+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002d	33 c0		 xor	 eax, eax
  0002f	49 89 06	 mov	 QWORD PTR [r14], rax
  00032	49 89 46 08	 mov	 QWORD PTR [r14+8], rax
  00036	49 89 46 10	 mov	 QWORD PTR [r14+16], rax

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0003a	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

  0003e	48 8b 77 28	 mov	 rsi, QWORD PTR [rdi+40]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

  00042	48 3b de	 cmp	 rbx, rsi
  00045	74 73		 je	 SHORT $LN99@construct

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00047	48 8b fe	 mov	 rdi, rsi
  0004a	48 2b fb	 sub	 rdi, rbx
  0004d	48 c1 ff 03	 sar	 rdi, 3
  00051	48 b8 cd cc cc
	cc cc cc cc cc	 mov	 rax, -3689348814741910323 ; cccccccccccccccdH
  0005b	48 0f af f8	 imul	 rdi, rax

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  0005f	48 8b d7	 mov	 rdx, rdi
  00062	e8 00 00 00 00	 call	 ?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportFunctionInfo>::allocate

; 1699 :         _Myfirst           = _Newvec;

  00067	49 89 06	 mov	 QWORD PTR [r14], rax

; 1700 :         _Mylast            = _Newvec;

  0006a	49 89 46 08	 mov	 QWORD PTR [r14+8], rax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

  0006e	48 8d 0c bf	 lea	 rcx, QWORD PTR [rdi+rdi*4]
  00072	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00076	49 89 46 10	 mov	 QWORD PTR [r14+16], rax

; 551  :             _Tidy_guard<vector> _Guard{this};

  0007a	4c 89 74 24 68	 mov	 QWORD PTR _Guard$3[rsp], r14

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  0007f	49 8b 3e	 mov	 rdi, QWORD PTR [r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00082	48 89 7c 24 20	 mov	 QWORD PTR _Backout$1[rsp], rdi
  00087	48 89 7c 24 28	 mov	 QWORD PTR _Backout$1[rsp+8], rdi
  0008c	4c 89 74 24 30	 mov	 QWORD PTR _Backout$1[rsp+16], r14
$LL22@construct:
  00091	48 8b d3	 mov	 rdx, rbx
  00094	48 8b cf	 mov	 rcx, rdi
  00097	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0009c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000a0	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1621 :         ++_Last;

  000a4	48 83 c7 28	 add	 rdi, 40			; 00000028H
  000a8	48 89 7c 24 28	 mov	 QWORD PTR _Backout$1[rsp+8], rdi

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

  000ad	48 83 c3 28	 add	 rbx, 40			; 00000028H
  000b1	48 3b de	 cmp	 rbx, rsi
  000b4	75 db		 jne	 SHORT $LL22@construct
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000b6	49 89 7e 08	 mov	 QWORD PTR [r14+8], rdi
$LN99@construct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 683  :     }

  000ba	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000bf	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c3	41 5e		 pop	 r14
  000c5	5f		 pop	 rdi
  000c6	5e		 pop	 rsi
  000c7	c3		 ret	 0
??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
__formal$dead$ = 96
$T2 = 96
_Guard$3 = 104
_Ptr$ = 104
<_Args_0>$ = 112
?dtor$0@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$0
  00000	48 8b 8a 60 00
	00 00		 mov	 rcx, QWORD PTR $T2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
__formal$dead$ = 96
$T2 = 96
_Guard$3 = 104
_Ptr$ = 104
<_Args_0>$ = 112
?dtor$2@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$2
  00000	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR _Guard$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
?dtor$2@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
__formal$dead$ = 96
$T2 = 96
_Guard$3 = 104
_Ptr$ = 104
<_Args_0>$ = 112
?dtor$3@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$3
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$3@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
__formal$dead$ = 96
$T2 = 96
_Guard$3 = 104
_Ptr$ = 104
<_Args_0>$ = 112
?dtor$0@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$0
  00000	48 8b 8a 60 00
	00 00		 mov	 rcx, QWORD PTR $T2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
__formal$dead$ = 96
$T2 = 96
_Guard$3 = 104
_Ptr$ = 104
<_Args_0>$ = 112
?dtor$2@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$2
  00000	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR _Guard$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
?dtor$2@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
__formal$dead$ = 96
$T2 = 96
_Guard$3 = 104
_Ptr$ = 104
<_Args_0>$ = 112
?dtor$3@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA PROC ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$3
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$3@?0???$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z@4HA ENDP ; `std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z
_TEXT	SEGMENT
_Newsize$1$ = 32
_Constructed_last$ = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
$T1 = 136
??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>, COMDAT

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN98:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	4d 8b d8	 mov	 r11, r8
  00017	4c 8b e2	 mov	 r12, rdx
  0001a	48 8b f1	 mov	 rsi, rcx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0001d	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  00020	4c 8b ca	 mov	 r9, rdx
  00023	4d 2b ca	 sub	 r9, r10
  00026	48 b8 25 49 92
	24 49 92 24 49	 mov	 rax, 5270498306774157605 ; 4924924924924925H
  00030	49 f7 e9	 imul	 r9
  00033	4c 8b f2	 mov	 r14, rdx
  00036	49 c1 fe 04	 sar	 r14, 4
  0003a	49 8b c6	 mov	 rax, r14
  0003d	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00041	4c 03 f0	 add	 r14, rax

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00044	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00048	49 2b c2	 sub	 rax, r10
  0004b	48 c1 f8 03	 sar	 rax, 3
  0004f	48 ba b7 6d db
	b6 6d db b6 6d	 mov	 rdx, 7905747460161236407 ; 6db6db6db6db6db7H
  00059	48 0f af c2	 imul	 rax, rdx

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

  0005d	49 b9 92 24 49
	92 24 49 92 04	 mov	 r9, 329406144173384850	; 0492492492492492H
  00067	49 3b c1	 cmp	 rax, r9
  0006a	0f 84 a4 01 00
	00		 je	 $LN97@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

  00070	4c 8d 40 01	 lea	 r8, QWORD PTR [rax+1]
  00074	4c 89 44 24 20	 mov	 QWORD PTR _Newsize$1$[rsp], r8

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00079	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0007d	49 2b ca	 sub	 rcx, r10
  00080	48 c1 f9 03	 sar	 rcx, 3
  00084	48 0f af ca	 imul	 rcx, rdx

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00088	48 8b d1	 mov	 rdx, rcx
  0008b	48 d1 ea	 shr	 rdx, 1
  0008e	49 8b c1	 mov	 rax, r9
  00091	48 2b c2	 sub	 rax, rdx
  00094	48 3b c8	 cmp	 rcx, rax
  00097	0f 87 71 01 00
	00		 ja	 $LN91@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow
; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0009d	48 8d 04 0a	 lea	 rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  000a1	49 8b d8	 mov	 rbx, r8
  000a4	49 3b c0	 cmp	 rax, r8
  000a7	48 0f 43 d8	 cmovae	 rbx, rax
  000ab	49 3b d9	 cmp	 rbx, r9
  000ae	0f 87 5a 01 00
	00		 ja	 $LN91@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000b4	4c 6b fb 38	 imul	 r15, rbx, 56		; 00000038H
  000b8	48 89 5c 24 78	 mov	 QWORD PTR _Newcapacity$[rsp], rbx

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000bd	49 81 ff 00 10
	00 00		 cmp	 r15, 4096		; 00001000H
  000c4	72 31		 jb	 SHORT $LN24@Emplace_re

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000c6	49 8d 4f 27	 lea	 rcx, QWORD PTR [r15+39]

; 130  :     if (_Block_size <= _Bytes) {

  000ca	49 3b cf	 cmp	 rcx, r15
  000cd	0f 86 3b 01 00
	00		 jbe	 $LN91@Emplace_re

; 79   :         return ::operator new(_Bytes);

  000d3	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000d8	48 85 c0	 test	 rax, rax
  000db	0f 84 26 01 00
	00		 je	 $LN78@Emplace_re

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000e1	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000e5	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000e9	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000ed	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR <_Val_0>$[rsp]
  000f5	eb 21		 jmp	 SHORT $LN93@Emplace_re
$LN24@Emplace_re:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  000f7	4d 85 ff	 test	 r15, r15
  000fa	74 15		 je	 SHORT $LN25@Emplace_re

; 79   :         return ::operator new(_Bytes);

  000fc	49 8b cf	 mov	 rcx, r15
  000ff	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00104	48 8b f8	 mov	 rdi, rax

; 235  :         return _Traits::_Allocate(_Bytes);

  00107	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR <_Val_0>$[rsp]
  0010f	eb 02		 jmp	 SHORT $LN94@Emplace_re
$LN25@Emplace_re:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  00111	33 ff		 xor	 edi, edi
$LN94@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	48 89 5c 24 78	 mov	 QWORD PTR _Newcapacity$[rsp], rbx
$LN93@Emplace_re:
  00118	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR $T1[rsp], rdi
  00120	4d 6b ee 38	 imul	 r13, r14, 56		; 00000038H
  00124	4c 03 ef	 add	 r13, rdi
  00127	49 8d 5d 38	 lea	 rbx, QWORD PTR [r13+56]
  0012b	48 89 5c 24 28	 mov	 QWORD PTR _Constructed_last$[rsp], rbx

; 773  :         pointer _Constructed_first      = _Constructed_last;

  00130	48 89 5c 24 70	 mov	 QWORD PTR _Constructed_first$[rsp], rbx

; 774  : 
; 775  :         _TRY_BEGIN
; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00135	4d 8b c3	 mov	 r8, r11
  00138	49 8b d5	 mov	 rdx, r13
  0013b	e8 00 00 00 00	 call	 ??$construct@UImportInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@AEBU34@@Z ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo const &>

; 777  :         _Constructed_first = _Newvec + _Whereoff;

  00140	4c 89 6c 24 70	 mov	 QWORD PTR _Constructed_first$[rsp], r13

; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00145	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  00149	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0014c	4c 8b c7	 mov	 r8, rdi
  0014f	4c 3b e2	 cmp	 r12, rdx
  00152	74 17		 je	 SHORT $LN95@Emplace_re

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00154	49 8b d4	 mov	 rdx, r12
  00157	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportInfo *,std::allocator<portable_executable::ImportInfo> >

; 780  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 781  :         } else { // provide basic guarantee
; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 783  :             _Constructed_first = _Newvec;

  0015c	48 89 7c 24 70	 mov	 QWORD PTR _Constructed_first$[rsp], rdi

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00161	4c 8b c3	 mov	 r8, rbx
  00164	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  00168	49 8b cc	 mov	 rcx, r12
$LN95@Emplace_re:

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0016b	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportInfo *,std::allocator<portable_executable::ImportInfo> >
  00170	90		 npad	 1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

  00171	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  00174	48 85 db	 test	 rbx, rbx
  00177	74 63		 je	 SHORT $LN71@Emplace_re

; 1733 :             _Destroy(_Myfirst, _Mylast);

  00179	4c 8b 76 08	 mov	 r14, QWORD PTR [rsi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 904  :         for (; _First != _Last; ++_First) {

  0017d	49 3b de	 cmp	 rbx, r14
  00180	74 14		 je	 SHORT $LN59@Emplace_re
$LL60@Emplace_re:
  00182	48 8b cb	 mov	 rcx, rbx
  00185	e8 00 00 00 00	 call	 ??1ImportInfo@portable_executable@@QEAA@XZ
  0018a	48 83 c3 38	 add	 rbx, 56			; 00000038H
  0018e	49 3b de	 cmp	 rbx, r14
  00191	75 ef		 jne	 SHORT $LL60@Emplace_re
  00193	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
$LN59@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1734 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00196	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  0019a	48 2b c3	 sub	 rax, rbx
  0019d	48 c1 f8 03	 sar	 rax, 3
  001a1	48 b9 b7 6d db
	b6 6d db b6 6d	 mov	 rcx, 7905747460161236407 ; 6db6db6db6db6db7H
  001ab	48 0f af c1	 imul	 rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001af	48 6b d0 38	 imul	 rdx, rax, 56		; 00000038H

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  001b3	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  001ba	72 18		 jb	 SHORT $LN81@Emplace_re

; 147  :     _Bytes += _Non_user_size;

  001bc	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001c0	48 8b 4b f8	 mov	 rcx, QWORD PTR [rbx-8]

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001c4	48 2b d9	 sub	 rbx, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c7	48 8d 43 f8	 lea	 rax, QWORD PTR [rbx-8]
  001cb	48 83 f8 1f	 cmp	 rax, 31
  001cf	77 36		 ja	 SHORT $LN78@Emplace_re

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001d1	48 8b d9	 mov	 rbx, rcx
$LN81@Emplace_re:

; 255  :         ::operator delete(_Ptr, _Bytes);

  001d4	48 8b cb	 mov	 rcx, rbx
  001d7	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN71@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

  001dc	48 89 3e	 mov	 QWORD PTR [rsi], rdi

; 1738 :         _Mylast  = _Newvec + _Newsize;

  001df	48 6b 4c 24 20
	38		 imul	 rcx, QWORD PTR _Newsize$1$[rsp], 56 ; 00000038H
  001e5	48 03 cf	 add	 rcx, rdi
  001e8	48 89 4e 08	 mov	 QWORD PTR [rsi+8], rcx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

  001ec	49 8d 0c 3f	 lea	 rcx, QWORD PTR [r15+rdi]
  001f0	48 89 4e 10	 mov	 QWORD PTR [rsi+16], rcx

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);
; 789  :         _RERAISE;
; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

  001f4	49 8b c5	 mov	 rax, r13

; 794  :     }

  001f7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001fb	41 5f		 pop	 r15
  001fd	41 5e		 pop	 r14
  001ff	41 5d		 pop	 r13
  00201	41 5c		 pop	 r12
  00203	5f		 pop	 rdi
  00204	5e		 pop	 rsi
  00205	5b		 pop	 rbx
  00206	c3		 ret	 0
$LN78@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0020d	cc		 int	 3
$LN91@Emplace_re:

; 131  :         _Throw_bad_array_new_length(); // add overflow

  0020e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00213	cc		 int	 3
$LN97@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 765  :             _Xlength();

  00214	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@CAXXZ ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Xlength
  00219	cc		 int	 3
$LN92@Emplace_re:
??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Newsize$1$ = 32
_Constructed_last$ = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
$T1 = 136
?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>'::`1'::catch$0

; 785  :         }
; 786  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 45 28	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00011	48 8b 55 70	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00015	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@0@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Destroy

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

  0001a	4c 8b 45 78	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  0001e	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR $T1[rbp]
  00025	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UImportInfo@portable_executable@@@std@@QEAAXQEAUImportInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportInfo>::deallocate

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);
; 789  :         _RERAISE;

  0002a	33 d2		 xor	 edx, edx
  0002c	33 c9		 xor	 ecx, ecx
  0002e	e8 00 00 00 00	 call	 _CxxThrowException
  00033	90		 npad	 1
?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newsize$1$ = 32
_Constructed_last$ = 40
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
$T1 = 136
?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>'::`1'::catch$0

; 786  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z$0:

; 787  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 45 28	 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00011	48 8b 55 70	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00015	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@0@Z ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Destroy

; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

  0001a	4c 8b 45 78	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  0001e	48 8b 95 88 00
	00 00		 mov	 rdx, QWORD PTR $T1[rbp]
  00025	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UImportInfo@portable_executable@@@std@@QEAAXQEAUImportInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportInfo>::deallocate

; 789  :         _RERAISE;

  0002a	33 d2		 xor	 edx, edx
  0002c	33 c9		 xor	 ecx, ecx
  0002e	e8 00 00 00 00	 call	 _CxxThrowException
  00033	90		 npad	 1
?catch$0@?0???$_Emplace_reallocate@AEBUImportInfo@portable_executable@@@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Emplace_reallocate<portable_executable::ImportInfo const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UImportInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportInfo@portable_executable@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UImportInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportInfo@portable_executable@@@0@AEAV10@@Z PROC ; std::move<std::allocator<portable_executable::ImportInfo> &>, COMDAT

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1398 : }

  00003	c3		 ret	 0
??$move@AEAV?$allocator@UImportInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportInfo@portable_executable@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<portable_executable::ImportInfo> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PEAUImportInfo@portable_executable@@$$T@std@@YAPEAUImportInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUImportInfo@portable_executable@@$$T@std@@YAPEAUImportInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<portable_executable::ImportInfo *,std::nullptr_t>, COMDAT

; 601  :     // assign _New_val to _Val, return previous _Val
; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00006	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 604  :     return _Old_val;
; 605  : }

  00009	c3		 ret	 0
??$exchange@PEAUImportInfo@portable_executable@@$$T@std@@YAPEAUImportInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<portable_executable::ImportInfo *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@UImportInfo@portable_executable@@@std@@PEAUImportInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportInfo@portable_executable@@@1@$$QEAPEAUImportInfo@portable_executable@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@UImportInfo@portable_executable@@@std@@PEAUImportInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportInfo@portable_executable@@@1@$$QEAPEAUImportInfo@portable_executable@@22@Z PROC ; std::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1><std::allocator<portable_executable::ImportInfo>,portable_executable::ImportInfo *,portable_executable::ImportInfo *,portable_executable::ImportInfo *>, COMDAT

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	48 8b 44 24 30	 mov	 rax, QWORD PTR <_Val2_2>$[rsp]
  00005	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00008	48 8b 44 24 28	 mov	 rax, QWORD PTR <_Val2_1>$[rsp]
  0000d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00010	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00013	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	48 8b c1	 mov	 rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00019	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001d	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	c3		 ret	 0
??$?0V?$allocator@UImportInfo@portable_executable@@@std@@PEAUImportInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportInfo@portable_executable@@@1@$$QEAPEAUImportInfo@portable_executable@@22@Z ENDP ; std::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1><std::allocator<portable_executable::ImportInfo>,portable_executable::ImportInfo *,portable_executable::ImportInfo *,portable_executable::ImportInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AEBURelocInfo@portable_executable@@@std@@YAAEBURelocInfo@portable_executable@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBURelocInfo@portable_executable@@@std@@YAAEBURelocInfo@portable_executable@@AEBU12@@Z PROC ; std::forward<portable_executable::RelocInfo const &>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@AEBURelocInfo@portable_executable@@@std@@YAAEBURelocInfo@portable_executable@@AEBU12@@Z ENDP ; std::forward<portable_executable::RelocInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@URelocInfo@portable_executable@@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@URelocInfo@portable_executable@@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@@Z PROC ; std::_Unfancy<portable_executable::RelocInfo>, COMDAT

; 266  :     return _Ptr;

  00000	48 8b c1	 mov	 rax, rcx

; 267  : }

  00003	c3		 ret	 0
??$_Unfancy@URelocInfo@portable_executable@@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@@Z ENDP ; std::_Unfancy<portable_executable::RelocInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@URelocInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@URelocInfo@portable_executable@@@1@QEAURelocInfo@portable_executable@@AEBU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@URelocInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@URelocInfo@portable_executable@@@1@QEAURelocInfo@portable_executable@@AEBU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::RelocInfo> >::construct<portable_executable::RelocInfo,portable_executable::RelocInfo const &>, COMDAT

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00004	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00007	f2 41 0f 10 48
	10		 movsd	 xmm1, QWORD PTR [r8+16]
  0000d	f2 0f 11 4a 10	 movsd	 QWORD PTR [rdx+16], xmm1

; 675  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 676  :         if (_STD is_constant_evaluated()) {
; 677  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 678  :         } else
; 679  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 680  :         {
; 681  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 682  :         }
; 683  :     }

  00012	c3		 ret	 0
??$construct@URelocInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@URelocInfo@portable_executable@@@1@QEAURelocInfo@portable_executable@@AEBU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::RelocInfo> >::construct<portable_executable::RelocInfo,portable_executable::RelocInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Emplace_reallocate<portable_executable::RelocInfo const &>, COMDAT

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN132:
  00000	40 57		 push	 rdi
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 57		 push	 r15
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0000c	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  0000f	4c 8b ca	 mov	 r9, rdx
  00012	4d 2b ca	 sub	 r9, r10
  00015	4c 8b fa	 mov	 r15, rdx
  00018	48 b8 ab aa aa
	aa aa aa aa 2a	 mov	 rax, 3074457345618258603 ; 2aaaaaaaaaaaaaabH
  00022	4d 8b e8	 mov	 r13, r8
  00025	49 f7 e9	 imul	 r9

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 763  : 
; 764  :         if (_Oldsize == max_size()) {

  00028	49 b8 aa aa aa
	aa aa aa aa 0a	 mov	 r8, 768614336404564650	; 0aaaaaaaaaaaaaaaH
  00032	48 8b f9	 mov	 rdi, rcx
  00035	4c 8b e2	 mov	 r12, rdx
  00038	48 ba ab aa aa
	aa aa aa aa aa	 mov	 rdx, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  00042	49 c1 fc 02	 sar	 r12, 2
  00046	49 8b c4	 mov	 rax, r12
  00049	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0004d	4c 03 e0	 add	 r12, rax
  00050	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00054	49 2b c2	 sub	 rax, r10
  00057	48 c1 f8 03	 sar	 rax, 3
  0005b	48 0f af c2	 imul	 rax, rdx
  0005f	49 3b c0	 cmp	 rax, r8
  00062	0f 84 83 01 00
	00		 je	 $LN130@Emplace_re

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00068	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0006c	49 2b ca	 sub	 rcx, r10
  0006f	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00074	48 c1 f9 03	 sar	 rcx, 3
  00078	48 0f af ca	 imul	 rcx, rdx
  0007c	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00081	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00086	48 8b d1	 mov	 rdx, rcx
  00089	48 d1 ea	 shr	 rdx, 1
  0008c	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

  00091	4c 8d 70 01	 lea	 r14, QWORD PTR [rax+1]

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00095	49 8b c0	 mov	 rax, r8
  00098	48 2b c2	 sub	 rax, rdx
  0009b	48 3b c8	 cmp	 rcx, rax
  0009e	0f 87 4d 01 00
	00		 ja	 $LN122@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow
; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000a4	48 8d 04 0a	 lea	 rax, QWORD PTR [rdx+rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  000a8	49 8b ce	 mov	 rcx, r14
  000ab	49 3b c6	 cmp	 rax, r14
  000ae	48 0f 43 c8	 cmovae	 rcx, rax
  000b2	49 3b c8	 cmp	 rcx, r8
  000b5	0f 87 36 01 00
	00		 ja	 $LN122@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000bb	48 8d 04 49	 lea	 rax, QWORD PTR [rcx+rcx*2]
  000bf	48 8d 34 c5 00
	00 00 00	 lea	 rsi, QWORD PTR [rax*8]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000c7	48 81 fe 00 10
	00 00		 cmp	 rsi, 4096		; 00001000H
  000ce	72 29		 jb	 SHORT $LN24@Emplace_re

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  000d0	48 8d 4e 27	 lea	 rcx, QWORD PTR [rsi+39]

; 130  :     if (_Block_size <= _Bytes) {

  000d4	48 3b ce	 cmp	 rcx, rsi
  000d7	0f 86 14 01 00
	00		 jbe	 $LN122@Emplace_re

; 79   :         return ::operator new(_Bytes);

  000dd	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  000e2	48 85 c0	 test	 rax, rax
  000e5	0f 84 f9 00 00
	00		 je	 $LN113@Emplace_re

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000eb	48 8d 58 27	 lea	 rbx, QWORD PTR [rax+39]
  000ef	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000f3	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000f7	eb 14		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  000f9	48 85 f6	 test	 rsi, rsi
  000fc	74 0d		 je	 SHORT $LN25@Emplace_re

; 79   :         return ::operator new(_Bytes);

  000fe	48 8b ce	 mov	 rcx, rsi
  00101	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00106	48 8b d8	 mov	 rbx, rax

; 235  :         return _Traits::_Allocate(_Bytes);

  00109	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  0010b	33 db		 xor	 ebx, ebx
$LN23@Emplace_re:

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0010d	41 0f 10 45 00	 movups	 xmm0, XMMWORD PTR [r13]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00112	4b 8d 04 64	 lea	 rax, QWORD PTR [r12+r12*2]

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00116	48 8b cb	 mov	 rcx, rbx
  00119	48 8d 2c c3	 lea	 rbp, QWORD PTR [rbx+rax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0011d	0f 11 45 00	 movups	 XMMWORD PTR [rbp], xmm0
  00121	f2 41 0f 10 4d
	10		 movsd	 xmm1, QWORD PTR [r13+16]
  00127	f2 0f 11 4d 10	 movsd	 QWORD PTR [rbp+16], xmm1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0012c	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  00130	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00133	4d 3b f8	 cmp	 r15, r8
  00136	75 05		 jne	 SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00138	4c 2b c2	 sub	 r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 781  :         } else { // provide basic guarantee

  0013b	eb 19		 jmp	 SHORT $LN128@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0013d	4d 8b c7	 mov	 r8, r15
  00140	4c 2b c2	 sub	 r8, rdx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00143	e8 00 00 00 00	 call	 memmove

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00148	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0014c	48 8d 4d 18	 lea	 rcx, QWORD PTR [rbp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00150	4d 2b c7	 sub	 r8, r15

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00153	49 8b d7	 mov	 rdx, r15
$LN128@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00156	e8 00 00 00 00	 call	 memmove

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

  0015b	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0015e	48 85 c9	 test	 rcx, rcx
  00161	74 47		 je	 SHORT $LN106@Emplace_re

; 1733 :             _Destroy(_Myfirst, _Mylast);
; 1734 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00163	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00167	48 ba ab aa aa
	aa aa aa aa aa	 mov	 rdx, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  00171	48 2b c1	 sub	 rax, rcx
  00174	48 c1 f8 03	 sar	 rax, 3
  00178	48 0f af c2	 imul	 rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0017c	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  00180	48 c1 e2 03	 shl	 rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00184	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0018b	72 18		 jb	 SHORT $LN116@Emplace_re

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0018d	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00191	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00195	49 2b c8	 sub	 rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00198	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0019c	48 83 f8 1f	 cmp	 rax, 31
  001a0	77 42		 ja	 SHORT $LN113@Emplace_re

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001a2	49 8b c8	 mov	 rcx, r8
$LN116@Emplace_re:

; 255  :         ::operator delete(_Ptr, _Bytes);

  001a5	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN106@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1738 :         _Mylast  = _Newvec + _Newsize;

  001aa	4b 8d 0c 76	 lea	 rcx, QWORD PTR [r14+r14*2]
  001ae	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  001b1	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  001b6	48 8d 14 cb	 lea	 rdx, QWORD PTR [rbx+rcx*8]

; 1739 :         _Myend   = _Newvec + _Newcapacity;

  001ba	48 8d 0c 1e	 lea	 rcx, QWORD PTR [rsi+rbx]
  001be	48 89 57 08	 mov	 QWORD PTR [rdi+8], rdx
  001c2	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);
; 789  :         _RERAISE;
; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

  001c7	48 8b c5	 mov	 rax, rbp
  001ca	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001cf	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 1739 :         _Myend   = _Newvec + _Newcapacity;

  001d4	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx

; 794  :     }

  001d8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001dc	41 5f		 pop	 r15
  001de	41 5d		 pop	 r13
  001e0	41 5c		 pop	 r12
  001e2	5f		 pop	 rdi
  001e3	c3		 ret	 0
$LN113@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001ea	cc		 int	 3
$LN130@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 765  :             _Xlength();

  001eb	e8 00 00 00 00	 call	 ?_Xlength@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@CAXXZ ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Xlength
  001f0	cc		 int	 3
$LN122@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

  001f1	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  001f6	cc		 int	 3
$LN127@Emplace_re:
??$_Emplace_reallocate@AEBURelocInfo@portable_executable@@@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@QEAU23@AEBU23@@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Emplace_reallocate<portable_executable::RelocInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@URelocInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@URelocInfo@portable_executable@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@URelocInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@URelocInfo@portable_executable@@@0@AEAV10@@Z PROC ; std::move<std::allocator<portable_executable::RelocInfo> &>, COMDAT

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1398 : }

  00003	c3		 ret	 0
??$move@AEAV?$allocator@URelocInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@URelocInfo@portable_executable@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<portable_executable::RelocInfo> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PEAURelocInfo@portable_executable@@$$T@std@@YAPEAURelocInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAURelocInfo@portable_executable@@$$T@std@@YAPEAURelocInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<portable_executable::RelocInfo *,std::nullptr_t>, COMDAT

; 601  :     // assign _New_val to _Val, return previous _Val
; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00006	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 604  :     return _Old_val;
; 605  : }

  00009	c3		 ret	 0
??$exchange@PEAURelocInfo@portable_executable@@$$T@std@@YAPEAURelocInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<portable_executable::RelocInfo *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@URelocInfo@portable_executable@@@std@@PEAURelocInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@URelocInfo@portable_executable@@@1@$$QEAPEAURelocInfo@portable_executable@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@URelocInfo@portable_executable@@@std@@PEAURelocInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@URelocInfo@portable_executable@@@1@$$QEAPEAURelocInfo@portable_executable@@22@Z PROC ; std::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1><std::allocator<portable_executable::RelocInfo>,portable_executable::RelocInfo *,portable_executable::RelocInfo *,portable_executable::RelocInfo *>, COMDAT

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	48 8b 44 24 30	 mov	 rax, QWORD PTR <_Val2_2>$[rsp]
  00005	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00008	48 8b 44 24 28	 mov	 rax, QWORD PTR <_Val2_1>$[rsp]
  0000d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00010	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00013	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	48 8b c1	 mov	 rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00019	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001d	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	c3		 ret	 0
??$?0V?$allocator@URelocInfo@portable_executable@@@std@@PEAURelocInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@URelocInfo@portable_executable@@@1@$$QEAPEAURelocInfo@portable_executable@@22@Z ENDP ; std::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1><std::allocator<portable_executable::RelocInfo>,portable_executable::RelocInfo *,portable_executable::RelocInfo *,portable_executable::RelocInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AEBUImportFunctionInfo@portable_executable@@@std@@YAAEBUImportFunctionInfo@portable_executable@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBUImportFunctionInfo@portable_executable@@@std@@YAAEBUImportFunctionInfo@portable_executable@@AEBU12@@Z PROC ; std::forward<portable_executable::ImportFunctionInfo const &>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@AEBUImportFunctionInfo@portable_executable@@@std@@YAAEBUImportFunctionInfo@portable_executable@@AEBU12@@Z ENDP ; std::forward<portable_executable::ImportFunctionInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UImportFunctionInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEBU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@UImportFunctionInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEBU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::construct<portable_executable::ImportFunctionInfo,portable_executable::ImportFunctionInfo const &>, COMDAT

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	49 8b d8	 mov	 rbx, r8
  00010	48 8b cf	 mov	 rcx, rdi
  00013	49 8b d0	 mov	 rdx, r8
  00016	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]

; 675  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 676  :         if (_STD is_constant_evaluated()) {
; 677  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 678  :         } else
; 679  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 680  :         {
; 681  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 682  :         }
; 683  :     }

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
??$construct@UImportFunctionInfo@portable_executable@@AEBU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEBU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::construct<portable_executable::ImportFunctionInfo,portable_executable::ImportFunctionInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>, COMDAT

; 752  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN59:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	4c 8b ea	 mov	 r13, rdx
  00017	48 8b d9	 mov	 rbx, rcx

; 753  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 754  :         _Alty& _Al        = _Getal();
; 755  :         auto& _My_data    = _Mypair._Myval2;
; 756  :         pointer& _Myfirst = _My_data._Myfirst;
; 757  :         pointer& _Mylast  = _My_data._Mylast;
; 758  : 
; 759  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 760  : 
; 761  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0001a	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  0001d	4c 8b ca	 mov	 r9, rdx
  00020	4d 2b ca	 sub	 r9, r10
  00023	48 b8 67 66 66
	66 66 66 66 66	 mov	 rax, 7378697629483820647 ; 6666666666666667H
  0002d	49 f7 e9	 imul	 r9
  00030	4c 8b f2	 mov	 r14, rdx
  00033	49 c1 fe 04	 sar	 r14, 4
  00037	49 8b c6	 mov	 rax, r14
  0003a	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0003e	4c 03 f0	 add	 r14, rax

; 762  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00041	4c 8b 79 08	 mov	 r15, QWORD PTR [rcx+8]
  00045	4d 2b fa	 sub	 r15, r10
  00048	49 c1 ff 03	 sar	 r15, 3
  0004c	48 b8 cd cc cc
	cc cc cc cc cc	 mov	 rax, -3689348814741910323 ; cccccccccccccccdH
  00056	4c 0f af f8	 imul	 r15, rax

; 763  : 
; 764  :         if (_Oldsize == max_size()) {

  0005a	48 bf 66 66 66
	66 66 66 66 06	 mov	 rdi, 461168601842738790	; 0666666666666666H
  00064	4c 3b ff	 cmp	 r15, rdi
  00067	0f 84 3d 01 00
	00		 je	 $LN58@Emplace_re

; 766  :         }
; 767  : 
; 768  :         const size_type _Newsize     = _Oldsize + 1;

  0006d	49 ff c7	 inc	 r15

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00070	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00074	49 2b ca	 sub	 rcx, r10
  00077	48 c1 f9 03	 sar	 rcx, 3
  0007b	48 0f af c8	 imul	 rcx, rax

; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0007f	48 8b d1	 mov	 rdx, rcx
  00082	48 d1 ea	 shr	 rdx, 1
  00085	48 8b c7	 mov	 rax, rdi
  00088	48 2b c2	 sub	 rax, rdx
  0008b	48 3b c8	 cmp	 rcx, rax
  0008e	77 0b		 ja	 SHORT $LN55@Emplace_re

; 1676 :             return _Max; // geometric growth would overflow
; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00090	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

  00094	49 3b ff	 cmp	 rdi, r15
  00097	49 0f 42 ff	 cmovb	 rdi, r15
$LN55@Emplace_re:

; 769  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 770  : 
; 771  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  0009b	48 89 7c 24 78	 mov	 QWORD PTR _Newcapacity$[rsp], rdi
  000a0	48 8b d7	 mov	 rdx, rdi
  000a3	e8 00 00 00 00	 call	 ?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportFunctionInfo>::allocate
  000a8	48 8b f0	 mov	 rsi, rax
  000ab	48 89 44 24 20	 mov	 QWORD PTR _Newvec$[rsp], rax

; 772  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000b0	4b 8d 0c b6	 lea	 rcx, QWORD PTR [r14+r14*4]
  000b4	4c 8d 34 c8	 lea	 r14, QWORD PTR [rax+rcx*8]
  000b8	4d 8d 66 28	 lea	 r12, QWORD PTR [r14+40]
  000bc	4c 89 a4 24 88
	00 00 00	 mov	 QWORD PTR _Constructed_last$[rsp], r12

; 773  :         pointer _Constructed_first      = _Constructed_last;

  000c4	4c 89 64 24 70	 mov	 QWORD PTR _Constructed_first$[rsp], r12
  000c9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR <_Val_0>$[rsp]
  000d1	49 8b ce	 mov	 rcx, r14
  000d4	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000d9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR <_Val_0>$[rsp]
  000e1	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000e5	49 89 46 20	 mov	 QWORD PTR [r14+32], rax

; 774  : 
; 775  :         _TRY_BEGIN
; 776  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);
; 777  :         _Constructed_first = _Newvec + _Whereoff;

  000e9	4c 89 74 24 70	 mov	 QWORD PTR _Constructed_first$[rsp], r14

; 778  : 
; 779  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000ee	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  000f2	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000f5	4c 8b c6	 mov	 r8, rsi
  000f8	4c 3b ea	 cmp	 r13, rdx
  000fb	74 17		 je	 SHORT $LN56@Emplace_re

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000fd	49 8b d5	 mov	 rdx, r13
  00100	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >

; 780  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 781  :         } else { // provide basic guarantee
; 782  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 783  :             _Constructed_first = _Newvec;

  00105	48 89 74 24 70	 mov	 QWORD PTR _Constructed_first$[rsp], rsi

; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0010a	4d 8b c4	 mov	 r8, r12
  0010d	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00111	49 8b cd	 mov	 rcx, r13
$LN56@Emplace_re:

; 784  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00114	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >
  00119	90		 npad	 1

; 1732 :         if (_Myfirst) { // destroy and deallocate old array

  0011a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0011d	48 85 c9	 test	 rcx, rcx
  00120	74 53		 je	 SHORT $LN39@Emplace_re

; 1667 :         _Destroy_range(_First, _Last, _Getal());

  00122	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00126	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAXPEAUImportFunctionInfo@portable_executable@@QEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Destroy_range<std::allocator<portable_executable::ImportFunctionInfo> >

; 1734 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0012b	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0012e	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00132	48 2b c1	 sub	 rax, rcx
  00135	48 c1 f8 03	 sar	 rax, 3
  00139	48 ba cd cc cc
	cc cc cc cc cc	 mov	 rdx, -3689348814741910323 ; cccccccccccccccdH
  00143	48 0f af c2	 imul	 rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00147	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]
  0014b	48 c1 e2 03	 shl	 rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0014f	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00156	72 18		 jb	 SHORT $LN49@Emplace_re

; 147  :     _Bytes += _Non_user_size;

  00158	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0015c	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00160	49 2b c8	 sub	 rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00163	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00167	48 83 f8 1f	 cmp	 rax, 31
  0016b	77 36		 ja	 SHORT $LN46@Emplace_re

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0016d	49 8b c8	 mov	 rcx, r8
$LN49@Emplace_re:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00170	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN39@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

  00175	48 89 33	 mov	 QWORD PTR [rbx], rsi

; 1738 :         _Mylast  = _Newvec + _Newsize;

  00178	4b 8d 0c bf	 lea	 rcx, QWORD PTR [r15+r15*4]
  0017c	48 8d 14 ce	 lea	 rdx, QWORD PTR [rsi+rcx*8]
  00180	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

  00184	48 8d 0c bf	 lea	 rcx, QWORD PTR [rdi+rdi*4]
  00188	48 8d 14 ce	 lea	 rdx, QWORD PTR [rsi+rcx*8]
  0018c	48 89 53 10	 mov	 QWORD PTR [rbx+16], rdx

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);
; 789  :         _RERAISE;
; 790  :         _CATCH_END
; 791  : 
; 792  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 793  :         return _Newvec + _Whereoff;

  00190	49 8b c6	 mov	 rax, r14

; 794  :     }

  00193	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00197	41 5f		 pop	 r15
  00199	41 5e		 pop	 r14
  0019b	41 5d		 pop	 r13
  0019d	41 5c		 pop	 r12
  0019f	5f		 pop	 rdi
  001a0	5e		 pop	 rsi
  001a1	5b		 pop	 rbx
  001a2	c3		 ret	 0
$LN46@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001a9	cc		 int	 3
$LN58@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 765  :             _Xlength();

  001aa	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@CAXXZ ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Xlength
  001af	cc		 int	 3
$LN54@Emplace_re:
??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>'::`1'::catch$1

; 785  :         }
; 786  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z$0:

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00014	48 8b 55 70	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00018	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@0@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Destroy

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

  0001d	4c 8b 45 78	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00021	48 8b 55 20	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  00025	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAXQEAUImportFunctionInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportFunctionInfo>::deallocate

; 785  :         }
; 786  :         _CATCH_ALL
; 787  :         _Destroy(_Constructed_first, _Constructed_last);
; 788  :         _Al.deallocate(_Newvec, _Newcapacity);
; 789  :         _RERAISE;

  0002a	33 d2		 xor	 edx, edx
  0002c	33 c9		 xor	 ecx, ecx
  0002e	e8 00 00 00 00	 call	 _CxxThrowException
  00033	90		 npad	 1
?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Constructed_first$ = 112
this$ = 112
_Newcapacity$ = 120
_Whereptr$ = 120
<_Val_0>$ = 128
_Constructed_last$ = 136
?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA PROC ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>'::`1'::catch$1

; 786  :         _CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z$0:

; 787  :         _Destroy(_Constructed_first, _Constructed_last);

  0000d	4c 8b 85 88 00
	00 00		 mov	 r8, QWORD PTR _Constructed_last$[rbp]
  00014	48 8b 55 70	 mov	 rdx, QWORD PTR _Constructed_first$[rbp]
  00018	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@0@Z ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Destroy

; 788  :         _Al.deallocate(_Newvec, _Newcapacity);

  0001d	4c 8b 45 78	 mov	 r8, QWORD PTR _Newcapacity$[rbp]
  00021	48 8b 55 20	 mov	 rdx, QWORD PTR _Newvec$[rbp]
  00025	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAXQEAUImportFunctionInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportFunctionInfo>::deallocate

; 789  :         _RERAISE;

  0002a	33 d2		 xor	 edx, edx
  0002c	33 c9		 xor	 ecx, ecx
  0002e	e8 00 00 00 00	 call	 _CxxThrowException
  00033	90		 npad	 1
?catch$1@?0???$_Emplace_reallocate@AEBUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@QEAU23@AEBU23@@Z@4HA ENDP ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_reallocate<portable_executable::ImportFunctionInfo const &>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1331 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Haystack$ = 48
_Hay_size$ = 56
_Start_at$dead$ = 64
_Needle$dead$ = 72
_Needle_size$ = 80
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 598  :     const size_t _Needle_size) noexcept {

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 599  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 600  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00014	48 8b 7c 24 50	 mov	 rdi, QWORD PTR _Needle_size$[rsp]
  00019	48 8b f1	 mov	 rsi, rcx
  0001c	48 3b fa	 cmp	 rdi, rdx
  0001f	77 64		 ja	 SHORT $LN6@Traits_fin

; 610  :     }
; 611  : 
; 612  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  00021	48 85 ff	 test	 rdi, rdi
  00024	75 04		 jne	 SHORT $LN7@Traits_fin

; 613  :         return _Start_at;

  00026	33 c0		 xor	 eax, eax
  00028	eb 62		 jmp	 SHORT $LN3@Traits_fin
$LN7@Traits_fin:

; 614  :     }
; 615  : 
; 616  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0002a	48 8b ee	 mov	 rbp, rsi
  0002d	48 2b ef	 sub	 rbp, rdi
  00030	48 03 ea	 add	 rbp, rdx

; 422  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00033	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH

; 617  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 618  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  00038	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  0003c	4c 2b c6	 sub	 r8, rsi

; 422  :             return __builtin_char_memchr(_First, _Ch, _Count);

  0003f	e8 00 00 00 00	 call	 memchr
  00044	48 8b d8	 mov	 rbx, rax

; 619  :         if (!_Match_try) { // didn't find first character; report failure

  00047	48 85 c0	 test	 rax, rax
  0004a	74 39		 je	 SHORT $LN6@Traits_fin
  0004c	0f 1f 40 00	 npad	 4
$LL4@Traits_fin:

; 382  :         return __builtin_memcmp(_First1, _First2, _Count);

  00050	4c 8b c7	 mov	 r8, rdi
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BDPNIACE@?2SystemRoot?2@
  0005a	48 8b cb	 mov	 rcx, rbx
  0005d	e8 00 00 00 00	 call	 memcmp

; 620  :             return static_cast<size_t>(-1);
; 621  :         }
; 622  : 
; 623  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  00062	85 c0		 test	 eax, eax
  00064	74 3b		 je	 SHORT $LN17@Traits_fin

; 617  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 618  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  00066	48 ff c3	 inc	 rbx
  00069	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  0006d	4c 2b c3	 sub	 r8, rbx

; 422  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00070	48 8b cb	 mov	 rcx, rbx
  00073	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00078	e8 00 00 00 00	 call	 memchr
  0007d	48 8b d8	 mov	 rbx, rax

; 619  :         if (!_Match_try) { // didn't find first character; report failure

  00080	48 85 c0	 test	 rax, rax
  00083	75 cb		 jne	 SHORT $LL4@Traits_fin
$LN6@Traits_fin:

; 601  :         // xpos cannot exist, report failure
; 602  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 603  :         // 1. _Start_at <= xpos
; 604  :         // 2. xpos + _Needle_size <= _Hay_size;
; 605  :         // therefore:
; 606  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 607  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 608  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 609  :         return static_cast<size_t>(-1);

  00085	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN3@Traits_fin:

; 625  :         }
; 626  :     }
; 627  : }

  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00096	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
$LN17@Traits_fin:

; 624  :             return static_cast<size_t>(_Match_try - _Haystack);

  000a1	48 2b de	 sub	 rbx, rsi
  000a4	48 8b c3	 mov	 rax, rbx
  000a7	eb e3		 jmp	 SHORT $LN3@Traits_fin
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 253  :     return __builtin_addressof(_Val);

  00000	48 8b c1	 mov	 rax, rcx

; 254  : }

  00003	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z
_TEXT	SEGMENT
tv522 = 80
this$ = 80
_Size_increase$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
<_Args_1>$ = 112
<_Args_2>$ = 120
<_Args_3>$ = 128
??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_55b0f89b53a0342680e40398a0d39887>,unsigned __int64,unsigned __int64,char const *,unsigned __int64>, COMDAT

; 4504 :         const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN82:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 56		 push	 r14
  00005	41 57		 push	 r15
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4505 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4506 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4507 :         auto& _My_data            = _Mypair._Myval2;
; 4508 :         const size_type _Old_size = _My_data._Mysize;

  0000b	4c 8b 71 10	 mov	 r14, QWORD PTR [rcx+16]

; 4509 :         if (max_size() - _Old_size < _Size_increase) {

  0000f	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00019	48 8b c3	 mov	 rax, rbx
  0001c	4d 8b f9	 mov	 r15, r9
  0001f	49 2b c6	 sub	 rax, r14
  00022	48 8b f1	 mov	 rsi, rcx
  00025	48 3b c2	 cmp	 rax, rdx
  00028	0f 82 86 01 00
	00		 jb	 $LN79@Reallocate

; 4511 :         }
; 4512 : 
; 4513 :         const size_type _New_size     = _Old_size + _Size_increase;
; 4514 :         const size_type _Old_capacity = _My_data._Myres;

  0002e	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00033	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00037	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  0003c	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00041	4d 8d 24 16	 lea	 r12, QWORD PTR [r14+rdx]

; 4454 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00045	49 8b cc	 mov	 rcx, r12
  00048	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0004d	48 83 c9 0f	 or	 rcx, 15
  00051	48 3b cb	 cmp	 rcx, rbx

; 4455 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00054	77 3a		 ja	 SHORT $LN77@Reallocate

; 4456 :             return _Max;
; 4457 :         }
; 4458 : 
; 4459 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00056	48 8b d5	 mov	 rdx, rbp
  00059	48 8b c3	 mov	 rax, rbx
  0005c	48 d1 ea	 shr	 rdx, 1
  0005f	48 2b c2	 sub	 rax, rdx
  00062	48 3b e8	 cmp	 rbp, rax
  00065	77 29		 ja	 SHORT $LN77@Reallocate

; 4460 :             return _Max;
; 4461 :         }
; 4462 : 
; 4463 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00067	48 8d 04 2a	 lea	 rax, QWORD PTR [rdx+rbp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 43   :     return _Left < _Right ? _Right : _Left;

  0006b	48 8b d9	 mov	 rbx, rcx
  0006e	48 3b c8	 cmp	 rcx, rax
  00071	48 0f 42 d8	 cmovb	 rbx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4517 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00075	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00079	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0007f	72 35		 jb	 SHORT $LN17@Reallocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00081	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]

; 130  :     if (_Block_size <= _Bytes) {

  00085	48 3b c8	 cmp	 rcx, rax
  00088	0f 86 2c 01 00
	00		 jbe	 $LN80@Reallocate
  0008e	eb 0a		 jmp	 SHORT $LN27@Reallocate
$LN77@Reallocate:

; 79   :         return ::operator new(_Bytes);

  00090	48 b9 27 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775769 ; 8000000000000027H
$LN27@Reallocate:
  0009a	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0009f	48 85 c0	 test	 rax, rax
  000a2	0f 84 b5 00 00
	00		 je	 $LN57@Reallocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000a8	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000ac	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000b0	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000b4	eb 14		 jmp	 SHORT $LN16@Reallocate
$LN17@Reallocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

  000b6	48 85 c0	 test	 rax, rax
  000b9	74 0d		 je	 SHORT $LN18@Reallocate

; 79   :         return ::operator new(_Bytes);

  000bb	48 8b c8	 mov	 rcx, rax
  000be	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000c3	48 8b f8	 mov	 rdi, rax

; 235  :         return _Traits::_Allocate(_Bytes);

  000c6	eb 02		 jmp	 SHORT $LN16@Reallocate
$LN18@Reallocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

  000c8	33 ff		 xor	 edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4527 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000ca	4c 8b 6c 24 70	 mov	 r13, QWORD PTR <_Args_1>$[rsp]
  000cf	4d 2b f7	 sub	 r14, r15
  000d2	4d 2b f5	 sub	 r14, r13
  000d5	48 89 5e 18	 mov	 QWORD PTR [rsi+24], rbx
  000d9	4c 89 66 10	 mov	 QWORD PTR [rsi+16], r12
  000dd	4e 8d 24 3f	 lea	 r12, QWORD PTR [rdi+r15]

; 4528 :         if (_BUF_SIZE <= _Old_capacity) {

  000e1	4d 8b c7	 mov	 r8, r15
  000e4	48 8b cf	 mov	 rcx, rdi
  000e7	49 8d 5e 01	 lea	 rbx, QWORD PTR [r14+1]
  000eb	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR <_Args_3>$[rsp]
  000f3	48 89 5c 24 50	 mov	 QWORD PTR tv522[rsp], rbx
  000f8	48 83 fd 10	 cmp	 rbp, 16
  000fc	72 66		 jb	 SHORT $LN3@Reallocate

; 4529 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000fe	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00101	48 8b d3	 mov	 rdx, rbx
  00104	e8 00 00 00 00	 call	 memcpy
  00109	48 8b 54 24 78	 mov	 rdx, QWORD PTR <_Args_2>$[rsp]
  0010e	4d 8b c6	 mov	 r8, r14
  00111	49 8b cc	 mov	 rcx, r12
  00114	e8 00 00 00 00	 call	 memcpy
  00119	4c 8b 44 24 50	 mov	 r8, QWORD PTR tv522[rsp]

; 3563 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);

  0011e	4a 8d 14 3b	 lea	 rdx, QWORD PTR [rbx+r15]
  00122	49 03 d5	 add	 rdx, r13

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00125	4b 8d 0c 34	 lea	 rcx, QWORD PTR [r12+r14]
  00129	e8 00 00 00 00	 call	 memcpy

; 4530 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4531 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  0012e	48 8d 55 01	 lea	 rdx, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00132	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00139	72 18		 jb	 SHORT $LN60@Reallocate

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0013b	48 8b 4b f8	 mov	 rcx, QWORD PTR [rbx-8]
  0013f	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00143	48 2b d9	 sub	 rbx, rcx

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00146	48 8d 43 f8	 lea	 rax, QWORD PTR [rbx-8]
  0014a	48 83 f8 1f	 cmp	 rax, 31
  0014e	77 0d		 ja	 SHORT $LN57@Reallocate

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00150	48 8b d9	 mov	 rbx, rcx
$LN60@Reallocate:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00153	48 8b cb	 mov	 rcx, rbx
  00156	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4533 :         } else {

  0015b	eb 32		 jmp	 SHORT $LN4@Reallocate
$LN57@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00163	cc		 int	 3
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00164	48 8b d6	 mov	 rdx, rsi
  00167	e8 00 00 00 00	 call	 memcpy
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR <_Args_2>$[rsp]
  00171	4d 8b c6	 mov	 r8, r14
  00174	49 8b cc	 mov	 rcx, r12
  00177	e8 00 00 00 00	 call	 memcpy

; 3563 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);

  0017c	4b 8d 14 2f	 lea	 rdx, QWORD PTR [r15+r13]

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00180	4c 8b c3	 mov	 r8, rbx

; 3563 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);

  00183	48 03 d6	 add	 rdx, rsi

; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00186	4b 8d 0c 34	 lea	 rcx, QWORD PTR [r12+r14]
  0018a	e8 00 00 00 00	 call	 memcpy
$LN4@Reallocate:

; 4534 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4535 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4536 :         }
; 4537 : 
; 4538 :         return *this;

  0018f	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  00192	48 8b c6	 mov	 rax, rsi
  00195	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  0019a	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  0019f	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001a4	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]

; 4539 :     }

  001a9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001ad	41 5f		 pop	 r15
  001af	41 5e		 pop	 r14
  001b1	5e		 pop	 rsi
  001b2	5b		 pop	 rbx
  001b3	c3		 ret	 0
$LN79@Reallocate:

; 4510 :             _Xlen_string(); // result too long

  001b4	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  001b9	cc		 int	 3
$LN80@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 131  :         _Throw_bad_array_new_length(); // add overflow

  001ba	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  001bf	cc		 int	 3
$LN76@Reallocate:
??$_Reallocate_grow_by@V<lambda_55b0f89b53a0342680e40398a0d39887>@@_K_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_55b0f89b53a0342680e40398a0d39887>@@_K2PEBD2@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_55b0f89b53a0342680e40398a0d39887>,unsigned __int64,unsigned __int64,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 884  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 885  :         _Left = _STD move(_Right);
; 886  :     }
; 887  : }

  00000	c2 00 00	 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
_Backout$1 = 32
this$ = 96
_Guard$2 = 104
__that$ = 104
??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z PROC	; portable_executable::ImportInfo::ImportInfo, COMDAT
$LN99:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 56		 push	 r14
  00013	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00017	48 8b fa	 mov	 rdi, rdx
  0001a	48 8b e9	 mov	 rbp, rcx
  0001d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00022	90		 npad	 1
  00023	4c 8d 75 20	 lea	 r14, QWORD PTR [rbp+32]

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	33 c0		 xor	 eax, eax
  00029	49 89 06	 mov	 QWORD PTR [r14], rax
  0002c	49 89 46 08	 mov	 QWORD PTR [r14+8], rax
  00030	49 89 46 10	 mov	 QWORD PTR [r14+16], rax

; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00034	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

  00038	48 8b 77 28	 mov	 rsi, QWORD PTR [rdi+40]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

  0003c	48 3b de	 cmp	 rbx, rsi
  0003f	74 78		 je	 SHORT $LN96@ImportInfo

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00041	48 8b fe	 mov	 rdi, rsi
  00044	48 2b fb	 sub	 rdi, rbx
  00047	48 c1 ff 03	 sar	 rdi, 3
  0004b	48 b8 cd cc cc
	cc cc cc cc cc	 mov	 rax, -3689348814741910323 ; cccccccccccccccdH
  00055	48 0f af f8	 imul	 rdi, rax

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00059	48 8b d7	 mov	 rdx, rdi
  0005c	e8 00 00 00 00	 call	 ?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportFunctionInfo>::allocate

; 1699 :         _Myfirst           = _Newvec;

  00061	49 89 06	 mov	 QWORD PTR [r14], rax

; 1700 :         _Mylast            = _Newvec;

  00064	49 89 46 08	 mov	 QWORD PTR [r14+8], rax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

  00068	48 8d 0c bf	 lea	 rcx, QWORD PTR [rdi+rdi*4]
  0006c	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00070	49 89 46 10	 mov	 QWORD PTR [r14+16], rax

; 551  :             _Tidy_guard<vector> _Guard{this};

  00074	4c 89 74 24 68	 mov	 QWORD PTR _Guard$2[rsp], r14

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00079	49 8b 3e	 mov	 rdi, QWORD PTR [r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0007c	48 89 7c 24 20	 mov	 QWORD PTR _Backout$1[rsp], rdi
  00081	48 89 7c 24 28	 mov	 QWORD PTR _Backout$1[rsp+8], rdi
  00086	4c 89 74 24 30	 mov	 QWORD PTR _Backout$1[rsp+16], r14
  0008b	0f 1f 44 00 00	 npad	 5
$LL20@ImportInfo:
  00090	48 8b d3	 mov	 rdx, rbx
  00093	48 8b cf	 mov	 rcx, rdi
  00096	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0009b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009f	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1621 :         ++_Last;

  000a3	48 83 c7 28	 add	 rdi, 40			; 00000028H
  000a7	48 89 7c 24 28	 mov	 QWORD PTR _Backout$1[rsp+8], rdi

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

  000ac	48 83 c3 28	 add	 rbx, 40			; 00000028H
  000b0	48 3b de	 cmp	 rbx, rsi
  000b3	75 db		 jne	 SHORT $LL20@ImportInfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000b5	49 89 7e 08	 mov	 QWORD PTR [r14+8], rdi
$LN96@ImportInfo:
  000b9	48 8b c5	 mov	 rax, rbp
  000bc	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000c1	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  000c6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ca	41 5e		 pop	 r14
  000cc	5f		 pop	 rdi
  000cd	5e		 pop	 rsi
  000ce	c3		 ret	 0
??0ImportInfo@portable_executable@@QEAA@AEBU01@@Z ENDP	; portable_executable::ImportInfo::ImportInfo
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
this$ = 96
_Guard$2 = 104
__that$ = 104
?dtor$0@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA PROC ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$0
  00000	48 8b 8a 60 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA ENDP ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
this$ = 96
_Guard$2 = 104
__that$ = 104
?dtor$2@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA PROC ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$2
  00000	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR _Guard$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
?dtor$2@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA ENDP ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$2
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
this$ = 96
_Guard$2 = 104
__that$ = 104
?dtor$3@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA PROC ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$3
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$3@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA ENDP ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
this$ = 96
_Guard$2 = 104
__that$ = 104
?dtor$0@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA PROC ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$0
  00000	48 8b 8a 60 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA ENDP ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
this$ = 96
_Guard$2 = 104
__that$ = 104
?dtor$2@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA PROC ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$2
  00000	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR _Guard$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
?dtor$2@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA ENDP ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
this$ = 96
_Guard$2 = 104
__that$ = 104
?dtor$3@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA PROC ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$3
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$3@?0???0ImportInfo@portable_executable@@QEAA@AEBU01@@Z@4HA ENDP ; `portable_executable::ImportInfo::ImportInfo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0ImportFunctionInfo@portable_executable@@QEAA@AEBU01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0ImportFunctionInfo@portable_executable@@QEAA@AEBU01@@Z PROC ; portable_executable::ImportFunctionInfo::ImportFunctionInfo, COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00015	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00019	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001e	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00022	48 8b c7	 mov	 rax, rdi
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
??0ImportFunctionInfo@portable_executable@@QEAA@AEBU01@@Z ENDP ; portable_executable::ImportFunctionInfo::ImportFunctionInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportInfo@portable_executable@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportInfo@portable_executable@@00@Z PROC ; std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >, COMDAT

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00003	48 8b c1	 mov	 rax, rcx
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  0000a	4c 89 49 10	 mov	 QWORD PTR [rcx+16], r9
  0000e	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportInfo@portable_executable@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >, COMDAT

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@CAXXZ PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Xlength, COMDAT

; 1760 :     [[noreturn]] static void _Xlength() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1761 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  00011	cc		 int	 3
$LN3@Xlength:
?_Xlength@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@CAXXZ ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z
_TEXT	SEGMENT
this$ = 64
_Newvec$ = 72
_Newsize$ = 80
_Newcapacity$ = 88
?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Change_array, COMDAT

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN41:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

  00013	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  00016	4d 8b f1	 mov	 r14, r9
  00019	4d 8b f8	 mov	 r15, r8
  0001c	48 8b ea	 mov	 rbp, rdx
  0001f	48 8b f9	 mov	 rdi, rcx
  00022	48 85 db	 test	 rbx, rbx
  00025	74 6d		 je	 SHORT $LN20@Change_arr

; 1733 :             _Destroy(_Myfirst, _Mylast);

  00027	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0002c	48 8b 71 08	 mov	 rsi, QWORD PTR [rcx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 904  :         for (; _First != _Last; ++_First) {

  00030	48 3b de	 cmp	 rbx, rsi
  00033	74 14		 je	 SHORT $LN8@Change_arr
$LL9@Change_arr:
  00035	48 8b cb	 mov	 rcx, rbx
  00038	e8 00 00 00 00	 call	 ??1ImportInfo@portable_executable@@QEAA@XZ
  0003d	48 83 c3 38	 add	 rbx, 56			; 00000038H
  00041	48 3b de	 cmp	 rbx, rsi
  00044	75 ef		 jne	 SHORT $LL9@Change_arr
  00046	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1734 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00049	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0004d	48 b9 b7 6d db
	b6 6d db b6 6d	 mov	 rcx, 7905747460161236407 ; 6db6db6db6db6db7H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00057	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1734 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0005c	48 2b c3	 sub	 rax, rbx
  0005f	48 c1 f8 03	 sar	 rax, 3
  00063	48 0f af c1	 imul	 rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00067	48 6b d0 38	 imul	 rdx, rax, 56		; 00000038H

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0006b	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00072	72 18		 jb	 SHORT $LN30@Change_arr

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00074	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]
  00078	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0007c	48 2b d8	 sub	 rbx, rax

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	48 83 c3 f8	 add	 rbx, -8
  00083	48 83 fb 1f	 cmp	 rbx, 31
  00087	77 38		 ja	 SHORT $LN27@Change_arr

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00089	48 8b d8	 mov	 rbx, rax
$LN30@Change_arr:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0008c	48 8b cb	 mov	 rcx, rbx
  0008f	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN20@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1740 :     }

  00094	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00099	48 89 2f	 mov	 QWORD PTR [rdi], rbp
  0009c	49 6b c7 38	 imul	 rax, r15, 56		; 00000038H
  000a0	48 03 c5	 add	 rax, rbp
  000a3	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  000a7	49 6b c6 38	 imul	 rax, r14, 56		; 00000038H
  000ab	48 03 c5	 add	 rax, rbp
  000ae	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000b3	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  000b7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bb	41 5f		 pop	 r15
  000bd	41 5e		 pop	 r14
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
$LN27@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000c7	cc		 int	 3
$LN38@Change_arr:
?_Change_array@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportInfo@portable_executable@@_K1@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Calculate_growth, COMDAT

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00004	48 b8 b7 6d db
	b6 6d db b6 6d	 mov	 rax, 7905747460161236407 ; 6db6db6db6db6db7H
  0000e	4c 2b 01	 sub	 r8, QWORD PTR [rcx]
  00011	49 c1 f8 03	 sar	 r8, 3
  00015	4c 0f af c0	 imul	 r8, rax

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00019	48 b8 92 24 49
	92 24 49 92 04	 mov	 rax, 329406144173384850	; 0492492492492492H
  00023	4d 8b c8	 mov	 r9, r8
  00026	48 8b c8	 mov	 rcx, rax
  00029	49 d1 e9	 shr	 r9, 1
  0002c	49 2b c9	 sub	 rcx, r9
  0002f	4c 3b c1	 cmp	 r8, rcx
  00032	77 0b		 ja	 SHORT $LN3@Calculate_

; 1676 :             return _Max; // geometric growth would overflow
; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00034	4b 8d 04 01	 lea	 rax, QWORD PTR [r9+r8]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

  00038	48 3b c2	 cmp	 rax, rdx
  0003b	48 0f 42 c2	 cmovb	 rax, rdx
$LN3@Calculate_:

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

  0003f	c3		 ret	 0
?_Calculate_growth@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@00@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Umove_if_noexcept, COMDAT

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 1651 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00006	48 8b d0	 mov	 rdx, rax
  00009	4d 8b c1	 mov	 r8, r9
  0000c	e9 00 00 00 00	 jmp	 ??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportInfo *,std::allocator<portable_executable::ImportInfo> >
?_Umove_if_noexcept@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@00@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAPEAUImportInfo@portable_executable@@PEAU34@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAPEAUImportInfo@portable_executable@@PEAU34@00@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Umove, COMDAT

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 1645 :         // move [_First, _Last) to raw _Dest, using allocator
; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00006	48 8b d0	 mov	 rdx, rax
  00009	4d 8b c1	 mov	 r8, r9
  0000c	e9 00 00 00 00	 jmp	 ??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportInfo *,std::allocator<portable_executable::ImportInfo> >
?_Umove@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAPEAUImportInfo@portable_executable@@PEAU34@00@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEBA_KXZ PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::max_size, COMDAT

; 1540 :         return (_STD min)(

  00000	48 b8 92 24 49
	92 24 49 92 04	 mov	 rax, 329406144173384850	; 0492492492492492H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

  0000a	c3		 ret	 0
?max_size@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@UImportInfo@portable_executable@@@std@@QEAAPEAUImportInfo@portable_executable@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UImportInfo@portable_executable@@@std@@QEAAPEAUImportInfo@portable_executable@@_K@Z PROC ; std::allocator<portable_executable::ImportInfo>::allocate, COMDAT

; 800  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 60   :         if (_Count > _Max_possible) {

  00004	48 b8 92 24 49
	92 24 49 92 04	 mov	 rax, 329406144173384850	; 0492492492492492H
  0000e	48 3b d0	 cmp	 rdx, rax
  00011	77 53		 ja	 SHORT $LN27@allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00013	48 6b ca 38	 imul	 rcx, rdx, 56		; 00000038H

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00017	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0001e	72 31		 jb	 SHORT $LN8@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00020	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 130  :     if (_Block_size <= _Bytes) {

  00024	48 3b c1	 cmp	 rax, rcx
  00027	76 3d		 jbe	 SHORT $LN27@allocate

; 79   :         return ::operator new(_Bytes);

  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00031	48 8b c8	 mov	 rcx, rax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00034	48 85 c0	 test	 rax, rax
  00037	74 11		 je	 SHORT $LN17@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00039	48 83 c0 27	 add	 rax, 39			; 00000027H
  0003d	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00041	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  00045	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00049	c3		 ret	 0
$LN17@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00050	cc		 int	 3
$LN8@allocate:

; 234  :     if (_Bytes != 0) {

  00051	48 85 c9	 test	 rcx, rcx
  00054	74 09		 je	 SHORT $LN9@allocate

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 79   :         return ::operator new(_Bytes);

  0005a	e9 00 00 00 00	 jmp	 ??2@YAPEAX_K@Z		; operator new
$LN9@allocate:

; 238  :     return nullptr;

  0005f	33 c0		 xor	 eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
$LN27@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

  00066	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0006b	cc		 int	 3
$LN28@allocate:
?allocate@?$allocator@UImportInfo@portable_executable@@@std@@QEAAPEAUImportInfo@portable_executable@@_K@Z ENDP ; std::allocator<portable_executable::ImportInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@UImportInfo@portable_executable@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UImportInfo@portable_executable@@@std@@QEAA@XZ PROC ; std::allocator<portable_executable::ImportInfo>::allocator<portable_executable::ImportInfo>, COMDAT

; 787  :     constexpr allocator() noexcept {}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@UImportInfo@portable_executable@@@std@@QEAA@XZ ENDP ; std::allocator<portable_executable::ImportInfo>::allocator<portable_executable::ImportInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@std@@QEAA@PEAURelocInfo@portable_executable@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@std@@QEAA@PEAURelocInfo@portable_executable@@00@Z PROC ; std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >, COMDAT

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00003	48 8b c1	 mov	 rax, rcx
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  0000a	4c 89 49 10	 mov	 QWORD PTR [rcx+16], r9
  0000e	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@std@@QEAA@PEAURelocInfo@portable_executable@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >, COMDAT

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@CAXXZ PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Xlength, COMDAT

; 1760 :     [[noreturn]] static void _Xlength() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1761 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  00011	cc		 int	 3
$LN3@Xlength:
?_Xlength@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@CAXXZ ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXQEAURelocInfo@portable_executable@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXQEAURelocInfo@portable_executable@@_K1@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Change_array, COMDAT

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN25:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	48 8b d9	 mov	 rbx, rcx
  00018	49 8b f1	 mov	 rsi, r9

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

  0001b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001e	4d 8b f0	 mov	 r14, r8
  00021	48 8b fa	 mov	 rdi, rdx
  00024	48 85 c9	 test	 rcx, rcx
  00027	74 47		 je	 SHORT $LN8@Change_arr

; 1733 :             _Destroy(_Myfirst, _Mylast);
; 1734 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00029	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0002d	48 ba ab aa aa
	aa aa aa aa aa	 mov	 rdx, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  00037	48 2b c1	 sub	 rax, rcx
  0003a	48 c1 f8 03	 sar	 rax, 3
  0003e	48 0f af c2	 imul	 rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00042	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  00046	48 c1 e2 03	 shl	 rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0004a	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00051	72 18		 jb	 SHORT $LN18@Change_arr

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00053	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00057	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0005b	49 2b c8	 sub	 rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005e	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  00062	48 83 f8 1f	 cmp	 rax, 31
  00066	77 39		 ja	 SHORT $LN15@Change_arr

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00068	49 8b c8	 mov	 rcx, r8
$LN18@Change_arr:

; 255  :         ::operator delete(_Ptr, _Bytes);

  0006b	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN8@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

  00070	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 1738 :         _Mylast  = _Newvec + _Newsize;

  00073	4b 8d 04 76	 lea	 rax, QWORD PTR [r14+r14*2]
  00077	48 8d 0c c7	 lea	 rcx, QWORD PTR [rdi+rax*8]
  0007b	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

  0007f	48 8d 04 76	 lea	 rax, QWORD PTR [rsi+rsi*2]

; 1740 :     }

  00083	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00088	48 8d 0c c7	 lea	 rcx, QWORD PTR [rdi+rax*8]
  0008c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00091	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx
  00095	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	41 5e		 pop	 r14
  000a0	c3		 ret	 0
$LN15@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000a7	cc		 int	 3
$LN22@Change_arr:
?_Change_array@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXQEAURelocInfo@portable_executable@@_K1@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Calculate_growth, COMDAT

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00004	48 b8 ab aa aa
	aa aa aa aa aa	 mov	 rax, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  0000e	4c 2b 01	 sub	 r8, QWORD PTR [rcx]
  00011	49 c1 f8 03	 sar	 r8, 3
  00015	4c 0f af c0	 imul	 r8, rax

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00019	48 b8 aa aa aa
	aa aa aa aa 0a	 mov	 rax, 768614336404564650	; 0aaaaaaaaaaaaaaaH
  00023	4d 8b c8	 mov	 r9, r8
  00026	48 8b c8	 mov	 rcx, rax
  00029	49 d1 e9	 shr	 r9, 1
  0002c	49 2b c9	 sub	 rcx, r9
  0002f	4c 3b c1	 cmp	 r8, rcx
  00032	77 0b		 ja	 SHORT $LN3@Calculate_

; 1676 :             return _Max; // geometric growth would overflow
; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00034	4b 8d 04 01	 lea	 rax, QWORD PTR [r9+r8]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

  00038	48 3b c2	 cmp	 rax, rdx
  0003b	48 0f 42 c2	 cmovb	 rax, rdx
$LN3@Calculate_:

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

  0003f	c3		 ret	 0
?_Calculate_growth@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXPEAURelocInfo@portable_executable@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXPEAURelocInfo@portable_executable@@00@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Umove_if_noexcept, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00000	4c 2b c2	 sub	 r8, rdx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00003	49 8b c9	 mov	 rcx, r9
  00006	e9 00 00 00 00	 jmp	 memmove
?_Umove_if_noexcept@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXPEAURelocInfo@portable_executable@@00@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAPEAURelocInfo@portable_executable@@PEAU34@00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAPEAURelocInfo@portable_executable@@PEAU34@00@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Umove, COMDAT

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d8	 mov	 rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000d	49 8b c9	 mov	 rcx, r9
  00010	48 2b da	 sub	 rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

  00013	49 8b f9	 mov	 rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00016	4c 8b c3	 mov	 r8, rbx
  00019	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1712 :             return _Dest + (_ULast - _UFirst);

  0001e	48 b8 ab aa aa
	aa aa aa aa 2a	 mov	 rax, 3074457345618258603 ; 2aaaaaaaaaaaaaabH
  00028	48 f7 eb	 imul	 rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

  0002b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1712 :             return _Dest + (_ULast - _UFirst);

  00030	48 c1 fa 02	 sar	 rdx, 2
  00034	48 8b c2	 mov	 rax, rdx
  00037	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0003b	48 03 d0	 add	 rdx, rax
  0003e	48 8d 04 52	 lea	 rax, QWORD PTR [rdx+rdx*2]
  00042	48 8d 04 c7	 lea	 rax, QWORD PTR [rdi+rax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1647 :     }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
?_Umove@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAPEAURelocInfo@portable_executable@@PEAU34@00@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEBA_KXZ PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::max_size, COMDAT

; 1540 :         return (_STD min)(

  00000	48 b8 aa aa aa
	aa aa aa aa 0a	 mov	 rax, 768614336404564650	; 0aaaaaaaaaaaaaaaH

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

  0000a	c3		 ret	 0
?max_size@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@URelocInfo@portable_executable@@@std@@QEAAPEAURelocInfo@portable_executable@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@URelocInfo@portable_executable@@@std@@QEAAPEAURelocInfo@portable_executable@@_K@Z PROC ; std::allocator<portable_executable::RelocInfo>::allocate, COMDAT

; 800  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 60   :         if (_Count > _Max_possible) {

  00004	48 b8 aa aa aa
	aa aa aa aa 0a	 mov	 rax, 768614336404564650	; 0aaaaaaaaaaaaaaaH
  0000e	48 3b d0	 cmp	 rdx, rax
  00011	77 5b		 ja	 SHORT $LN27@allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00013	48 8d 04 52	 lea	 rax, QWORD PTR [rdx+rdx*2]
  00017	48 8d 0c c5 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*8]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001f	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00026	72 31		 jb	 SHORT $LN8@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00028	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 130  :     if (_Block_size <= _Bytes) {

  0002c	48 3b c1	 cmp	 rax, rcx
  0002f	76 3d		 jbe	 SHORT $LN27@allocate

; 79   :         return ::operator new(_Bytes);

  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00039	48 8b c8	 mov	 rcx, rax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0003c	48 85 c0	 test	 rax, rax
  0003f	74 11		 je	 SHORT $LN17@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00041	48 83 c0 27	 add	 rax, 39			; 00000027H
  00045	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	c3		 ret	 0
$LN17@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00058	cc		 int	 3
$LN8@allocate:

; 234  :     if (_Bytes != 0) {

  00059	48 85 c9	 test	 rcx, rcx
  0005c	74 09		 je	 SHORT $LN9@allocate

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 79   :         return ::operator new(_Bytes);

  00062	e9 00 00 00 00	 jmp	 ??2@YAPEAX_K@Z		; operator new
$LN9@allocate:

; 238  :     return nullptr;

  00067	33 c0		 xor	 eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
$LN27@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

  0006e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00073	cc		 int	 3
$LN28@allocate:
?allocate@?$allocator@URelocInfo@portable_executable@@@std@@QEAAPEAURelocInfo@portable_executable@@_K@Z ENDP ; std::allocator<portable_executable::RelocInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@URelocInfo@portable_executable@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@URelocInfo@portable_executable@@@std@@QEAA@XZ PROC ; std::allocator<portable_executable::RelocInfo>::allocator<portable_executable::RelocInfo>, COMDAT

; 787  :     constexpr allocator() noexcept {}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@URelocInfo@portable_executable@@@std@@QEAA@XZ ENDP ; std::allocator<portable_executable::RelocInfo>::allocator<portable_executable::RelocInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >, COMDAT

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@CAXXZ PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Xlength, COMDAT

; 1760 :     [[noreturn]] static void _Xlength() {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1761 :         _Xlength_error("vector too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  00011	cc		 int	 3
$LN3@Xlength:
?_Xlength@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@CAXXZ ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportFunctionInfo@portable_executable@@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportFunctionInfo@portable_executable@@_K1@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Change_array, COMDAT

; 1723 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN27:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	48 8b d9	 mov	 rbx, rcx
  00018	49 8b f1	 mov	 rsi, r9

; 1724 :         // orphan all iterators, discard old array, acquire new array
; 1725 :         auto& _My_data    = _Mypair._Myval2;
; 1726 :         pointer& _Myfirst = _My_data._Myfirst;
; 1727 :         pointer& _Mylast  = _My_data._Mylast;
; 1728 :         pointer& _Myend   = _My_data._Myend;
; 1729 : 
; 1730 :         _My_data._Orphan_all();
; 1731 : 
; 1732 :         if (_Myfirst) { // destroy and deallocate old array

  0001b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001e	4d 8b f0	 mov	 r14, r8
  00021	48 8b fa	 mov	 rdi, rdx
  00024	48 85 c9	 test	 rcx, rcx
  00027	74 53		 je	 SHORT $LN10@Change_arr

; 1667 :         _Destroy_range(_First, _Last, _Getal());

  00029	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  0002d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAXPEAUImportFunctionInfo@portable_executable@@QEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Destroy_range<std::allocator<portable_executable::ImportFunctionInfo> >

; 1733 :             _Destroy(_Myfirst, _Mylast);
; 1734 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00032	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00035	48 ba cd cc cc
	cc cc cc cc cc	 mov	 rdx, -3689348814741910323 ; cccccccccccccccdH
  0003f	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00043	48 2b c1	 sub	 rax, rcx
  00046	48 c1 f8 03	 sar	 rax, 3
  0004a	48 0f af c2	 imul	 rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 797  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0004e	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]
  00052	48 c1 e2 03	 shl	 rdx, 3

; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00056	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0005d	72 18		 jb	 SHORT $LN20@Change_arr

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0005f	4c 8b 41 f8	 mov	 r8, QWORD PTR [rcx-8]
  00063	48 83 c2 27	 add	 rdx, 39			; 00000027H

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00067	49 2b c8	 sub	 rcx, r8

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006a	48 8d 41 f8	 lea	 rax, QWORD PTR [rcx-8]
  0006e	48 83 f8 1f	 cmp	 rax, 31
  00072	77 39		 ja	 SHORT $LN17@Change_arr

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00074	49 8b c8	 mov	 rcx, r8
$LN20@Change_arr:

; 255  :         ::operator delete(_Ptr, _Bytes);

  00077	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN10@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1737 :         _Myfirst = _Newvec;

  0007c	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 1738 :         _Mylast  = _Newvec + _Newsize;

  0007f	4b 8d 04 b6	 lea	 rax, QWORD PTR [r14+r14*4]
  00083	48 8d 0c c7	 lea	 rcx, QWORD PTR [rdi+rax*8]
  00087	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx

; 1739 :         _Myend   = _Newvec + _Newcapacity;

  0008b	48 8d 04 b6	 lea	 rax, QWORD PTR [rsi+rsi*4]

; 1740 :     }

  0008f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00094	48 8d 0c c7	 lea	 rcx, QWORD PTR [rdi+rax*8]
  00098	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0009d	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx
  000a1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	41 5e		 pop	 r14
  000ac	c3		 ret	 0
$LN17@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000b3	cc		 int	 3
$LN24@Change_arr:
?_Change_array@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXQEAUImportFunctionInfo@portable_executable@@_K1@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Calculate_growth, COMDAT

; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00004	48 b8 cd cc cc
	cc cc cc cc cc	 mov	 rax, -3689348814741910323 ; cccccccccccccccdH
  0000e	4c 2b 01	 sub	 r8, QWORD PTR [rcx]
  00011	49 c1 f8 03	 sar	 r8, 3
  00015	4c 0f af c0	 imul	 r8, rax

; 1671 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1672 :         const size_type _Oldcapacity = capacity();
; 1673 :         const auto _Max              = max_size();
; 1674 : 
; 1675 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00019	48 b8 66 66 66
	66 66 66 66 06	 mov	 rax, 461168601842738790	; 0666666666666666H
  00023	4d 8b c8	 mov	 r9, r8
  00026	48 8b c8	 mov	 rcx, rax
  00029	49 d1 e9	 shr	 r9, 1
  0002c	49 2b c9	 sub	 rcx, r9
  0002f	4c 3b c1	 cmp	 r8, rcx
  00032	77 0b		 ja	 SHORT $LN3@Calculate_

; 1676 :             return _Max; // geometric growth would overflow
; 1677 :         }
; 1678 : 
; 1679 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00034	4b 8d 04 01	 lea	 rax, QWORD PTR [r9+r8]

; 1680 : 
; 1681 :         if (_Geometric < _Newsize) {

  00038	48 3b c2	 cmp	 rax, rdx
  0003b	48 0f 42 c2	 cmovb	 rax, rdx
$LN3@Calculate_:

; 1682 :             return _Newsize; // geometric growth would be insufficient
; 1683 :         }
; 1684 : 
; 1685 :         return _Geometric; // geometric growth is sufficient
; 1686 :     }

  0003f	c3		 ret	 0
?_Calculate_growth@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove_if_noexcept@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@00@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Umove_if_noexcept, COMDAT

; 1659 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 1651 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00006	48 8b d0	 mov	 rdx, rax
  00009	4d 8b c1	 mov	 r8, r9
  0000c	e9 00 00 00 00	 jmp	 ??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >
?_Umove_if_noexcept@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@00@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU34@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
?_Umove@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU34@00@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Umove, COMDAT

; 1644 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 1645 :         // move [_First, _Last) to raw _Dest, using allocator
; 1646 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00006	48 8b d0	 mov	 rdx, rax
  00009	4d 8b c1	 mov	 r8, r9
  0000c	e9 00 00 00 00	 jmp	 ??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >
?_Umove@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU34@00@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBA_KXZ PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::max_size, COMDAT

; 1540 :         return (_STD min)(

  00000	48 b8 66 66 66
	66 66 66 66 06	 mov	 rax, 461168601842738790	; 0666666666666666H

; 1541 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1542 :     }

  0000a	c3		 ret	 0
?max_size@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
_Backout$1 = 32
_Guard$2 = 96
this$ = 96
_Right$ = 104
??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >, COMDAT

; 542  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN94:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00012	4c 8b f1	 mov	 r14, rcx

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00015	33 c0		 xor	 eax, eax
  00017	48 89 01	 mov	 QWORD PTR [rcx], rax
  0001a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0001e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 543  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 544  :         auto& _My_data            = _Mypair._Myval2;
; 545  :         const auto& _Right_data   = _Right._Mypair._Myval2;
; 546  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00022	48 8b 1a	 mov	 rbx, QWORD PTR [rdx]

; 547  :         const pointer _Rightlast  = _Right_data._Mylast;

  00025	48 8b 6a 08	 mov	 rbp, QWORD PTR [rdx+8]

; 548  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 549  :         if (_Rightfirst != _Rightlast) {

  00029	48 3b dd	 cmp	 rbx, rbp
  0002c	74 7b		 je	 SHORT $LN91@vector

; 550  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  0002e	48 8b fd	 mov	 rdi, rbp
  00031	48 2b fb	 sub	 rdi, rbx
  00034	48 c1 ff 03	 sar	 rdi, 3
  00038	48 b8 cd cc cc
	cc cc cc cc cc	 mov	 rax, -3689348814741910323 ; cccccccccccccccdH
  00042	48 0f af f8	 imul	 rdi, rax

; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00046	48 8b d7	 mov	 rdx, rdi
  00049	e8 00 00 00 00	 call	 ?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportFunctionInfo>::allocate
  0004e	48 8b f0	 mov	 rsi, rax

; 1699 :         _Myfirst           = _Newvec;

  00051	49 89 06	 mov	 QWORD PTR [r14], rax

; 1700 :         _Mylast            = _Newvec;

  00054	49 89 46 08	 mov	 QWORD PTR [r14+8], rax

; 1701 :         _Myend             = _Newvec + _Newcapacity;

  00058	48 8d 0c bf	 lea	 rcx, QWORD PTR [rdi+rdi*4]
  0005c	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  00060	49 89 56 10	 mov	 QWORD PTR [r14+16], rdx

; 551  :             _Tidy_guard<vector> _Guard{this};

  00064	4c 89 74 24 60	 mov	 QWORD PTR _Guard$2[rsp], r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00069	48 89 44 24 20	 mov	 QWORD PTR _Backout$1[rsp], rax
  0006e	48 89 44 24 28	 mov	 QWORD PTR _Backout$1[rsp+8], rax
  00073	4c 89 74 24 30	 mov	 QWORD PTR _Backout$1[rsp+16], r14
  00078	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@vector:
  00080	48 8b d3	 mov	 rdx, rbx
  00083	48 8b ce	 mov	 rcx, rsi
  00086	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0008b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0008f	48 89 46 20	 mov	 QWORD PTR [rsi+32], rax

; 1621 :         ++_Last;

  00093	48 83 c6 28	 add	 rsi, 40			; 00000028H
  00097	48 89 74 24 28	 mov	 QWORD PTR _Backout$1[rsp+8], rsi

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

  0009c	48 83 c3 28	 add	 rbx, 40			; 00000028H
  000a0	48 3b dd	 cmp	 rbx, rbp
  000a3	75 db		 jne	 SHORT $LL16@vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 552  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000a5	49 89 76 08	 mov	 QWORD PTR [r14+8], rsi
$LN91@vector:

; 553  :             _Guard._Target   = nullptr;
; 554  :         }
; 555  : 
; 556  :         _Proxy._Release();
; 557  :     }

  000a9	49 8b c6	 mov	 rax, r14
  000ac	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000b1	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  000b6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ba	41 5e		 pop	 r14
  000bc	5f		 pop	 rdi
  000bd	5e		 pop	 rsi
  000be	c3		 ret	 0
??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
_Guard$2 = 96
this$ = 96
_Right$ = 104
?dtor$0@?0???0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Guard$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
?dtor$0@?0???0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$0
text$x	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
_Guard$2 = 96
this$ = 96
_Right$ = 104
?dtor$1@?0???0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$1@?0???0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
_Guard$2 = 96
this$ = 96
_Right$ = 104
?dtor$0@?0???0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Guard$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
?dtor$0@?0???0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
_Guard$2 = 96
this$ = 96
_Right$ = 104
?dtor$1@?0???0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$1
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$1@?0???0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z PROC ; std::allocator<portable_executable::ImportFunctionInfo>::allocate, COMDAT

; 800  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN30:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 60   :         if (_Count > _Max_possible) {

  00004	48 b8 66 66 66
	66 66 66 66 06	 mov	 rax, 461168601842738790	; 0666666666666666H
  0000e	48 3b d0	 cmp	 rdx, rax
  00011	77 5b		 ja	 SHORT $LN27@allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00013	48 8d 04 92	 lea	 rax, QWORD PTR [rdx+rdx*4]
  00017	48 8d 0c c5 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*8]

; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001f	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00026	72 31		 jb	 SHORT $LN8@allocate

; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00028	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 130  :     if (_Block_size <= _Bytes) {

  0002c	48 3b c1	 cmp	 rax, rcx
  0002f	76 3d		 jbe	 SHORT $LN27@allocate

; 79   :         return ::operator new(_Bytes);

  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00039	48 8b c8	 mov	 rcx, rax

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0003c	48 85 c0	 test	 rax, rax
  0003f	74 11		 je	 SHORT $LN17@allocate

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00041	48 83 c0 27	 add	 rax, 39			; 00000027H
  00045	48 83 e0 e0	 and	 rax, -32		; ffffffffffffffe0H

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	48 89 48 f8	 mov	 QWORD PTR [rax-8], rcx

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	c3		 ret	 0
$LN17@allocate:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00058	cc		 int	 3
$LN8@allocate:

; 234  :     if (_Bytes != 0) {

  00059	48 85 c9	 test	 rcx, rcx
  0005c	74 09		 je	 SHORT $LN9@allocate

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 79   :         return ::operator new(_Bytes);

  00062	e9 00 00 00 00	 jmp	 ??2@YAPEAX_K@Z		; operator new
$LN9@allocate:

; 238  :     return nullptr;

  00067	33 c0		 xor	 eax, eax

; 801  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 802  :     }

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
$LN27@allocate:

; 131  :         _Throw_bad_array_new_length(); // add overflow

  0006e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00073	cc		 int	 3
$LN28@allocate:
?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z ENDP ; std::allocator<portable_executable::ImportFunctionInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAA@XZ PROC ; std::allocator<portable_executable::ImportFunctionInfo>::allocator<portable_executable::ImportFunctionInfo>, COMDAT

; 787  :     constexpr allocator() noexcept {}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAA@XZ ENDP ; std::allocator<portable_executable::ImportFunctionInfo>::allocator<portable_executable::ImportFunctionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Ch$dead$ = 24
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::find, COMDAT

; 410  :         // look for _Ch in [_First, _First + _Count)
; 411  : #if _HAS_CXX17
; 412  : #ifdef __cpp_char8_t
; 413  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 414  : #if _HAS_U8_INTRINSICS
; 415  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 416  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 417  :             return _Primary_char_traits::find(_First, _Count, _Ch);
; 418  : #endif // _HAS_U8_INTRINSICS
; 419  :         } else
; 420  : #endif // __cpp_char8_t
; 421  :         {
; 422  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00008	e9 00 00 00 00	 jmp	 memchr
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >, COMDAT

; 34   :         if (_Target) {

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00003	48 85 c9	 test	 rcx, rcx
  00006	0f 85 00 00 00
	00		 jne	 ?_Tidy@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXXZ ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Tidy

; 35   :             _Target->_Tidy();
; 36   :         }
; 37   :     }

  0000c	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >::~_Tidy_guard<std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@UImportInfo@portable_executable@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@UImportInfo@portable_executable@@@2@XZ PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Getal, COMDAT

; 1809 :         return _Mypair._Get_first();

  00000	48 8b c1	 mov	 rax, rcx

; 1810 :     }

  00003	c3		 ret	 0
?_Getal@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@UImportInfo@portable_executable@@@2@XZ ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Umove_if_noexcept1, COMDAT

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 1650 :         // move [_First, _Last) to raw _Dest, using allocator
; 1651 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00006	48 8b d0	 mov	 rdx, rax
  00009	4d 8b c1	 mov	 r8, r9
  0000c	e9 00 00 00 00	 jmp	 ??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportInfo *,std::allocator<portable_executable::ImportInfo> >
?_Umove_if_noexcept1@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEBA_KXZ PROC ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::capacity, COMDAT

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 b9 b7 6d db
	b6 6d db b6 6d	 mov	 rcx, 7905747460161236407 ; 6db6db6db6db6db7H
  00011	48 c1 f8 03	 sar	 rax, 3
  00015	48 0f af c1	 imul	 rax, rcx

; 1547 :     }

  00019	c3		 ret	 0
?capacity@?$vector@UImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<portable_executable::ImportInfo,std::allocator<portable_executable::ImportInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@UImportInfo@portable_executable@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@UImportInfo@portable_executable@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::max_size, COMDAT

; 695  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	48 b8 92 24 49
	92 24 49 92 04	 mov	 rax, 329406144173384850	; 0492492492492492H

; 696  :     }

  0000a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@UImportInfo@portable_executable@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@URelocInfo@portable_executable@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@URelocInfo@portable_executable@@@2@XZ PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Getal, COMDAT

; 1809 :         return _Mypair._Get_first();

  00000	48 8b c1	 mov	 rax, rcx

; 1810 :     }

  00003	c3		 ret	 0
?_Getal@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@URelocInfo@portable_executable@@@2@XZ ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXPEAURelocInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXPEAURelocInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00000	4c 2b c2	 sub	 r8, rdx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00003	49 8b c9	 mov	 rcx, r9
  00006	e9 00 00 00 00	 jmp	 memmove
?_Umove_if_noexcept1@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@AEAAXPEAURelocInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEBA_KXZ PROC ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::capacity, COMDAT

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 b9 ab aa aa
	aa aa aa aa aa	 mov	 rcx, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  00011	48 c1 f8 03	 sar	 rax, 3
  00015	48 0f af c1	 imul	 rax, rcx

; 1547 :     }

  00019	c3		 ret	 0
?capacity@?$vector@URelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<portable_executable::RelocInfo,std::allocator<portable_executable::RelocInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@URelocInfo@portable_executable@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@URelocInfo@portable_executable@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::RelocInfo> >::max_size, COMDAT

; 695  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	48 b8 aa aa aa
	aa aa aa aa 0a	 mov	 rax, 768614336404564650	; 0aaaaaaaaaaaaaaaH

; 696  :     }

  0000a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@URelocInfo@portable_executable@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::RelocInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@XZ PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Getal, COMDAT

; 1809 :         return _Mypair._Get_first();

  00000	48 8b c1	 mov	 rax, rcx

; 1810 :     }

  00003	c3		 ret	 0
?_Getal@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEBAAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@XZ ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$ = 56
?_Buy_raw@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAX_K@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Buy_raw, COMDAT

; 1688 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 1689 :         // allocate array with _Newcapacity elements
; 1690 :         auto& _My_data    = _Mypair._Myval2;
; 1691 :         pointer& _Myfirst = _My_data._Myfirst;
; 1692 :         pointer& _Mylast  = _My_data._Mylast;
; 1693 :         pointer& _Myend   = _My_data._Myend;
; 1694 : 
; 1695 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1696 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1697 : 
; 1698 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00010	e8 00 00 00 00	 call	 ?allocate@?$allocator@UImportFunctionInfo@portable_executable@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@_K@Z ; std::allocator<portable_executable::ImportFunctionInfo>::allocate

; 1699 :         _Myfirst           = _Newvec;

  00015	48 89 07	 mov	 QWORD PTR [rdi], rax

; 1700 :         _Mylast            = _Newvec;
; 1701 :         _Myend             = _Newvec + _Newcapacity;

  00018	48 8d 14 9b	 lea	 rdx, QWORD PTR [rbx+rbx*4]

; 1702 :     }

  0001c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00021	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  00025	48 8d 04 d0	 lea	 rax, QWORD PTR [rax+rdx*8]
  00029	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
?_Buy_raw@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAX_K@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Umove_if_noexcept1, COMDAT

; 1649 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 1650 :         // move [_First, _Last) to raw _Dest, using allocator
; 1651 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00006	48 8b d0	 mov	 rdx, rax
  00009	4d 8b c1	 mov	 r8, r9
  0000c	e9 00 00 00 00	 jmp	 ??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Uninitialized_move<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >
?_Umove_if_noexcept1@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAXPEAUImportFunctionInfo@portable_executable@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBA_KXZ PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::capacity, COMDAT

; 1545 :         auto& _My_data = _Mypair._Myval2;
; 1546 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 b9 cd cc cc
	cc cc cc cc cc	 mov	 rcx, -3689348814741910323 ; cccccccccccccccdH
  00011	48 c1 f8 03	 sar	 rax, 3
  00015	48 0f af c1	 imul	 rax, rcx

; 1547 :     }

  00019	c3		 ret	 0
?capacity@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SA?AV?$allocator@UImportFunctionInfo@portable_executable@@@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SA?AV?$allocator@UImportFunctionInfo@portable_executable@@@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::select_on_container_copy_construction, COMDAT

; 699  :         return _Al;

  00000	48 8b c1	 mov	 rax, rcx

; 700  :     }

  00003	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SA?AV?$allocator@UImportFunctionInfo@portable_executable@@@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::max_size, COMDAT

; 695  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00000	48 b8 66 66 66
	66 66 66 66 06	 mov	 rax, 461168601842738790	; 0666666666666666H

; 696  :     }

  0000a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SA_KAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImportInfo@portable_executable@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImportInfo@portable_executable@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1>::_Get_first, COMDAT

; 1343 :         return *this;

  00000	48 8b c1	 mov	 rax, rcx

; 1344 :     }

  00003	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UImportInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImportInfo@portable_executable@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<portable_executable::ImportInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@URelocInfo@portable_executable@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@URelocInfo@portable_executable@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1>::_Get_first, COMDAT

; 1343 :         return *this;

  00000	48 8b c1	 mov	 rax, rcx

; 1344 :     }

  00003	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@URelocInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@URelocInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@URelocInfo@portable_executable@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<portable_executable::RelocInfo>,std::_Vector_val<std::_Simple_types<portable_executable::RelocInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Get_first, COMDAT

; 1343 :         return *this;

  00000	48 8b c1	 mov	 rax, rcx

; 1344 :     }

  00003	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEBAAEBV?$allocator@UImportFunctionInfo@portable_executable@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAUImportInfo@portable_executable@@@std@@YAPEAXPEAUImportInfo@portable_executable@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAUImportInfo@portable_executable@@@std@@YAPEAXPEAUImportInfo@portable_executable@@@Z PROC ; std::_Voidify_iter<portable_executable::ImportInfo *>, COMDAT

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  00000	48 8b c1	 mov	 rax, rcx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

  00003	c3		 ret	 0
??$_Voidify_iter@PEAUImportInfo@portable_executable@@@std@@YAPEAXPEAUImportInfo@portable_executable@@@Z ENDP ; std::_Voidify_iter<portable_executable::ImportInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportInfo@portable_executable@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportInfo@portable_executable@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<portable_executable::ImportInfo> >, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportInfo@portable_executable@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<portable_executable::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAUImportInfo@portable_executable@@@std@@YA$$QEAPEAUImportInfo@portable_executable@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUImportInfo@portable_executable@@@std@@YA$$QEAPEAUImportInfo@portable_executable@@AEAPEAU12@@Z PROC ; std::forward<portable_executable::ImportInfo *>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@PEAUImportInfo@portable_executable@@@std@@YA$$QEAPEAUImportInfo@portable_executable@@AEAPEAU12@@Z ENDP ; std::forward<portable_executable::ImportInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAURelocInfo@portable_executable@@@std@@YAPEAXPEAURelocInfo@portable_executable@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAURelocInfo@portable_executable@@@std@@YAPEAXPEAURelocInfo@portable_executable@@@Z PROC ; std::_Voidify_iter<portable_executable::RelocInfo *>, COMDAT

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  00000	48 8b c1	 mov	 rax, rcx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

  00003	c3		 ret	 0
??$_Voidify_iter@PEAURelocInfo@portable_executable@@@std@@YAPEAXPEAURelocInfo@portable_executable@@@Z ENDP ; std::_Voidify_iter<portable_executable::RelocInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@URelocInfo@portable_executable@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@URelocInfo@portable_executable@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<portable_executable::RelocInfo> >, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@URelocInfo@portable_executable@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<portable_executable::RelocInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAURelocInfo@portable_executable@@@std@@YA$$QEAPEAURelocInfo@portable_executable@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAURelocInfo@portable_executable@@@std@@YA$$QEAPEAURelocInfo@portable_executable@@AEAPEAU12@@Z PROC ; std::forward<portable_executable::RelocInfo *>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@PEAURelocInfo@portable_executable@@@std@@YA$$QEAPEAURelocInfo@portable_executable@@AEAPEAU12@@Z ENDP ; std::forward<portable_executable::RelocInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PEAUImportFunctionInfo@portable_executable@@@std@@YAPEAXPEAUImportFunctionInfo@portable_executable@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAUImportFunctionInfo@portable_executable@@@std@@YAPEAXPEAUImportFunctionInfo@portable_executable@@@Z PROC ; std::_Voidify_iter<portable_executable::ImportFunctionInfo *>, COMDAT

; 124  :     if constexpr (is_pointer_v<_Iter>) {
; 125  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  00000	48 8b c1	 mov	 rax, rcx

; 126  :     } else {
; 127  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 128  :     }
; 129  : }

  00003	c3		 ret	 0
??$_Voidify_iter@PEAUImportFunctionInfo@portable_executable@@@std@@YAPEAXPEAUImportFunctionInfo@portable_executable@@@Z ENDP ; std::_Voidify_iter<portable_executable::ImportFunctionInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Dest$ = 32
_Al$dead$ = 40
??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z PROC ; std::_Uninitialized_move<portable_executable::ImportInfo *,std::allocator<portable_executable::ImportInfo> >, COMDAT

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN77:
  00000	48 83 ec 08	 sub	 rsp, 8
  00004	49 8b c0	 mov	 rax, r8
  00007	4c 8b da	 mov	 r11, rdx

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

  0000a	48 3b ca	 cmp	 rcx, rdx
  0000d	74 7b		 je	 SHORT $LN74@Uninitiali

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0000f	4c 8b d0	 mov	 r10, rax
  00012	48 89 1c 24	 mov	 QWORD PTR [rsp], rbx
  00016	4c 2b d1	 sub	 r10, rcx
  00019	4c 8d 41 28	 lea	 r8, QWORD PTR [rcx+40]
  0001d	33 db		 xor	 ebx, ebx
  0001f	90		 npad	 1
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00020	48 89 18	 mov	 QWORD PTR [rax], rbx

; 2322 :     size_type _Mysize = 0; // current length of string

  00023	4b 89 5c 02 e8	 mov	 QWORD PTR [r10+r8-24], rbx

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  00028	4b 89 5c 02 f0	 mov	 QWORD PTR [r10+r8-16], rbx

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0002d	41 0f 10 40 d8	 movups	 xmm0, XMMWORD PTR [r8-40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

  00032	4d 8d 40 38	 lea	 r8, QWORD PTR [r8+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00036	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  00039	41 0f 10 48 b0	 movups	 xmm1, XMMWORD PTR [r8-80]
  0003e	0f 11 48 10	 movups	 XMMWORD PTR [rax+16], xmm1

; 4562 :         _My_data._Mysize = 0;

  00042	49 89 58 b0	 mov	 QWORD PTR [r8-80], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

  00046	48 83 c0 38	 add	 rax, 56			; 00000038H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  0004a	49 c7 40 b8 0f
	00 00 00	 mov	 QWORD PTR [r8-72], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00052	41 88 58 a0	 mov	 BYTE PTR [r8-96], bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00056	49 8b 48 c0	 mov	 rcx, QWORD PTR [r8-64]
  0005a	4d 8b 48 d0	 mov	 r9, QWORD PTR [r8-48]
  0005e	49 8b 50 c8	 mov	 rdx, QWORD PTR [r8-56]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00062	49 89 58 d0	 mov	 QWORD PTR [r8-48], rbx
  00066	49 89 58 c8	 mov	 QWORD PTR [r8-56], rbx
  0006a	49 89 58 c0	 mov	 QWORD PTR [r8-64], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  0006e	4b 89 4c 02 c0	 mov	 QWORD PTR [r10+r8-64], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

  00073	49 8d 48 d8	 lea	 rcx, QWORD PTR [r8-40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00077	4b 89 54 02 c8	 mov	 QWORD PTR [r10+r8-56], rdx
  0007c	4f 89 4c 02 d0	 mov	 QWORD PTR [r10+r8-48], r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

  00081	49 3b cb	 cmp	 rcx, r11
  00084	75 9a		 jne	 SHORT $LL4@Uninitiali

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

  00086	48 8b 1c 24	 mov	 rbx, QWORD PTR [rsp]
$LN74@Uninitiali:

; 1722 : }

  0008a	48 83 c4 08	 add	 rsp, 8
  0008e	c3		 ret	 0
??$_Uninitialized_move@PEAUImportInfo@portable_executable@@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@YAPEAUImportInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportInfo@portable_executable@@@0@@Z ENDP ; std::_Uninitialized_move<portable_executable::ImportInfo *,std::allocator<portable_executable::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUImportInfo@portable_executable@@@std@@YA?A_TAEBQEAUImportInfo@portable_executable@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUImportInfo@portable_executable@@@std@@YA?A_TAEBQEAUImportInfo@portable_executable@@@Z PROC ; std::_Get_unwrapped<portable_executable::ImportInfo * const &>, COMDAT

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

  00003	c3		 ret	 0
??$_Get_unwrapped@AEBQEAUImportInfo@portable_executable@@@std@@YA?A_TAEBQEAUImportInfo@portable_executable@@@Z ENDP ; std::_Get_unwrapped<portable_executable::ImportInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<56>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {

  00004	48 b8 92 24 49
	92 24 49 92 04	 mov	 rax, 329406144173384850	; 0492492492492492H
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 09		 ja	 SHORT $LN6@Get_size_o

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00013	48 6b c1 38	 imul	 rax, rcx, 56		; 00000038H

; 66   : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
$LN6@Get_size_o:

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001c	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00021	cc		 int	 3
$LN4@Get_size_o:
??$_Get_size_of_n@$0DI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<56>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAURelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YAPEAURelocInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@URelocInfo@portable_executable@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAURelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YAPEAURelocInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@URelocInfo@portable_executable@@@0@@Z PROC ; std::_Uninitialized_move<portable_executable::RelocInfo *,std::allocator<portable_executable::RelocInfo> >, COMDAT

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility

; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1712 :             return _Dest + (_ULast - _UFirst);

  00021	48 b8 ab aa aa
	aa aa aa aa 2a	 mov	 rax, 3074457345618258603 ; 2aaaaaaaaaaaaaabH
  0002b	48 f7 eb	 imul	 rbx

; 1713 :         }
; 1714 :     }
; 1715 : 
; 1716 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {
; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();
; 1722 : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 c1 fa 02	 sar	 rdx, 2
  00037	48 8b c2	 mov	 rax, rdx
  0003a	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0003e	48 03 d0	 add	 rdx, rax
  00041	48 8d 04 52	 lea	 rax, QWORD PTR [rdx+rdx*2]
  00045	48 8d 04 c7	 lea	 rax, QWORD PTR [rdi+rax*8]
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
??$_Uninitialized_move@PEAURelocInfo@portable_executable@@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@YAPEAURelocInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@URelocInfo@portable_executable@@@0@@Z ENDP ; std::_Uninitialized_move<portable_executable::RelocInfo *,std::allocator<portable_executable::RelocInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAURelocInfo@portable_executable@@@std@@YA?A_TAEBQEAURelocInfo@portable_executable@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAURelocInfo@portable_executable@@@std@@YA?A_TAEBQEAURelocInfo@portable_executable@@@Z PROC ; std::_Get_unwrapped<portable_executable::RelocInfo * const &>, COMDAT

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

  00003	c3		 ret	 0
??$_Get_unwrapped@AEBQEAURelocInfo@portable_executable@@@std@@YA?A_TAEBQEAURelocInfo@portable_executable@@@Z ENDP ; std::_Get_unwrapped<portable_executable::RelocInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<24>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {

  00004	48 b8 aa aa aa
	aa aa aa aa 0a	 mov	 rax, 768614336404564650	; 0aaaaaaaaaaaaaaaH
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 0d		 ja	 SHORT $LN6@Get_size_o

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00013	48 8d 04 49	 lea	 rax, QWORD PTR [rcx+rcx*2]
  00017	48 c1 e0 03	 shl	 rax, 3

; 66   : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN6@Get_size_o:

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00020	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00025	cc		 int	 3
$LN4@Get_size_o:
??$_Get_size_of_n@$0BI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<24>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z PROC ; std::_Uninitialized_move<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >, COMDAT

; 1699 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN50:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b d8	 mov	 rbx, r8

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

  00009	48 3b ca	 cmp	 rcx, rdx
  0000c	74 59		 je	 SHORT $LN3@Uninitiali

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0000e	48 8b c3	 mov	 rax, rbx
  00011	4c 8d 41 18	 lea	 r8, QWORD PTR [rcx+24]
  00015	48 2b c1	 sub	 rax, rcx
  00018	45 33 c9	 xor	 r9d, r9d
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@Uninitiali:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00020	4c 89 0b	 mov	 QWORD PTR [rbx], r9

; 2322 :     size_type _Mysize = 0; // current length of string

  00023	4e 89 4c 00 f8	 mov	 QWORD PTR [rax+r8-8], r9

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  00028	4e 89 0c 00	 mov	 QWORD PTR [rax+r8], r9

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0002c	41 0f 10 40 e8	 movups	 xmm0, XMMWORD PTR [r8-24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

  00031	4d 8d 40 28	 lea	 r8, QWORD PTR [r8+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00035	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00038	41 0f 10 48 d0	 movups	 xmm1, XMMWORD PTR [r8-48]
  0003d	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 4562 :         _My_data._Mysize = 0;

  00041	4d 89 48 d0	 mov	 QWORD PTR [r8-48], r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

  00045	48 83 c3 28	 add	 rbx, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00049	49 c7 40 d8 0f
	00 00 00	 mov	 QWORD PTR [r8-40], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00051	45 88 48 c0	 mov	 BYTE PTR [r8-64], r9b
  00055	49 8b 48 e0	 mov	 rcx, QWORD PTR [r8-32]
  00059	4a 89 4c 00 e0	 mov	 QWORD PTR [rax+r8-32], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1717 :     for (; _UFirst != _ULast; ++_UFirst) {

  0005e	49 8d 48 e8	 lea	 rcx, QWORD PTR [r8-24]
  00062	48 3b ca	 cmp	 rcx, rdx
  00065	75 b9		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1615 :         _Destroy_range(_First, _Last, _Al);

  00067	48 8b d3	 mov	 rdx, rbx
  0006a	48 8b cb	 mov	 rcx, rbx
  0006d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAXPEAUImportFunctionInfo@portable_executable@@QEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Destroy_range<std::allocator<portable_executable::ImportFunctionInfo> >

; 1718 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1719 :     }
; 1720 : 
; 1721 :     return _Backout._Release();

  00072	48 8b c3	 mov	 rax, rbx

; 1722 : }

  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
??$_Uninitialized_move@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ENDP ; std::_Uninitialized_move<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAUImportFunctionInfo@portable_executable@@@std@@YA?A_TAEBQEAUImportFunctionInfo@portable_executable@@@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAUImportFunctionInfo@portable_executable@@@std@@YA?A_TAEBQEAUImportFunctionInfo@portable_executable@@@Z PROC ; std::_Get_unwrapped<portable_executable::ImportFunctionInfo * const &>, COMDAT

; 1275 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1276 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1277 :         return _It + 0;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1278 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1279 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1280 :     } else {
; 1281 :         return static_cast<_Iter&&>(_It);
; 1282 :     }
; 1283 : }

  00003	c3		 ret	 0
??$_Get_unwrapped@AEBQEAUImportFunctionInfo@portable_executable@@@std@@YA?A_TAEBQEAUImportFunctionInfo@portable_executable@@@Z ENDP ; std::_Get_unwrapped<portable_executable::ImportFunctionInfo * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@UImportFunctionInfo@portable_executable@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@UImportFunctionInfo@portable_executable@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1><std::allocator<portable_executable::ImportFunctionInfo> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 390  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0V?$allocator@UImportFunctionInfo@portable_executable@@@std@@$$V@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1><std::allocator<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z
_TEXT	SEGMENT
_Backout$1 = 32
this$ = 80
_First$ = 88
_Last$ = 96
_Dest$ = 104
??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Ucopy<portable_executable::ImportFunctionInfo *>, COMDAT

; 1639 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

$LN28:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	49 8b f9	 mov	 rdi, r9
  00012	49 8b f0	 mov	 rsi, r8
  00015	48 8b da	 mov	 rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00018	4c 89 4c 24 20	 mov	 QWORD PTR _Backout$1[rsp], r9
  0001d	4c 89 4c 24 28	 mov	 QWORD PTR _Backout$1[rsp+8], r9
  00022	48 89 4c 24 30	 mov	 QWORD PTR _Backout$1[rsp+16], rcx

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

  00027	49 3b d0	 cmp	 rdx, r8
  0002a	74 29		 je	 SHORT $LN5@Ucopy
  0002c	0f 1f 40 00	 npad	 4
$LL6@Ucopy:
  00030	48 8b d3	 mov	 rdx, rbx
  00033	48 8b cf	 mov	 rcx, rdi
  00036	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003b	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0003f	48 89 4f 20	 mov	 QWORD PTR [rdi+32], rcx

; 1621 :         ++_Last;

  00043	48 83 c7 28	 add	 rdi, 40			; 00000028H
  00047	48 89 7c 24 28	 mov	 QWORD PTR _Backout$1[rsp+8], rdi

; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

  0004c	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00050	48 3b de	 cmp	 rbx, rsi
  00053	75 db		 jne	 SHORT $LL6@Ucopy
$LN5@Ucopy:

; 1615 :         _Destroy_range(_First, _Last, _Al);

  00055	48 8b d7	 mov	 rdx, rdi
  00058	48 8b cf	 mov	 rcx, rdi
  0005b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAXPEAUImportFunctionInfo@portable_executable@@QEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Destroy_range<std::allocator<portable_executable::ImportFunctionInfo> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 1641 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00060	48 8b c7	 mov	 rax, rdi

; 1642 :     }

  00063	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00068	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0006d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
??$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Ucopy<portable_executable::ImportFunctionInfo *>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
this$ = 80
_First$ = 88
_Last$ = 96
_Dest$ = 104
?dtor$0@?0???$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z@4HA PROC ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Ucopy<portable_executable::ImportFunctionInfo *>'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$0@?0???$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z@4HA ENDP ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Ucopy<portable_executable::ImportFunctionInfo *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$1 = 32
this$ = 80
_First$ = 88
_Last$ = 96
_Dest$ = 104
?dtor$0@?0???$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z@4HA PROC ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Ucopy<portable_executable::ImportFunctionInfo *>'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$0@?0???$_Ucopy@PEAUImportFunctionInfo@portable_executable@@@?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@AEAAPEAUImportFunctionInfo@portable_executable@@PEAU23@00@Z@4HA ENDP ; `std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::_Ucopy<portable_executable::ImportFunctionInfo *>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<40>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {

  00004	48 b8 66 66 66
	66 66 66 66 06	 mov	 rax, 461168601842738790	; 0666666666666666H
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 0d		 ja	 SHORT $LN6@Get_size_o

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00013	48 8d 04 89	 lea	 rax, QWORD PTR [rcx+rcx*4]
  00017	48 c1 e0 03	 shl	 rax, 3

; 66   : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN6@Get_size_o:

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00020	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  00025	cc		 int	 3
$LN4@Get_size_o:
??$_Get_size_of_n@$0CI@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<40>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Release, COMDAT

; 1625 :         _First = _Last;

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1626 :         return _Last;
; 1627 :     }

  00007	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAPEAUImportFunctionInfo@portable_executable@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >, COMDAT

; 1615 :         _Destroy_range(_First, _Last, _Al);

  00000	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00004	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00007	e9 00 00 00 00	 jmp	 ??$_Destroy_range@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAXPEAUImportFunctionInfo@portable_executable@@QEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Destroy_range<std::allocator<portable_executable::ImportFunctionInfo> >
??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportFunctionInfo@portable_executable@@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportFunctionInfo@portable_executable@@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >, COMDAT

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00003	48 8b c1	 mov	 rax, rcx
  00006	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0000a	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8
  0000e	c3		 ret	 0
??0?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportFunctionInfo@portable_executable@@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::_Release, COMDAT

; 1625 :         _First = _Last;

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1626 :         return _Last;
; 1627 :     }

  00007	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAPEAURelocInfo@portable_executable@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >, COMDAT

; 1615 :         _Destroy_range(_First, _Last, _Al);
; 1616 :     }

  00000	c2 00 00	 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@PEAURelocInfo@portable_executable@@AEAV?$allocator@URelocInfo@portable_executable@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@PEAURelocInfo@portable_executable@@AEAV?$allocator@URelocInfo@portable_executable@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >, COMDAT

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00003	48 8b c1	 mov	 rax, rcx
  00006	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0000a	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8
  0000e	c3		 ret	 0
??0?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAA@PEAURelocInfo@portable_executable@@AEAV?$allocator@URelocInfo@portable_executable@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::_Release, COMDAT

; 1625 :         _First = _Last;

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1626 :         return _Last;
; 1627 :     }

  00007	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAPEAUImportInfo@portable_executable@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >, COMDAT

; 1614 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1615 :         _Destroy_range(_First, _Last, _Al);

  0000a	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  0000e	48 8b 19	 mov	 rbx, QWORD PTR [rcx]

; 904  :         for (; _First != _Last; ++_First) {

  00011	48 3b df	 cmp	 rbx, rdi
  00014	74 11		 je	 SHORT $LN5@Uninitiali
$LL6@Uninitiali:
  00016	48 8b cb	 mov	 rcx, rbx
  00019	e8 00 00 00 00	 call	 ??1ImportInfo@portable_executable@@QEAA@XZ
  0001e	48 83 c3 38	 add	 rbx, 56			; 00000038H
  00022	48 3b df	 cmp	 rbx, rdi
  00025	75 ef		 jne	 SHORT $LL6@Uninitiali
$LN5@Uninitiali:

; 1616 :     }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportInfo@portable_executable@@AEAV?$allocator@UImportInfo@portable_executable@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportInfo@portable_executable@@AEAV?$allocator@UImportInfo@portable_executable@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >, COMDAT

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00003	48 8b c1	 mov	 rax, rcx
  00006	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0000a	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8
  0000e	c3		 ret	 0
??0?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportInfo@portable_executable@@AEAV?$allocator@UImportInfo@portable_executable@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAUImportInfo@portable_executable@@@std@@YA$$QEAUImportInfo@portable_executable@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUImportInfo@portable_executable@@@std@@YA$$QEAUImportInfo@portable_executable@@AEAU12@@Z PROC ; std::move<portable_executable::ImportInfo &>, COMDAT

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1398 : }

  00003	c3		 ret	 0
??$move@AEAUImportInfo@portable_executable@@@std@@YA$$QEAUImportInfo@portable_executable@@AEAU12@@Z ENDP ; std::move<portable_executable::ImportInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@UImportInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAX$$QEAUImportInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UImportInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAX$$QEAUImportInfo@portable_executable@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::_Emplace_back<portable_executable::ImportInfo>, COMDAT

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00004	45 33 db	 xor	 r11d, r11d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00007	4c 8b c2	 mov	 r8, rdx
  0000a	4c 8b d1	 mov	 r10, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  0000d	4d 89 19	 mov	 QWORD PTR [r9], r11

; 2322 :     size_type _Mysize = 0; // current length of string

  00010	4d 89 59 10	 mov	 QWORD PTR [r9+16], r11

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  00014	4d 89 59 18	 mov	 QWORD PTR [r9+24], r11

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00018	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  0001b	41 0f 11 01	 movups	 XMMWORD PTR [r9], xmm0
  0001f	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  00023	41 0f 11 49 10	 movups	 XMMWORD PTR [r9+16], xmm1

; 4562 :         _My_data._Mysize = 0;

  00028	4c 89 5a 10	 mov	 QWORD PTR [rdx+16], r11

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  0002c	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00034	44 88 1a	 mov	 BYTE PTR [rdx], r11b
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00037	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  0003b	49 8b 48 28	 mov	 rcx, QWORD PTR [r8+40]
  0003f	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00043	4d 89 58 30	 mov	 QWORD PTR [r8+48], r11
  00047	4d 89 58 28	 mov	 QWORD PTR [r8+40], r11
  0004b	4d 89 58 20	 mov	 QWORD PTR [r8+32], r11
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  0004f	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  00053	49 89 49 28	 mov	 QWORD PTR [r9+40], rcx
  00057	49 89 51 30	 mov	 QWORD PTR [r9+48], rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

  0005b	49 83 42 08 38	 add	 QWORD PTR [r10+8], 56	; 00000038H

; 1622 :     }

  00060	c3		 ret	 0
??$_Emplace_back@UImportInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@QEAAX$$QEAUImportInfo@portable_executable@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportInfo> >::_Emplace_back<portable_executable::ImportInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAURelocInfo@portable_executable@@@std@@YA$$QEAURelocInfo@portable_executable@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAURelocInfo@portable_executable@@@std@@YA$$QEAURelocInfo@portable_executable@@AEAU12@@Z PROC ; std::move<portable_executable::RelocInfo &>, COMDAT

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1398 : }

  00003	c3		 ret	 0
??$move@AEAURelocInfo@portable_executable@@@std@@YA$$QEAURelocInfo@portable_executable@@AEAU12@@Z ENDP ; std::move<portable_executable::RelocInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PEAURelocInfo@portable_executable@@PEAU12@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEAURelocInfo@portable_executable@@PEAU12@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@00@Z PROC ; std::_Copy_memmove<portable_executable::RelocInfo *,portable_executable::RelocInfo *>, COMDAT

; 4058 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8

; 4059 :     auto _FirstPtr              = _To_address(_First);
; 4060 :     auto _LastPtr               = _To_address(_Last);
; 4061 :     auto _DestPtr               = _To_address(_Dest);
; 4062 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4063 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4064 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4065 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00010	48 2b d9	 sub	 rbx, rcx

; 4066 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00013	48 8b d1	 mov	 rdx, rcx
  00016	4c 8b c3	 mov	 r8, rbx
  00019	48 8b cf	 mov	 rcx, rdi
  0001c	e8 00 00 00 00	 call	 memmove

; 4067 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4068 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00021	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 4069 :     } else {
; 4070 :         return _Dest + (_LastPtr - _FirstPtr);
; 4071 :     }
; 4072 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
??$_Copy_memmove@PEAURelocInfo@portable_executable@@PEAU12@@std@@YAPEAURelocInfo@portable_executable@@PEAU12@00@Z ENDP ; std::_Copy_memmove<portable_executable::RelocInfo *,portable_executable::RelocInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PEAURelocInfo@portable_executable@@@std@@YA?A_PAEBQEAURelocInfo@portable_executable@@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAURelocInfo@portable_executable@@@std@@YA?A_PAEBQEAURelocInfo@portable_executable@@@Z PROC ; std::_To_address<portable_executable::RelocInfo *>, COMDAT

; 3981 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 3982 :     return _Val;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 3983 : }

  00003	c3		 ret	 0
??$_To_address@PEAURelocInfo@portable_executable@@@std@@YA?A_PAEBQEAURelocInfo@portable_executable@@@Z ENDP ; std::_To_address<portable_executable::RelocInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@URelocInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAX$$QEAURelocInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@URelocInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAX$$QEAURelocInfo@portable_executable@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::_Emplace_back<portable_executable::RelocInfo>, COMDAT

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00004	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00007	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  0000a	f2 0f 10 4a 10	 movsd	 xmm1, QWORD PTR [rdx+16]
  0000f	f2 0f 11 48 10	 movsd	 QWORD PTR [rax+16], xmm1

; 1621 :         ++_Last;

  00014	48 83 41 08 18	 add	 QWORD PTR [rcx+8], 24

; 1622 :     }

  00019	c3		 ret	 0
??$_Emplace_back@URelocInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@QEAAX$$QEAURelocInfo@portable_executable@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::RelocInfo> >::_Emplace_back<portable_executable::RelocInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAUImportFunctionInfo@portable_executable@@@std@@YA$$QEAUImportFunctionInfo@portable_executable@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUImportFunctionInfo@portable_executable@@@std@@YA$$QEAUImportFunctionInfo@portable_executable@@AEAU12@@Z PROC ; std::move<portable_executable::ImportFunctionInfo &>, COMDAT

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1398 : }

  00003	c3		 ret	 0
??$move@AEAUImportFunctionInfo@portable_executable@@@std@@YA$$QEAUImportFunctionInfo@portable_executable@@AEAU12@@Z ENDP ; std::move<portable_executable::ImportFunctionInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@UImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAX$$QEAUImportFunctionInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 8
<_Vals_0>$ = 16
??$_Emplace_back@UImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAX$$QEAUImportFunctionInfo@portable_executable@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_back<portable_executable::ImportFunctionInfo>, COMDAT

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00004	33 c0		 xor	 eax, eax
  00006	49 89 00	 mov	 QWORD PTR [r8], rax

; 2322 :     size_type _Mysize = 0; // current length of string

  00009	49 89 40 10	 mov	 QWORD PTR [r8+16], rax

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  0000d	49 89 40 18	 mov	 QWORD PTR [r8+24], rax

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00011	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00014	41 0f 11 00	 movups	 XMMWORD PTR [r8], xmm0
  00018	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  0001c	41 0f 11 48 10	 movups	 XMMWORD PTR [r8+16], xmm1

; 4562 :         _My_data._Mysize = 0;

  00021	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00025	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0002d	88 02		 mov	 BYTE PTR [rdx], al
  0002f	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00033	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1621 :         ++_Last;

  00037	48 83 41 08 28	 add	 QWORD PTR [rcx+8], 40	; 00000028H

; 1622 :     }

  0003c	c3		 ret	 0
??$_Emplace_back@UImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAX$$QEAUImportFunctionInfo@portable_executable@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_back<portable_executable::ImportFunctionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@AEAV10@@Z PROC ; std::forward<std::allocator<portable_executable::ImportFunctionInfo> >, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@AEAV10@@Z ENDP ; std::forward<std::allocator<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z
_TEXT	SEGMENT
_Backout$ = 32
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z PROC ; std::_Uninitialized_copy<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >, COMDAT

; 1637 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN26:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 1609 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00018	4c 89 44 24 20	 mov	 QWORD PTR _Backout$[rsp], r8
  0001d	4c 89 44 24 28	 mov	 QWORD PTR _Backout$[rsp+8], r8
  00022	4c 89 4c 24 30	 mov	 QWORD PTR _Backout$[rsp+16], r9

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

  00027	48 3b ca	 cmp	 rcx, rdx
  0002a	74 29		 je	 SHORT $LN3@Uninitiali
  0002c	0f 1f 40 00	 npad	 4
$LL4@Uninitiali:
  00030	48 8b d3	 mov	 rdx, rbx
  00033	48 8b cf	 mov	 rcx, rdi
  00036	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003b	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0003f	48 89 4f 20	 mov	 QWORD PTR [rdi+32], rcx

; 1621 :         ++_Last;

  00043	48 83 c7 28	 add	 rdi, 40			; 00000028H
  00047	48 89 7c 24 28	 mov	 QWORD PTR _Backout$[rsp+8], rdi

; 1638 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1639 :     // note: only called internally from elsewhere in the STL
; 1640 :     using _Ptrval = typename _Alloc::value_type*;
; 1641 : 
; 1642 :     auto _UFirst      = _Get_unwrapped(_First);
; 1643 :     const auto _ULast = _Get_unwrapped(_Last);
; 1644 : 
; 1645 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1646 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1647 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1648 :         if (!_STD is_constant_evaluated())
; 1649 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1650 :         {
; 1651 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1652 :             _Dest += _ULast - _UFirst;
; 1653 :             return _Dest;
; 1654 :         }
; 1655 :     }
; 1656 : 
; 1657 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1658 :     for (; _UFirst != _ULast; ++_UFirst) {

  0004c	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00050	48 3b de	 cmp	 rbx, rsi
  00053	75 db		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1615 :         _Destroy_range(_First, _Last, _Al);

  00055	48 8b d7	 mov	 rdx, rdi
  00058	48 8b cf	 mov	 rcx, rdi
  0005b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAXPEAUImportFunctionInfo@portable_executable@@QEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ; std::_Destroy_range<std::allocator<portable_executable::ImportFunctionInfo> >

; 1659 :         _Backout._Emplace_back(*_UFirst);
; 1660 :     }
; 1661 : 
; 1662 :     return _Backout._Release();

  00060	48 8b c7	 mov	 rax, rdi

; 1663 : }

  00063	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00068	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0006d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
??$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z ENDP ; std::_Uninitialized_copy<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$0@?0???$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Backout$ = 32
_First$ = 80
_Last$ = 88
_Dest$ = 96
_Al$ = 104
?dtor$0@?0???$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z@4HA PROC ; `std::_Uninitialized_copy<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$0
  00000	48 8d 8a 20 00
	00 00		 lea	 rcx, QWORD PTR _Backout$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::~_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >
?dtor$0@?0???$_Uninitialized_copy@PEAUImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YAPEAUImportFunctionInfo@portable_executable@@QEAU12@0PEAU12@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@@Z@4HA ENDP ; `std::_Uninitialized_copy<portable_executable::ImportFunctionInfo *,std::allocator<portable_executable::ImportFunctionInfo> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@UImportInfo@portable_executable@@@std@@YA$$QEAUImportInfo@portable_executable@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UImportInfo@portable_executable@@@std@@YA$$QEAUImportInfo@portable_executable@@AEAU12@@Z PROC ; std::forward<portable_executable::ImportInfo>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@UImportInfo@portable_executable@@@std@@YA$$QEAUImportInfo@portable_executable@@AEAU12@@Z ENDP ; std::forward<portable_executable::ImportInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UImportInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UImportInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	45 33 d2	 xor	 r10d, r10d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00003	4c 8b ca	 mov	 r9, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00006	4c 89 12	 mov	 QWORD PTR [rdx], r10

; 2322 :     size_type _Mysize = 0; // current length of string

  00009	4c 89 52 10	 mov	 QWORD PTR [rdx+16], r10

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  0000d	4c 89 52 18	 mov	 QWORD PTR [rdx+24], r10

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00011	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00015	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00018	41 0f 10 48 10	 movups	 xmm1, XMMWORD PTR [r8+16]
  0001d	0f 11 4a 10	 movups	 XMMWORD PTR [rdx+16], xmm1

; 4562 :         _My_data._Mysize = 0;

  00021	4d 89 50 10	 mov	 QWORD PTR [r8+16], r10

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00025	49 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [r8+24], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0002d	45 88 10	 mov	 BYTE PTR [r8], r10b
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00030	49 8b 50 30	 mov	 rdx, QWORD PTR [r8+48]
  00034	49 8b 48 28	 mov	 rcx, QWORD PTR [r8+40]
  00038	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  0003c	4d 89 50 30	 mov	 QWORD PTR [r8+48], r10
  00040	4d 89 50 28	 mov	 QWORD PTR [r8+40], r10
  00044	4d 89 50 20	 mov	 QWORD PTR [r8+32], r10
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00048	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  0004c	49 89 49 28	 mov	 QWORD PTR [r9+40], rcx
  00050	49 89 51 30	 mov	 QWORD PTR [r9+48], rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 683  :     }

  00054	c3		 ret	 0
??$construct@UImportInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@UImportInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportInfo@portable_executable@@@1@QEAUImportInfo@portable_executable@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportInfo> >::construct<portable_executable::ImportInfo,portable_executable::ImportInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@URelocInfo@portable_executable@@@std@@YA$$QEAURelocInfo@portable_executable@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@URelocInfo@portable_executable@@@std@@YA$$QEAURelocInfo@portable_executable@@AEAU12@@Z PROC ; std::forward<portable_executable::RelocInfo>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@URelocInfo@portable_executable@@@std@@YA$$QEAURelocInfo@portable_executable@@AEAU12@@Z ENDP ; std::forward<portable_executable::RelocInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@URelocInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@URelocInfo@portable_executable@@@1@QEAURelocInfo@portable_executable@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@URelocInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@URelocInfo@portable_executable@@@1@QEAURelocInfo@portable_executable@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::RelocInfo> >::construct<portable_executable::RelocInfo,portable_executable::RelocInfo>, COMDAT

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00004	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00007	f2 41 0f 10 48
	10		 movsd	 xmm1, QWORD PTR [r8+16]
  0000d	f2 0f 11 4a 10	 movsd	 QWORD PTR [rdx+16], xmm1

; 675  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 676  :         if (_STD is_constant_evaluated()) {
; 677  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 678  :         } else
; 679  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 680  :         {
; 681  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 682  :         }
; 683  :     }

  00012	c3		 ret	 0
??$construct@URelocInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@URelocInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@URelocInfo@portable_executable@@@1@QEAURelocInfo@portable_executable@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::RelocInfo> >::construct<portable_executable::RelocInfo,portable_executable::RelocInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@UImportFunctionInfo@portable_executable@@@std@@YA$$QEAUImportFunctionInfo@portable_executable@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UImportFunctionInfo@portable_executable@@@std@@YA$$QEAUImportFunctionInfo@portable_executable@@AEAU12@@Z PROC ; std::forward<portable_executable::ImportFunctionInfo>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@UImportFunctionInfo@portable_executable@@@std@@YA$$QEAUImportFunctionInfo@portable_executable@@AEAU12@@Z ENDP ; std::forward<portable_executable::ImportFunctionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UImportFunctionInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UImportFunctionInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@$$QEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::construct<portable_executable::ImportFunctionInfo,portable_executable::ImportFunctionInfo>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	33 c0		 xor	 eax, eax
  00002	48 89 02	 mov	 QWORD PTR [rdx], rax

; 2322 :     size_type _Mysize = 0; // current length of string

  00005	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  00009	48 89 42 18	 mov	 QWORD PTR [rdx+24], rax

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0000d	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00011	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  00014	41 0f 10 48 10	 movups	 xmm1, XMMWORD PTR [r8+16]
  00019	0f 11 4a 10	 movups	 XMMWORD PTR [rdx+16], xmm1

; 4562 :         _My_data._Mysize = 0;

  0001d	49 89 40 10	 mov	 QWORD PTR [r8+16], rax

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00021	49 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [r8+24], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00029	41 88 00	 mov	 BYTE PTR [r8], al
  0002c	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00030	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 683  :     }

  00034	c3		 ret	 0
??$construct@UImportFunctionInfo@portable_executable@@U12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@$$QEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::construct<portable_executable::ImportFunctionInfo,portable_executable::ImportFunctionInfo>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AEAUImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEAUImportFunctionInfo@portable_executable@@@Z
_TEXT	SEGMENT
this$ = 48
<_Vals_0>$ = 56
??$_Emplace_back@AEAUImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEAUImportFunctionInfo@portable_executable@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_back<portable_executable::ImportFunctionInfo &>, COMDAT

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0000f	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]

; 1619 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00013	48 8b f1	 mov	 rsi, rcx
  00016	48 8b cb	 mov	 rcx, rbx
  00019	48 8b fa	 mov	 rdi, rdx
  0001c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00021	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00025	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 1620 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);
; 1621 :         ++_Last;

  00029	48 83 46 08 28	 add	 QWORD PTR [rsi+8], 40	; 00000028H

; 1622 :     }

  0002e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
??$_Emplace_back@AEAUImportFunctionInfo@portable_executable@@@?$_Uninitialized_backout_al@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAAXAEAUImportFunctionInfo@portable_executable@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<portable_executable::ImportFunctionInfo> >::_Emplace_back<portable_executable::ImportFunctionInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0ImportInfo@portable_executable@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0ImportInfo@portable_executable@@QEAA@$$QEAU01@@Z PROC ; portable_executable::ImportInfo::ImportInfo, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	45 33 d2	 xor	 r10d, r10d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	4c 89 11	 mov	 QWORD PTR [rcx], r10
  00009	4c 8b c9	 mov	 r9, rcx

; 2322 :     size_type _Mysize = 0; // current length of string

  0000c	4c 89 51 10	 mov	 QWORD PTR [rcx+16], r10

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  00010	4c 89 51 18	 mov	 QWORD PTR [rcx+24], r10

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00014	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00017	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  0001a	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  0001e	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1

; 4562 :         _My_data._Mysize = 0;

  00022	4c 89 52 10	 mov	 QWORD PTR [rdx+16], r10

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;

  00026	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15

; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0002e	44 88 12	 mov	 BYTE PTR [rdx], r10b
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00031	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00035	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00039	49 8b 48 28	 mov	 rcx, QWORD PTR [r8+40]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  0003d	4d 89 50 30	 mov	 QWORD PTR [r8+48], r10
  00041	4d 89 50 28	 mov	 QWORD PTR [r8+40], r10
  00045	4d 89 50 20	 mov	 QWORD PTR [r8+32], r10
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00049	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  0004d	49 8b c1	 mov	 rax, r9
  00050	49 89 49 28	 mov	 QWORD PTR [r9+40], rcx
  00054	49 89 51 30	 mov	 QWORD PTR [r9+48], rdx
  00058	c3		 ret	 0
??0ImportInfo@portable_executable@@QEAA@$$QEAU01@@Z ENDP ; portable_executable::ImportInfo::ImportInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0ImportFunctionInfo@portable_executable@@QEAA@$$QEAU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0ImportFunctionInfo@portable_executable@@QEAA@$$QEAU01@@Z PROC ; portable_executable::ImportFunctionInfo::ImportFunctionInfo, COMDAT

; 2313 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2322 :     size_type _Mysize = 0; // current length of string

  00005	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2323 :     size_type _Myres  = 0; // current storage reserved for string

  00009	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 2835 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0000d	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00010	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00013	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  00017	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1

; 4562 :         _My_data._Mysize = 0;

  0001b	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 4563 : 
; 4564 : #ifdef __cpp_lib_constexpr_string
; 4565 :         if (_STD is_constant_evaluated()) {
; 4566 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4567 :             auto& _Al              = _Getal();
; 4568 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4569 :             _My_data._Bx._Ptr      = _New_ptr;
; 4570 : 
; 4571 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4572 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4573 :         } else
; 4574 : #endif // __cpp_lib_constexpr_string
; 4575 :         {
; 4576 :             _My_data._Myres = _BUF_SIZE - 1;
; 4577 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4578 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0001f	88 02		 mov	 BYTE PTR [rdx], al
  00021	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15
  00029	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  0002d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  00031	48 8b c1	 mov	 rax, rcx
  00034	c3		 ret	 0
??0ImportFunctionInfo@portable_executable@@QEAA@$$QEAU01@@Z ENDP ; portable_executable::ImportFunctionInfo::ImportFunctionInfo
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00003	45 33 d2	 xor	 r10d, r10d
  00006	4c 8b 4a 10	 mov	 r9, QWORD PTR [rdx+16]

; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0000a	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]

; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  0000e	4c 89 52 10	 mov	 QWORD PTR [rdx+16], r10
  00012	4c 89 52 08	 mov	 QWORD PTR [rdx+8], r10
  00016	4c 89 12	 mov	 QWORD PTR [rdx], r10
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00019	48 89 01	 mov	 QWORD PTR [rcx], rax

; 609  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 610  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 611  :     }

  0001c	48 8b c1	 mov	 rax, rcx

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  0001f	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  00023	4c 89 49 10	 mov	 QWORD PTR [rcx+16], r9

; 609  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 610  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 611  :     }

  00027	c3		 ret	 0
??0?$vector@UImportFunctionInfo@portable_executable@@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >::vector<portable_executable::ImportFunctionInfo,std::allocator<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AEAUImportFunctionInfo@portable_executable@@@std@@YAAEAUImportFunctionInfo@portable_executable@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAUImportFunctionInfo@portable_executable@@@std@@YAAEAUImportFunctionInfo@portable_executable@@AEAU12@@Z PROC ; std::forward<portable_executable::ImportFunctionInfo &>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@AEAUImportFunctionInfo@portable_executable@@@std@@YAAEAUImportFunctionInfo@portable_executable@@AEAU12@@Z ENDP ; std::forward<portable_executable::ImportFunctionInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@UImportFunctionInfo@portable_executable@@AEAU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 48
_Ptr$ = 56
<_Args_0>$ = 64
??$construct@UImportFunctionInfo@portable_executable@@AEAU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEAU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::construct<portable_executable::ImportFunctionInfo,portable_executable::ImportFunctionInfo &>, COMDAT

; 674  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	49 8b d8	 mov	 rbx, r8
  00010	48 8b cf	 mov	 rcx, rdi
  00013	49 8b d0	 mov	 rdx, r8
  00016	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]

; 675  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 676  :         if (_STD is_constant_evaluated()) {
; 677  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 678  :         } else
; 679  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 680  :         {
; 681  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 682  :         }
; 683  :     }

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
??$construct@UImportFunctionInfo@portable_executable@@AEAU12@@?$_Default_allocator_traits@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@SAXAEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@QEAUImportFunctionInfo@portable_executable@@AEAU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<portable_executable::ImportFunctionInfo> >::construct<portable_executable::ImportFunctionInfo,portable_executable::ImportFunctionInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@AEAV10@@Z PROC ; std::move<std::allocator<portable_executable::ImportFunctionInfo> &>, COMDAT

; 1397 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1398 : }

  00003	c3		 ret	 0
??$move@AEAV?$allocator@UImportFunctionInfo@portable_executable@@@std@@@std@@YA$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@0@AEAV10@@Z ENDP ; std::move<std::allocator<portable_executable::ImportFunctionInfo> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PEAUImportFunctionInfo@portable_executable@@$$T@std@@YAPEAUImportFunctionInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z
_TEXT	SEGMENT
_Val$ = 8
_New_val$ = 16
??$exchange@PEAUImportFunctionInfo@portable_executable@@$$T@std@@YAPEAUImportFunctionInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z PROC ; std::exchange<portable_executable::ImportFunctionInfo *,std::nullptr_t>, COMDAT

; 601  :     // assign _New_val to _Val, return previous _Val
; 602  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);
; 603  :     _Val         = static_cast<_Other&&>(_New_val);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00006	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 604  :     return _Old_val;
; 605  : }

  00009	c3		 ret	 0
??$exchange@PEAUImportFunctionInfo@portable_executable@@$$T@std@@YAPEAUImportFunctionInfo@portable_executable@@AEAPEAU12@$$QEA$$T@Z ENDP ; std::exchange<portable_executable::ImportFunctionInfo *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@UImportFunctionInfo@portable_executable@@@std@@PEAUImportFunctionInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@$$QEAPEAUImportFunctionInfo@portable_executable@@22@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
<_Val2_0>$ = 32
<_Val2_1>$ = 40
<_Val2_2>$ = 48
??$?0V?$allocator@UImportFunctionInfo@portable_executable@@@std@@PEAUImportFunctionInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@$$QEAPEAUImportFunctionInfo@portable_executable@@22@Z PROC ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1><std::allocator<portable_executable::ImportFunctionInfo>,portable_executable::ImportFunctionInfo *,portable_executable::ImportFunctionInfo *,portable_executable::ImportFunctionInfo *>, COMDAT

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	48 8b 44 24 30	 mov	 rax, QWORD PTR <_Val2_2>$[rsp]
  00005	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00008	48 8b 44 24 28	 mov	 rax, QWORD PTR <_Val2_1>$[rsp]
  0000d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00010	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00013	48 89 01	 mov	 QWORD PTR [rcx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00016	48 8b c1	 mov	 rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00019	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001d	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory

; 1336 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	c3		 ret	 0
??$?0V?$allocator@UImportFunctionInfo@portable_executable@@@std@@PEAUImportFunctionInfo@portable_executable@@PEAU23@PEAU23@@?$_Compressed_pair@V?$allocator@UImportFunctionInfo@portable_executable@@@std@@V?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@UImportFunctionInfo@portable_executable@@@1@$$QEAPEAUImportFunctionInfo@portable_executable@@22@Z ENDP ; std::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1>::_Compressed_pair<std::allocator<portable_executable::ImportFunctionInfo>,std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >,1><std::allocator<portable_executable::ImportFunctionInfo>,portable_executable::ImportFunctionInfo *,portable_executable::ImportFunctionInfo *,portable_executable::ImportFunctionInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportFunctionInfo@portable_executable@@00@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
_End$ = 32
??0?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportFunctionInfo@portable_executable@@00@Z PROC ; std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >, COMDAT

; 393  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00003	48 8b c1	 mov	 rax, rcx
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  0000a	4c 89 49 10	 mov	 QWORD PTR [rcx+16], r9
  0000e	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UImportFunctionInfo@portable_executable@@@std@@@std@@QEAA@PEAUImportFunctionInfo@portable_executable@@00@Z ENDP ; std::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >::_Vector_val<std::_Simple_types<portable_executable::ImportFunctionInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PEAUImportFunctionInfo@portable_executable@@@std@@YA$$QEAPEAUImportFunctionInfo@portable_executable@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUImportFunctionInfo@portable_executable@@@std@@YA$$QEAPEAUImportFunctionInfo@portable_executable@@AEAPEAU12@@Z PROC ; std::forward<portable_executable::ImportFunctionInfo *>, COMDAT

; 1386 :     return static_cast<_Ty&&>(_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1387 : }

  00003	c3		 ret	 0
??$forward@PEAUImportFunctionInfo@portable_executable@@@std@@YA$$QEAPEAUImportFunctionInfo@portable_executable@@AEAPEAU12@@Z ENDP ; std::forward<portable_executable::ImportFunctionInfo *>
_TEXT	ENDS
END
